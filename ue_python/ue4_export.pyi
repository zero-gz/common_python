# -*- encoding: utf-8 -*-
import typing
from enum import Enum

class Guid(object):
	"""A globally unique identifier (mirrored from Guid.h)"""

	@property
	def A(self) -> int: ...

	@property
	def B(self) -> int: ...

	@property
	def C(self) -> int: ...

	@property
	def D(self) -> int: ...

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InA: int, InB: int, InC: int, InD: int): ...

	@overload
	def __init__(self, InGuidStr: str): ...

	def Invalidate(self): ...

	def IsValid(self) -> bool: ...

	@overload
	def ToString(self) -> str: ...

	@overload
	def ToString(self, Format: int) -> str: ...

	@staticmethod
	def NewGuid() -> Guid: ...

	@staticmethod
	def Parse(GuidString: str) -> typing.Tuple[bool, Guid]: ...

	@staticmethod
	def ParseExact(GuidString: str, Format: int) -> typing.Tuple[bool, Guid]: ...

	pass

class Vector(object):
	"""A point or direction FVector in 3d space.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Vector.h"""

	@property
	def X(self) -> float: ...

	@property
	def Y(self) -> float: ...

	@property
	def Z(self) -> float: ...

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InF: float): ...

	@overload
	def __init__(self, InX: float, InY: float, InZ: float): ...

	@staticmethod
	def CrossProduct(A: Vector, B: Vector) -> Vector: ...

	@staticmethod
	def DotProduct(A: Vector, B: Vector) -> float: ...

	@overload
	def __add__(self, V: Vector) -> Vector: ...

	@overload
	def __add__(self, Bias: float) -> Vector: ...

	@overload
	def __sub__(self, V: Vector) -> Vector: ...

	@overload
	def __sub__(self, Bias: float) -> Vector: ...

	@overload
	def __mul__(self, Scale: float) -> Vector: ...

	@overload
	def __mul__(self, V: Vector) -> Vector: ...

	@overload
	def __div__(self, Scale: float) -> Vector: ...

	@overload
	def __div__(self, V: Vector) -> Vector: ...

	def __eq__(self, V: Vector) -> bool: ...

	def __ne__(self, V: Vector) -> bool: ...

	def Equals(self, V: Vector, Tolerance: float = ...) -> bool: ...

	def AllComponentsEqual(self, Tolerance: float = ...) -> bool: ...

	def __iadd__(self, V: Vector) -> Vector: ...

	def __isub__(self, V: Vector) -> Vector: ...

	@overload
	def __imul__(self, Scale: float) -> Vector: ...

	@overload
	def __imul__(self, V: Vector) -> Vector: ...

	@overload
	def __idiv__(self, V: float) -> Vector: ...

	@overload
	def __idiv__(self, V: Vector) -> Vector: ...

	def Component(self, Index: int) -> float: ...

	def Set(self, InX: float, InY: float, InZ: float): ...

	def GetMax(self) -> float: ...

	def GetAbsMax(self) -> float: ...

	def GetMin(self) -> float: ...

	def GetAbsMin(self) -> float: ...

	def ComponentMin(self, Other: Vector) -> Vector: ...

	def ComponentMax(self, Other: Vector) -> Vector: ...

	def GetAbs(self) -> Vector: ...

	def Size(self) -> float: ...

	def SizeSquared(self) -> float: ...

	def Size2D(self) -> float: ...

	def SizeSquared2D(self) -> float: ...

	def IsNearlyZero(self, Tolerance: float = ...) -> bool: ...

	def IsZero(self) -> bool: ...

	def IsUnit(self, LengthSquaredTolerance: float = ...) -> bool: ...

	def IsNormalized(self) -> bool: ...

	def Normalize(self, Tolerance: float = ...) -> bool: ...

	def GetUnsafeNormal(self) -> Vector: ...

	def GetSafeNormal(self, Tolerance: float = ...) -> Vector: ...

	def GetSafeNormal2D(self, Tolerance: float = ...) -> Vector: ...

	def GetSignVector(self) -> Vector: ...

	def Projection(self) -> Vector: ...

	def GetUnsafeNormal2D(self) -> Vector: ...

	def BoundToCube(self, Radius: float) -> Vector: ...

	def BoundToBox(self, Min: Vector, Max: Vector) -> Vector: ...

	def GetClampedToSize(self, Min: float, Max: float) -> Vector: ...

	def GetClampedToSize2D(self, Min: float, Max: float) -> Vector: ...

	def GetClampedToMaxSize(self, MaxSize: float) -> Vector: ...

	def GetClampedToMaxSize2D(self, MaxSize: float) -> Vector: ...

	def AddBounded(self, V: Vector, Radius: float = ...): ...

	def Reciprocal(self) -> Vector: ...

	def IsUniform(self, Tolerance: float = ...) -> bool: ...

	def MirrorByVector(self, MirrorNormal: Vector) -> Vector: ...

	def MirrorByPlane(self, Plane: Plane) -> Vector: ...

	def RotateAngleAxis(self, AngleDeg: float, Axis: Vector) -> Vector: ...

	def CosineAngle2D(self, B: Vector) -> float: ...

	def ProjectOnTo(self, A: Vector) -> Vector: ...

	def ProjectOnToNormal(self, Normal: Vector) -> Vector: ...

	def ToOrientationRotator(self) -> Rotator: ...

	def ToOrientationQuat(self) -> Quat: ...

	def Rotation(self) -> Rotator: ...

	def FindBestAxisVectors(self) -> typing.Tuple[Vector, Vector]: ...

	def UnwindEuler(self): ...

	def ContainsNaN(self) -> bool: ...

	def ToString(self) -> str: ...

	def UnitCartesianToSpherical(self) -> Vector2D: ...

	def HeadingAngle(self) -> float: ...

	@staticmethod
	def CreateOrthonormalBasis() -> typing.Tuple[Vector, Vector, Vector]: ...

	@staticmethod
	def PointsAreSame(P: Vector, Q: Vector) -> bool: ...

	@staticmethod
	def PointsAreNear(Point1: Vector, Point2: Vector, Dist: float) -> bool: ...

	@staticmethod
	def PointPlaneDist(Point: Vector, PlaneBase: Vector, PlaneNormal: Vector) -> float: ...

	@staticmethod
	@overload
	def PointPlaneProject(Point: Vector, Plane: Plane) -> Vector: ...

	@staticmethod
	@overload
	def PointPlaneProject(Point: Vector, A: Vector, B: Vector, C: Vector) -> Vector: ...

	@staticmethod
	@overload
	def PointPlaneProject(Point: Vector, PlaneBase: Vector, PlaneNormal: Vector) -> Vector: ...

	@staticmethod
	def VectorPlaneProject(V: Vector, PlaneNormal: Vector) -> Vector: ...

	@staticmethod
	def Dist(V1: Vector, V2: Vector) -> float: ...

	@staticmethod
	def Distance(V1: Vector, V2: Vector) -> float: ...

	@staticmethod
	def DistXY(V1: Vector, V2: Vector) -> float: ...

	@staticmethod
	def Dist2D(V1: Vector, V2: Vector) -> float: ...

	@staticmethod
	def DistSquared(V1: Vector, V2: Vector) -> float: ...

	@staticmethod
	def DistSquaredXY(V1: Vector, V2: Vector) -> float: ...

	@staticmethod
	def DistSquared2D(V1: Vector, V2: Vector) -> float: ...

	@staticmethod
	def BoxPushOut(Normal: Vector, Size: Vector) -> float: ...

	@staticmethod
	def Parallel(Normal1: Vector, Normal2: Vector, ParallelCosineThreshold: float = ...) -> bool: ...

	@staticmethod
	def Coincident(Normal1: Vector, Normal2: Vector, ParallelCosineThreshold: float = ...) -> bool: ...

	@staticmethod
	def Orthogonal(Normal1: Vector, Normal2: Vector, OrthogonalCosineThreshold: float = ...) -> bool: ...

	@staticmethod
	def Coplanar(Base1: Vector, Normal1: Vector, Base2: Vector, Normal2: Vector, ParallelCosineThreshold: float = ...) -> bool: ...

	@staticmethod
	def Triple(X: Vector, Y: Vector, Z: Vector) -> float: ...

	@staticmethod
	def RadiansToDegrees(RadVector: Vector) -> Vector: ...

	@staticmethod
	def DegreesToRadians(DegVector: Vector) -> Vector: ...

	pass

class Vector4(object):
	"""A 4-D homogeneous vector.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Vector4.h"""

	@property
	def X(self) -> float: ...

	@property
	def Y(self) -> float: ...

	@property
	def Z(self) -> float: ...

	@property
	def W(self) -> float: ...

	@overload
	def __init__(self, InX: float = ..., InY: float = ..., InZ: float = ..., InW: float = ...): ...

	@overload
	def __init__(self, InVector): ...

	def __add__(self, V: Vector4) -> Vector4: ...

	def __iadd__(self, V: Vector4) -> Vector4: ...

	def __sub__(self, V: Vector4) -> Vector4: ...

	def __isub__(self, V: Vector4) -> Vector4: ...

	@overload
	def __mul__(self, Scale: float) -> Vector4: ...

	@overload
	def __mul__(self, V: Vector4) -> Vector4: ...

	@overload
	def __div__(self, Scale: float) -> Vector4: ...

	@overload
	def __div__(self, V: Vector4) -> Vector4: ...

	@overload
	def __imul__(self, V: Vector4) -> Vector4: ...

	@overload
	def __imul__(self, S: float) -> Vector4: ...

	def __idiv__(self, V: Vector4) -> Vector4: ...

	def __eq__(self, V: Vector4) -> bool: ...

	def __ne__(self, V: Vector4) -> bool: ...

	def Equals(self, V: Vector4, Tolerance: float = ...) -> bool: ...

	def IsUnit3(self, LengthSquaredTolerance: float = ...) -> bool: ...

	def ToString(self) -> str: ...

	def GetSafeNormal(self, Tolerance: float = ...) -> Vector4: ...

	def GetUnsafeNormal3(self) -> Vector4: ...

	def ToOrientationRotator(self) -> Rotator: ...

	def ToOrientationQuat(self) -> Quat: ...

	def Rotation(self) -> Rotator: ...

	def Set(self, InX: float, InY: float, InZ: float, InW: float): ...

	def Size3(self) -> float: ...

	def SizeSquared3(self) -> float: ...

	def Size(self) -> float: ...

	def SizeSquared(self) -> float: ...

	def ContainsNaN(self) -> bool: ...

	def IsNearlyZero3(self, Tolerance: float = ...) -> bool: ...

	def Reflect3(self, Normal: Vector4) -> Vector4: ...

	def FindBestAxisVectors3(self) -> typing.Tuple[Vector4, Vector4]: ...

	pass

class Vector2D(object):
	"""A vector in 2-D space composed of components (X, Y) with floating point precision.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Vector2D.h"""

	@property
	def X(self) -> float: ...

	@property
	def Y(self) -> float: ...

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InX: float, InY: float): ...

	@overload
	def __init__(self, InF: float): ...

	@overload
	def __add__(self, V: Vector2D) -> Vector2D: ...

	@overload
	def __add__(self, A: float) -> Vector2D: ...

	@overload
	def __sub__(self, V: Vector2D) -> Vector2D: ...

	@overload
	def __sub__(self, A: float) -> Vector2D: ...

	@overload
	def __mul__(self, Scale: float) -> Vector2D: ...

	@overload
	def __mul__(self, V: Vector2D) -> Vector2D: ...

	@overload
	def __div__(self, Scale: float) -> Vector2D: ...

	@overload
	def __div__(self, V: Vector2D) -> Vector2D: ...

	def __eq__(self, V: Vector2D) -> bool: ...

	def __ne__(self, V: Vector2D) -> bool: ...

	def __lt__(self, Other: Vector2D) -> bool: ...

	def __gt__(self, Other: Vector2D) -> bool: ...

	def __le__(self, Other: Vector2D) -> bool: ...

	def __ge__(self, Other: Vector2D) -> bool: ...

	def __iadd__(self, V: Vector2D) -> Vector2D: ...

	def __isub__(self, V: Vector2D) -> Vector2D: ...

	@overload
	def __imul__(self, Scale: float) -> Vector2D: ...

	@overload
	def __imul__(self, V: Vector2D) -> Vector2D: ...

	@overload
	def __idiv__(self, V: float) -> Vector2D: ...

	@overload
	def __idiv__(self, V: Vector2D) -> Vector2D: ...

	def Component(self, Index: int) -> float: ...

	@staticmethod
	def DotProduct(A: Vector2D, B: Vector2D) -> float: ...

	@staticmethod
	def DistSquared(V1: Vector2D, V2: Vector2D) -> float: ...

	@staticmethod
	def Distance(V1: Vector2D, V2: Vector2D) -> float: ...

	@staticmethod
	def CrossProduct(A: Vector2D, B: Vector2D) -> float: ...

	@staticmethod
	def Max(A: Vector2D, B: Vector2D) -> Vector2D: ...

	@staticmethod
	def Min(A: Vector2D, B: Vector2D) -> Vector2D: ...

	def Equals(self, V: Vector2D, Tolerance: float = ...) -> bool: ...

	def Set(self, InX: float, InY: float): ...

	def GetMax(self) -> float: ...

	def GetAbsMax(self) -> float: ...

	def GetMin(self) -> float: ...

	def Size(self) -> float: ...

	def SizeSquared(self) -> float: ...

	def GetRotated(self, AngleDeg: float) -> Vector2D: ...

	def GetSafeNormal(self, Tolerance: float = ...) -> Vector2D: ...

	def Normalize(self, Tolerance: float = ...): ...

	def IsNearlyZero(self, Tolerance: float = ...) -> bool: ...

	def IsZero(self) -> bool: ...

	def IntPoint(self) -> IntPoint: ...

	def RoundToVector(self) -> Vector2D: ...

	def ClampAxes(self, MinAxisVal: float, MaxAxisVal: float) -> Vector2D: ...

	def GetSignVector(self) -> Vector2D: ...

	def GetAbs(self) -> Vector2D: ...

	def ToString(self) -> str: ...

	def ContainsNaN(self) -> bool: ...

	def SphericalToUnitCartesian(self) -> Vector: ...

	pass

class TwoVectors(object):
	"""A pair of 3D vectors (mirrored from TwoVectors.h)."""

	@property
	def v1(self) -> Vector: ...
	"""V 1"""

	@property
	def v2(self) -> Vector: ...
	"""V 2"""

	pass

class Plane(Vector):
	"""A plane definition in 3D space.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Plane.h"""

	@property
	def W(self) -> float: ...

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, V: Vector4): ...

	@overload
	def __init__(self, InX: float, InY: float, InZ: float, InW: float): ...

	@overload
	def __init__(self, InNormal: Vector, InW: float): ...

	@overload
	def __init__(self, InBase: Vector, InNormal: Vector): ...

	@overload
	def __init__(self, A: Vector, B: Vector, C: Vector): ...

	def IsValid(self) -> bool: ...

	def GetOrigin(self) -> Vector: ...

	def GetNormal(self) -> Vector: ...

	def PlaneDot(self, P: Vector) -> float: ...

	def Normalize(self, Tolerance: float = ...) -> bool: ...

	def Flip(self) -> Plane: ...

	def TransformBy(self, M: Matrix) -> Plane: ...

	def TransformByUsingAdjointT(self, M: Matrix, DetM: float, TA: Matrix) -> Plane: ...

	def __eq__(self, V: Plane) -> bool: ...

	def __ne__(self, V: Plane) -> bool: ...

	def Equals(self, V: Plane, Tolerance: float = ...) -> bool: ...

	def __add__(self, V: Plane) -> Plane: ...

	def __sub__(self, V: Plane) -> Plane: ...

	def __div__(self, Scale: float) -> Plane: ...

	@overload
	def __mul__(self, Scale: float) -> Plane: ...

	@overload
	def __mul__(self, V: Plane) -> Plane: ...

	def __iadd__(self, V: Plane) -> Plane: ...

	def __isub__(self, V: Plane) -> Plane: ...

	@overload
	def __imul__(self, Scale: float) -> Plane: ...

	@overload
	def __imul__(self, V: Plane) -> Plane: ...

	def __idiv__(self, V: float) -> Plane: ...

	pass

class Rotator(object):
	"""An orthogonal rotation in 3d space.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Rotator.h"""

	@property
	def Pitch(self) -> float: ...

	@property
	def Yaw(self) -> float: ...

	@property
	def Roll(self) -> float: ...

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InF: float): ...

	@overload
	def __init__(self, InPitch: float, InYaw: float, InRoll: float): ...

	@overload
	def __init__(self, Quat: Quat): ...

	def __add__(self, R: Rotator) -> Rotator: ...

	def __sub__(self, R: Rotator) -> Rotator: ...

	def __mul__(self, Scale: float) -> Rotator: ...

	def __imul__(self, Scale: float) -> Rotator: ...

	def __eq__(self, R: Rotator) -> bool: ...

	def __ne__(self, V: Rotator) -> bool: ...

	def __iadd__(self, R: Rotator) -> Rotator: ...

	def __isub__(self, R: Rotator) -> Rotator: ...

	def IsNearlyZero(self, Tolerance: float = ...) -> bool: ...

	def IsZero(self) -> bool: ...

	def Equals(self, R: Rotator, Tolerance: float = ...) -> bool: ...

	def Add(self, DeltaPitch: float, DeltaYaw: float, DeltaRoll: float) -> Rotator: ...

	def GetInverse(self) -> Rotator: ...

	def GridSnap(self, RotGrid: Rotator) -> Rotator: ...

	def Vector(self) -> Vector: ...

	def Quaternion(self) -> Quat: ...

	def Euler(self) -> Vector: ...

	def RotateVector(self, V: Vector) -> Vector: ...

	def UnrotateVector(self, V: Vector) -> Vector: ...

	def Clamp(self) -> Rotator: ...

	def GetNormalized(self) -> Rotator: ...

	def GetDenormalized(self) -> Rotator: ...

	def Normalize(self): ...

	def GetWindingAndRemainder(self) -> typing.Tuple[Rotator, Rotator]: ...

	def GetManhattanDistance(self, Rotator: Rotator) -> float: ...

	def GetEquivalentRotator(self) -> Rotator: ...

	def SetClosestToMe(self) -> Rotator: ...

	def ToString(self) -> str: ...

	def ContainsNaN(self) -> bool: ...

	@staticmethod
	def ClampAxis(Angle: float) -> float: ...

	@staticmethod
	def NormalizeAxis(Angle: float) -> float: ...

	@staticmethod
	def CompressAxisToByte(Angle: float) -> int: ...

	@staticmethod
	def DecompressAxisFromByte(Angle: int) -> float: ...

	@staticmethod
	def CompressAxisToShort(Angle: float) -> int: ...

	@staticmethod
	def DecompressAxisFromShort(Angle: int) -> float: ...

	@staticmethod
	def MakeFromEuler(Euler: Vector) -> Rotator: ...

	pass

class Quat(object):
	"""Quaternion.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Quat.h"""

	@property
	def X(self) -> float: ...

	@property
	def Y(self) -> float: ...

	@property
	def Z(self) -> float: ...

	@property
	def W(self) -> float: ...

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InX: float, InY: float, InZ: float, InW: float): ...

	@overload
	def __init__(self, M: Matrix): ...

	@overload
	def __init__(self, R: Rotator): ...

	@overload
	def __init__(self, Axis: Vector, AngleRad: float): ...

	def __add__(self, Q: Quat) -> Quat: ...

	def __iadd__(self, Q: Quat) -> Quat: ...

	def __sub__(self, Q: Quat) -> Quat: ...

	def Equals(self, Q: Quat, Tolerance: float = ...) -> bool: ...

	def IsIdentity(self, Tolerance: float = ...) -> bool: ...

	def __isub__(self, Q: Quat) -> Quat: ...

	@overload
	def __mul__(self, Q: Quat) -> Quat: ...

	@overload
	def __mul__(self, V: Vector) -> Vector: ...

	@overload
	def __mul__(self, M: Matrix) -> Matrix: ...

	@overload
	def __mul__(self, Scale: float) -> Quat: ...

	@overload
	def __imul__(self, Q: Quat) -> Quat: ...

	@overload
	def __imul__(self, Scale: float) -> Quat: ...

	def __idiv__(self, Scale: float) -> Quat: ...

	def __div__(self, Scale: float) -> Quat: ...

	def Identical(self, Q: Quat, PortFlags: int) -> bool: ...

	def __eq__(self, Q: Quat) -> bool: ...

	def __ne__(self, Q: Quat) -> bool: ...

	@staticmethod
	def MakeFromEuler(Euler: Vector) -> Quat: ...

	def Euler(self) -> Vector: ...

	def Normalize(self, Tolerance: float = ...): ...

	def GetNormalized(self, Tolerance: float = ...) -> Quat: ...

	def IsNormalized(self) -> bool: ...

	def Size(self) -> float: ...

	def SizeSquared(self) -> float: ...

	def GetAngle(self) -> float: ...

	def ToSwingTwist(self, InTwistAxis: Vector) -> typing.Tuple[Quat, Quat]: ...

	def GetTwistAngle(self, TwistAxis: Vector) -> float: ...

	def RotateVector(self, V: Vector) -> Vector: ...

	def UnrotateVector(self, V: Vector) -> Vector: ...

	def Log(self) -> Quat: ...

	def Exp(self) -> Quat: ...

	def Inverse(self) -> Quat: ...

	def EnforceShortestArcWith(self, OtherQuat: Quat): ...

	def GetAxisX(self) -> Vector: ...

	def GetAxisY(self) -> Vector: ...

	def GetAxisZ(self) -> Vector: ...

	def GetForwardVector(self) -> Vector: ...

	def GetRightVector(self) -> Vector: ...

	def GetUpVector(self) -> Vector: ...

	def Vector(self) -> Vector: ...

	def Rotator(self) -> Rotator: ...

	def GetRotationAxis(self) -> Vector: ...

	def AngularDistance(self, Q: Quat) -> float: ...

	def ContainsNaN(self) -> bool: ...

	def ToString(self) -> str: ...

	@staticmethod
	def FindBetween(Vector1: Vector, Vector2: Vector) -> Quat: ...

	@staticmethod
	def FindBetweenNormals(Normal1: Vector, Normal2: Vector) -> Quat: ...

	@staticmethod
	def FindBetweenVectors(Vector1: Vector, Vector2: Vector) -> Quat: ...

	@staticmethod
	def Error(Q1: Quat, Q2: Quat) -> float: ...

	@staticmethod
	def ErrorAutoNormalize(A: Quat, B: Quat) -> float: ...

	@staticmethod
	def FastLerp(A: Quat, B: Quat, Alpha: float) -> Quat: ...

	@staticmethod
	def FastBilerp(P00: Quat, P10: Quat, P01: Quat, P11: Quat, FracX: float, FracY: float) -> Quat: ...

	@staticmethod
	def Slerp_NotNormalized(Quat1: Quat, Quat2: Quat, Slerp: float) -> Quat: ...

	@staticmethod
	def Slerp(Quat1: Quat, Quat2: Quat, Slerp: float) -> Quat: ...

	@staticmethod
	def SlerpFullPath_NotNormalized(quat1: Quat, quat2: Quat, Alpha: float) -> Quat: ...

	@staticmethod
	def SlerpFullPath(quat1: Quat, quat2: Quat, Alpha: float) -> Quat: ...

	@staticmethod
	def Squad(quat1: Quat, tang1: Quat, quat2: Quat, tang2: Quat, Alpha: float) -> Quat: ...

	@staticmethod
	def SquadFullPath(quat1: Quat, tang1: Quat, quat2: Quat, tang2: Quat, Alpha: float) -> Quat: ...

	@staticmethod
	def CalcTangents(PrevP: Quat, P: Quat, NextP: Quat, Tension: float) -> Quat: ...

	pass

class IntPoint(object):
	"""Screen coordinates.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/IntPoint.h"""

	@property
	def X(self) -> int: ...
	"""X"""

	@property
	def Y(self) -> int: ...
	"""Y"""

	pass

class IntVector(object):
	"""An integer vector in 3D space.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/IntVector.h"""

	@property
	def X(self) -> int: ...
	"""X"""

	@property
	def Y(self) -> int: ...
	"""Y"""

	@property
	def Z(self) -> int: ...
	"""Z"""

	pass

class Color(object):
	"""Stores a color with 8 bits of precision per channel. (BGRA).
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Color.h"""

	@property
	def B(self) -> int: ...
	"""B"""

	@property
	def G(self) -> int: ...
	"""G"""

	@property
	def R(self) -> int: ...
	"""R"""

	@property
	def A(self) -> int: ...
	"""A"""

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InR: int, InG: int, InB: int, InA: int = ...): ...

	@overload
	def __init__(self, InColor: int): ...

	def __eq__(self, C: Color) -> bool: ...

	def __ne__(self, C: Color) -> bool: ...

	def __iadd__(self, C: Color): ...

	def FromRGBE(self) -> LinearColor: ...

	@staticmethod
	def FromHex(HexString: str) -> Color: ...

	@staticmethod
	def MakeRandomColor() -> Color: ...

	@staticmethod
	def MakeRedToGreenColorFromScalar(Scalar: float) -> Color: ...

	@staticmethod
	def MakeFromColorTemperature(Temp: float) -> Color: ...

	def WithAlpha(self, Alpha: int) -> Color: ...

	def ReinterpretAsLinear(self) -> LinearColor: ...

	def ToHex(self) -> str: ...

	def ToString(self) -> str: ...

	def ToPackedARGB(self) -> int: ...

	def ToPackedABGR(self) -> int: ...

	def ToPackedRGBA(self) -> int: ...

	def ToPackedBGRA(self) -> int: ...

	pass

class LinearColor(object):
	"""A linear, 32-bit/component floating point RGBA color.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Color.h"""

	@property
	def R(self) -> float: ...

	@property
	def G(self) -> float: ...

	@property
	def B(self) -> float: ...

	@property
	def A(self) -> float: ...

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InR: float, InG: float, InB: float, InA: float = ...): ...

	@overload
	def __init__(self, Color: Color): ...

	def ToRGBE(self) -> Color: ...

	@staticmethod
	def FromSRGBColor(Color: Color) -> LinearColor: ...

	@staticmethod
	def FromPow22Color(Color: Color) -> LinearColor: ...

	def __add__(self, ColorB: LinearColor) -> LinearColor: ...

	def __iadd__(self, ColorB: LinearColor) -> LinearColor: ...

	def __sub__(self, ColorB: LinearColor) -> LinearColor: ...

	def __isub__(self, ColorB: LinearColor) -> LinearColor: ...

	@overload
	def __mul__(self, ColorB: LinearColor) -> LinearColor: ...

	@overload
	def __mul__(self, Scalar: float) -> LinearColor: ...

	@overload
	def __imul__(self, ColorB: LinearColor) -> LinearColor: ...

	@overload
	def __imul__(self, Scalar: float) -> LinearColor: ...

	@overload
	def __div__(self, ColorB: LinearColor) -> LinearColor: ...

	@overload
	def __div__(self, Scalar: float) -> LinearColor: ...

	@overload
	def __idiv__(self, ColorB: LinearColor) -> LinearColor: ...

	@overload
	def __idiv__(self, Scalar: float) -> LinearColor: ...

	def GetClamped(self, InMin: float = ..., InMax: float = ...) -> LinearColor: ...

	def __eq__(self, ColorB: LinearColor) -> bool: ...

	def __ne__(self, Other: LinearColor) -> bool: ...

	def Equals(self, ColorB: LinearColor, Tolerance: float = ...) -> bool: ...

	def CopyWithNewOpacity(self, NewOpacicty: float) -> LinearColor: ...

	@staticmethod
	def FGetHSV(H: int, S: int, V: int) -> LinearColor: ...

	@staticmethod
	def MakeFromHSV8(H: int, S: int, V: int) -> LinearColor: ...

	@staticmethod
	def MakeRandomColor() -> LinearColor: ...

	@staticmethod
	def MakeFromColorTemperature(Temp: float) -> LinearColor: ...

	@staticmethod
	def Dist(V1: LinearColor, V2: LinearColor) -> float: ...

	def LinearRGBToHSV(self) -> LinearColor: ...

	def HSVToLinearRGB(self) -> LinearColor: ...

	@staticmethod
	def LerpUsingHSV(From: LinearColor, To: LinearColor, Progress: float) -> LinearColor: ...

	def Quantize(self) -> Color: ...

	def QuantizeRound(self) -> Color: ...

	def ToFColor(self, bSRGB: bool) -> Color: ...

	def Desaturate(self, Desaturation: float) -> LinearColor: ...

	def ComputeLuminance(self) -> float: ...

	def GetMax(self) -> float: ...

	def IsAlmostBlack(self) -> bool: ...

	def GetMin(self) -> float: ...

	def GetLuminance(self) -> float: ...

	def ToString(self) -> str: ...

	pass

class Box(object):
	"""A bounding box.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Box.h"""

	@property
	def Min(self) -> Vector: ...
	"""Min"""

	@property
	def Max(self) -> Vector: ...
	"""Max"""

	@property
	def IsValid(self) -> int: ...
	"""Is Valid"""

	pass

class Box2D(object):
	"""A rectangular 2D Box.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Box2D.h"""

	@property
	def Min(self) -> Vector2D: ...

	@property
	def Max(self) -> Vector2D: ...

	@property
	def bIsValid(self) -> bool: ...

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InMin: Vector2D, InMax: Vector2D): ...

	def __eq__(self, Other: Box2D) -> bool: ...

	def __ne__(self, Other: Box2D) -> bool: ...

	@overload
	def __iadd__(self, Other: Vector2D) -> Box2D: ...

	@overload
	def __iadd__(self, Other: Box2D) -> Box2D: ...

	@overload
	def __add__(self, Other: Vector2D) -> Box2D: ...

	@overload
	def __add__(self, Other: Box2D) -> Box2D: ...

	def ComputeSquaredDistanceToPoint(self, Point: Vector2D) -> float: ...

	def ExpandBy(self, W: float) -> Box2D: ...

	def GetArea(self) -> float: ...

	def GetCenter(self) -> Vector2D: ...

	def GetCenterAndExtents(self) -> typing.Tuple[Vector2D, Vector2D]: ...

	def GetClosestPointTo(self, Point: Vector2D) -> Vector2D: ...

	def GetExtent(self) -> Vector2D: ...

	def GetSize(self) -> Vector2D: ...

	def Init(self): ...

	def Intersect(self, other: Box2D) -> bool: ...

	@overload
	def IsInside(self, TestPoint: Vector2D) -> bool: ...

	@overload
	def IsInside(self, Other: Box2D) -> bool: ...

	def ShiftBy(self, Offset: Vector2D) -> Box2D: ...

	def ToString(self) -> str: ...

	pass

class BoxSphereBounds(object):
	"""A bounding box and bounding sphere with the same origin.
@note The full C++ class is located here : Engine/Source/Runtime/Core/Public/Math/BoxSphereBounds.h"""

	@property
	def Origin(self) -> Vector: ...

	@property
	def BoxExtent(self) -> Vector: ...

	@property
	def SphereRadius(self) -> float: ...

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InOrigin: Vector, InBoxExtent: Vector, InSphereRadius: float): ...

	@overload
	def __init__(self, Box: Box): ...

	def __add__(self, Other: BoxSphereBounds) -> BoxSphereBounds: ...

	def __eq__(self, Other: BoxSphereBounds) -> bool: ...

	def __ne__(self, Other: BoxSphereBounds) -> bool: ...

	def ComputeSquaredDistanceFromBoxToPoint(self, Point: Vector) -> float: ...

	@staticmethod
	def SpheresIntersect(A: BoxSphereBounds, B: BoxSphereBounds, Tolerance: float = ...) -> bool: ...

	@staticmethod
	def BoxesIntersect(A: BoxSphereBounds, B: BoxSphereBounds) -> bool: ...

	def GetBox(self) -> Box: ...

	def GetBoxExtrema(self, Extrema: int) -> Vector: ...

	def ExpandBy(self, ExpandAmount: float) -> BoxSphereBounds: ...

	@overload
	def TransformBy(self, M: Matrix) -> BoxSphereBounds: ...

	@overload
	def TransformBy(self, M: Transform) -> BoxSphereBounds: ...

	def ToString(self) -> str: ...

	def ContainsNaN(self) -> bool: ...

	pass

class Matrix(object):
	"""A 4x4 matrix.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/Matrix.h"""

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InX: Plane, InY: Plane, InZ: Plane, InW: Plane): ...

	@overload
	def __init__(self, InX: Vector, InY: Vector, InZ: Vector, InW: Vector): ...

	def SetIdentity(self): ...

	@overload
	def __mul__(self, Other: Matrix) -> Matrix: ...

	@overload
	def __mul__(self, Other: float) -> Matrix: ...

	@overload
	def __imul__(self, Other: Matrix): ...

	@overload
	def __imul__(self, Other: float): ...

	def __add__(self, Other: Matrix) -> Matrix: ...

	def __iadd__(self, Other: Matrix): ...

	def __eq__(self, Other: Matrix) -> bool: ...

	def Equals(self, Other: Matrix, Tolerance: float = ...) -> bool: ...

	def __ne__(self, Other: Matrix) -> bool: ...

	def TransformFVector4(self, V: Vector4) -> Vector4: ...

	def TransformPosition(self, V: Vector) -> Vector4: ...

	def InverseTransformPosition(self, V: Vector) -> Vector: ...

	def TransformVector(self, V: Vector) -> Vector4: ...

	def InverseTransformVector(self, V: Vector) -> Vector: ...

	def GetTransposed(self) -> Matrix: ...

	def Determinant(self) -> float: ...

	def RotDeterminant(self) -> float: ...

	def InverseFast(self) -> Matrix: ...

	def Inverse(self) -> Matrix: ...

	def TransposeAdjoint(self) -> Matrix: ...

	def RemoveScaling(self, Tolerance: float = ...): ...

	def GetMatrixWithoutScale(self, Tolerance: float = ...) -> Matrix: ...

	def ExtractScaling(self, Tolerance: float = ...) -> Vector: ...

	def GetScaleVector(self, Tolerance: float = ...) -> Vector: ...

	def RemoveTranslation(self) -> Matrix: ...

	def ConcatTranslation(self, Translation: Vector) -> Matrix: ...

	def ContainsNaN(self) -> bool: ...

	def ScaleTranslation(self, Scale3D: Vector): ...

	def GetMaximumAxisScale(self) -> float: ...

	def ApplyScale(self, Scale: float) -> Matrix: ...

	def GetOrigin(self) -> Vector: ...

	def GetScaledAxes(self) -> typing.Tuple[Vector, Vector, Vector]: ...

	def GetUnitAxes(self) -> typing.Tuple[Vector, Vector, Vector]: ...

	def SetAxis(self, i: int, Axis: Vector): ...

	def SetOrigin(self, NewOrigin: Vector): ...

	def SetAxes(self, Axis0: Vector = ..., Axis1: Vector = ..., Axis2: Vector = ..., Origin: Vector = ...): ...

	def GetColumn(self, i: int) -> Vector: ...

	def SetColumn(self, i: int, Value: Vector): ...

	def Rotator(self) -> Rotator: ...

	def ToQuat(self) -> Quat: ...

	def GetFrustumNearPlane(self) -> typing.Tuple[bool, Plane]: ...

	def GetFrustumFarPlane(self) -> typing.Tuple[bool, Plane]: ...

	def GetFrustumLeftPlane(self) -> typing.Tuple[bool, Plane]: ...

	def GetFrustumRightPlane(self) -> typing.Tuple[bool, Plane]: ...

	def GetFrustumTopPlane(self) -> typing.Tuple[bool, Plane]: ...

	def GetFrustumBottomPlane(self) -> typing.Tuple[bool, Plane]: ...

	def ToString(self) -> str: ...

	def ComputeHash(self) -> int: ...

	pass

class InterpCurvePointFloat(object):
	"""Describes one specific point on an interpolation curve.
@note This is a mirror of TInterpCurvePoint<float>, defined in InterpCurvePoint.h"""

	@property
	def InVal(self) -> float: ...
	"""Float input value that corresponds to this key (eg. time)."""

	@property
	def OutVal(self) -> float: ...
	"""Float output value type when input is equal to InVal."""

	@property
	def ArriveTangent(self) -> float: ...
	"""Tangent of curve arriving at this point."""

	@property
	def LeaveTangent(self) -> float: ...
	"""Tangent of curve leaving this point."""

	@property
	def InterpMode(self) -> int: ...
	"""Interpolation mode between this point and the next one."""

	pass

class InterpCurveFloat(object):
	"""Describes an entire curve that is used to compute a float output value from a float input.
@note This is a mirror of TInterpCurve<float>, defined in InterpCurve.h"""

	@property
	def Points(self) -> typing.List[InterpCurvePointFloat]: ...
	"""Holds the collection of interpolation points."""

	@property
	def bIsLooped(self) -> bool: ...
	"""Specify whether the curve is looped or not"""

	@property
	def LoopKeyOffset(self) -> float: ...
	"""Specify the offset from the last point's input key corresponding to the loop point"""

	pass

class InterpCurvePointVector2D(object):
	"""Describes one specific point on an interpolation curve.
@note This is a mirror of TInterpCurvePoint<FVector2D>, defined in InterpCurvePoint.h"""

	@property
	def InVal(self) -> float: ...
	"""Float input value that corresponds to this key (eg. time)."""

	@property
	def OutVal(self) -> Vector2D: ...
	"""2D vector output value of when input is equal to InVal."""

	@property
	def ArriveTangent(self) -> Vector2D: ...
	"""Tangent of curve arriving at this point."""

	@property
	def LeaveTangent(self) -> Vector2D: ...
	"""Tangent of curve leaving this point."""

	@property
	def InterpMode(self) -> int: ...
	"""Interpolation mode between this point and the next one."""

	pass

class InterpCurveVector2D(object):
	"""Describes an entire curve that is used to compute a 2D vector output value from a float input.
@note This is a mirror of TInterpCurve<FVector2D>, defined in InterpCurve.h"""

	@property
	def Points(self) -> typing.List[InterpCurvePointVector2D]: ...
	"""Holds the collection of interpolation points."""

	@property
	def bIsLooped(self) -> bool: ...
	"""Specify whether the curve is looped or not"""

	@property
	def LoopKeyOffset(self) -> float: ...
	"""Specify the offset from the last point's input key corresponding to the loop point"""

	pass

class InterpCurvePointVector(object):
	"""Describes one specific point on an interpolation curve.
@note This is a mirror of TInterpCurvePoint<FVector>, defined in InterpCurvePoint.h"""

	@property
	def InVal(self) -> float: ...
	"""Float input value that corresponds to this key (eg. time)."""

	@property
	def OutVal(self) -> Vector: ...
	"""3D vector output value of when input is equal to InVal."""

	@property
	def ArriveTangent(self) -> Vector: ...
	"""Tangent of curve arriving at this point."""

	@property
	def LeaveTangent(self) -> Vector: ...
	"""Tangent of curve leaving this point."""

	@property
	def InterpMode(self) -> int: ...
	"""Interpolation mode between this point and the next one."""

	pass

class InterpCurveVector(object):
	"""Describes an entire curve that is used to compute a 3D vector output value from a float input.
@note This is a mirror of TInterpCurve<FVector>, defined in InterpCurve.h"""

	@property
	def Points(self) -> typing.List[InterpCurvePointVector]: ...
	"""Holds the collection of interpolation points."""

	@property
	def bIsLooped(self) -> bool: ...
	"""Specify whether the curve is looped or not"""

	@property
	def LoopKeyOffset(self) -> float: ...
	"""Specify the offset from the last point's input key corresponding to the loop point"""

	pass

class InterpCurvePointQuat(object):
	"""Describes one specific point on an interpolation curve.
@note This is a mirror of TInterpCurvePoint<FQuat>, defined in InterpCurvePoint.h"""

	@property
	def InVal(self) -> float: ...
	"""Float input value that corresponds to this key (eg. time)."""

	@property
	def OutVal(self) -> Quat: ...
	"""Quaternion output value of when input is equal to InVal."""

	@property
	def ArriveTangent(self) -> Quat: ...
	"""Tangent of curve arriving at this point."""

	@property
	def LeaveTangent(self) -> Quat: ...
	"""Tangent of curve leaving this point."""

	@property
	def InterpMode(self) -> int: ...
	"""Interpolation mode between this point and the next one."""

	pass

class InterpCurveQuat(object):
	"""Describes an entire curve that is used to compute a quaternion output value from a float input.
@note This is a mirror of TInterpCurve<FQuat>, defined in InterpCurve.h"""

	@property
	def Points(self) -> typing.List[InterpCurvePointQuat]: ...
	"""Holds the collection of interpolation points."""

	@property
	def bIsLooped(self) -> bool: ...
	"""Specify whether the curve is looped or not"""

	@property
	def LoopKeyOffset(self) -> float: ...
	"""Specify the offset from the last point's input key corresponding to the loop point"""

	pass

class InterpCurvePointTwoVectors(object):
	"""Describes one specific point on an interpolation curve.
@note This is a mirror of TInterpCurvePoint<FTwoVectors>, defined in InterpCurvePoint.h"""

	@property
	def InVal(self) -> float: ...
	"""Float input value that corresponds to this key (eg. time)."""

	@property
	def OutVal(self) -> TwoVectors: ...
	"""Two 3D vectors output value of when input is equal to InVal."""

	@property
	def ArriveTangent(self) -> TwoVectors: ...
	"""Tangent of curve arriving at this point."""

	@property
	def LeaveTangent(self) -> TwoVectors: ...
	"""Tangent of curve leaving this point."""

	@property
	def InterpMode(self) -> int: ...
	"""Interpolation mode between this point and the next one."""

	pass

class InterpCurveTwoVectors(object):
	"""Describes an entire curve that is used to compute two 3D vector values from a float input.
@note This is a mirror of TInterpCurve<FTwoVectors>, defined in InterpCurve.h"""

	@property
	def Points(self) -> typing.List[InterpCurvePointTwoVectors]: ...
	"""Holds the collection of interpolation points."""

	@property
	def bIsLooped(self) -> bool: ...
	"""Specify whether the curve is looped or not"""

	@property
	def LoopKeyOffset(self) -> float: ...
	"""Specify the offset from the last point's input key corresponding to the loop point"""

	pass

class InterpCurvePointLinearColor(object):
	"""Describes one specific point on an interpolation curve.
@note This is a mirror of TInterpCurvePoint<FLinearColor>, defined in InterpCurvePoint.h"""

	@property
	def InVal(self) -> float: ...
	"""Float input value that corresponds to this key (eg. time)."""

	@property
	def OutVal(self) -> LinearColor: ...
	"""Color output value of when input is equal to InVal."""

	@property
	def ArriveTangent(self) -> LinearColor: ...
	"""Tangent of curve arriving at this point."""

	@property
	def LeaveTangent(self) -> LinearColor: ...
	"""Tangent of curve leaving this point."""

	@property
	def InterpMode(self) -> int: ...
	"""Interpolation mode between this point and the next one."""

	pass

class InterpCurveLinearColor(object):
	"""Describes an entire curve that is used to compute a color output value from a float input.
@note This is a mirror of TInterpCurve<FLinearColor>, defined in InterpCurve.h"""

	@property
	def Points(self) -> typing.List[InterpCurvePointLinearColor]: ...
	"""Holds the collection of interpolation points."""

	@property
	def bIsLooped(self) -> bool: ...
	"""Specify whether the curve is looped or not"""

	@property
	def LoopKeyOffset(self) -> float: ...
	"""Specify the offset from the last point's input key corresponding to the loop point"""

	pass

class Transform(object):
	"""Transform composed of Quat/Translation/Scale.
@note This is implemented in either TransformVectorized.h or TransformNonVectorized.h depending on the platform."""

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InTranslation: Vector): ...

	@overload
	def __init__(self, InRotation: Quat): ...

	@overload
	def __init__(self, InRotation: Rotator): ...

	@overload
	def __init__(self, InRotation: Quat, InTranslation: Vector, InScale3D: Vector = ...): ...

	@overload
	def __init__(self, InRotation: Rotator, InTranslation: Vector, InScale3D: Vector = ...): ...

	@overload
	def __init__(self, InMatrix: Matrix): ...

	@overload
	def __init__(self, InX: Vector, InY: Vector, InZ: Vector, InTranslation: Vector): ...

	def ToHumanReadableString(self) -> str: ...

	def ToString(self) -> str: ...

	def ToMatrixWithScale(self) -> Matrix: ...

	def ToInverseMatrixWithScale(self) -> Matrix: ...

	def Inverse(self) -> Transform: ...

	def ToMatrixNoScale(self) -> Matrix: ...

	def Blend(self, Atom1: Transform, Atom2: Transform, Alpha: float): ...

	def BlendWith(self, OtherAtom: Transform, Alpha: float): ...

	def __add__(self, Atom: Transform) -> Transform: ...

	def __iadd__(self, Atom: Transform) -> Transform: ...

	@overload
	def __mul__(self, Other: Transform) -> Transform: ...

	@overload
	def __mul__(self, Other: Quat) -> Transform: ...

	@overload
	def __imul__(self, Other: Transform): ...

	@overload
	def __imul__(self, Other: Quat): ...

	@staticmethod
	def AnyHasNegativeScale(InScale3D: Vector, InOtherScale3D: Vector) -> bool: ...

	def ScaleTranslation(self, InScale3D: Vector): ...

	def RemoveScaling(self, Tolerance: float = ...): ...

	def GetMaximumAxisScale(self) -> float: ...

	def GetMinimumAxisScale(self) -> float: ...

	def GetRelativeTransform(self, Other: Transform) -> Transform: ...

	def GetRelativeTransformReverse(self, Other: Transform) -> Transform: ...

	def SetToRelativeTransform(self, ParentTransform: Transform): ...

	def TransformFVector4(self, V: Vector4) -> Vector4: ...

	def TransformFVector4NoScale(self, V: Vector4) -> Vector4: ...

	def TransformPosition(self, V: Vector) -> Vector: ...

	def TransformPositionNoScale(self, V: Vector) -> Vector: ...

	def InverseTransformPosition(self, V: Vector) -> Vector: ...

	def InverseTransformPositionNoScale(self, V: Vector) -> Vector: ...

	def TransformVector(self, V: Vector) -> Vector: ...

	def TransformVectorNoScale(self, V: Vector) -> Vector: ...

	def InverseTransformVector(self, V: Vector) -> Vector: ...

	def InverseTransformVectorNoScale(self, V: Vector) -> Vector: ...

	def TransformRotation(self, Q: Quat) -> Quat: ...

	def InverseTransformRotation(self, Q: Quat) -> Quat: ...

	@overload
	def GetScaled(self, Scale: float) -> Transform: ...

	@overload
	def GetScaled(self, Scale: Vector) -> Transform: ...

	@staticmethod
	def GetSafeScaleReciprocal(InScale: Vector, Tolerance: float = ...) -> Vector: ...

	def GetLocation(self) -> Vector: ...

	def Rotator(self) -> Rotator: ...

	def GetDeterminant(self) -> float: ...

	def SetLocation(self, Origin: Vector): ...

	def ContainsNaN(self) -> bool: ...

	def IsValid(self) -> bool: ...

	@staticmethod
	def AreRotationsEqual(A: Transform, B: Transform, Tolerance: float = ...) -> bool: ...

	@staticmethod
	def AreTranslationsEqual(A: Transform, B: Transform, Tolerance: float = ...) -> bool: ...

	@staticmethod
	def AreScale3DsEqual(A: Transform, B: Transform, Tolerance: float = ...) -> bool: ...

	def RotationEquals(self, Other: Transform, Tolerance: float = ...) -> bool: ...

	def TranslationEquals(self, Other: Transform, Tolerance: float = ...) -> bool: ...

	def Scale3DEquals(self, Other: Transform, Tolerance: float = ...) -> bool: ...

	def Equals(self, Other: Transform, Tolerance: float = ...) -> bool: ...

	def Identical(self, Other: Transform, PortFlags: int) -> bool: ...

	def EqualsNoScale(self, Other: Transform, Tolerance: float = ...) -> bool: ...

	@staticmethod
	def Multiply(OutTransform: Transform, A: Transform, B: Transform): ...

	def SetComponents(self, InRotation: Quat, InTranslation: Vector, InScale3D: Vector): ...

	def SetIdentity(self): ...

	def MultiplyScale3D(self, Scale3DMultiplier: Vector): ...

	def SetTranslation(self, NewTranslation: Vector): ...

	def CopyTranslation(self, Other: Transform): ...

	def ConcatenateRotation(self, DeltaRotation: Quat): ...

	def AddToTranslation(self, DeltaTranslation: Vector): ...

	@staticmethod
	def AddTranslations(A: Transform, B: Transform) -> Vector: ...

	@staticmethod
	def SubtractTranslations(A: Transform, B: Transform) -> Vector: ...

	def SetRotation(self, NewRotation: Quat): ...

	def CopyRotation(self, Other: Transform): ...

	def SetScale3D(self, NewScale3D: Vector): ...

	def CopyScale3D(self, Other: Transform): ...

	def SetTranslationAndScale3D(self, NewTranslation: Vector, NewScale3D: Vector): ...

	def Accumulate(self, SourceAtom: Transform): ...

	def NormalizeRotation(self): ...

	def IsRotationNormalized(self) -> bool: ...

	def GetRotation(self) -> Quat: ...

	def GetTranslation(self) -> Vector: ...

	def GetScale3D(self) -> Vector: ...

	def CopyRotationPart(self, SrcBA: Transform): ...

	def CopyTranslationAndScale3D(self, SrcBA: Transform): ...

	def SetFromMatrix(self, InMatrix: Matrix): ...

	pass

class RandomStream(object):
	"""Thread-safe random number generator that can be manually seeded.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Math/RandomStream.h"""

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InSeed: int): ...

	@overload
	def __init__(self, InName: str): ...

	@overload
	def Initialize(self, InSeed: int): ...

	@overload
	def Initialize(self, InName: str): ...

	def Reset(self): ...

	def GetInitialSeed(self) -> int: ...

	def GenerateNewSeed(self): ...

	def GetFraction(self) -> float: ...

	def GetUnsignedInt(self) -> int: ...

	def GetUnitVector(self) -> Vector: ...

	def GetCurrentSeed(self) -> int: ...

	def FRand(self) -> float: ...

	def RandHelper(self, A: int) -> int: ...

	def RandRange(self, Min: int, Max: int) -> int: ...

	def FRandRange(self, InMin: float, InMax: float) -> float: ...

	def VRand(self) -> Vector: ...

	@overload
	def VRandCone(self, Dir: Vector, ConeHalfAngleRad: float) -> Vector: ...

	@overload
	def VRandCone(self, Dir: Vector, HorizontalConeHalfAngleRad: float, VerticalConeHalfAngleRad: float) -> Vector: ...

	def ToString(self) -> str: ...

	pass

class DateTime(object):
	"""A value representing a specific point date and time over a wide range of years.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Misc/DateTime.h"""

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InTicks: long): ...

	@overload
	def __init__(self, Year: int, Month: int, Day: int, Hour: int = ..., Minute: int = ..., Second: int = ..., Millisecond: int = ...): ...

	@overload
	def __add__(self, Other: Timespan) -> DateTime: ...

	@overload
	def __add__(self, Other: DateTime) -> DateTime: ...

	def __iadd__(self, Other: Timespan) -> DateTime: ...

	@overload
	def __sub__(self, Other: DateTime) -> Timespan: ...

	@overload
	def __sub__(self, Other: Timespan) -> DateTime: ...

	def __isub__(self, Other: Timespan) -> DateTime: ...

	def __eq__(self, Other: DateTime) -> bool: ...

	def __ne__(self, Other: DateTime) -> bool: ...

	def __gt__(self, Other: DateTime) -> bool: ...

	def __ge__(self, Other: DateTime) -> bool: ...

	def __lt__(self, Other: DateTime) -> bool: ...

	def __le__(self, Other: DateTime) -> bool: ...

	def GetDate(self) -> DateTime: ...

	def GetDay(self) -> int: ...

	def GetDayOfWeek(self) -> int: ...

	def GetDayOfYear(self) -> int: ...

	def GetHour(self) -> int: ...

	def GetHour12(self) -> int: ...

	def GetJulianDay(self) -> float: ...

	def GetModifiedJulianDay(self) -> float: ...

	def GetMillisecond(self) -> int: ...

	def GetMinute(self) -> int: ...

	def GetMonth(self) -> int: ...

	def GetMonthOfYear(self) -> int: ...

	def GetSecond(self) -> int: ...

	def GetTicks(self) -> long: ...

	def GetTimeOfDay(self) -> Timespan: ...

	def GetYear(self) -> int: ...

	def IsAfternoon(self) -> bool: ...

	def IsMorning(self) -> bool: ...

	def ToHttpDate(self) -> str: ...

	def ToIso8601(self) -> str: ...

	def ToString(self) -> str: ...

	def ToUnixTimestamp(self) -> long: ...

	@staticmethod
	def DaysInMonth(Year: int, Month: int) -> int: ...

	@staticmethod
	def DaysInYear(Year: int) -> int: ...

	@staticmethod
	def FromJulianDay(JulianDay: float) -> DateTime: ...

	@staticmethod
	def FromUnixTimestamp(UnixTime: long) -> DateTime: ...

	@staticmethod
	def IsLeapYear(Year: int) -> bool: ...

	@staticmethod
	def MaxValue() -> DateTime: ...

	@staticmethod
	def MinValue() -> DateTime: ...

	@staticmethod
	def Now() -> DateTime: ...

	@staticmethod
	def Parse(DateTimeString: str) -> typing.Tuple[bool, DateTime]: ...

	@staticmethod
	def ParseHttpDate(HttpDate: str) -> typing.Tuple[bool, DateTime]: ...

	@staticmethod
	def Today() -> DateTime: ...

	@staticmethod
	def UtcNow() -> DateTime: ...

	@staticmethod
	def Validate(Year: int, Month: int, Day: int, Hour: int, Minute: int, Second: int, Millisecond: int) -> bool: ...

	pass

class FrameNumber(object):
	"""A frame number value, representing discrete frames since the start of timing.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Misc/FrameNumber.h"""

	@property
	def Value(self) -> int: ...
	"""Value"""

	pass

class FrameRate(object):
	"""A frame rate represented as a fraction comprising 2 integers: a numerator (number of frames), and a denominator (per second).
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Misc/FrameRate.h"""

	@property
	def Numerator(self) -> int: ...
	"""The numerator of the framerate represented as a number of frames per second (e.g. 60 for 60 fps)"""

	@property
	def Denominator(self) -> int: ...
	"""The denominator of the framerate represented as a number of frames per second (e.g. 1 for 60 fps)"""

	pass

class QualifiedFrameTime(object):
	"""A frame time qualified by a frame rate context.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Misc/QualifiedFrameTime.h"""

	@property
	def Time(self) -> typing.Any: ...
	"""The frame time"""

	@property
	def Rate(self) -> FrameRate: ...
	"""The rate that this frame time is in"""

	pass

class Timecode(object):
	"""A timecode that stores time in HH:MM:SS format with the remainder of time represented by an integer frame count.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Misc/TimeCode.h"""

	@property
	def Hours(self) -> int: ...
	"""Hours"""

	@property
	def Minutes(self) -> int: ...
	"""Minutes"""

	@property
	def Seconds(self) -> int: ...
	"""Seconds"""

	@property
	def Frames(self) -> int: ...
	"""Frames"""

	@property
	def bDropFrameFormat(self) -> bool: ...
	"""If true, this Timecode represents a Drop Frame timecode used to account for fractional frame rates in NTSC play rates."""

	pass

class Timespan(object):
	"""A time span value, which is the difference between two dates and times.
@note The full C++ class is located here: Engine/Source/Runtime/Core/Public/Misc/Timespan.h"""

	pass

class SoftObjectPath(object):
	"""A struct that contains a string reference to an object, either a top level asset or a subobject.
@note The full C++ class is located here: Engine/Source/Runtime/CoreUObject/Public/UObject/SoftObjectPath.h"""

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, Other: SoftObjectPath): ...

	@overload
	def __init__(self, Path: str): ...

	@overload
	def __init__(self, InAssetPathName: str, InSubPathString: str): ...

	@overload
	def __init__(self, InObject: Object): ...

	def ToString(self) -> str: ...

	def GetAssetPathName(self) -> str: ...

	def GetAssetPathString(self) -> str: ...

	def GetSubPathString(self) -> str: ...

	def GetLongPackageName(self) -> str: ...

	def GetAssetName(self) -> str: ...

	def SetPath(self, Path: str): ...

	def ResolveObject(self) -> Object: ...

	def Reset(self): ...

	def IsValid(self) -> bool: ...

	def IsNull(self) -> bool: ...

	def IsAsset(self) -> bool: ...

	def IsSubobject(self) -> bool: ...

	def __eq__(self, Other: SoftObjectPath) -> bool: ...

	def __ne__(self, Other: SoftObjectPath) -> bool: ...

	@staticmethod
	def GetCurrentTag() -> int: ...

	@staticmethod
	def InvalidateTag() -> int: ...

	@staticmethod
	def GetOrCreateIDForObject(Object: Object) -> SoftObjectPath: ...

	@staticmethod
	def AddPIEPackageName(NewPIEPackageName: str): ...

	@staticmethod
	def ClearPIEPackageNames(): ...

	pass

class SoftClassPath(SoftObjectPath):
	"""A struct that contains a string reference to a class, can be used to make soft references to classes.
@note The full C++ class is located here: Engine/Source/Runtime/CoreUObject/Public/UObject/SoftObjectPath.h"""

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, Other: SoftClassPath): ...

	@overload
	def __init__(self, PathString: str): ...

	@overload
	def __init__(self, InClass: Class): ...

	def ResolveClass(self) -> Class: ...

	@staticmethod
	def GetOrCreateIDForClass(InClass: Class) -> SoftClassPath: ...

	pass

class PrimaryAssetType(object):
	"""A type of primary asset, used by the Asset Manager system.
@note The full C++ class is located here: Engine/Source/Runtime/CoreUObject/Public/UObject/PrimaryAssetId.h"""

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InName: str): ...

	def GetName(self) -> str: ...

	def __eq__(self, Other: PrimaryAssetType) -> bool: ...

	def __ne__(self, Other: PrimaryAssetType) -> bool: ...

	def IsValid(self) -> bool: ...

	def ToString(self) -> str: ...

	pass

class PrimaryAssetId(object):
	"""This identifies an object as a 'primary' asset that can be searched for by the AssetManager and used in various tools
@note The full C++ class is located here: Engine/Source/Runtime/CoreUObject/Public/UObject/PrimaryAssetId.h"""

	@property
	def PrimaryAssetType(self) -> PrimaryAssetType: ...

	@property
	def PrimaryAssetName(self) -> str: ...

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InAssetType: PrimaryAssetType, InAssetName: str): ...

	@overload
	def __init__(self, TypeAndName: str): ...

	@staticmethod
	@overload
	def ParseTypeAndName(TypeAndName: str) -> PrimaryAssetId: ...

	@staticmethod
	@overload
	def ParseTypeAndName(TypeAndName: str) -> PrimaryAssetId: ...

	def IsValid(self) -> bool: ...

	def ToString(self) -> str: ...

	@staticmethod
	def FromString(String: str) -> PrimaryAssetId: ...

	def __eq__(self, Other: PrimaryAssetId) -> bool: ...

	def __ne__(self, Other: PrimaryAssetId) -> bool: ...

	pass

class FloatRange(object):
	"""A contiguous set of floats described by lower and upper bound values.
@note This is a mirror of TRange<float>, defined in Range.h"""

	@property
	def LowerBound(self) -> typing.Any: ...
	"""Holds the range's lower bound."""

	@property
	def UpperBound(self) -> typing.Any: ...
	"""Holds the range's upper bound."""

	pass

class Int32Range(object):
	"""A contiguous set of floats described by lower and upper bound values.
@note This is a mirror of TRange<int32>, defined in Range.h"""

	@property
	def LowerBound(self) -> typing.Any: ...
	"""Holds the range's lower bound."""

	@property
	def UpperBound(self) -> typing.Any: ...
	"""Holds the range's upper bound."""

	pass

class ARFilter(object):
	"""ARFilter"""

	@property
	def PackageNames(self) -> typing.List[str]: ...
	"""The filter component for package names"""

	@property
	def PackagePaths(self) -> typing.List[str]: ...
	"""The filter component for package paths"""

	@property
	def ObjectPaths(self) -> typing.List[str]: ...
	"""The filter component containing specific object paths"""

	@property
	def ClassNames(self) -> typing.List[str]: ...
	"""The filter component for class names. Instances of the specified classes, but not subclasses (by default), will be included. Derived classes will be included only if bRecursiveClasses is true."""

	@property
	def RecursiveClassesExclusionSet(self) -> typing.Set[str]: ...
	"""Only if bRecursiveClasses is true, the results will exclude classes (and subclasses) in this list"""

	@property
	def bRecursivePaths(self) -> bool: ...
	"""If true, PackagePath components will be recursive"""

	@property
	def bRecursiveClasses(self) -> bool: ...
	"""If true, subclasses of ClassNames will also be included and RecursiveClassesExclusionSet will be excluded."""

	@property
	def bIncludeOnlyOnDiskAssets(self) -> bool: ...
	"""If true, only on-disk assets will be returned. Be warned that this is rarely what you want and should only be used for performance reasons"""

	pass

class AssetData(object):
	"""A struct to hold important information about an assets found by the Asset Registry
This struct is transient and should never be serialized"""

	@property
	def ObjectPath(self) -> str: ...
	"""The object path for the asset in the form PackageName.AssetName. Only top level objects in a package can have AssetData"""

	@property
	def PackageName(self) -> str: ...
	"""The name of the package in which the asset is found, this is the full long package name such as /Game/Path/Package"""

	@property
	def PackagePath(self) -> str: ...
	"""The path to the package in which the asset is found, this is /Game/Path with the Package stripped off"""

	@property
	def AssetName(self) -> str: ...
	"""The name of the asset without the package"""

	@property
	def AssetClass(self) -> str: ...
	"""The name of the asset's class"""

	pass

class UniqueNetIdWrapper(object):
	"""Unique Net Id Wrapper"""

	pass

class Math(object):
	@staticmethod
	def RandHelper(A: int) -> int: ...

	@staticmethod
	def RandHelper64(A: long) -> long: ...

	@staticmethod
	@overload
	def RandRange(Min: int, Max: int) -> int: ...

	@staticmethod
	@overload
	def RandRange(Min: long, Max: long) -> long: ...

	@staticmethod
	@overload
	def RandRange(InMin: float, InMax: float) -> float: ...

	@staticmethod
	def FRandRange(InMin: float, InMax: float) -> float: ...

	@staticmethod
	def RandBool() -> bool: ...

	@staticmethod
	def VRand() -> Vector: ...

	@staticmethod
	@overload
	def VRandCone(Dir: Vector, ConeHalfAngleRad: float) -> Vector: ...

	@staticmethod
	@overload
	def VRandCone(Dir: Vector, HorizontalConeHalfAngleRad: float, VerticalConeHalfAngleRad: float) -> Vector: ...

	@staticmethod
	def RandPointInCircle(CircleRadius: float) -> Vector2D: ...

	@staticmethod
	def RandPointInBox(Box: Box) -> Vector: ...

	@staticmethod
	def GetReflectionVector(Direction: Vector, SurfaceNormal: Vector) -> Vector: ...

	@staticmethod
	@overload
	def IsNearlyEqual(A: float, B: float, ErrorTolerance: float = ...) -> bool: ...

	@staticmethod
	@overload
	def IsNearlyEqual(A: float, B: float, ErrorTolerance: float = ...) -> bool: ...

	@staticmethod
	@overload
	def IsNearlyZero(Value: float, ErrorTolerance: float = ...) -> bool: ...

	@staticmethod
	@overload
	def IsNearlyZero(Value: float, ErrorTolerance: float = ...) -> bool: ...

	@staticmethod
	@overload
	def IsNearlyEqualByULP(A: float, B: float, MaxUlps: int = ...) -> bool: ...

	@staticmethod
	@overload
	def IsNearlyEqualByULP(A: float, B: float, MaxUlps: int = ...) -> bool: ...

	@staticmethod
	@overload
	def Floor(F: float) -> float: ...

	@staticmethod
	@overload
	def Floor(F: float) -> float: ...

	@staticmethod
	def Log2(Value: float) -> float: ...

	@staticmethod
	def FastAsin(Value: float) -> float: ...

	@staticmethod
	def ClampAngle(AngleDegrees: float, MinAngleDegrees: float, MaxAngleDegrees: float) -> float: ...

	@staticmethod
	def FindDeltaAngleDegrees(A1: float, A2: float) -> float: ...

	@staticmethod
	def FindDeltaAngleRadians(A1: float, A2: float) -> float: ...

	@staticmethod
	def FindDeltaAngle(A1: float, A2: float) -> float: ...

	@staticmethod
	def UnwindRadians(A: float) -> float: ...

	@staticmethod
	def UnwindDegrees(A: float) -> float: ...

	@staticmethod
	def FixedTurn(InCurrent: float, InDesired: float, InDeltaRate: float) -> float: ...

	@staticmethod
	def GetDotDistance(Direction: Vector, AxisX: Vector, AxisY: Vector, AxisZ: Vector) -> typing.Tuple[bool, Vector2D]: ...

	@staticmethod
	def GetAzimuthAndElevation(Direction: Vector, AxisX: Vector, AxisY: Vector, AxisZ: Vector) -> Vector2D: ...

	@staticmethod
	def GetRangePct(Range: Vector2D, Value: float) -> float: ...

	@staticmethod
	def GetRangeValue(Range: Vector2D, Pct: float) -> float: ...

	@staticmethod
	def GetMappedRangeValueClamped(InputRange: Vector2D, OutputRange: Vector2D, Value: float) -> float: ...

	@staticmethod
	def GetMappedRangeValueUnclamped(InputRange: Vector2D, OutputRange: Vector2D, Value: float) -> float: ...

	@staticmethod
	def VInterpNormalRotationTo(Current: Vector, Target: Vector, DeltaTime: float, RotationSpeedDegrees: float) -> Vector: ...

	@staticmethod
	def VInterpConstantTo(Current: Vector, Target: Vector, DeltaTime: float, InterpSpeed: float) -> Vector: ...

	@staticmethod
	def VInterpTo(Current: Vector, Target: Vector, DeltaTime: float, InterpSpeed: float) -> Vector: ...

	@staticmethod
	def Vector2DInterpConstantTo(Current: Vector2D, Target: Vector2D, DeltaTime: float, InterpSpeed: float) -> Vector2D: ...

	@staticmethod
	def Vector2DInterpTo(Current: Vector2D, Target: Vector2D, DeltaTime: float, InterpSpeed: float) -> Vector2D: ...

	@staticmethod
	def RInterpConstantTo(Current: Rotator, Target: Rotator, DeltaTime: float, InterpSpeed: float) -> Rotator: ...

	@staticmethod
	def RInterpTo(Current: Rotator, Target: Rotator, DeltaTime: float, InterpSpeed: float) -> Rotator: ...

	@staticmethod
	def FInterpConstantTo(Current: float, Target: float, DeltaTime: float, InterpSpeed: float) -> float: ...

	@staticmethod
	def FInterpTo(Current: float, Target: float, DeltaTime: float, InterpSpeed: float) -> float: ...

	@staticmethod
	def CInterpTo(Current: LinearColor, Target: LinearColor, DeltaTime: float, InterpSpeed: float) -> LinearColor: ...

	@staticmethod
	def QInterpConstantTo(Current: Quat, Target: Quat, DeltaTime: float, InterpSpeed: float) -> Quat: ...

	@staticmethod
	def QInterpTo(Current: Quat, Target: Quat, DeltaTime: float, InterpSpeed: float) -> Quat: ...

	@staticmethod
	def MakePulsatingValue(InCurrentTime: float, InPulsesPerSecond: float, InPhase: float = ...) -> float: ...

	@staticmethod
	def RayPlaneIntersection(RayOrigin: Vector, RayDirection: Vector, Plane: Plane) -> Vector: ...

	@staticmethod
	@overload
	def LinePlaneIntersection(Point1: Vector, Point2: Vector, PlaneOrigin: Vector, PlaneNormal: Vector) -> Vector: ...

	@staticmethod
	@overload
	def LinePlaneIntersection(Point1: Vector, Point2: Vector, Plane: Plane) -> Vector: ...

	@staticmethod
	def ComputeProjectedSphereScissorRect(SphereOrigin: Vector, Radius: float, ViewOrigin: Vector, ViewMatrix: Matrix, ProjMatrix: Matrix) -> typing.Tuple[int, typing.Any]: ...

	@staticmethod
	def PlaneAABBIntersection(P: Plane, AABB: Box) -> bool: ...

	@staticmethod
	def PlaneAABBRelativePosition(P: Plane, AABB: Box) -> int: ...

	@staticmethod
	def SphereAABBIntersection(SphereCenter: Vector, RadiusSquared: float, AABB: Box) -> bool: ...

	@staticmethod
	def PointBoxIntersection(Point: Vector, Box: Box) -> bool: ...

	@staticmethod
	@overload
	def LineBoxIntersection(Box: Box, Start: Vector, End: Vector, Direction: Vector) -> bool: ...

	@staticmethod
	@overload
	def LineBoxIntersection(Box: Box, Start: Vector, End: Vector, Direction: Vector, OneOverDirection: Vector) -> bool: ...

	@staticmethod
	def LineSphereIntersection(Start: Vector, Dir: Vector, Length: float, Origin: Vector, Radius: float) -> bool: ...

	@staticmethod
	def SphereConeIntersection(SphereCenter: Vector, SphereRadius: float, ConeAxis: Vector, ConeAngleSin: float, ConeAngleCos: float) -> bool: ...

	@staticmethod
	def ClosestPointOnLine(LineStart: Vector, LineEnd: Vector, Point: Vector) -> Vector: ...

	@staticmethod
	def ClosestPointOnInfiniteLine(LineStart: Vector, LineEnd: Vector, Point: Vector) -> Vector: ...

	@staticmethod
	def IntersectPlanes3(P1: Plane, P2: Plane, P3: Plane) -> typing.Tuple[bool, Vector]: ...

	@staticmethod
	def IntersectPlanes2(P1: Plane, P2: Plane) -> typing.Tuple[bool, Vector, Vector]: ...

	@staticmethod
	@overload
	def PointDistToLine(Point: Vector, Direction: Vector, Origin: Vector) -> typing.Tuple[float, Vector]: ...

	@staticmethod
	@overload
	def PointDistToLine(Point: Vector, Direction: Vector, Origin: Vector) -> float: ...

	@staticmethod
	def ClosestPointOnSegment(Point: Vector, StartPoint: Vector, EndPoint: Vector) -> Vector: ...

	@staticmethod
	def ClosestPointOnSegment2D(Point: Vector2D, StartPoint: Vector2D, EndPoint: Vector2D) -> Vector2D: ...

	@staticmethod
	def PointDistToSegment(Point: Vector, StartPoint: Vector, EndPoint: Vector) -> float: ...

	@staticmethod
	def PointDistToSegmentSquared(Point: Vector, StartPoint: Vector, EndPoint: Vector) -> float: ...

	@staticmethod
	def SegmentDistToSegment(A1: Vector, B1: Vector, A2: Vector, B2: Vector) -> typing.Tuple[Vector, Vector]: ...

	@staticmethod
	def SegmentDistToSegmentSafe(A1: Vector, B1: Vector, A2: Vector, B2: Vector) -> typing.Tuple[Vector, Vector]: ...

	@staticmethod
	def GetTForSegmentPlaneIntersect(StartPoint: Vector, EndPoint: Vector, Plane: Plane) -> float: ...

	@staticmethod
	def SegmentPlaneIntersection(StartPoint: Vector, EndPoint: Vector, Plane: Plane) -> typing.Tuple[bool, Vector]: ...

	@staticmethod
	def SegmentTriangleIntersection(StartPoint: Vector, EndPoint: Vector, A: Vector, B: Vector, C: Vector) -> typing.Tuple[bool, Vector, Vector]: ...

	@staticmethod
	def SegmentIntersection2D(SegmentStartA: Vector, SegmentEndA: Vector, SegmentStartB: Vector, SegmentEndB: Vector) -> typing.Tuple[bool, Vector]: ...

	@staticmethod
	def ClosestPointOnTriangleToPoint(Point: Vector, A: Vector, B: Vector, C: Vector) -> Vector: ...

	@staticmethod
	def ClosestPointOnTetrahedronToPoint(Point: Vector, A: Vector, B: Vector, C: Vector, D: Vector) -> Vector: ...

	@staticmethod
	def SphereDistToLine(SphereOrigin: Vector, SphereRadius: float, LineOrigin: Vector, LineDir: Vector) -> Vector: ...

	@staticmethod
	@overload
	def TruncateToHalfIfClose(F: float, Tolerance: float = ...) -> float: ...

	@staticmethod
	@overload
	def TruncateToHalfIfClose(F: float, Tolerance: float = ...) -> float: ...

	@staticmethod
	@overload
	def RoundHalfToEven(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundHalfToEven(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundHalfFromZero(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundHalfFromZero(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundHalfToZero(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundHalfToZero(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundFromZero(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundFromZero(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundToZero(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundToZero(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundToNegativeInfinity(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundToNegativeInfinity(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundToPositiveInfinity(F: float) -> float: ...

	@staticmethod
	@overload
	def RoundToPositiveInfinity(F: float) -> float: ...

	@staticmethod
	def FormatIntToHumanReadable(Val: int) -> str: ...

	@staticmethod
	def GetBaryCentric2D(Point: Vector, A: Vector, B: Vector, C: Vector) -> Vector: ...

	@staticmethod
	def ComputeBaryCentric2D(Point: Vector, A: Vector, B: Vector, C: Vector) -> Vector: ...

	@staticmethod
	def ComputeBaryCentric3D(Point: Vector, A: Vector, B: Vector, C: Vector, D: Vector) -> Vector4: ...

	@staticmethod
	def SmoothStep(A: float, B: float, X: float) -> float: ...

	@staticmethod
	def Quantize8UnsignedByte(x: float) -> int: ...

	@staticmethod
	def Quantize8SignedByte(x: float) -> int: ...

	@staticmethod
	def GreatestCommonDivisor(a: int, b: int) -> int: ...

	@staticmethod
	def LeastCommonMultiplier(a: int, b: int) -> int: ...

	@staticmethod
	def PerlinNoise1D(Value: float) -> float: ...

	@staticmethod
	def PerlinNoise2D(Location: Vector2D) -> float: ...

	@staticmethod
	def PerlinNoise3D(Location: Vector) -> float: ...

	@staticmethod
	def WeightedMovingAverage(CurrentSample: float, PreviousSample: float, Weight: float) -> float: ...

	@staticmethod
	def DynamicWeightedMovingAverage(CurrentSample: float, PreviousSample: float, MaxDistance: float, MinWeight: float, MaxWeight: float) -> float: ...

	pass

class Object(object):
	"""Direct base class for all UE4 objects
@note The full C++ class is located here: Engine/Source/Runtime/CoreUObject/Public/UObject/Object.h"""

	def GetClass(self) -> Class: ...

	def GetFlags(self) -> int: ...

	def SetFlags(self, Flags: int, Reset: bool) -> None: ...

	def ClearFlags(Flags: int) -> None: ...

	def ResetFlags(self) -> None: ...

	def GetOuter(self) -> Object: ...

	def SetOuter(self, InPackage: Package) -> bool: ...

	def GetOutermost(self) -> Package: ...

	def IsValid(self) -> bool: ...

	def IsA(self, InClass: Class) -> bool: ...

	def GetName(self) -> str: ...

	def SetName(self, InName: str) -> bool: ...

	def GetFullName(self) -> str: ...

	def GetPathName(self) -> str: ...

	def BindEvent(self, EventName: str, Callback: typing.Callable) -> None: ...

	def UnbindEvent(self, EventName: str, Callback: typing.Callable) -> None: ...

	def SetProperty(self, PropName: str, PropValue: typing.Any) -> None: ...

	def IsOwnedByPython(self) -> bool: ...

	def OwnByPython(self) -> None: ...

	def DisownByPython(self) -> None: ...

	def AsDict(self) -> typing.Dict[str, typing.Any]: ...

	pass

class Class(object):
	"""An object class"""

	def ClassGeneratedBy() -> Object: ...

	def GetClassFlags() -> EClassFlags: ...

	def SetClassFlags(EClassFlags) -> None: ...

	def GetSuperClass() -> Class: ...

	def IsChildOf(Class) -> bool: ...

	def GetDefaultObject() -> Object: ...

	pass

class ELifetimeCondition(Enum):
	"""Secondary condition to check before considering the replication of a lifetime property."""

	# 
	COND_None = 0
	# This property has no condition, and will send anytime it changes
	COND_InitialOnly = 1
	# This property will only attempt to send on the initial bunch
	COND_OwnerOnly = 2
	# This property will only send to the actor's owner
	COND_SkipOwner = 3
	# This property send to every connection EXCEPT the owner
	COND_SimulatedOnly = 4
	# This property will only send to simulated actors
	COND_AutonomousOnly = 5
	# This property will only send to autonomous actors
	COND_SimulatedOrPhysics = 6
	# This property will send to simulated OR bRepPhysics actors
	COND_InitialOrOwner = 7
	# This property will send on the initial packet, or to the actors owner
	COND_Custom = 8
	# This property has no particular condition, but wants the ability to toggle on/off via SetCustomIsActiveOverride
	COND_ReplayOrOwner = 9
	# This property will only send to the replay connection, or to the actors owner
	COND_ReplayOnly = 10
	# This property will only send to the replay connection
	COND_SimulatedOnlyNoReplay = 11
	# This property will send to actors only, but not to replay connections
	COND_SimulatedOrPhysicsNoReplay = 12
	# This property will send to simulated Or bRepPhysics actors, but not to replay connections
	COND_SkipReplay = 13
	# This property will not send to the replay connection
	COND_Never = 15
	# This property will never be replicated
	COND_Max = 16

class ESearchCase(Enum):
	"""Determines case sensitivity options for string comparisons.
@note Mirrored from Engine/Source/Runtime/Core/Public/Containers/UnrealString.h"""

	# 
	CaseSensitive = 0
	# 
	IgnoreCase = 1

class ESearchDir(Enum):
	"""Determines search direction for string operations.
@note Mirrored from Engine/Source/Runtime/Core/Public/Containers/UnrealString.h"""

	# 
	FromStart = 0
	# 
	FromEnd = 1

class ELogTimes(Enum):
	"""Enum that defines how the log times are to be displayed.
@note Mirrored from Engine/Source/Runtime/Core/Public/Misc/OutputDevice.h"""

	# Do not display log timestamps.
	None = 0
	# Display log timestamps in UTC.
	UTC = 1
	# Display log timestamps in seconds elapsed since GStartTime.
	SinceGStartTime = 2
	# Display log timestamps in local time.
	Local = 3

class EAxis(Enum):
	"""Generic axis enum (mirrored for native use in Axis.h)."""

	# 
	None = 0
	# 
	X = 1
	# 
	Y = 2
	# 
	Z = 3

class EInterpCurveMode(Enum):
	"""Describes shape of an interpolation curve (mirrored from InterpCurvePoint.h)."""

	# A straight line between two keypoint values.
	CIM_Linear = 0
	# A cubic-hermite curve between two keypoints, using Arrive/Leave tangents. These tangents will be automatically
	#               updated when points are moved, etc.  Tangents are unclamped and will plateau at curve start and end points.
	CIM_CurveAuto = 1
	# The out value is held constant until the next key, then will jump to that value.
	CIM_Constant = 2
	# A smooth curve just like CIM_Curve, but tangents are not automatically updated so you can have manual control over them (eg. in Curve Editor).
	CIM_CurveUser = 3
	# A curve like CIM_Curve, but the arrive and leave tangents are not forced to be the same, so you can create a 'corner' at this key.
	CIM_CurveBreak = 4
	# A cubic-hermite curve between two keypoints, using Arrive/Leave tangents. These tangents will be automatically
	#           updated when points are moved, etc.  Tangents are clamped and will plateau at curve start and end points.
	CIM_CurveAutoClamped = 5

class EPixelFormat(Enum):
	"""Describes the format of a each pixel in a graphics buffer.
@warning: When you update this, you must add an entry to GPixelFormats(see RenderUtils.cpp)
@warning: When you update this, you must add an entries to PixelFormat.h, usually just copy the generated section on the header into EPixelFormat
@warning: The *Tools DLLs will also need to be recompiled if the ordering is changed, but should not need code changes."""

	# 
	PF_Unknown = 0
	# 
	PF_A32B32G32R32F = 1
	# UNORM (0..1), corresponds to FColor.  Unpacks as rgba in the shader.
	PF_B8G8R8A8 = 2
	# UNORM red (0..1)
	PF_G8 = 3
	# 
	PF_G16 = 4
	# 
	PF_DXT1 = 5
	# 
	PF_DXT3 = 6
	# 
	PF_DXT5 = 7
	# 
	PF_UYVY = 8
	# Same as PF_FloatR11G11B10
	PF_FloatRGB = 9
	# RGBA 16 bit signed FP format.  Use FFloat16Color on the CPU.
	PF_FloatRGBA = 10
	# A depth+stencil format with platform-specific implementation, for use with render targets.
	PF_DepthStencil = 11
	# A depth format with platform-specific implementation, for use with render targets.
	PF_ShadowDepth = 12
	# 
	PF_R32_FLOAT = 13
	# 
	PF_G16R16 = 14
	# 
	PF_G16R16F = 15
	# 
	PF_G16R16F_FILTER = 16
	# 
	PF_G32R32F = 17
	# 
	PF_A2B10G10R10 = 18
	# 
	PF_A16B16G16R16 = 19
	# 
	PF_D24 = 20
	# 
	PF_R16F = 21
	# 
	PF_R16F_FILTER = 22
	# 
	PF_BC5 = 23
	# SNORM red, green (-1..1). Not supported on all RHI e.g. Metal
	PF_V8U8 = 24
	# 
	PF_A1 = 25
	# A low precision floating point format, unsigned.  Use FFloat3Packed on the CPU.
	PF_FloatR11G11B10 = 26
	# 
	PF_A8 = 27
	# 
	PF_R32_UINT = 28
	# 
	PF_R32_SINT = 29
	# 
	PF_PVRTC2 = 30
	# 
	PF_PVRTC4 = 31
	# 
	PF_R16_UINT = 32
	# 
	PF_R16_SINT = 33
	# 
	PF_R16G16B16A16_UINT = 34
	# 
	PF_R16G16B16A16_SINT = 35
	# 
	PF_R5G6B5_UNORM = 36
	# 
	PF_R8G8B8A8 = 37
	# Only used for legacy loading; do NOT use!
	PF_A8R8G8B8 = 38
	# High precision single channel block compressed, equivalent to a single channel BC5, 8 bytes per 4x4 block.
	PF_BC4 = 39
	# UNORM red, green (0..1).
	PF_R8G8 = 40
	# ATITC format.
	PF_ATC_RGB = 41
	# ATITC format.
	PF_ATC_RGBA_E = 42
	# ATITC format.
	PF_ATC_RGBA_I = 43
	# Used for creating SRVs to alias a DepthStencil buffer to read Stencil.  Don't use for creating textures.
	PF_X24_G8 = 44
	# 
	PF_ETC1 = 45
	# 
	PF_ETC2_RGB = 46
	# 
	PF_ETC2_RGBA = 47
	# 
	PF_R32G32B32A32_UINT = 48
	# 
	PF_R16G16_UINT = 49
	# 8.00 bpp
	PF_ASTC_4x4 = 50
	# 3.56 bpp
	PF_ASTC_6x6 = 51
	# 2.00 bpp
	PF_ASTC_8x8 = 52
	# 1.28 bpp
	PF_ASTC_10x10 = 53
	# 0.89 bpp
	PF_ASTC_12x12 = 54
	# 
	PF_BC6H = 55
	# 
	PF_BC7 = 56
	# 
	PF_R8_UINT = 57
	# 
	PF_L8 = 58
	# 
	PF_XGXR8 = 59
	# 
	PF_R8G8B8A8_UINT = 60
	# SNORM (-1..1), corresponds to FFixedRGBASigned8.
	PF_R8G8B8A8_SNORM = 61
	# 
	PF_R16G16B16A16_UNORM = 62
	# 
	PF_R16G16B16A16_SNORM = 63
	# 
	PF_PLATFORM_HDR_0 = 64
	# 
	PF_PLATFORM_HDR_1 = 65
	# 
	PF_PLATFORM_HDR_2 = 66
	# 
	PF_NV12 = 67
	# 
	PF_R32G32_UINT = 68
	# 
	PF_ETC2_R11_EAC = 69
	# 
	PF_ETC2_RG11_EAC = 70
	# 
	PF_MAX = 71

class EMouseCursor(Enum):
	"""Mouse cursor types (mirrored from ICursor.h)"""

	# Causes no mouse cursor to be visible.
	None = 0
	# Default cursor (arrow).
	Default = 1
	# Text edit beam.
	TextEditBeam = 2
	# Resize horizontal.
	ResizeLeftRight = 3
	# Resize vertical.
	ResizeUpDown = 4
	# Resize diagonal.
	ResizeSouthEast = 5
	# Resize other diagonal.
	ResizeSouthWest = 6
	# MoveItem.
	CardinalCross = 7
	# Target Cross.
	Crosshairs = 8
	# Hand cursor.
	Hand = 9
	# Grab Hand cursor.
	GrabHand = 10
	# Grab Hand cursor closed.
	GrabHandClosed = 11
	# a circle with a diagonal line through it.
	SlashedCircle = 12
	# Eye-dropper cursor for picking colors.
	EyeDropper = 13

class EUnit(Enum):
	"""A set of numerical unit types supported by the engine. Mirrored from UnitConversion.h"""

	# Scalar distance/length unit.
	Micrometers = 0
	# 
	Millimeters = 1
	# 
	Centimeters = 2
	# 
	Meters = 3
	# 
	Kilometers = 4
	# 
	Inches = 5
	# 
	Feet = 6
	# 
	Yards = 7
	# 
	Miles = 8
	# 
	Lightyears = 9
	# Angular units
	Degrees = 10
	# 
	Radians = 11
	# Speed units
	MetersPerSecond = 12
	# 
	KilometersPerHour = 13
	# 
	MilesPerHour = 14
	# Temperature units
	Celsius = 15
	# 
	Farenheit = 16
	# 
	Kelvin = 17
	# Mass units
	Micrograms = 18
	# 
	Milligrams = 19
	# 
	Grams = 20
	# 
	Kilograms = 21
	# 
	MetricTons = 22
	# 
	Ounces = 23
	# 
	Pounds = 24
	# 
	Stones = 25
	# Force units
	Newtons = 26
	# 
	PoundsForce = 27
	# 
	KilogramsForce = 28
	# Frequency units
	Hertz = 29
	# 
	Kilohertz = 30
	# 
	Megahertz = 31
	# 
	Gigahertz = 32
	# 
	RevolutionsPerMinute = 33
	# Data Size units
	Bytes = 34
	# 
	Kilobytes = 35
	# 
	Megabytes = 36
	# 
	Gigabytes = 37
	# 
	Terabytes = 38
	# Luminous flux units
	Lumens = 39
	# Time units
	Milliseconds = 40
	# 
	Seconds = 41
	# 
	Minutes = 42
	# 
	Hours = 43
	# 
	Days = 44
	# 
	Months = 45
	# 
	Years = 46
	# Arbitrary multiplier
	Multiplier = 47
	# Percentage
	Percentage = 48
	# Symbolic entry, not specifiable on meta data.
	Unspecified = 49

class EPropertyAccessChangeNotifyMode(Enum):
	"""Enum controlling when to emit property change notifications when setting a property value.
@note Mirrored from PropertyAccessUtil.h"""

	# Notify only when a value change has actually occurred
	Default = 0
	# Never notify that a value change has occurred
	Never = 1
	# Always notify that a value change has occurred, even if the value is unchanged
	Always = 2

class EAppReturnType(Enum):
	"""Enum denoting message dialog return types.
@note Mirrored from GenericPlatformMisc.h"""

	# 
	No = 0
	# 
	Yes = 1
	# 
	YesAll = 2
	# 
	NoAll = 3
	# 
	Cancel = 4
	# 
	Ok = 5
	# 
	Retry = 6
	# 
	Continue = 7

class EAppMsgType(Enum):
	"""Enumerates supported message dialog button types."""

	# 
	Ok = 0
	# 
	YesNo = 1
	# 
	OkCancel = 2
	# 
	YesNoCancel = 3
	# 
	CancelRetryContinue = 4
	# 
	YesNoYesAllNoAll = 5
	# 
	YesNoYesAllNoAllCancel = 6
	# 
	YesNoYesAll = 7

class ERangeBoundTypes(Enum):
	"""Enumerates the valid types of range bounds (mirrored from RangeBound.h)"""

	# The range excludes the bound.
	Exclusive = 0
	# The range includes the bound.
	Inclusive = 1
	# The bound is open.
	Open = 2

class ELocalizedTextSourceCategory(Enum):
	"""Categories of localized text (mirrored in LocalizedTextSourceTypes.h"""

	# 
	Game = 0
	# 
	Engine = 1
	# 
	Editor = 2

class EAutomationEventType(Enum):
	"""Report level of automation events (mirrored in AutomationEvent.h)."""

	# 
	Info = 0
	# 
	Warning = 1
	# 
	Error = 2

class EDataValidationResult(Enum):
	"""Enum used by DataValidation plugin to see if an asset has been validated for correctness (mirrored in UObjectGlobals.h)"""

	# Asset has failed validation
	Invalid = 0
	# Asset has passed validation
	Valid = 1
	# Asset has not yet been validated
	NotValidated = 2

class BodyInstanceCore(object):
	"""Body Instance Core"""

	@property
	def bSimulatePhysics(self) -> bool: ...
	"""If true, this body will use simulation. If false, will be 'fixed' (ie kinematic) and move where it is told.
For a Skeletal Mesh Component, simulating requires a physics asset setup and assigned on the SkeletalMesh asset.
For a Static Mesh Component, simulating requires simple collision to be setup on the StaticMesh asset."""

	@property
	def bOverrideMass(self) -> bool: ...
	"""If true, mass will not be automatically computed and you must set it directly"""

	@property
	def bEnableGravity(self) -> bool: ...
	"""If object should have the force of gravity applied"""

	@property
	def bAutoWeld(self) -> bool: ...
	"""If true and is attached to a parent, the two bodies will be joined into a single rigid body. Physical settings like collision profile and body settings are determined by the root"""

	@property
	def bStartAwake(self) -> bool: ...
	"""If object should start awake, or if it should initially be sleeping"""

	@property
	def bGenerateWakeEvents(self) -> bool: ...
	"""Should 'wake/sleep' events fire when this object is woken up or put to sleep by the physics simulation."""

	@property
	def bUpdateMassWhenScaleChanges(self) -> bool: ...
	"""If true, it will update mass when scale changes *"""

	pass

class ChaosPhysicalMaterial(Object):
	"""Physical materials are used to define the response of a physical object when
interacting dynamically with the world."""

	@property
	def Friction(self) -> float: ...
	"""Friction value of a surface in motion, controls how easily things can slide on this surface (0 is frictionless, higher values increase the amount of friction)"""

	@property
	def StaticFriction(self) -> float: ...
	"""Friction value of surface at rest, controls how easily things can slide on this surface (0 is frictionless, higher values increase the amount of friction)"""

	@property
	def Restitution(self) -> float: ...
	"""Restitution or 'bounciness' of this surface, between 0 (no bounce) and 1 (outgoing velocity is same as incoming)."""

	@property
	def LinearEtherDrag(self) -> float: ...
	"""Uniform linear ether drag, the resistance a body experiences to its translation."""

	@property
	def AngularEtherDrag(self) -> float: ...
	"""Uniform angular ether drag, the resistance a body experiences to its rotation."""

	@property
	def SleepingLinearVelocityThreshold(self) -> float: ...
	"""How much to scale the damage threshold by on any destructible we are applied to"""

	@property
	def SleepingAngularVelocityThreshold(self) -> float: ...
	"""How much to scale the damage threshold by on any destructible we are applied to"""

	pass

class PhysicalMaterial(Object):
	"""Physical materials are used to define the response of a physical object when interacting dynamically with the world."""

	@property
	def Friction(self) -> float: ...
	"""Friction value of surface, controls how easily things can slide on this surface (0 is frictionless, higher values increase the amount of friction)"""

	@property
	def StaticFriction(self) -> float: ...
	"""Static Friction value of surface, controls how easily things can slide on this surface (0 is frictionless, higher values increase the amount of friction)"""

	@property
	def FrictionCombineMode(self) -> int: ...
	"""Friction combine mode, controls how friction is computed for multiple materials."""

	@property
	def bOverrideFrictionCombineMode(self) -> bool: ...
	"""If set we will use the FrictionCombineMode of this material, instead of the FrictionCombineMode found in the project settings."""

	@property
	def Restitution(self) -> float: ...
	"""Restitution or 'bounciness' of this surface, between 0 (no bounce) and 1 (outgoing velocity is same as incoming)."""

	@property
	def RestitutionCombineMode(self) -> int: ...
	"""Restitution combine mode, controls how restitution is computed for multiple materials."""

	@property
	def bOverrideRestitutionCombineMode(self) -> bool: ...
	"""If set we will use the RestitutionCombineMode of this material, instead of the RestitutionCombineMode found in the project settings."""

	@property
	def Density(self) -> float: ...
	"""Used with the shape of the object to calculate its mass properties. The higher the number, the heavier the object. g per cubic cm."""

	@property
	def SleepLinearVelocityThreshold(self) -> float: ...
	"""How low the linear velocity can be before solver puts body to sleep."""

	@property
	def SleepAngularVelocityThreshold(self) -> float: ...
	"""How low the angular velocity can be before solver puts body to sleep."""

	@property
	def SleepCounterThreshold(self) -> int: ...
	"""How many ticks we can be under thresholds for before solver puts body to sleep."""

	@property
	def RaiseMassToPower(self) -> float: ...
	"""Used to adjust the way that mass increases as objects get larger. This is applied to the mass as calculated based on a 'solid' object.
In actuality, larger objects do not tend to be solid, and become more like 'shells' (e.g. a car is not a solid piece of metal).
Values are clamped to 1 or less."""

	@property
	def DestructibleDamageThresholdScale(self) -> float: ...
	"""How much to scale the damage threshold by on any destructible we are applied to"""

	@property
	def SurfaceType(self) -> int: ...
	"""To edit surface type for your project, use ProjectSettings/Physics/PhysicalSurface section"""

	pass

class ECollisionTraceFlag(Enum):
	"""ECollision Trace Flag"""

	# Use project physics settings (DefaultShapeComplexity)
	CTF_UseDefault = 0
	# Create both simple and complex shapes. Simple shapes are used for regular scene queries and collision tests. Complex shape (per poly) is used for complex scene queries.
	CTF_UseSimpleAndComplex = 1
	# Create only simple shapes. Use simple shapes for all scene queries and collision tests.
	CTF_UseSimpleAsComplex = 2
	# Create only complex shapes (per poly). Use complex shapes for all scene queries and collision tests. Can be used in simulation for static shapes only (i.e can be collided against but not moved through forces or velocity.)
	CTF_UseComplexAsSimple = 3
	# 
	CTF_MAX = 4

class EPhysicsType(Enum):
	"""EPhysics Type"""

	# Follow owner.
	PhysType_Default = 0
	# Do not follow owner, but make kinematic.
	PhysType_Kinematic = 1
	# Do not follow owner, but simulate.
	PhysType_Simulated = 2

class EBodyCollisionResponse(Enum):
	"""EBody Collision Response"""

	# 
	BodyCollision_Enabled = 0
	# 
	BodyCollision_Disabled = 1

class EPhysicalSurface(Enum):
	"""Types of surfaces in the game, used by Physical Materials"""

	# 
	SurfaceType_Default = 0
	# 
	SurfaceType1 = 1
	# 
	SurfaceType2 = 2
	# 
	SurfaceType3 = 3
	# 
	SurfaceType4 = 4
	# 
	SurfaceType5 = 5
	# 
	SurfaceType6 = 6
	# 
	SurfaceType7 = 7
	# 
	SurfaceType8 = 8
	# 
	SurfaceType9 = 9
	# 
	SurfaceType10 = 10
	# 
	SurfaceType11 = 11
	# 
	SurfaceType12 = 12
	# 
	SurfaceType13 = 13
	# 
	SurfaceType14 = 14
	# 
	SurfaceType15 = 15
	# 
	SurfaceType16 = 16
	# 
	SurfaceType17 = 17
	# 
	SurfaceType18 = 18
	# 
	SurfaceType19 = 19
	# 
	SurfaceType20 = 20
	# 
	SurfaceType21 = 21
	# 
	SurfaceType22 = 22
	# 
	SurfaceType23 = 23
	# 
	SurfaceType24 = 24
	# 
	SurfaceType25 = 25
	# 
	SurfaceType26 = 26
	# 
	SurfaceType27 = 27
	# 
	SurfaceType28 = 28
	# 
	SurfaceType29 = 29
	# 
	SurfaceType30 = 30
	# 
	SurfaceType31 = 31
	# 
	SurfaceType32 = 32
	# 
	SurfaceType33 = 33
	# 
	SurfaceType34 = 34
	# 
	SurfaceType35 = 35
	# 
	SurfaceType36 = 36
	# 
	SurfaceType37 = 37
	# 
	SurfaceType38 = 38
	# 
	SurfaceType39 = 39
	# 
	SurfaceType40 = 40
	# 
	SurfaceType41 = 41
	# 
	SurfaceType42 = 42
	# 
	SurfaceType43 = 43
	# 
	SurfaceType44 = 44
	# 
	SurfaceType45 = 45
	# 
	SurfaceType46 = 46
	# 
	SurfaceType47 = 47
	# 
	SurfaceType48 = 48
	# 
	SurfaceType49 = 49
	# 
	SurfaceType50 = 50
	# 
	SurfaceType51 = 51
	# 
	SurfaceType52 = 52
	# 
	SurfaceType53 = 53
	# 
	SurfaceType54 = 54
	# 
	SurfaceType55 = 55
	# 
	SurfaceType56 = 56
	# 
	SurfaceType57 = 57
	# 
	SurfaceType58 = 58
	# 
	SurfaceType59 = 59
	# 
	SurfaceType60 = 60
	# 
	SurfaceType61 = 61
	# 
	SurfaceType62 = 62
	# 
	SurfaceType_Max = 63

class ERadialImpulseFalloff(Enum):
	"""Enum for controlling the falloff of strength of a radial impulse as a function of distance from Origin."""

	# Impulse is a constant strength, up to the limit of its range.
	RIF_Constant = 0
	# Impulse should get linearly weaker the further from origin.
	RIF_Linear = 1
	# 
	RIF_MAX = 2

class ESleepFamily(Enum):
	"""Presets of values used in considering when put this body to sleep."""

	# Engine defaults.
	Normal = 0
	# A family of values with a lower sleep threshold; good for slower pendulum-like physics.
	Sensitive = 1
	# Specify your own sleep threshold multiplier
	Custom = 2

class EAngularConstraintMotion(Enum):
	"""Specifies angular degrees of freedom"""

	# No constraint against this axis.
	ACM_Free = 0
	# Limited freedom along this axis.
	ACM_Limited = 1
	# Fully constraint against this axis.
	ACM_Locked = 2
	# 
	ACM_MAX = 3

class EConstraintFrame(Enum):
	"""Enum to indicate which context frame we use for physical constraints"""

	# 
	Frame1 = 0
	# 
	Frame2 = 1

class ELinearConstraintMotion(Enum):
	"""LINEAR DOF"""

	# No constraint against this axis.
	LCM_Free = 0
	# Limited freedom along this axis.
	LCM_Limited = 1
	# Fully constraint against this axis.
	LCM_Locked = 2
	# 
	LCM_MAX = 3

class EFrictionCombineMode(Enum):
	"""EFriction Combine Mode"""

	# Uses the average value of the materials touching: (a+b)/2
	Average = 0
	# Uses the minimum value of the materials touching: min(a,b)
	Min = 1
	# Uses the product of the values of the materials touching: a*b
	Multiply = 2
	# Uses the maximum value of materials touching: max(a,b)
	Max = 3

class Key(object):
	"""Key"""

	pass

class EControllerHand(Enum):
	"""Defines the controller hands for tracking.  Could be expanded, as needed, to facilitate non-handheld controllers"""

	# 
	Left = 0
	# 
	Right = 1
	# 
	AnyHand = 2
	# 
	Pad = 3
	# 
	ExternalCamera = 4
	# 
	Gun = 5
	# 
	Special_1 = 6
	# 
	Special_2 = 7
	# 
	Special_3 = 8
	# 
	Special_4 = 9
	# 
	Special_5 = 10
	# 
	Special_6 = 11
	# 
	Special_7 = 12
	# 
	Special_8 = 13
	# 
	Special_9 = 14
	# 
	Special_10 = 15
	# 
	Special_11 = 16
	# 
	ControllerHand_Count = 17

class ETouchIndex(Enum):
	"""The number of entries in ETouchIndex must match the number of touch keys defined in EKeys and NUM_TOUCH_KEYS above"""

	# 
	Touch1 = 0
	# 
	Touch2 = 1
	# 
	Touch3 = 2
	# 
	Touch4 = 3
	# 
	Touch5 = 4
	# 
	Touch6 = 5
	# 
	Touch7 = 6
	# 
	Touch8 = 7
	# 
	Touch9 = 8
	# 
	Touch10 = 9
	# This entry is special.  NUM_TOUCH_KEYS - 1, is used for the cursor so that it's represented
	# as another finger index, but doesn't overlap with touch input indexes.
	CursorPointerIndex = 10
	# 
	MAX_TOUCHES = 11

class EConsoleForGamepadLabels(Enum):
	"""EConsole for Gamepad Labels"""

	# 
	None = 0
	# 
	XBoxOne = 1
	# 
	PS4 = 2

class ETouchType(Enum):
	"""Various states of touch inputs."""

	# 
	Began = 0
	# 
	Moved = 1
	# 
	Stationary = 2
	# 
	ForceChanged = 3
	# 
	FirstMove = 4
	# 
	Ended = 5
	# 
	NumTypes = 6

class Vector_NetQuantize(Vector):
	"""FVector_NetQuantize

0 decimal place of precision.
Up to 20 bits per component.
Valid range: 2^20 = +/- 1,048,576

Note: this is the historical UE format for vector net serialization"""

	pass

class Vector_NetQuantize10(Vector):
	"""FVector_NetQuantize10

1 decimal place of precision.
Up to 24 bits per component.
Valid range: 2^24 / 10 = +/- 1,677,721.6"""

	pass

class Vector_NetQuantize100(Vector):
	"""FVector_NetQuantize100

2 decimal place of precision.
Up to 30 bits per component.
Valid range: 2^30 / 100 = +/- 10,737,418.24"""

	pass

class Vector_NetQuantizeNormal(Vector):
	"""FVector_NetQuantizeNormal

16 bits per component
Valid range: -1..+1 inclusive"""

	pass

class LightingChannels(object):
	"""Specifies which lighting channels are relevant"""

	@property
	def bChannel0(self) -> bool: ...
	"""Default channel for all primitives and lights."""

	@property
	def bChannel1(self) -> bool: ...
	"""First custom channel"""

	@property
	def bChannel2(self) -> bool: ...
	"""Second custom channel"""

	pass

class CollisionResponseContainer(object):
	"""Container for indicating a set of collision channels that this object will collide with."""

	@property
	def WorldStatic(self) -> int: ...
	"""Reserved Engine Trace Channels

Note -        If you change this (add/remove/modify)
                      you should make sure it matches with ECollisionChannel (including DisplayName)
                      They has to be mirrored if serialized"""

	@property
	def WorldDynamic(self) -> int: ...
	"""0"""

	@property
	def Pawn(self) -> int: ...
	"""1."""

	@property
	def Visibility(self) -> int: ...
	"""2"""

	@property
	def Camera(self) -> int: ...
	"""3"""

	@property
	def PhysicsBody(self) -> int: ...
	"""4"""

	@property
	def Vehicle(self) -> int: ...
	"""5"""

	@property
	def Destructible(self) -> int: ...
	"""6"""

	@property
	def EngineTraceChannel1(self) -> int: ...
	"""Unspecified Engine Trace Channels"""

	@property
	def EngineTraceChannel2(self) -> int: ...
	"""8"""

	@property
	def EngineTraceChannel3(self) -> int: ...
	"""9"""

	@property
	def EngineTraceChannel4(self) -> int: ...
	"""10"""

	@property
	def EngineTraceChannel5(self) -> int: ...
	"""11"""

	@property
	def EngineTraceChannel6(self) -> int: ...
	"""12"""

	@property
	def GameTraceChannel1(self) -> int: ...
	"""in order to use this custom channels
we recommend to define in your local file
- i.e. #define COLLISION_WEAPON               ECC_GameTraceChannel1
and make sure you customize these it in INI file by

in DefaultEngine.ini

[/Script/Engine.CollisionProfile]
GameTraceChannel1='Weapon'

also in the INI file, you can override collision profiles that are defined by simply redefining
note that Weapon isn't defined in the BaseEngine.ini file, but 'Trigger' is defined in Engine
+Profiles=(Name='Trigger',CollisionEnabled=QueryOnly,ObjectTypeName=WorldDynamic, DefaultResponse=ECR_Overlap, CustomResponses=((Channel=Visibility, Response=ECR_Ignore), (Channel=Weapon, Response=ECR_Ignore)))"""

	@property
	def GameTraceChannel2(self) -> int: ...
	"""14"""

	@property
	def GameTraceChannel3(self) -> int: ...
	"""15"""

	@property
	def GameTraceChannel4(self) -> int: ...
	"""16"""

	@property
	def GameTraceChannel5(self) -> int: ...
	"""17"""

	@property
	def GameTraceChannel6(self) -> int: ...
	"""18"""

	@property
	def GameTraceChannel7(self) -> int: ...
	"""19"""

	@property
	def GameTraceChannel8(self) -> int: ...
	"""20"""

	@property
	def GameTraceChannel9(self) -> int: ...
	"""21"""

	@property
	def GameTraceChannel10(self) -> int: ...
	"""22"""

	@property
	def GameTraceChannel11(self) -> int: ...
	"""23"""

	@property
	def GameTraceChannel12(self) -> int: ...
	"""24"""

	@property
	def GameTraceChannel13(self) -> int: ...
	"""25"""

	@property
	def GameTraceChannel14(self) -> int: ...
	"""26"""

	@property
	def GameTraceChannel15(self) -> int: ...
	"""27"""

	@property
	def GameTraceChannel16(self) -> int: ...
	"""28"""

	@property
	def GameTraceChannel17(self) -> int: ...
	"""28"""

	@property
	def GameTraceChannel18(self) -> int: ...
	"""30"""

	pass

class FractureEffect(object):
	"""Struct used to hold effects for destructible damage events"""

	@property
	def ParticleSystem(self) -> ParticleSystem: ...
	"""Particle system effect to play at fracture location."""

	@property
	def Sound(self) -> SoundBase: ...
	"""Sound cue to play at fracture location."""

	pass

class BasedPosition(object):
	"""Struct for handling positions relative to a base actor, which is potentially moving"""

	@property
	def Base(self) -> Actor: ...
	"""Actor that is the base"""

	@property
	def Position(self) -> Vector: ...
	"""Position relative to the base actor"""

	@property
	def CachedBaseLocation(self) -> Vector: ...
	"""Cached Base Location"""

	@property
	def CachedBaseRotation(self) -> Rotator: ...
	"""Cached Base Rotation"""

	@property
	def CachedTransPosition(self) -> Vector: ...
	"""Cached Trans Position"""

	pass

class SubtitleCue(object):
	"""A line of subtitle text and the time at which it should be displayed."""

	@property
	def Text(self) -> str: ...
	"""The text to appear in the subtitle."""

	@property
	def Time(self) -> float: ...
	"""The time at which the subtitle is to be displayed, in seconds relative to the beginning of the line."""

	pass

class HitResult(object):
	"""Structure containing information about one hit of a trace, such as point of impact and surface normal at that point."""

	@property
	def bBlockingHit(self) -> bool: ...
	"""Indicates if this hit was a result of blocking collision. If false, there was no hit or it was an overlap/touch instead."""

	@property
	def bStartPenetrating(self) -> bool: ...
	"""Whether the trace started in penetration, i.e. with an initial blocking overlap.
In the case of penetration, if PenetrationDepth > 0.f, then it will represent the distance along the Normal vector that will result in
minimal contact between the swept shape and the object that was hit. In this case, ImpactNormal will be the normal opposed to movement at that location
(ie, Normal may not equal ImpactNormal). ImpactPoint will be the same as Location, since there is no single impact point to report."""

	@property
	def FaceIndex(self) -> int: ...
	"""Face index we hit (for complex hits with triangle meshes)."""

	@property
	def Time(self) -> float: ...
	"""'Time' of impact along trace direction (ranging from 0.0 to 1.0) if there is a hit, indicating time between TraceStart and TraceEnd.
For swept movement (but not queries) this may be pulled back slightly from the actual time of impact, to prevent precision problems with adjacent geometry."""

	@property
	def Distance(self) -> float: ...
	"""The distance from the TraceStart to the Location in world space. This value is 0 if there was an initial overlap (trace started inside another colliding object)."""

	@property
	def Location(self) -> Vector_NetQuantize: ...
	"""The location in world space where the moving shape would end up against the impacted object, if there is a hit. Equal to the point of impact for line tests.
Example: for a sphere trace test, this is the point where the center of the sphere would be located when it touched the other object.
For swept movement (but not queries) this may not equal the final location of the shape since hits are pulled back slightly to prevent precision issues from overlapping another surface."""

	@property
	def ImpactPoint(self) -> Vector_NetQuantize: ...
	"""Location in world space of the actual contact of the trace shape (box, sphere, ray, etc) with the impacted object.
Example: for a sphere trace test, this is the point where the surface of the sphere touches the other object.
@note: In the case of initial overlap (bStartPenetrating=true), ImpactPoint will be the same as Location because there is no meaningful single impact point to report."""

	@property
	def Normal(self) -> Vector_NetQuantizeNormal: ...
	"""Normal of the hit in world space, for the object that was swept. Equal to ImpactNormal for line tests.
This is computed for capsules and spheres, otherwise it will be the same as ImpactNormal.
Example: for a sphere trace test, this is a normalized vector pointing in towards the center of the sphere at the point of impact."""

	@property
	def ImpactNormal(self) -> Vector_NetQuantizeNormal: ...
	"""Normal of the hit in world space, for the object that was hit by the sweep, if any.
For example if a sphere hits a flat plane, this is a normalized vector pointing out from the plane.
In the case of impact with a corner or edge of a surface, usually the 'most opposing' normal (opposed to the query direction) is chosen."""

	@property
	def TraceStart(self) -> Vector_NetQuantize: ...
	"""Start location of the trace.
For example if a sphere is swept against the world, this is the starting location of the center of the sphere."""

	@property
	def TraceEnd(self) -> Vector_NetQuantize: ...
	"""End location of the trace; this is NOT where the impact occurred (if any), but the furthest point in the attempted sweep.
For example if a sphere is swept against the world, this would be the center of the sphere if there was no blocking hit."""

	@property
	def PenetrationDepth(self) -> float: ...
	"""If this test started in penetration (bStartPenetrating is true) and a depenetration vector can be computed,
this value is the distance along Normal that will result in moving out of penetration.
If the distance cannot be computed, this distance will be zero."""

	@property
	def Item(self) -> int: ...
	"""Extra data about item that was hit (hit primitive specific)."""

	@property
	def ElementIndex(self) -> int: ...
	"""Index to item that was hit, also hit primitive specific."""

	@property
	def PhysMaterial(self) -> PhysicalMaterial: ...
	"""Physical material that was hit.
@note Must set bReturnPhysicalMaterial on the swept PrimitiveComponent or in the query params for this to be returned."""

	@property
	def Actor(self) -> Actor: ...
	"""Actor hit by the trace."""

	@property
	def Component(self) -> PrimitiveComponent: ...
	"""PrimitiveComponent hit by the trace."""

	@property
	def BoneName(self) -> str: ...
	"""Name of bone we hit (for skeletal meshes)."""

	@property
	def MyBoneName(self) -> str: ...
	"""Name of the _my_ bone which took part in hit event (in case of two skeletal meshes colliding)."""

	pass

class POV(object):
	"""Point Of View structure used in Camera calculations"""

	@property
	def Location(self) -> Vector: ...
	"""Location"""

	@property
	def Rotation(self) -> Rotator: ...
	"""Rotation"""

	@property
	def FOV(self) -> float: ...
	"""FOV angle"""

	pass

class MeshBuildSettings(object):
	"""Settings applied when building a mesh."""

	@property
	def bUseMikkTSpace(self) -> bool: ...
	"""If true, degenerate triangles will be removed."""

	@property
	def bRecomputeNormals(self) -> bool: ...
	"""If true, normals in the raw mesh are ignored and recomputed."""

	@property
	def bRecomputeTangents(self) -> bool: ...
	"""If true, tangents in the raw mesh are ignored and recomputed."""

	@property
	def bComputeWeightedNormals(self) -> bool: ...
	"""If true, we will use the surface area and the corner angle of the triangle as a ratio when computing the normals."""

	@property
	def bRemoveDegenerates(self) -> bool: ...
	"""If true, degenerate triangles will be removed."""

	@property
	def bBuildAdjacencyBuffer(self) -> bool: ...
	"""Required for PNT tessellation but can be slow. Recommend disabling for larger meshes."""

	@property
	def bBuildReversedIndexBuffer(self) -> bool: ...
	"""Required to optimize mesh in mirrored transform. Double index buffer size."""

	@property
	def bUseHighPrecisionTangentBasis(self) -> bool: ...
	"""If true, Tangents will be stored at 16 bit vs 8 bit precision."""

	@property
	def bUseFullPrecisionUVs(self) -> bool: ...
	"""If true, UVs will be stored at full floating point precision."""

	@property
	def bGenerateLightmapUVs(self) -> bool: ...
	"""Generate Lightmap UVs"""

	@property
	def bGenerateDistanceFieldAsIfTwoSided(self) -> bool: ...
	"""Whether to generate the distance field treating every triangle hit as a front face.
When enabled prevents the distance field from being discarded due to the mesh being open, but also lowers Distance Field AO quality."""

	@property
	def bSupportFaceRemap(self) -> bool: ...
	"""Support Face Remap"""

	@property
	def MinLightmapResolution(self) -> int: ...
	"""Min Lightmap Resolution"""

	@property
	def SrcLightmapIndex(self) -> int: ...
	"""Src Lightmap Index"""

	@property
	def DstLightmapIndex(self) -> int: ...
	"""Dst Lightmap Index"""

	@property
	def BuildScale3D(self) -> Vector: ...
	"""The local scale applied when building the mesh"""

	@property
	def DistanceFieldResolutionScale(self) -> float: ...
	"""Scale to apply to the mesh when allocating the distance field volume texture.
The default scale is 1, which is assuming that the mesh will be placed unscaled in the world."""

	@property
	def DistanceFieldReplacementMesh(self) -> StaticMesh: ...
	"""Distance Field Replacement Mesh"""

	pass

class SkeletalMeshBuildSettings(object):
	"""Settings applied when building a mesh."""

	@property
	def bRecomputeNormals(self) -> bool: ...
	"""If true, normals in the raw mesh are ignored and recomputed."""

	@property
	def bRecomputeTangents(self) -> bool: ...
	"""If true, tangents in the raw mesh are ignored and recomputed."""

	@property
	def bUseMikkTSpace(self) -> bool: ...
	"""If true, degenerate triangles will be removed."""

	@property
	def bComputeWeightedNormals(self) -> bool: ...
	"""If true, we will use the surface area and the corner angle of the triangle as a ratio when computing the normals."""

	@property
	def bRemoveDegenerates(self) -> bool: ...
	"""If true, degenerate triangles will be removed."""

	@property
	def bUseHighPrecisionTangentBasis(self) -> bool: ...
	"""If true, Tangents will be stored at 16 bit vs 8 bit precision."""

	@property
	def bUseFullPrecisionUVs(self) -> bool: ...
	"""If true, UVs will be stored at full floating point precision."""

	@property
	def bBuildAdjacencyBuffer(self) -> bool: ...
	"""Required for PNT tessellation but can be slow. Recommend disabling for larger meshes."""

	@property
	def ThresholdPosition(self) -> float: ...
	"""Threshold use to decide if two vertex position are equal."""

	@property
	def ThresholdTangentNormal(self) -> float: ...
	"""Threshold use to decide if two normal, tangents or bi-normals are equal."""

	@property
	def ThresholdUV(self) -> float: ...
	"""Threshold use to decide if two UVs are equal."""

	@property
	def MorphThresholdPosition(self) -> float: ...
	"""Threshold to compare vertex position equality when computing morph target deltas."""

	pass

class DamageEvent(object):
	"""Event used by AActor::TakeDamage and related functions"""

	@property
	def DamageTypeClass(self) -> DamageType: ...
	"""Optional DamageType for this event.  If nullptr, UDamageType will be assumed."""

	pass

class PointDamageEvent(DamageEvent):
	"""Damage subclass that handles damage with a single impact location and source direction"""

	@property
	def Damage(self) -> float: ...
	"""Actual damage done"""

	@property
	def ShotDirection(self) -> Vector_NetQuantizeNormal: ...
	"""Direction the shot came from. Should be normalized."""

	@property
	def HitInfo(self) -> HitResult: ...
	"""Describes the trace/location that caused this damage"""

	pass

class RadialDamageParams(object):
	"""Parameters used to compute radial damage"""

	@property
	def BaseDamage(self) -> float: ...
	"""Max damage done"""

	@property
	def MinimumDamage(self) -> float: ...
	"""Damage will not fall below this if within range"""

	@property
	def InnerRadius(self) -> float: ...
	"""Within InnerRadius, do max damage"""

	@property
	def OuterRadius(self) -> float: ...
	"""Outside OuterRadius, do no damage"""

	@property
	def DamageFalloff(self) -> float: ...
	"""Describes amount of exponential damage falloff"""

	pass

class RadialDamageEvent(DamageEvent):
	"""Damage subclass that handles damage with a source location and falloff radius"""

	@property
	def Params(self) -> RadialDamageParams: ...
	"""Static parameters describing damage falloff math"""

	@property
	def Origin(self) -> Vector: ...
	"""Location of origin point"""

	@property
	def ComponentHits(self) -> typing.List[HitResult]: ...
	"""Hit reslts of specific impacts"""

	pass

class WalkableSlopeOverride(object):
	"""Struct allowing control over 'walkable' normals, by allowing a restriction or relaxation of what steepness is normally walkable."""

	@property
	def WalkableSlopeBehavior(self) -> int: ...
	"""Behavior of this surface (whether we affect the walkable slope).
See: GetWalkableSlopeBehavior(), SetWalkableSlopeBehavior()"""

	@property
	def WalkableSlopeAngle(self) -> float: ...
	"""Override walkable slope angle (in degrees), applying the rules of the Walkable Slope Behavior.
See: GetWalkableSlopeAngle(), SetWalkableSlopeAngle()"""

	pass

class ComponentReference(object):
	"""Struct that allows for different ways to reference a component.
If just an Actor is specified, will return RootComponent of that Actor."""

	@property
	def OtherActor(self) -> Actor: ...
	"""Pointer to a different Actor that owns the Component.
If this is not provided the reference refers to a component on this / the same actor."""

	@property
	def ComponentProperty(self) -> str: ...
	"""Name of component to use. If this is not specified the reference refers to the root component."""

	@property
	def PathToComponent(self) -> str: ...
	"""Path to the component from its owner actor"""

	pass

class FilePath(object):
	"""Structure for file paths that are displayed in the editor with a picker UI."""

	@property
	def FilePath(self) -> str: ...
	"""The path to the file."""

	pass

class DirectoryPath(object):
	"""Structure for directory paths that are displayed in the editor with a picker UI."""

	@property
	def Path(self) -> str: ...
	"""The path to the directory."""

	pass

class CollectionReference(object):
	"""Reference to an editor collection of assets. This allows an editor-only picker UI"""

	@property
	def CollectionName(self) -> str: ...
	"""Name of the collection"""

	pass

class DebugFloatHistory(object):
	"""Structure for recording float values and displaying them as an Histogram through DrawDebugFloatHistory."""

	@property
	def MaxSamples(self) -> float: ...
	"""Max Samples to record."""

	@property
	def MinValue(self) -> float: ...
	"""Min value to record."""

	@property
	def MaxValue(self) -> float: ...
	"""Max value to record."""

	@property
	def bAutoAdjustMinMax(self) -> bool: ...
	"""Auto adjust Min/Max as new values are recorded?"""

	pass

class DepthFieldGlowInfo(object):
	"""Info for glow when using depth field rendering"""

	@property
	def bEnableGlow(self) -> bool: ...
	"""Whether to turn on the outline glow (depth field fonts only)"""

	@property
	def GlowColor(self) -> LinearColor: ...
	"""Base color to use for the glow"""

	@property
	def GlowOuterRadius(self) -> Vector2D: ...
	"""If bEnableGlow, outline glow outer radius (0 to 1, 0.5 is edge of character silhouette)
glow influence will be 0 at GlowOuterRadius.X and 1 at GlowOuterRadius.Y"""

	@property
	def GlowInnerRadius(self) -> Vector2D: ...
	"""If bEnableGlow, outline glow inner radius (0 to 1, 0.5 is edge of character silhouette)
glow influence will be 1 at GlowInnerRadius.X and 0 at GlowInnerRadius.Y"""

	pass

class FontRenderInfo(object):
	"""Information used in font rendering"""

	@property
	def bClipText(self) -> bool: ...
	"""Whether to clip text"""

	@property
	def bEnableShadow(self) -> bool: ...
	"""Whether to turn on shadowing"""

	@property
	def GlowInfo(self) -> DepthFieldGlowInfo: ...
	"""Depth field glow parameters (only usable if font was imported with a depth field)"""

	pass

class CanvasUVTri(object):
	"""Simple 2d triangle with UVs"""

	@property
	def V0_Pos(self) -> Vector2D: ...
	"""Position of first vertex"""

	@property
	def V0_UV(self) -> Vector2D: ...
	"""UV of first vertex"""

	@property
	def V0_Color(self) -> LinearColor: ...
	"""Color of first vertex"""

	@property
	def V1_Pos(self) -> Vector2D: ...
	"""Position of second vertex"""

	@property
	def V1_UV(self) -> Vector2D: ...
	"""UV of second vertex"""

	@property
	def V1_Color(self) -> LinearColor: ...
	"""Color of second vertex"""

	@property
	def V2_Pos(self) -> Vector2D: ...
	"""Position of third vertex"""

	@property
	def V2_UV(self) -> Vector2D: ...
	"""UV of third vertex"""

	@property
	def V2_Color(self) -> LinearColor: ...
	"""Color of third vertex"""

	pass

class UserActivity(object):
	"""The description of a user activity"""

	@property
	def ActionName(self) -> str: ...
	"""Describes the user's activity"""

	pass

class MaterialProxySettings(object):
	"""Material Proxy Settings"""

	@property
	def TextureSize(self) -> IntPoint: ...
	"""Size of generated BaseColor map"""

	@property
	def GutterSpace(self) -> float: ...
	"""Gutter space to take into account"""

	@property
	def MetallicConstant(self) -> float: ...
	"""Constant value to use for the Metallic property"""

	@property
	def RoughnessConstant(self) -> float: ...
	"""Constant value to use for the Roughness property"""

	@property
	def AnisotropyConstant(self) -> float: ...
	"""Constant value to use for the Anisotropy property"""

	@property
	def SpecularConstant(self) -> float: ...
	"""Constant value to use for the Specular property"""

	@property
	def OpacityConstant(self) -> float: ...
	"""Constant value to use for the Opacity property"""

	@property
	def OpacityMaskConstant(self) -> float: ...
	"""Constant value to use for the Opacity mask property"""

	@property
	def AmbientOcclusionConstant(self) -> float: ...
	"""Constant value to use for the Ambient Occlusion property"""

	@property
	def TextureSizingType(self) -> int: ...
	"""Method that should be used to generate the sizes of the output textures"""

	@property
	def MaterialMergeType(self) -> int: ...
	"""Material Merge Type"""

	@property
	def BlendMode(self) -> int: ...
	"""Target blend mode for the generated material"""

	@property
	def bAllowTwoSidedMaterial(self) -> bool: ...
	"""Whether or not to allow the generated material can be two-sided"""

	@property
	def bNormalMap(self) -> bool: ...
	"""Whether to generate a texture for the Normal property"""

	@property
	def bTangentMap(self) -> bool: ...
	"""Whether to generate a texture for the Tangent property"""

	@property
	def bMetallicMap(self) -> bool: ...
	"""Whether to generate a texture for the Metallic property"""

	@property
	def bRoughnessMap(self) -> bool: ...
	"""Whether to generate a texture for the Roughness property"""

	@property
	def bAnisotropyMap(self) -> bool: ...
	"""Whether to generate a texture for the Anisotropy property"""

	@property
	def bSpecularMap(self) -> bool: ...
	"""Whether to generate a texture for the Specular property"""

	@property
	def bEmissiveMap(self) -> bool: ...
	"""Whether to generate a texture for the Emissive property"""

	@property
	def bOpacityMap(self) -> bool: ...
	"""Whether to generate a texture for the Opacity property"""

	@property
	def bOpacityMaskMap(self) -> bool: ...
	"""Whether to generate a texture for the Opacity Mask property"""

	@property
	def bAmbientOcclusionMap(self) -> bool: ...
	"""Whether to generate a texture for the Ambient Occlusion property"""

	@property
	def DiffuseTextureSize(self) -> IntPoint: ...
	"""Override Diffuse texture size"""

	@property
	def NormalTextureSize(self) -> IntPoint: ...
	"""Override Normal texture size"""

	@property
	def TangentTextureSize(self) -> IntPoint: ...
	"""Override Tangent texture size"""

	@property
	def MetallicTextureSize(self) -> IntPoint: ...
	"""Override Metallic texture size"""

	@property
	def RoughnessTextureSize(self) -> IntPoint: ...
	"""Override Roughness texture size"""

	@property
	def AnisotropyTextureSize(self) -> IntPoint: ...
	"""Override Anisotropy texture size"""

	@property
	def SpecularTextureSize(self) -> IntPoint: ...
	"""Override Specular texture size"""

	@property
	def EmissiveTextureSize(self) -> IntPoint: ...
	"""Override Emissive texture size"""

	@property
	def OpacityTextureSize(self) -> IntPoint: ...
	"""Override Opacity texture size"""

	@property
	def OpacityMaskTextureSize(self) -> IntPoint: ...
	"""Override Opacity Mask texture size"""

	@property
	def AmbientOcclusionTextureSize(self) -> IntPoint: ...
	"""Override Ambient Occlusion texture size"""

	pass

class MovementProperties(object):
	"""Movement capabilities, determining available movement options for Pawns and used by AI for reachability tests."""

	@property
	def bCanCrouch(self) -> bool: ...
	"""If true, this Pawn is capable of crouching."""

	@property
	def bCanJump(self) -> bool: ...
	"""If true, this Pawn is capable of jumping."""

	@property
	def bCanWalk(self) -> bool: ...
	"""If true, this Pawn is capable of walking or moving on the ground."""

	@property
	def bCanSwim(self) -> bool: ...
	"""If true, this Pawn is capable of swimming or moving through fluid volumes."""

	@property
	def bCanFly(self) -> bool: ...
	"""If true, this Pawn is capable of flying."""

	pass

class NavAgentProperties(MovementProperties):
	"""Properties of representation of an 'agent' (or Pawn) used by AI navigation/pathfinding."""

	@property
	def AgentRadius(self) -> float: ...
	"""Radius of the capsule used for navigation/pathfinding."""

	@property
	def AgentHeight(self) -> float: ...
	"""Total height of the capsule used for navigation/pathfinding."""

	@property
	def AgentStepHeight(self) -> float: ...
	"""Step height to use, or -1 for default value from navdata's config."""

	@property
	def NavWalkingSearchHeightScale(self) -> float: ...
	"""Scale factor to apply to height of bounds when searching for navmesh to project to when nav walking"""

	@property
	def PreferredNavData(self) -> SoftClassPath: ...
	"""Type of navigation data used by agent, null means 'any'"""

	pass

class NavDataConfig(NavAgentProperties):
	"""Nav Data Config"""

	@property
	def Name(self) -> str: ...
	"""Internal/debug name of this agent"""

	@property
	def Color(self) -> Color: ...
	"""Color used to represent this agent in the editor and for debugging"""

	@property
	def DefaultQueryExtent(self) -> Vector: ...
	"""Rough size of this agent, used when projecting unto navigation mesh"""

	@property
	def NavigationDataClass(self) -> Actor: ...
	"""Navigation Data Class"""

	pass

class NavAvoidanceMask(object):
	"""Nav Avoidance Mask"""

	@property
	def bGroup0(self) -> bool: ...
	"""Group 0"""

	@property
	def bGroup1(self) -> bool: ...
	"""Group 1"""

	@property
	def bGroup2(self) -> bool: ...
	"""Group 2"""

	@property
	def bGroup3(self) -> bool: ...
	"""Group 3"""

	@property
	def bGroup4(self) -> bool: ...
	"""Group 4"""

	@property
	def bGroup5(self) -> bool: ...
	"""Group 5"""

	@property
	def bGroup6(self) -> bool: ...
	"""Group 6"""

	@property
	def bGroup7(self) -> bool: ...
	"""Group 7"""

	@property
	def bGroup8(self) -> bool: ...
	"""Group 8"""

	@property
	def bGroup9(self) -> bool: ...
	"""Group 9"""

	@property
	def bGroup10(self) -> bool: ...
	"""Group 10"""

	@property
	def bGroup11(self) -> bool: ...
	"""Group 11"""

	@property
	def bGroup12(self) -> bool: ...
	"""Group 12"""

	@property
	def bGroup13(self) -> bool: ...
	"""Group 13"""

	@property
	def bGroup14(self) -> bool: ...
	"""Group 14"""

	@property
	def bGroup15(self) -> bool: ...
	"""Group 15"""

	@property
	def bGroup16(self) -> bool: ...
	"""Group 16"""

	@property
	def bGroup17(self) -> bool: ...
	"""Group 17"""

	@property
	def bGroup18(self) -> bool: ...
	"""Group 18"""

	@property
	def bGroup19(self) -> bool: ...
	"""Group 19"""

	@property
	def bGroup20(self) -> bool: ...
	"""Group 20"""

	@property
	def bGroup21(self) -> bool: ...
	"""Group 21"""

	@property
	def bGroup22(self) -> bool: ...
	"""Group 22"""

	@property
	def bGroup23(self) -> bool: ...
	"""Group 23"""

	@property
	def bGroup24(self) -> bool: ...
	"""Group 24"""

	@property
	def bGroup25(self) -> bool: ...
	"""Group 25"""

	@property
	def bGroup26(self) -> bool: ...
	"""Group 26"""

	@property
	def bGroup27(self) -> bool: ...
	"""Group 27"""

	@property
	def bGroup28(self) -> bool: ...
	"""Group 28"""

	@property
	def bGroup29(self) -> bool: ...
	"""Group 29"""

	@property
	def bGroup30(self) -> bool: ...
	"""Group 30"""

	@property
	def bGroup31(self) -> bool: ...
	"""Group 31"""

	pass

class NavigationLinkBase(object):
	"""Navigation Link Base"""

	@property
	def LeftProjectHeight(self) -> float: ...
	"""if greater than 0 nav system will attempt to project navlink's start point on geometry below"""

	@property
	def MaxFallDownLength(self) -> float: ...
	"""if greater than 0 nav system will attempt to project navlink's end point on geometry below"""

	@property
	def SnapRadius(self) -> float: ...
	"""Snap Radius"""

	@property
	def SnapHeight(self) -> float: ...
	"""Snap Height"""

	@property
	def SupportedAgents(self) -> typing.Any: ...
	"""restrict area only to specified agents"""

	@property
	def bSupportsAgent0(self) -> bool: ...
	"""DEPRECATED AGENT CONFIG"""

	@property
	def bSupportsAgent1(self) -> bool: ...
	"""Supports Agent 1"""

	@property
	def bSupportsAgent2(self) -> bool: ...
	"""Supports Agent 2"""

	@property
	def bSupportsAgent3(self) -> bool: ...
	"""Supports Agent 3"""

	@property
	def bSupportsAgent4(self) -> bool: ...
	"""Supports Agent 4"""

	@property
	def bSupportsAgent5(self) -> bool: ...
	"""Supports Agent 5"""

	@property
	def bSupportsAgent6(self) -> bool: ...
	"""Supports Agent 6"""

	@property
	def bSupportsAgent7(self) -> bool: ...
	"""Supports Agent 7"""

	@property
	def bSupportsAgent8(self) -> bool: ...
	"""Supports Agent 8"""

	@property
	def bSupportsAgent9(self) -> bool: ...
	"""Supports Agent 9"""

	@property
	def bSupportsAgent10(self) -> bool: ...
	"""Supports Agent 10"""

	@property
	def bSupportsAgent11(self) -> bool: ...
	"""Supports Agent 11"""

	@property
	def bSupportsAgent12(self) -> bool: ...
	"""Supports Agent 12"""

	@property
	def bSupportsAgent13(self) -> bool: ...
	"""Supports Agent 13"""

	@property
	def bSupportsAgent14(self) -> bool: ...
	"""Supports Agent 14"""

	@property
	def bSupportsAgent15(self) -> bool: ...
	"""Supports Agent 15"""

	@property
	def Direction(self) -> int: ...
	"""WITH_EDITORONLY_DATA"""

	@property
	def bUseSnapHeight(self) -> bool: ...
	"""Use Snap Height"""

	@property
	def bSnapToCheapestArea(self) -> bool: ...
	"""If set, link will try to snap to cheapest area in given radius"""

	@property
	def bCustomFlag0(self) -> bool: ...
	"""custom flag, check DescribeCustomFlags for details"""

	@property
	def bCustomFlag1(self) -> bool: ...
	"""custom flag, check DescribeCustomFlags for details"""

	@property
	def bCustomFlag2(self) -> bool: ...
	"""custom flag, check DescribeCustomFlags for details"""

	@property
	def bCustomFlag3(self) -> bool: ...
	"""custom flag, check DescribeCustomFlags for details"""

	@property
	def bCustomFlag4(self) -> bool: ...
	"""custom flag, check DescribeCustomFlags for details"""

	@property
	def bCustomFlag5(self) -> bool: ...
	"""custom flag, check DescribeCustomFlags for details"""

	@property
	def bCustomFlag6(self) -> bool: ...
	"""custom flag, check DescribeCustomFlags for details"""

	@property
	def bCustomFlag7(self) -> bool: ...
	"""custom flag, check DescribeCustomFlags for details"""

	pass

class NavigationLink(NavigationLinkBase):
	"""Navigation Link"""

	@property
	def Left(self) -> Vector: ...
	"""Left"""

	@property
	def Right(self) -> Vector: ...
	"""Right"""

	pass

class NavigationSegmentLink(NavigationLinkBase):
	"""Navigation Segment Link"""

	@property
	def LeftStart(self) -> Vector: ...
	"""Left Start"""

	@property
	def LeftEnd(self) -> Vector: ...
	"""Left End"""

	@property
	def RightStart(self) -> Vector: ...
	"""Right Start"""

	@property
	def RightEnd(self) -> Vector: ...
	"""Right End"""

	pass

class LatentActionInfo(object):
	"""Latent action info"""

	@property
	def Linkage(self) -> int: ...
	"""The resume point within the function to execute"""

	@property
	def UUID(self) -> int: ...
	"""the UUID for this action"""

	@property
	def ExecutionFunction(self) -> str: ...
	"""The function to execute."""

	@property
	def CallbackTarget(self) -> Object: ...
	"""Object to execute the function on."""

	pass

class PerBoneBlendWeight(object):
	"""Per Bone Blend Weight"""

	@property
	def SourceIndex(self) -> int: ...
	"""Source index of the buffer."""

	@property
	def BlendWeight(self) -> float: ...
	"""Blend Weight"""

	pass

class PerBoneBlendWeights(object):
	"""Per Bone Blend Weights"""

	@property
	def BoneBlendWeights(self) -> typing.List[PerBoneBlendWeight]: ...
	"""Bone Blend Weights"""

	pass

class AnimNotifyEvent(AnimLinkableElement):
	"""Triggers an animation notify.  Each AnimNotifyEvent contains an AnimNotify object
which has its Notify method called and passed to the animation."""

	@property
	def TriggerTimeOffset(self) -> float: ...
	"""An offset from the DisplayTime to the actual time we will trigger the notify, as we cannot always trigger it exactly at the time the user wants"""

	@property
	def EndTriggerTimeOffset(self) -> float: ...
	"""An offset similar to TriggerTimeOffset but used for the end scrub handle of a notify state's duration"""

	@property
	def TriggerWeightThreshold(self) -> float: ...
	"""Trigger Weight Threshold"""

	@property
	def NotifyName(self) -> str: ...
	"""Notify Name"""

	@property
	def Notify(self) -> AnimNotify: ...
	"""Notify"""

	@property
	def NotifyStateClass(self) -> AnimNotifyState: ...
	"""Notify State Class"""

	@property
	def Duration(self) -> float: ...
	"""Duration"""

	@property
	def EndLink(self) -> typing.Any: ...
	"""Linkable element to use for the end handle representing a notify state duration"""

	@property
	def bConvertedFromBranchingPoint(self) -> bool: ...
	"""If TRUE, this notify has been converted from an old BranchingPoint."""

	@property
	def MontageTickType(self) -> int: ...
	"""Montage Tick Type"""

	@property
	def NotifyTriggerChance(self) -> float: ...
	"""Defines the chance of of this notify triggering, 0 = No Chance, 1 = Always triggers"""

	@property
	def NotifyFilterType(self) -> int: ...
	"""Defines a method for filtering notifies (stopping them triggering) e.g. by looking at the meshes current LOD"""

	@property
	def NotifyFilterLOD(self) -> int: ...
	"""LOD to start filtering this notify from."""

	@property
	def bTriggerOnDedicatedServer(self) -> bool: ...
	"""If disabled this notify will be skipped on dedicated servers"""

	@property
	def bTriggerOnFollower(self) -> bool: ...
	"""If enabled this notify will trigger when the animation is a follower in a sync group (by default only the sync group leaders notifies trigger"""

	@property
	def TrackIndex(self) -> int: ...
	"""'Track' that the notify exists on, used for visual placement in editor and sorting priority in runtime"""

	pass

class AnimSyncMarker(object):
	"""Anim Sync Marker"""

	@property
	def MarkerName(self) -> str: ...
	"""The name of this marker"""

	@property
	def Time(self) -> float: ...
	"""Time in seconds of this marker"""

	pass

class MeshUVChannelInfo(object):
	"""The world size for each texcoord mapping. Used by the texture streaming."""

	@property
	def bInitialized(self) -> bool: ...
	"""Initialized"""

	@property
	def bOverrideDensities(self) -> bool: ...
	"""Whether this values was set manually or is auto generated."""

	@property
	def LocalUVDensities(self) -> typing.List[float]: ...
	"""The UV density in the mesh, before any transform scaling, in world unit per UV.
This value represents the length taken to cover a full UV unit."""

	pass

class SkeletalMaterial(object):
	"""Skeletal Material"""

	@property
	def MaterialInterface(self) -> MaterialInterface: ...
	"""Material Interface"""

	@property
	def MaterialSlotName(self) -> str: ...
	"""This name should be use by the gameplay to avoid error if the skeletal mesh Materials array topology change"""

	@property
	def UVChannelData(self) -> MeshUVChannelInfo: ...
	"""Data used for texture streaming relative to each UV channels."""

	pass

class BlendSampleData(object):
	"""Transform definition"""

	@property
	def SampleDataIndex(self) -> int: ...
	"""Sample Data Index"""

	@property
	def Animation(self) -> AnimSequence: ...
	"""Animation"""

	@property
	def TotalWeight(self) -> float: ...
	"""Total Weight"""

	@property
	def Time(self) -> float: ...
	"""Time"""

	@property
	def PreviousTime(self) -> float: ...
	"""Previous Time"""

	@property
	def SamplePlayRate(self) -> float: ...
	"""We may merge multiple samples if they use the same animation
Calculate the combined sample play rate here"""

	pass

class MarkerSyncAnimPosition(object):
	"""Represent a current play position in an animation
based on sync markers"""

	@property
	def PreviousMarkerName(self) -> str: ...
	"""The marker we have passed"""

	@property
	def NextMarkerName(self) -> str: ...
	"""The marker we are heading towards"""

	@property
	def PositionBetweenMarkers(self) -> float: ...
	"""Value between 0 and 1 representing where we are:
      0   we are at PreviousMarker
      1   we are at NextMarker
      0.5 we are half way between the two"""

	pass

class NamedFloat(object):
	"""A named float"""

	@property
	def Value(self) -> float: ...
	"""Value"""

	@property
	def Name(self) -> str: ...
	"""Name"""

	pass

class NamedVector(object):
	"""A named float"""

	@property
	def Value(self) -> Vector: ...
	"""Value"""

	@property
	def Name(self) -> str: ...
	"""Name"""

	pass

class NamedColor(object):
	"""A named color"""

	@property
	def Value(self) -> Color: ...
	"""Value"""

	@property
	def Name(self) -> str: ...
	"""Name"""

	pass

class NamedTransform(object):
	"""A named transform"""

	@property
	def Value(self) -> Transform: ...
	"""Value"""

	@property
	def Name(self) -> str: ...
	"""Name"""

	pass

class LocalSpacePose(object):
	"""A pose in local space (i.e. each transform is relative to its parent)"""

	@property
	def Transforms(self) -> typing.List[Transform]: ...
	"""Transforms"""

	@property
	def Names(self) -> typing.List[str]: ...
	"""Names"""

	pass

class ComponentSpacePose(object):
	"""A pose in component space (i.e. each transform is relative to the component's transform)"""

	@property
	def Transforms(self) -> typing.List[Transform]: ...
	"""Transforms"""

	@property
	def Names(self) -> typing.List[str]: ...
	"""Names"""

	pass

class PoseLinkBase(object):
	"""A pose link to another node"""

	@property
	def LinkID(self) -> int: ...
	"""Serialized link ID, used to build the non-serialized pointer map."""

	pass

class PoseLink(PoseLinkBase):
	"""A local-space pose link to another node"""

	pass

class ComponentSpacePoseLink(PoseLinkBase):
	"""A component-space pose link to another node"""

	pass

class MaterialParameterInfo(object):
	"""Material Parameter Info"""

	@property
	def Name(self) -> str: ...
	"""Name"""

	@property
	def Association(self) -> int: ...
	"""Whether this is a global parameter, or part of a layer or blend"""

	@property
	def Index(self) -> int: ...
	"""Layer or blend index this parameter is part of. INDEX_NONE for global parameters."""

	pass

class SkelMeshSkinWeightInfo(object):
	"""Vertex skin weight info supplied for a component override."""

	@property
	def Bones(self) -> typing.List[int]: ...
	"""Index of bones that influence this vertex"""

	@property
	def Weights(self) -> typing.List[int]: ...
	"""Influence of each bone on this vertex"""

	pass

class VertexOffsetUsage(object):
	"""Vertex Offset Usage"""

	@property
	def Usage(self) -> int: ...
	"""Usage"""

	pass

class SingleAnimationPlayData(object):
	"""Single Animation Play Data"""

	@property
	def AnimToPlay(self) -> AnimationAsset: ...
	"""@todo in the future, we should make this one UObject
and have detail customization to display different things
The default sequence to play on this skeletal mesh"""

	@property
	def bSavedLooping(self) -> bool: ...
	"""Default setting for looping for SequenceToPlay. This is not current state of looping."""

	@property
	def bSavedPlaying(self) -> bool: ...
	"""Default setting for playing for SequenceToPlay. This is not current state of playing."""

	@property
	def SavedPosition(self) -> float: ...
	"""Default setting for position of SequenceToPlay to play."""

	@property
	def SavedPlayRate(self) -> float: ...
	"""Default setting for play rate of SequenceToPlay to play."""

	pass

class PoseSnapshot(object):
	"""A pose for a skeletal mesh"""

	@property
	def LocalTransforms(self) -> typing.List[Transform]: ...
	"""Array of transforms per-bone"""

	@property
	def BoneNames(self) -> typing.List[str]: ...
	"""Array of bone names (corresponding to LocalTransforms)"""

	@property
	def SkeletalMeshName(self) -> str: ...
	"""The name of the skeletal mesh that was used to take this snapshot"""

	@property
	def SnapshotName(self) -> str: ...
	"""The name for this snapshot"""

	@property
	def bIsValid(self) -> bool: ...
	"""Whether the pose is valid"""

	pass

class PhysicalAnimationData(object):
	"""Stores info on the type of motor that will be used for a given bone"""

	@property
	def BodyName(self) -> str: ...
	"""The body we will be driving. We specifically hide this from users since they provide the body name and bodies below in the component API."""

	@property
	def bIsLocalSimulation(self) -> bool: ...
	"""Whether the drive targets are in world space or local"""

	@property
	def OrientationStrength(self) -> float: ...
	"""The strength used to correct orientation error"""

	@property
	def AngularVelocityStrength(self) -> float: ...
	"""The strength used to correct angular velocity error"""

	@property
	def PositionStrength(self) -> float: ...
	"""The strength used to correct linear position error. Only used for non-local simulation"""

	@property
	def VelocityStrength(self) -> float: ...
	"""The strength used to correct linear velocity error. Only used for non-local simulation"""

	@property
	def MaxLinearForce(self) -> float: ...
	"""The max force used to correct linear errors"""

	@property
	def MaxAngularForce(self) -> float: ...
	"""The max force used to correct angular errors"""

	pass

class SolverIterations(object):
	"""[Chaos Only]"""

	@property
	def FixedTimeStep(self) -> float: ...
	"""[Chaos Only]
The recommended fixed timestep for the solver if supported (e.g., in RigidBody Anim Node). 0 to run with variable timestep.
NOTE: If this value is non-zero and less than the current frame time, physics will step multiple times."""

	@property
	def SolverIterations(self) -> int: ...
	"""[Chaos Only]
The recommended number of solver iterations. Increase this if collision and joints are fighting, or joint chains are stretching."""

	@property
	def JointIterations(self) -> int: ...
	"""[Chaos Only]
The recommended number of joint sub-iterations. Increasing this can help with chains of long-thin bodies."""

	@property
	def CollisionIterations(self) -> int: ...
	"""[Chaos Only]
The recommended number of collision sub-iterations. Increasing this can help with collision jitter."""

	@property
	def SolverPushOutIterations(self) -> int: ...
	"""Increase this if bodies remain penetrating"""

	@property
	def JointPushOutIterations(self) -> int: ...
	"""[Chaos Only]
The recommended number of joint sub-push-out iterations."""

	@property
	def CollisionPushOutIterations(self) -> int: ...
	"""[Chaos Only]
The recommended number of joint sub-push-out iterations. Increasing this can help with collision penetration problems."""

	pass

class InputScaleBias(object):
	"""Input scaling struct"""

	@property
	def Scale(self) -> float: ...
	"""Scale"""

	@property
	def Bias(self) -> float: ...
	"""Bias"""

	pass

class InputRange(object):
	"""Input Range"""

	@property
	def Min(self) -> float: ...
	"""Min"""

	@property
	def Max(self) -> float: ...
	"""Max"""

	pass

class InputScaleBiasClamp(object):
	"""Input Scale Bias Clamp"""

	@property
	def bMapRange(self) -> bool: ...
	"""Map Range"""

	@property
	def bClampResult(self) -> bool: ...
	"""Clamp Result"""

	@property
	def bInterpResult(self) -> bool: ...
	"""Interp Result"""

	@property
	def InRange(self) -> InputRange: ...
	"""In Range"""

	@property
	def OutRange(self) -> InputRange: ...
	"""Out Range"""

	@property
	def Scale(self) -> float: ...
	"""Scale"""

	@property
	def Bias(self) -> float: ...
	"""Bias"""

	@property
	def ClampMin(self) -> float: ...
	"""Clamp Min"""

	@property
	def ClampMax(self) -> float: ...
	"""Clamp Max"""

	@property
	def InterpSpeedIncreasing(self) -> float: ...
	"""Interp Speed Increasing"""

	@property
	def InterpSpeedDecreasing(self) -> float: ...
	"""Interp Speed Decreasing"""

	pass

class InputAlphaBoolBlend(object):
	"""Input Alpha Bool Blend"""

	@property
	def BlendInTime(self) -> float: ...
	"""Blend in Time"""

	@property
	def BlendOutTime(self) -> float: ...
	"""Blend Out Time"""

	@property
	def BlendOption(self) -> int: ...
	"""Blend Option"""

	@property
	def bInitialized(self) -> bool: ...
	"""Initialized"""

	@property
	def CustomCurve(self) -> CurveFloat: ...
	"""Custom Curve"""

	@property
	def AlphaBlend(self) -> typing.Any: ...
	"""Alpha Blend"""

	pass

class AnimNode_Base(object):
	"""This is the base of all runtime animation nodes

To create a new animation node:
  Create a struct derived from FAnimNode_Base - this is your runtime node
  Create a class derived from UAnimGraphNode_Base, containing an instance of your runtime node as a member - this is your visual/editor-only node"""

	pass

class AnimNode_ApplyMeshSpaceAdditive(AnimNode_Base):
	"""Anim Node Apply Mesh Space Additive"""

	@property
	def Base(self) -> PoseLink: ...
	"""Base"""

	@property
	def Additive(self) -> PoseLink: ...
	"""Additive"""

	@property
	def AlphaInputType(self) -> int: ...
	"""The data type used to control the alpha blending of the additive pose.
              Note: Changing this value will disconnect alpha input pins."""

	@property
	def Alpha(self) -> float: ...
	"""The float value that controls the alpha blending when the alpha input type is set to 'Float'"""

	@property
	def bAlphaBoolEnabled(self) -> bool: ...
	"""The boolean value that controls the alpha blending when the alpha input type is set to 'Bool'"""

	@property
	def AlphaBoolBlend(self) -> InputAlphaBoolBlend: ...
	"""Alpha Bool Blend"""

	@property
	def AlphaCurveName(self) -> str: ...
	"""Alpha Curve Name"""

	@property
	def AlphaScaleBias(self) -> InputScaleBias: ...
	"""Alpha Scale Bias"""

	@property
	def AlphaScaleBiasClamp(self) -> InputScaleBiasClamp: ...
	"""Alpha Scale Bias Clamp"""

	@property
	def LODThreshold(self) -> int: ...
	"""* Max LOD that this node is allowed to run
* For example if you have LODThreadhold to be 2, it will run until LOD 2 (based on 0 index)
* when the component LOD becomes 3, it will stop update/evaluate
* currently transition would be issue and that has to be re-visited"""

	pass

class AnimNode_Inertialization(AnimNode_Base):
	"""Anim Node Inertialization"""

	@property
	def Source(self) -> PoseLink: ...
	"""Source"""

	pass

class AnimNode_CustomProperty(AnimNode_Base):
	"""Custom property node that you'd like to expand pin by reflecting internal instance (we call TargetInstance here)

 Used by sub anim instance or control rig node
    where you have internal instance and would like to reflect to AnimNode as a pin

 To make pin working, you need storage inside of AnimInstance (SourceProperties/SourcePropertyNames)
 So this creates storage inside of AnimInstance with the unique custom property name
    and it copies to the actually TargetInstance here to allow the information be transferred in runtime (DestProperties/DestPropertyNames)

 TargetInstance - UObject derived instance that has certain dest properties
 Source - AnimInstance's copy properties that is used to store the data"""

	pass

class AnimNode_LinkedAnimGraph(AnimNode_CustomProperty):
	"""Anim Node Linked Anim Graph"""

	@property
	def InputPoses(self) -> typing.List[PoseLink]: ...
	"""Input poses for the node, intentionally not accessible because if there's no input
nodes in the target class we don't want to show these as pins"""

	@property
	def InputPoseNames(self) -> typing.List[str]: ...
	"""List of input pose names, 1-1 with pose links about, built by the compiler"""

	@property
	def InstanceClass(self) -> AnimInstance: ...
	"""The class spawned for this linked instance"""

	@property
	def Tag(self) -> str: ...
	"""Optional tag used to identify this linked instance"""

	@property
	def bReceiveNotifiesFromLinkedInstances(self) -> bool: ...
	"""Whether named notifies will be received by this linked instance from other instances (outer or other linked instances)"""

	@property
	def bPropagateNotifiesToLinkedInstances(self) -> bool: ...
	"""Whether named notifies will be propagated from this linked instance to other instances (outer or other linked instances)"""

	pass

class AnimNode_LinkedAnimLayer(AnimNode_LinkedAnimGraph):
	"""Anim Node Linked Anim Layer"""

	@property
	def Interface(self) -> typing.Any: ...
	"""Optional interface. If this is set then this node will only accept (both statically and dynamically) anim instances that implement this interface.
If not set, then this is considered a 'self' layer. This value is set when Layer is changed in the details panel."""

	@property
	def Layer(self) -> str: ...
	"""The layer in the interface to use"""

	pass

class AnimNode_Root(AnimNode_Base):
	"""Root node of an animation tree (sink)"""

	@property
	def Result(self) -> PoseLink: ...
	"""Result"""

	@property
	def Name(self) -> str: ...
	"""The name of this root node, used to identify the output of this graph. Filled in by the compiler, propagated from the parent graph."""

	@property
	def Group(self) -> str: ...
	"""The group of this root node, used to group this output with others when used in a layer."""

	pass

class AnimNode_SaveCachedPose(AnimNode_Base):
	"""Anim Node Save Cached Pose"""

	@property
	def Pose(self) -> PoseLink: ...
	"""Pose"""

	@property
	def CachePoseName(self) -> str: ...
	"""Intentionally not exposed, set by AnimBlueprintCompiler"""

	pass

class AnimNode_SequencePlayer(AnimNode_AssetPlayerBase):
	"""Sequence player node"""

	@property
	def Sequence(self) -> AnimSequenceBase: ...
	"""The animation sequence asset to play"""

	@property
	def PlayRateBasis(self) -> float: ...
	"""The Basis in which the PlayRate is expressed in. This is used to rescale PlayRate inputs.
For example a Basis of 100 means that the PlayRate input will be divided by 100."""

	@property
	def PlayRate(self) -> float: ...
	"""The play rate multiplier. Can be negative, which will cause the animation to play in reverse."""

	@property
	def PlayRateScaleBiasClamp(self) -> InputScaleBiasClamp: ...
	"""Additional scaling, offsetting and clamping of PlayRate input.
Performed after PlayRateBasis."""

	@property
	def StartPosition(self) -> float: ...
	"""The start up position, it only applies when reinitialized
if you loop, it will still start from 0.f after finishing the round"""

	@property
	def bLoopAnimation(self) -> bool: ...
	"""Should the animation continue looping when it reaches the end?"""

	pass

class AnimNode_TransitionPoseEvaluator(AnimNode_Base):
	"""Animation data node for state machine transitions.
Can be set to supply either the animation data from the transition source (From State) or the transition destination (To State)."""

	@property
	def FramesToCachePose(self) -> int: ...
	"""Frames to Cache Pose"""

	@property
	def DataSource(self) -> int: ...
	"""Data Source"""

	@property
	def EvaluatorMode(self) -> int: ...
	"""Evaluator Mode"""

	pass

class AnimNode_TransitionResult(AnimNode_Base):
	"""Root node of a state machine transition graph"""

	@property
	def bCanEnterTransition(self) -> bool: ...
	"""Can Enter Transition"""

	pass

class AnimNode_ConvertComponentToLocalSpace(AnimNode_Base):
	"""Anim Node Convert Component to Local Space"""

	@property
	def ComponentPose(self) -> ComponentSpacePoseLink: ...
	"""Component Pose"""

	pass

class AnimNode_ConvertLocalToComponentSpace(AnimNode_Base):
	"""Anim Node Convert Local to Component Space"""

	@property
	def LocalPose(self) -> PoseLink: ...
	"""Local Pose"""

	pass

class NamedCurveValue(object):
	"""Name/value pair for retrieving curve values"""

	@property
	def Name(self) -> str: ...
	"""The name of the curve"""

	@property
	def Value(self) -> float: ...
	"""The value of the curve"""

	pass

class ColorGradePerRangeSettings(object):
	"""Color Grade Per Range Settings"""

	@property
	def Saturation(self) -> Vector4: ...
	"""Saturation"""

	@property
	def Contrast(self) -> Vector4: ...
	"""Contrast"""

	@property
	def Gamma(self) -> Vector4: ...
	"""Gamma"""

	@property
	def Gain(self) -> Vector4: ...
	"""Gain"""

	@property
	def Offset(self) -> Vector4: ...
	"""Offset"""

	pass

class ColorGradingSettings(object):
	"""Color Grading Settings"""

	@property
	def Global(self) -> ColorGradePerRangeSettings: ...
	"""Global"""

	@property
	def Shadows(self) -> ColorGradePerRangeSettings: ...
	"""Shadows"""

	@property
	def Midtones(self) -> ColorGradePerRangeSettings: ...
	"""Midtones"""

	@property
	def Highlights(self) -> ColorGradePerRangeSettings: ...
	"""Highlights"""

	@property
	def ShadowsMax(self) -> float: ...
	"""Shadows Max"""

	@property
	def HighlightsMin(self) -> float: ...
	"""Highlights Min"""

	pass

class FilmStockSettings(object):
	"""Film Stock Settings"""

	@property
	def Slope(self) -> float: ...
	"""Slope"""

	@property
	def Toe(self) -> float: ...
	"""Toe"""

	@property
	def Shoulder(self) -> float: ...
	"""Shoulder"""

	@property
	def BlackClip(self) -> float: ...
	"""Black Clip"""

	@property
	def WhiteClip(self) -> float: ...
	"""White Clip"""

	pass

class GaussianSumBloomSettings(object):
	"""Gaussian Sum Bloom Settings"""

	@property
	def Intensity(self) -> float: ...
	"""Multiplier for all bloom contributions >=0: off, 1(default), >1 brighter"""

	@property
	def Threshold(self) -> float: ...
	"""minimum brightness the bloom starts having effect
-1:all pixels affect bloom equally (physically correct, faster as a threshold pass is omitted), 0:all pixels affect bloom brights more, 1(default), >1 brighter"""

	@property
	def SizeScale(self) -> float: ...
	"""Scale for all bloom sizes"""

	@property
	def Filter1Size(self) -> float: ...
	"""Diameter size for the Bloom1 in percent of the screen width
(is done in 1/2 resolution, larger values cost more performance, good for high frequency details)
>=0: can be clamped because of shader limitations"""

	@property
	def Filter2Size(self) -> float: ...
	"""Diameter size for Bloom2 in percent of the screen width
(is done in 1/4 resolution, larger values cost more performance)
>=0: can be clamped because of shader limitations"""

	@property
	def Filter3Size(self) -> float: ...
	"""Diameter size for Bloom3 in percent of the screen width
(is done in 1/8 resolution, larger values cost more performance)
>=0: can be clamped because of shader limitations"""

	@property
	def Filter4Size(self) -> float: ...
	"""Diameter size for Bloom4 in percent of the screen width
(is done in 1/16 resolution, larger values cost more performance, best for wide contributions)
>=0: can be clamped because of shader limitations"""

	@property
	def Filter5Size(self) -> float: ...
	"""Diameter size for Bloom5 in percent of the screen width
(is done in 1/32 resolution, larger values cost more performance, best for wide contributions)
>=0: can be clamped because of shader limitations"""

	@property
	def Filter6Size(self) -> float: ...
	"""Diameter size for Bloom6 in percent of the screen width
(is done in 1/64 resolution, larger values cost more performance, best for wide contributions)
>=0: can be clamped because of shader limitations"""

	@property
	def Filter1Tint(self) -> LinearColor: ...
	"""Bloom1 tint color"""

	@property
	def Filter2Tint(self) -> LinearColor: ...
	"""Bloom2 tint color"""

	@property
	def Filter3Tint(self) -> LinearColor: ...
	"""Bloom3 tint color"""

	@property
	def Filter4Tint(self) -> LinearColor: ...
	"""Bloom4 tint color"""

	@property
	def Filter5Tint(self) -> LinearColor: ...
	"""Bloom5 tint color"""

	@property
	def Filter6Tint(self) -> LinearColor: ...
	"""Bloom6 tint color"""

	pass

class ConvolutionBloomSettings(object):
	"""Convolution Bloom Settings"""

	@property
	def Texture(self) -> Texture2D: ...
	"""Texture to replace default convolution bloom kernel"""

	@property
	def Size(self) -> float: ...
	"""Relative size of the convolution kernel image compared to the minor axis of the viewport"""

	@property
	def CenterUV(self) -> Vector2D: ...
	"""The UV location of the center of the kernel.  Should be very close to (.5,.5)"""

	@property
	def PreFilterMin(self) -> float: ...
	"""Boost intensity of select pixels  prior to computing bloom convolution (Min, Max, Multiplier).  Max < Min disables"""

	@property
	def PreFilterMax(self) -> float: ...
	"""Boost intensity of select pixels  prior to computing bloom convolution (Min, Max, Multiplier).  Max < Min disables"""

	@property
	def PreFilterMult(self) -> float: ...
	"""Boost intensity of select pixels  prior to computing bloom convolution (Min, Max, Multiplier).  Max < Min disables"""

	@property
	def BufferScale(self) -> float: ...
	"""Implicit buffer region as a fraction of the screen size to insure the bloom does not wrap across the screen.  Larger sizes have perf impact."""

	pass

class LensBloomSettings(object):
	"""Lens Bloom Settings"""

	@property
	def GaussianSum(self) -> GaussianSumBloomSettings: ...
	"""Bloom gaussian sum method specific settings."""

	@property
	def Convolution(self) -> ConvolutionBloomSettings: ...
	"""Bloom convolution method specific settings."""

	@property
	def Method(self) -> int: ...
	"""Bloom algorithm"""

	pass

class LensImperfectionSettings(object):
	"""Lens Imperfection Settings"""

	@property
	def DirtMask(self) -> Texture: ...
	"""Texture that defines the dirt on the camera lens where the light of very bright objects is scattered."""

	@property
	def DirtMaskIntensity(self) -> float: ...
	"""BloomDirtMask intensity"""

	@property
	def DirtMaskTint(self) -> LinearColor: ...
	"""BloomDirtMask tint color"""

	pass

class LensSettings(object):
	"""Lens Settings"""

	@property
	def Bloom(self) -> LensBloomSettings: ...
	"""Bloom"""

	@property
	def Imperfections(self) -> LensImperfectionSettings: ...
	"""Imperfections"""

	@property
	def ChromaticAberration(self) -> float: ...
	"""in percent, Scene chromatic aberration / color fringe (camera imperfection) to simulate an artifact that happens in real-world lens, mostly visible in the image corners."""

	pass

class CameraExposureSettings(object):
	"""Camera Exposure Settings"""

	@property
	def Method(self) -> int: ...
	"""Luminance computation method"""

	@property
	def LowPercent(self) -> float: ...
	"""The eye adaptation will adapt to a value extracted from the luminance histogram of the scene color.
The value is defined as having x percent below this brightness. Higher values give bright spots on the screen more priority
but can lead to less stable results. Lower values give the medium and darker values more priority but might cause burn out of
bright spots.
>0, <100, good values are in the range 70 .. 80"""

	@property
	def HighPercent(self) -> float: ...
	"""The eye adaptation will adapt to a value extracted from the luminance histogram of the scene color.
The value is defined as having x percent below this brightness. Higher values give bright spots on the screen more priority
but can lead to less stable results. Lower values give the medium and darker values more priority but might cause burn out of
bright spots.
>0, <100, good values are in the range 80 .. 95"""

	@property
	def MinBrightness(self) -> float: ...
	"""A good value should be positive near 0. This is the minimum brightness the auto exposure can adapt to.
It should be tweaked in a dark lighting situation (too small: image appears too bright, too large: image appears too dark).
Note: Tweaking emissive materials and lights or tweaking auto exposure can look the same. Tweaking auto exposure has global
effect and defined the HDR range - you don't want to change that late in the project development.
Eye Adaptation is disabled if MinBrightness = MaxBrightness"""

	@property
	def MaxBrightness(self) -> float: ...
	"""A good value should be positive (2 is a good value). This is the maximum brightness the auto exposure can adapt to.
It should be tweaked in a bright lighting situation (too small: image appears too bright, too large: image appears too dark).
Note: Tweaking emissive materials and lights or tweaking auto exposure can look the same. Tweaking auto exposure has global
effect and defined the HDR range - you don't want to change that late in the project development.
Eye Adaptation is disabled if MinBrightness = MaxBrightness"""

	@property
	def SpeedUp(self) -> float: ...
	"""In F-stops per second, should be >0"""

	@property
	def SpeedDown(self) -> float: ...
	"""In F-stops per second, should be >0"""

	@property
	def Bias(self) -> float: ...
	"""Logarithmic adjustment for the exposure. Only used if a tonemapper is specified.
0: no adjustment, -1:2x darker, -2:4x darker, 1:2x brighter, 2:4x brighter, ..."""

	@property
	def BiasCurve(self) -> CurveFloat: ...
	"""Exposure compensation based on the scene EV100.
Used to calibrate the final exposure differently depending on the average scene luminance.
0: no adjustment, -1:2x darker, -2:4x darker, 1:2x brighter, 2:4x brighter, ..."""

	@property
	def MeterMask(self) -> Texture: ...
	"""Exposure metering mask. Bright spots on the mask will have high influence on auto-exposure metering
and dark spots will have low influence."""

	@property
	def HistogramLogMin(self) -> float: ...
	"""temporary exposed until we found good values, -8: 1/256, -10: 1/1024"""

	@property
	def HistogramLogMax(self) -> float: ...
	"""temporary exposed until we found good values 4: 16, 8: 256"""

	@property
	def CalibrationConstant(self) -> float: ...
	"""Calibration constant for 18% albedo."""

	@property
	def ApplyPhysicalCameraExposure(self) -> bool: ...
	"""Enables physical camera exposure using ShutterSpeed/ISO/Aperture."""

	pass

class WeightedBlendable(object):
	"""Weighted Blendable"""

	@property
	def Weight(self) -> float: ...
	"""0:no effect .. 1:full effect"""

	@property
	def Object(self) -> Object: ...
	"""should be of the IBlendableInterface* type but UProperties cannot express that"""

	pass

class WeightedBlendables(object):
	"""for easier detail customization, needed?"""

	@property
	def Array(self) -> typing.List[WeightedBlendable]: ...
	"""Array"""

	pass

class PostProcessSettings(object):
	"""Post Process Settings"""

	@property
	def bOverride_WhiteTemp(self) -> bool: ...
	"""first all bOverride_... as they get grouped together into bitfields"""

	@property
	def bOverride_WhiteTint(self) -> bool: ...
	"""Override White Tint"""

	@property
	def bOverride_ColorSaturation(self) -> bool: ...
	"""Color Correction controls"""

	@property
	def bOverride_ColorContrast(self) -> bool: ...
	"""Override Color Contrast"""

	@property
	def bOverride_ColorGamma(self) -> bool: ...
	"""Override Color Gamma"""

	@property
	def bOverride_ColorGain(self) -> bool: ...
	"""Override Color Gain"""

	@property
	def bOverride_ColorOffset(self) -> bool: ...
	"""Override Color Offset"""

	@property
	def bOverride_ColorSaturationShadows(self) -> bool: ...
	"""Override Color Saturation Shadows"""

	@property
	def bOverride_ColorContrastShadows(self) -> bool: ...
	"""Override Color Contrast Shadows"""

	@property
	def bOverride_ColorGammaShadows(self) -> bool: ...
	"""Override Color Gamma Shadows"""

	@property
	def bOverride_ColorGainShadows(self) -> bool: ...
	"""Override Color Gain Shadows"""

	@property
	def bOverride_ColorOffsetShadows(self) -> bool: ...
	"""Override Color Offset Shadows"""

	@property
	def bOverride_ColorSaturationMidtones(self) -> bool: ...
	"""Override Color Saturation Midtones"""

	@property
	def bOverride_ColorContrastMidtones(self) -> bool: ...
	"""Override Color Contrast Midtones"""

	@property
	def bOverride_ColorGammaMidtones(self) -> bool: ...
	"""Override Color Gamma Midtones"""

	@property
	def bOverride_ColorGainMidtones(self) -> bool: ...
	"""Override Color Gain Midtones"""

	@property
	def bOverride_ColorOffsetMidtones(self) -> bool: ...
	"""Override Color Offset Midtones"""

	@property
	def bOverride_ColorSaturationHighlights(self) -> bool: ...
	"""Override Color Saturation Highlights"""

	@property
	def bOverride_ColorContrastHighlights(self) -> bool: ...
	"""Override Color Contrast Highlights"""

	@property
	def bOverride_ColorGammaHighlights(self) -> bool: ...
	"""Override Color Gamma Highlights"""

	@property
	def bOverride_ColorGainHighlights(self) -> bool: ...
	"""Override Color Gain Highlights"""

	@property
	def bOverride_ColorOffsetHighlights(self) -> bool: ...
	"""Override Color Offset Highlights"""

	@property
	def bOverride_ColorCorrectionShadowsMax(self) -> bool: ...
	"""Override Color Correction Shadows Max"""

	@property
	def bOverride_ColorCorrectionHighlightsMin(self) -> bool: ...
	"""Override Color Correction Highlights Min"""

	@property
	def bOverride_BlueCorrection(self) -> bool: ...
	"""Override Blue Correction"""

	@property
	def bOverride_ExpandGamut(self) -> bool: ...
	"""Override Expand Gamut"""

	@property
	def bOverride_ToneCurveAmount(self) -> bool: ...
	"""Override Tone Curve Amount"""

	@property
	def bOverride_FilmWhitePoint(self) -> bool: ...
	"""Override Film White Point"""

	@property
	def bOverride_FilmSaturation(self) -> bool: ...
	"""Override Film Saturation"""

	@property
	def bOverride_FilmChannelMixerRed(self) -> bool: ...
	"""Override Film Channel Mixer Red"""

	@property
	def bOverride_FilmChannelMixerGreen(self) -> bool: ...
	"""Override Film Channel Mixer Green"""

	@property
	def bOverride_FilmChannelMixerBlue(self) -> bool: ...
	"""Override Film Channel Mixer Blue"""

	@property
	def bOverride_FilmContrast(self) -> bool: ...
	"""Override Film Contrast"""

	@property
	def bOverride_FilmDynamicRange(self) -> bool: ...
	"""Override Film Dynamic Range"""

	@property
	def bOverride_FilmHealAmount(self) -> bool: ...
	"""Override Film Heal Amount"""

	@property
	def bOverride_FilmToeAmount(self) -> bool: ...
	"""Override Film Toe Amount"""

	@property
	def bOverride_FilmShadowTint(self) -> bool: ...
	"""Override Film Shadow Tint"""

	@property
	def bOverride_FilmShadowTintBlend(self) -> bool: ...
	"""Override Film Shadow Tint Blend"""

	@property
	def bOverride_FilmShadowTintAmount(self) -> bool: ...
	"""Override Film Shadow Tint Amount"""

	@property
	def bOverride_FilmSlope(self) -> bool: ...
	"""Override Film Slope"""

	@property
	def bOverride_FilmToe(self) -> bool: ...
	"""Override Film Toe"""

	@property
	def bOverride_FilmShoulder(self) -> bool: ...
	"""Override Film Shoulder"""

	@property
	def bOverride_FilmBlackClip(self) -> bool: ...
	"""Override Film Black Clip"""

	@property
	def bOverride_FilmWhiteClip(self) -> bool: ...
	"""Override Film White Clip"""

	@property
	def bOverride_SceneColorTint(self) -> bool: ...
	"""Override Scene Color Tint"""

	@property
	def bOverride_SceneFringeIntensity(self) -> bool: ...
	"""Override Scene Fringe Intensity"""

	@property
	def bOverride_ChromaticAberrationStartOffset(self) -> bool: ...
	"""Override Chromatic Aberration Start Offset"""

	@property
	def bOverride_AmbientCubemapTint(self) -> bool: ...
	"""Override Ambient Cubemap Tint"""

	@property
	def bOverride_AmbientCubemapIntensity(self) -> bool: ...
	"""Override Ambient Cubemap Intensity"""

	@property
	def bOverride_BloomMethod(self) -> bool: ...
	"""Override Bloom Method"""

	@property
	def bOverride_BloomIntensity(self) -> bool: ...
	"""Override Bloom Intensity"""

	@property
	def bOverride_BloomThreshold(self) -> bool: ...
	"""Override Bloom Threshold"""

	@property
	def bOverride_Bloom1Tint(self) -> bool: ...
	"""Override Bloom 1Tint"""

	@property
	def bOverride_Bloom1Size(self) -> bool: ...
	"""Override Bloom 1Size"""

	@property
	def bOverride_Bloom2Size(self) -> bool: ...
	"""Override Bloom 2Size"""

	@property
	def bOverride_Bloom2Tint(self) -> bool: ...
	"""Override Bloom 2Tint"""

	@property
	def bOverride_Bloom3Tint(self) -> bool: ...
	"""Override Bloom 3Tint"""

	@property
	def bOverride_Bloom3Size(self) -> bool: ...
	"""Override Bloom 3Size"""

	@property
	def bOverride_Bloom4Tint(self) -> bool: ...
	"""Override Bloom 4Tint"""

	@property
	def bOverride_Bloom4Size(self) -> bool: ...
	"""Override Bloom 4Size"""

	@property
	def bOverride_Bloom5Tint(self) -> bool: ...
	"""Override Bloom 5Tint"""

	@property
	def bOverride_Bloom5Size(self) -> bool: ...
	"""Override Bloom 5Size"""

	@property
	def bOverride_Bloom6Tint(self) -> bool: ...
	"""Override Bloom 6Tint"""

	@property
	def bOverride_Bloom6Size(self) -> bool: ...
	"""Override Bloom 6Size"""

	@property
	def bOverride_BloomSizeScale(self) -> bool: ...
	"""Override Bloom Size Scale"""

	@property
	def bOverride_BloomConvolutionTexture(self) -> bool: ...
	"""Override Bloom Convolution Texture"""

	@property
	def bOverride_BloomConvolutionSize(self) -> bool: ...
	"""Override Bloom Convolution Size"""

	@property
	def bOverride_BloomConvolutionCenterUV(self) -> bool: ...
	"""Override Bloom Convolution Center UV"""

	@property
	def bOverride_BloomConvolutionPreFilterMin(self) -> bool: ...
	"""Override Bloom Convolution Pre Filter Min"""

	@property
	def bOverride_BloomConvolutionPreFilterMax(self) -> bool: ...
	"""Override Bloom Convolution Pre Filter Max"""

	@property
	def bOverride_BloomConvolutionPreFilterMult(self) -> bool: ...
	"""Override Bloom Convolution Pre Filter Mult"""

	@property
	def bOverride_BloomConvolutionBufferScale(self) -> bool: ...
	"""Override Bloom Convolution Buffer Scale"""

	@property
	def bOverride_BloomDirtMaskIntensity(self) -> bool: ...
	"""Override Bloom Dirt Mask Intensity"""

	@property
	def bOverride_BloomDirtMaskTint(self) -> bool: ...
	"""Override Bloom Dirt Mask Tint"""

	@property
	def bOverride_BloomDirtMask(self) -> bool: ...
	"""Override Bloom Dirt Mask"""

	@property
	def bOverride_CameraShutterSpeed(self) -> bool: ...
	"""Override Camera Shutter Speed"""

	@property
	def bOverride_CameraISO(self) -> bool: ...
	"""Override Camera ISO"""

	@property
	def bOverride_AutoExposureMethod(self) -> bool: ...
	"""Override Auto Exposure Method"""

	@property
	def bOverride_AutoExposureLowPercent(self) -> bool: ...
	"""Override Auto Exposure Low Percent"""

	@property
	def bOverride_AutoExposureHighPercent(self) -> bool: ...
	"""Override Auto Exposure High Percent"""

	@property
	def bOverride_AutoExposureMinBrightness(self) -> bool: ...
	"""Override Auto Exposure Min Brightness"""

	@property
	def bOverride_AutoExposureMaxBrightness(self) -> bool: ...
	"""Override Auto Exposure Max Brightness"""

	@property
	def bOverride_AutoExposureSpeedUp(self) -> bool: ...
	"""Override Auto Exposure Speed Up"""

	@property
	def bOverride_AutoExposureSpeedDown(self) -> bool: ...
	"""Override Auto Exposure Speed Down"""

	@property
	def bOverride_AutoExposureBias(self) -> bool: ...
	"""Override Auto Exposure Bias"""

	@property
	def bOverride_AutoExposureBiasCurve(self) -> bool: ...
	"""Override Auto Exposure Bias Curve"""

	@property
	def bOverride_AutoExposureMeterMask(self) -> bool: ...
	"""Override Auto Exposure Meter Mask"""

	@property
	def bOverride_AutoExposureApplyPhysicalCameraExposure(self) -> bool: ...
	"""Override Auto Exposure Apply Physical Camera Exposure"""

	@property
	def bOverride_HistogramLogMin(self) -> bool: ...
	"""Override Histogram Log Min"""

	@property
	def bOverride_HistogramLogMax(self) -> bool: ...
	"""Override Histogram Log Max"""

	@property
	def bOverride_LensFlareIntensity(self) -> bool: ...
	"""Override Lens Flare Intensity"""

	@property
	def bOverride_LensFlareTint(self) -> bool: ...
	"""Override Lens Flare Tint"""

	@property
	def bOverride_LensFlareTints(self) -> bool: ...
	"""Override Lens Flare Tints"""

	@property
	def bOverride_LensFlareBokehSize(self) -> bool: ...
	"""Override Lens Flare Bokeh Size"""

	@property
	def bOverride_LensFlareBokehShape(self) -> bool: ...
	"""Override Lens Flare Bokeh Shape"""

	@property
	def bOverride_LensFlareThreshold(self) -> bool: ...
	"""Override Lens Flare Threshold"""

	@property
	def bOverride_VignetteIntensity(self) -> bool: ...
	"""Override Vignette Intensity"""

	@property
	def bOverride_GrainIntensity(self) -> bool: ...
	"""Override Grain Intensity"""

	@property
	def bOverride_GrainJitter(self) -> bool: ...
	"""Override Grain Jitter"""

	@property
	def bOverride_AmbientOcclusionIntensity(self) -> bool: ...
	"""Override Ambient Occlusion Intensity"""

	@property
	def bOverride_AmbientOcclusionStaticFraction(self) -> bool: ...
	"""Override Ambient Occlusion Static Fraction"""

	@property
	def bOverride_AmbientOcclusionRadius(self) -> bool: ...
	"""Override Ambient Occlusion Radius"""

	@property
	def bOverride_AmbientOcclusionFadeDistance(self) -> bool: ...
	"""Override Ambient Occlusion Fade Distance"""

	@property
	def bOverride_AmbientOcclusionFadeRadius(self) -> bool: ...
	"""Override Ambient Occlusion Fade Radius"""

	@property
	def bOverride_AmbientOcclusionRadiusInWS(self) -> bool: ...
	"""Override Ambient Occlusion Radius in WS"""

	@property
	def bOverride_AmbientOcclusionPower(self) -> bool: ...
	"""Override Ambient Occlusion Power"""

	@property
	def bOverride_AmbientOcclusionBias(self) -> bool: ...
	"""Override Ambient Occlusion Bias"""

	@property
	def bOverride_AmbientOcclusionQuality(self) -> bool: ...
	"""Override Ambient Occlusion Quality"""

	@property
	def bOverride_AmbientOcclusionMipBlend(self) -> bool: ...
	"""Override Ambient Occlusion Mip Blend"""

	@property
	def bOverride_AmbientOcclusionMipScale(self) -> bool: ...
	"""Override Ambient Occlusion Mip Scale"""

	@property
	def bOverride_AmbientOcclusionMipThreshold(self) -> bool: ...
	"""Override Ambient Occlusion Mip Threshold"""

	@property
	def bOverride_AmbientOcclusionTemporalBlendWeight(self) -> bool: ...
	"""Override Ambient Occlusion Temporal Blend Weight"""

	@property
	def bOverride_RayTracingAO(self) -> bool: ...
	"""Override Ray Tracing AO"""

	@property
	def bOverride_RayTracingAOSamplesPerPixel(self) -> bool: ...
	"""Override Ray Tracing AOSamples Per Pixel"""

	@property
	def bOverride_RayTracingAOIntensity(self) -> bool: ...
	"""Override Ray Tracing AOIntensity"""

	@property
	def bOverride_RayTracingAORadius(self) -> bool: ...
	"""Override Ray Tracing AORadius"""

	@property
	def bOverride_LPVIntensity(self) -> bool: ...
	"""Override LPVIntensity"""

	@property
	def bOverride_LPVDirectionalOcclusionIntensity(self) -> bool: ...
	"""Override LPVDirectional Occlusion Intensity"""

	@property
	def bOverride_LPVDirectionalOcclusionRadius(self) -> bool: ...
	"""Override LPVDirectional Occlusion Radius"""

	@property
	def bOverride_LPVDiffuseOcclusionExponent(self) -> bool: ...
	"""Override LPVDiffuse Occlusion Exponent"""

	@property
	def bOverride_LPVSpecularOcclusionExponent(self) -> bool: ...
	"""Override LPVSpecular Occlusion Exponent"""

	@property
	def bOverride_LPVDiffuseOcclusionIntensity(self) -> bool: ...
	"""Override LPVDiffuse Occlusion Intensity"""

	@property
	def bOverride_LPVSpecularOcclusionIntensity(self) -> bool: ...
	"""Override LPVSpecular Occlusion Intensity"""

	@property
	def bOverride_LPVSize(self) -> bool: ...
	"""Override LPVSize"""

	@property
	def bOverride_LPVSecondaryOcclusionIntensity(self) -> bool: ...
	"""Override LPVSecondary Occlusion Intensity"""

	@property
	def bOverride_LPVSecondaryBounceIntensity(self) -> bool: ...
	"""Override LPVSecondary Bounce Intensity"""

	@property
	def bOverride_LPVGeometryVolumeBias(self) -> bool: ...
	"""Override LPVGeometry Volume Bias"""

	@property
	def bOverride_LPVVplInjectionBias(self) -> bool: ...
	"""Override LPVVpl Injection Bias"""

	@property
	def bOverride_LPVEmissiveInjectionIntensity(self) -> bool: ...
	"""Override LPVEmissive Injection Intensity"""

	@property
	def bOverride_LPVFadeRange(self) -> bool: ...
	"""Override LPVFade Range"""

	@property
	def bOverride_LPVDirectionalOcclusionFadeRange(self) -> bool: ...
	"""Override LPVDirectional Occlusion Fade Range"""

	@property
	def bOverride_IndirectLightingColor(self) -> bool: ...
	"""Override Indirect Lighting Color"""

	@property
	def bOverride_IndirectLightingIntensity(self) -> bool: ...
	"""Override Indirect Lighting Intensity"""

	@property
	def bOverride_ColorGradingIntensity(self) -> bool: ...
	"""Override Color Grading Intensity"""

	@property
	def bOverride_ColorGradingLUT(self) -> bool: ...
	"""Override Color Grading LUT"""

	@property
	def bOverride_DepthOfFieldFocalDistance(self) -> bool: ...
	"""Override Depth Of Field Focal Distance"""

	@property
	def bOverride_DepthOfFieldFstop(self) -> bool: ...
	"""Override Depth Of Field Fstop"""

	@property
	def bOverride_DepthOfFieldMinFstop(self) -> bool: ...
	"""Override Depth Of Field Min Fstop"""

	@property
	def bOverride_DepthOfFieldBladeCount(self) -> bool: ...
	"""Override Depth Of Field Blade Count"""

	@property
	def bOverride_DepthOfFieldSensorWidth(self) -> bool: ...
	"""Override Depth Of Field Sensor Width"""

	@property
	def bOverride_DepthOfFieldDepthBlurRadius(self) -> bool: ...
	"""Override Depth Of Field Depth Blur Radius"""

	@property
	def bOverride_DepthOfFieldDepthBlurAmount(self) -> bool: ...
	"""Override Depth Of Field Depth Blur Amount"""

	@property
	def bOverride_DepthOfFieldFocalRegion(self) -> bool: ...
	"""Override Depth Of Field Focal Region"""

	@property
	def bOverride_DepthOfFieldNearTransitionRegion(self) -> bool: ...
	"""Override Depth Of Field Near Transition Region"""

	@property
	def bOverride_DepthOfFieldFarTransitionRegion(self) -> bool: ...
	"""Override Depth Of Field Far Transition Region"""

	@property
	def bOverride_DepthOfFieldScale(self) -> bool: ...
	"""Override Depth Of Field Scale"""

	@property
	def bOverride_DepthOfFieldNearBlurSize(self) -> bool: ...
	"""Override Depth Of Field Near Blur Size"""

	@property
	def bOverride_DepthOfFieldFarBlurSize(self) -> bool: ...
	"""Override Depth Of Field Far Blur Size"""

	@property
	def bOverride_MobileHQGaussian(self) -> bool: ...
	"""Override Mobile HQGaussian"""

	@property
	def bOverride_DepthOfFieldOcclusion(self) -> bool: ...
	"""Override Depth Of Field Occlusion"""

	@property
	def bOverride_DepthOfFieldSkyFocusDistance(self) -> bool: ...
	"""Override Depth Of Field Sky Focus Distance"""

	@property
	def bOverride_DepthOfFieldVignetteSize(self) -> bool: ...
	"""Override Depth Of Field Vignette Size"""

	@property
	def bOverride_MotionBlurAmount(self) -> bool: ...
	"""Override Motion Blur Amount"""

	@property
	def bOverride_MotionBlurMax(self) -> bool: ...
	"""Override Motion Blur Max"""

	@property
	def bOverride_MotionBlurTargetFPS(self) -> bool: ...
	"""Override Motion Blur Target FPS"""

	@property
	def bOverride_MotionBlurPerObjectSize(self) -> bool: ...
	"""Override Motion Blur Per Object Size"""

	@property
	def bOverride_ScreenPercentage(self) -> bool: ...
	"""Override Screen Percentage"""

	@property
	def bOverride_ScreenSpaceReflectionIntensity(self) -> bool: ...
	"""Override Screen Space Reflection Intensity"""

	@property
	def bOverride_ScreenSpaceReflectionQuality(self) -> bool: ...
	"""Override Screen Space Reflection Quality"""

	@property
	def bOverride_ScreenSpaceReflectionMaxRoughness(self) -> bool: ...
	"""Override Screen Space Reflection Max Roughness"""

	@property
	def bOverride_ScreenSpaceReflectionRoughnessScale(self) -> bool: ...
	"""Override Screen Space Reflection Roughness Scale"""

	@property
	def bOverride_ReflectionsType(self) -> bool: ...
	"""Ray Tracing"""

	@property
	def bOverride_RayTracingReflectionsMaxRoughness(self) -> bool: ...
	"""Override Ray Tracing Reflections Max Roughness"""

	@property
	def bOverride_RayTracingReflectionsMaxBounces(self) -> bool: ...
	"""Override Ray Tracing Reflections Max Bounces"""

	@property
	def bOverride_RayTracingReflectionsSamplesPerPixel(self) -> bool: ...
	"""Override Ray Tracing Reflections Samples Per Pixel"""

	@property
	def bOverride_RayTracingReflectionsShadows(self) -> bool: ...
	"""Override Ray Tracing Reflections Shadows"""

	@property
	def bOverride_RayTracingReflectionsTranslucency(self) -> bool: ...
	"""Override Ray Tracing Reflections Translucency"""

	@property
	def bOverride_TranslucencyType(self) -> bool: ...
	"""Override Translucency Type"""

	@property
	def bOverride_RayTracingTranslucencyMaxRoughness(self) -> bool: ...
	"""Override Ray Tracing Translucency Max Roughness"""

	@property
	def bOverride_RayTracingTranslucencyRefractionRays(self) -> bool: ...
	"""Override Ray Tracing Translucency Refraction Rays"""

	@property
	def bOverride_RayTracingTranslucencySamplesPerPixel(self) -> bool: ...
	"""Override Ray Tracing Translucency Samples Per Pixel"""

	@property
	def bOverride_RayTracingTranslucencyShadows(self) -> bool: ...
	"""Override Ray Tracing Translucency Shadows"""

	@property
	def bOverride_RayTracingTranslucencyRefraction(self) -> bool: ...
	"""Override Ray Tracing Translucency Refraction"""

	@property
	def bOverride_RayTracingGI(self) -> bool: ...
	"""Override Ray Tracing GI"""

	@property
	def bOverride_RayTracingGIMaxBounces(self) -> bool: ...
	"""Override Ray Tracing GIMax Bounces"""

	@property
	def bOverride_RayTracingGISamplesPerPixel(self) -> bool: ...
	"""Override Ray Tracing GISamples Per Pixel"""

	@property
	def bOverride_PathTracingMaxBounces(self) -> bool: ...
	"""Override Path Tracing Max Bounces"""

	@property
	def bOverride_PathTracingSamplesPerPixel(self) -> bool: ...
	"""Override Path Tracing Samples Per Pixel"""

	@property
	def bMobileHQGaussian(self) -> bool: ...
	"""Enable HQ Gaussian on high end mobile platforms. (ES3_1)"""

	@property
	def BloomMethod(self) -> int: ...
	"""Bloom algorithm"""

	@property
	def AutoExposureMethod(self) -> int: ...
	"""Luminance computation method"""

	@property
	def WhiteTemp(self) -> float: ...
	"""White Temp"""

	@property
	def WhiteTint(self) -> float: ...
	"""White Tint"""

	@property
	def ColorSaturation(self) -> Vector4: ...
	"""Color Correction controls"""

	@property
	def ColorContrast(self) -> Vector4: ...
	"""Color Contrast"""

	@property
	def ColorGamma(self) -> Vector4: ...
	"""Color Gamma"""

	@property
	def ColorGain(self) -> Vector4: ...
	"""Color Gain"""

	@property
	def ColorOffset(self) -> Vector4: ...
	"""Color Offset"""

	@property
	def ColorSaturationShadows(self) -> Vector4: ...
	"""Color Saturation Shadows"""

	@property
	def ColorContrastShadows(self) -> Vector4: ...
	"""Color Contrast Shadows"""

	@property
	def ColorGammaShadows(self) -> Vector4: ...
	"""Color Gamma Shadows"""

	@property
	def ColorGainShadows(self) -> Vector4: ...
	"""Color Gain Shadows"""

	@property
	def ColorOffsetShadows(self) -> Vector4: ...
	"""Color Offset Shadows"""

	@property
	def ColorSaturationMidtones(self) -> Vector4: ...
	"""Color Saturation Midtones"""

	@property
	def ColorContrastMidtones(self) -> Vector4: ...
	"""Color Contrast Midtones"""

	@property
	def ColorGammaMidtones(self) -> Vector4: ...
	"""Color Gamma Midtones"""

	@property
	def ColorGainMidtones(self) -> Vector4: ...
	"""Color Gain Midtones"""

	@property
	def ColorOffsetMidtones(self) -> Vector4: ...
	"""Color Offset Midtones"""

	@property
	def ColorSaturationHighlights(self) -> Vector4: ...
	"""Color Saturation Highlights"""

	@property
	def ColorContrastHighlights(self) -> Vector4: ...
	"""Color Contrast Highlights"""

	@property
	def ColorGammaHighlights(self) -> Vector4: ...
	"""Color Gamma Highlights"""

	@property
	def ColorGainHighlights(self) -> Vector4: ...
	"""Color Gain Highlights"""

	@property
	def ColorOffsetHighlights(self) -> Vector4: ...
	"""Color Offset Highlights"""

	@property
	def ColorCorrectionHighlightsMin(self) -> float: ...
	"""Color Correction Highlights Min"""

	@property
	def ColorCorrectionShadowsMax(self) -> float: ...
	"""Color Correction Shadows Max"""

	@property
	def BlueCorrection(self) -> float: ...
	"""Correct for artifacts with 'electric' blues due to the ACEScg color space. Bright blue desaturates instead of going to violet."""

	@property
	def ExpandGamut(self) -> float: ...
	"""Expand bright saturated colors outside the sRGB gamut to fake wide gamut rendering."""

	@property
	def ToneCurveAmount(self) -> float: ...
	"""Allow effect of Tone Curve to be reduced (Set ToneCurveAmount and ExpandGamut to 0.0 to fully disable tone curve)"""

	@property
	def FilmSlope(self) -> float: ...
	"""Film Slope"""

	@property
	def FilmToe(self) -> float: ...
	"""Film Toe"""

	@property
	def FilmShoulder(self) -> float: ...
	"""Film Shoulder"""

	@property
	def FilmBlackClip(self) -> float: ...
	"""Film Black Clip"""

	@property
	def FilmWhiteClip(self) -> float: ...
	"""Film White Clip"""

	@property
	def FilmWhitePoint(self) -> LinearColor: ...
	"""Film White Point"""

	@property
	def FilmShadowTint(self) -> LinearColor: ...
	"""Film Shadow Tint"""

	@property
	def FilmShadowTintBlend(self) -> float: ...
	"""Film Shadow Tint Blend"""

	@property
	def FilmShadowTintAmount(self) -> float: ...
	"""Film Shadow Tint Amount"""

	@property
	def FilmSaturation(self) -> float: ...
	"""Film Saturation"""

	@property
	def FilmChannelMixerRed(self) -> LinearColor: ...
	"""Film Channel Mixer Red"""

	@property
	def FilmChannelMixerGreen(self) -> LinearColor: ...
	"""Film Channel Mixer Green"""

	@property
	def FilmChannelMixerBlue(self) -> LinearColor: ...
	"""Film Channel Mixer Blue"""

	@property
	def FilmContrast(self) -> float: ...
	"""Film Contrast"""

	@property
	def FilmToeAmount(self) -> float: ...
	"""Film Toe Amount"""

	@property
	def FilmHealAmount(self) -> float: ...
	"""Film Heal Amount"""

	@property
	def FilmDynamicRange(self) -> float: ...
	"""Film Dynamic Range"""

	@property
	def SceneColorTint(self) -> LinearColor: ...
	"""Scene tint color"""

	@property
	def SceneFringeIntensity(self) -> float: ...
	"""in percent, Scene chromatic aberration / color fringe (camera imperfection) to simulate an artifact that happens in real-world lens, mostly visible in the image corners."""

	@property
	def ChromaticAberrationStartOffset(self) -> float: ...
	"""A normalized distance to the center of the framebuffer where the effect takes place."""

	@property
	def BloomIntensity(self) -> float: ...
	"""Multiplier for all bloom contributions >=0: off, 1(default), >1 brighter"""

	@property
	def BloomThreshold(self) -> float: ...
	"""minimum brightness the bloom starts having effect
-1:all pixels affect bloom equally (physically correct, faster as a threshold pass is omitted), 0:all pixels affect bloom brights more, 1(default), >1 brighter"""

	@property
	def BloomSizeScale(self) -> float: ...
	"""Scale for all bloom sizes"""

	@property
	def Bloom1Size(self) -> float: ...
	"""Diameter size for the Bloom1 in percent of the screen width
(is done in 1/2 resolution, larger values cost more performance, good for high frequency details)
>=0: can be clamped because of shader limitations"""

	@property
	def Bloom2Size(self) -> float: ...
	"""Diameter size for Bloom2 in percent of the screen width
(is done in 1/4 resolution, larger values cost more performance)
>=0: can be clamped because of shader limitations"""

	@property
	def Bloom3Size(self) -> float: ...
	"""Diameter size for Bloom3 in percent of the screen width
(is done in 1/8 resolution, larger values cost more performance)
>=0: can be clamped because of shader limitations"""

	@property
	def Bloom4Size(self) -> float: ...
	"""Diameter size for Bloom4 in percent of the screen width
(is done in 1/16 resolution, larger values cost more performance, best for wide contributions)
>=0: can be clamped because of shader limitations"""

	@property
	def Bloom5Size(self) -> float: ...
	"""Diameter size for Bloom5 in percent of the screen width
(is done in 1/32 resolution, larger values cost more performance, best for wide contributions)
>=0: can be clamped because of shader limitations"""

	@property
	def Bloom6Size(self) -> float: ...
	"""Diameter size for Bloom6 in percent of the screen width
(is done in 1/64 resolution, larger values cost more performance, best for wide contributions)
>=0: can be clamped because of shader limitations"""

	@property
	def Bloom1Tint(self) -> LinearColor: ...
	"""Bloom1 tint color"""

	@property
	def Bloom2Tint(self) -> LinearColor: ...
	"""Bloom2 tint color"""

	@property
	def Bloom3Tint(self) -> LinearColor: ...
	"""Bloom3 tint color"""

	@property
	def Bloom4Tint(self) -> LinearColor: ...
	"""Bloom4 tint color"""

	@property
	def Bloom5Tint(self) -> LinearColor: ...
	"""Bloom5 tint color"""

	@property
	def Bloom6Tint(self) -> LinearColor: ...
	"""Bloom6 tint color"""

	@property
	def BloomConvolutionSize(self) -> float: ...
	"""Relative size of the convolution kernel image compared to the minor axis of the viewport"""

	@property
	def BloomConvolutionTexture(self) -> Texture2D: ...
	"""Texture to replace default convolution bloom kernel"""

	@property
	def BloomConvolutionCenterUV(self) -> Vector2D: ...
	"""The UV location of the center of the kernel.  Should be very close to (.5,.5)"""

	@property
	def BloomConvolutionPreFilterMin(self) -> float: ...
	"""Boost intensity of select pixels  prior to computing bloom convolution (Min, Max, Multiplier).  Max < Min disables"""

	@property
	def BloomConvolutionPreFilterMax(self) -> float: ...
	"""Boost intensity of select pixels  prior to computing bloom convolution (Min, Max, Multiplier).  Max < Min disables"""

	@property
	def BloomConvolutionPreFilterMult(self) -> float: ...
	"""Boost intensity of select pixels  prior to computing bloom convolution (Min, Max, Multiplier).  Max < Min disables"""

	@property
	def BloomConvolutionBufferScale(self) -> float: ...
	"""Implicit buffer region as a fraction of the screen size to insure the bloom does not wrap across the screen.  Larger sizes have perf impact."""

	@property
	def BloomDirtMask(self) -> Texture: ...
	"""Texture that defines the dirt on the camera lens where the light of very bright objects is scattered."""

	@property
	def BloomDirtMaskIntensity(self) -> float: ...
	"""BloomDirtMask intensity"""

	@property
	def BloomDirtMaskTint(self) -> LinearColor: ...
	"""BloomDirtMask tint color"""

	@property
	def AmbientCubemapTint(self) -> LinearColor: ...
	"""AmbientCubemap tint color"""

	@property
	def AmbientCubemapIntensity(self) -> float: ...
	"""To scale the Ambient cubemap brightness
>=0: off, 1(default), >1 brighter"""

	@property
	def AmbientCubemap(self) -> TextureCube: ...
	"""The Ambient cubemap (Affects diffuse and specular shading), blends additively which if different from all other settings here"""

	@property
	def CameraShutterSpeed(self) -> float: ...
	"""The camera shutter in seconds."""

	@property
	def CameraISO(self) -> float: ...
	"""The camera sensor sensitivity"""

	@property
	def DepthOfFieldFstop(self) -> float: ...
	"""Defines the opening of the camera lens, Aperture is 1/fstop, typical lens go down to f/1.2 (large opening), larger numbers reduce the DOF effect"""

	@property
	def DepthOfFieldMinFstop(self) -> float: ...
	"""Defines the maximum opening of the camera lens to control the curvature of blades of the diaphragm. Set it to 0 to get straight blades."""

	@property
	def DepthOfFieldBladeCount(self) -> int: ...
	"""Defines the number of blades of the diaphragm within the lens (between 4 and 16)."""

	@property
	def AutoExposureBias(self) -> float: ...
	"""Logarithmic adjustment for the exposure. Only used if a tonemapper is specified.
0: no adjustment, -1:2x darker, -2:4x darker, 1:2x brighter, 2:4x brighter, ..."""

	@property
	def AutoExposureBiasBackup(self) -> float: ...
	"""With the auto exposure changes, we are changing the AutoExposureBias inside the serialization code. We are
storing that value before conversion here as a backup. Hopefully it will not be needed, and removed in the next engine revision."""

	@property
	def bOverride_AutoExposureBiasBackup(self) -> bool: ...
	"""With the auto exposure changes, we are also changing the auto exposure override value, so we are storing
that backup as well."""

	@property
	def AutoExposureApplyPhysicalCameraExposure(self) -> bool: ...
	"""Only affects Manual exposure mode."""

	@property
	def AutoExposureBiasCurve(self) -> CurveFloat: ...
	"""Exposure compensation based on the scene EV100.
Used to calibrate the final exposure differently depending on the average scene luminance.
0: no adjustment, -1:2x darker, -2:4x darker, 1:2x brighter, 2:4x brighter, ..."""

	@property
	def AutoExposureMeterMask(self) -> Texture: ...
	"""Exposure metering mask. Bright spots on the mask will have high influence on auto-exposure metering
and dark spots will have low influence."""

	@property
	def AutoExposureLowPercent(self) -> float: ...
	"""The eye adaptation will adapt to a value extracted from the luminance histogram of the scene color.
The value is defined as having x percent below this brightness. Higher values give bright spots on the screen more priority
but can lead to less stable results. Lower values give the medium and darker values more priority but might cause burn out of
bright spots.
>0, <100, good values are in the range 70 .. 80"""

	@property
	def AutoExposureHighPercent(self) -> float: ...
	"""The eye adaptation will adapt to a value extracted from the luminance histogram of the scene color.
The value is defined as having x percent below this brightness. Higher values give bright spots on the screen more priority
but can lead to less stable results. Lower values give the medium and darker values more priority but might cause burn out of
bright spots.
>0, <100, good values are in the range 80 .. 95"""

	@property
	def AutoExposureMinBrightness(self) -> float: ...
	"""Auto-Exposure minimum adaptation. Eye Adaptation is disabled if Min = Max.
Auto-exposure is implemented by choosing an exposure value for which the average luminance generates a pixel brightness equal to the Constant Calibration value.
The Min/Max are expressed in pixel luminance (cd/m2) or in EV100 when using ExtendDefaultLuminanceRange (see project settings)."""

	@property
	def AutoExposureMaxBrightness(self) -> float: ...
	"""Auto-Exposure maximum adaptation. Eye Adaptation is disabled if Min = Max.
Auto-exposure is implemented by choosing an exposure value for which the average luminance generates a pixel brightness equal to the Constant Calibration value.
The Min/Max are expressed in pixel luminance (cd/m2) or in EV100 when using ExtendDefaultLuminanceRange (see project settings)."""

	@property
	def AutoExposureSpeedUp(self) -> float: ...
	"""In F-stops per second, should be >0"""

	@property
	def AutoExposureSpeedDown(self) -> float: ...
	"""In F-stops per second, should be >0"""

	@property
	def HistogramLogMin(self) -> float: ...
	"""Histogram Min value. Expressed in Log2(Luminance) or in EV100 when using ExtendDefaultLuminanceRange (see project settings)"""

	@property
	def HistogramLogMax(self) -> float: ...
	"""Histogram Max value. Expressed in Log2(Luminance) or in EV100 when using ExtendDefaultLuminanceRange (see project settings)"""

	@property
	def LensFlareIntensity(self) -> float: ...
	"""Brightness scale of the image cased lens flares (linear)"""

	@property
	def LensFlareTint(self) -> LinearColor: ...
	"""Tint color for the image based lens flares."""

	@property
	def LensFlareBokehSize(self) -> float: ...
	"""Size of the Lens Blur (in percent of the view width) that is done with the Bokeh texture (note: performance cost is radius*radius)"""

	@property
	def LensFlareThreshold(self) -> float: ...
	"""Minimum brightness the lens flare starts having effect (this should be as high as possible to avoid the performance cost of blurring content that is too dark too see)"""

	@property
	def LensFlareBokehShape(self) -> Texture: ...
	"""Defines the shape of the Bokeh when the image base lens flares are blurred, cannot be blended"""

	@property
	def LensFlareTints(self) -> typing.List[LinearColor]: ...
	"""RGB defines the lens flare color, A it's position. This is a temporary solution."""

	@property
	def VignetteIntensity(self) -> float: ...
	"""0..1 0=off/no vignette .. 1=strong vignette"""

	@property
	def GrainJitter(self) -> float: ...
	"""0..1 grain jitter"""

	@property
	def GrainIntensity(self) -> float: ...
	"""0..1 grain intensity"""

	@property
	def AmbientOcclusionIntensity(self) -> float: ...
	"""0..1 0=off/no ambient occlusion .. 1=strong ambient occlusion, defines how much it affects the non direct lighting after base pass"""

	@property
	def AmbientOcclusionStaticFraction(self) -> float: ...
	"""0..1 0=no effect on static lighting .. 1=AO affects the stat lighting, 0 is free meaning no extra rendering pass"""

	@property
	def AmbientOcclusionRadius(self) -> float: ...
	""">0, in unreal units, bigger values means even distant surfaces affect the ambient occlusion"""

	@property
	def AmbientOcclusionRadiusInWS(self) -> bool: ...
	"""true: AO radius is in world space units, false: AO radius is locked the view space in 400 units"""

	@property
	def AmbientOcclusionFadeDistance(self) -> float: ...
	""">0, in unreal units, at what distance the AO effect disppears in the distance (avoding artifacts and AO effects on huge object)"""

	@property
	def AmbientOcclusionFadeRadius(self) -> float: ...
	""">0, in unreal units, how many units before AmbientOcclusionFadeOutDistance it starts fading out"""

	@property
	def AmbientOcclusionPower(self) -> float: ...
	""">0, in unreal units, bigger values means even distant surfaces affect the ambient occlusion"""

	@property
	def AmbientOcclusionBias(self) -> float: ...
	""">0, in unreal units, default (3.0) works well for flat surfaces but can reduce details"""

	@property
	def AmbientOcclusionQuality(self) -> float: ...
	"""0=lowest quality..100=maximum quality, only a few quality levels are implemented, no soft transition"""

	@property
	def AmbientOcclusionMipBlend(self) -> float: ...
	"""Affects the blend over the multiple mips (lower resolution versions) , 0:fully use full resolution, 1::fully use low resolution, around 0.6 seems to be a good value"""

	@property
	def AmbientOcclusionMipScale(self) -> float: ...
	"""Affects the radius AO radius scale over the multiple mips (lower resolution versions)"""

	@property
	def AmbientOcclusionMipThreshold(self) -> float: ...
	"""to tweak the bilateral upsampling when using multiple mips (lower resolution versions)"""

	@property
	def AmbientOcclusionTemporalBlendWeight(self) -> float: ...
	"""How much to blend the current frame with previous frames when using GTAO with temporal accumulation"""

	@property
	def RayTracingAO(self) -> bool: ...
	"""Enables ray tracing ambient occlusion."""

	@property
	def RayTracingAOSamplesPerPixel(self) -> int: ...
	"""Sets the samples per pixel for ray tracing ambient occlusion."""

	@property
	def RayTracingAOIntensity(self) -> float: ...
	"""Scalar factor on the ray-tracing ambient occlusion score."""

	@property
	def RayTracingAORadius(self) -> float: ...
	"""Defines the world-space search radius for occlusion rays."""

	@property
	def IndirectLightingColor(self) -> LinearColor: ...
	"""Adjusts indirect lighting color. (1,1,1) is default. (0,0,0) to disable GI. The show flag 'Global Illumination' must be enabled to use this property."""

	@property
	def IndirectLightingIntensity(self) -> float: ...
	"""Scales the indirect lighting contribution. A value of 0 disables GI. Default is 1. The show flag 'Global Illumination' must be enabled to use this property."""

	@property
	def RayTracingGIType(self) -> int: ...
	"""Sets the ray tracing global illumination type."""

	@property
	def RayTracingGIMaxBounces(self) -> int: ...
	"""Sets the ray tracing global illumination maximum bounces."""

	@property
	def RayTracingGISamplesPerPixel(self) -> int: ...
	"""Sets the samples per pixel for ray tracing global illumination."""

	@property
	def ColorGradingIntensity(self) -> float: ...
	"""Color grading lookup table intensity. 0 = no intensity, 1=full intensity"""

	@property
	def ColorGradingLUT(self) -> Texture: ...
	"""Look up table texture to use or none of not used"""

	@property
	def DepthOfFieldSensorWidth(self) -> float: ...
	"""Width of the camera sensor to assume, in mm."""

	@property
	def DepthOfFieldFocalDistance(self) -> float: ...
	"""Distance in which the Depth of Field effect should be sharp, in unreal units (cm)"""

	@property
	def DepthOfFieldDepthBlurAmount(self) -> float: ...
	"""CircleDOF only: Depth blur km for 50%"""

	@property
	def DepthOfFieldDepthBlurRadius(self) -> float: ...
	"""CircleDOF only: Depth blur radius in pixels at 1920x"""

	@property
	def DepthOfFieldFocalRegion(self) -> float: ...
	"""Artificial region where all content is in focus, starting after DepthOfFieldFocalDistance, in unreal units  (cm)"""

	@property
	def DepthOfFieldNearTransitionRegion(self) -> float: ...
	"""To define the width of the transition region next to the focal region on the near side (cm)"""

	@property
	def DepthOfFieldFarTransitionRegion(self) -> float: ...
	"""To define the width of the transition region next to the focal region on the near side (cm)"""

	@property
	def DepthOfFieldScale(self) -> float: ...
	"""SM5: BokehDOF only: To amplify the depth of field effect (like aperture)  0=off
          ES3_1: Used to blend DoF. 0=off"""

	@property
	def DepthOfFieldNearBlurSize(self) -> float: ...
	"""Gaussian only: Maximum size of the Depth of Field blur (in percent of the view width) (note: performance cost scales with size)"""

	@property
	def DepthOfFieldFarBlurSize(self) -> float: ...
	"""Gaussian only: Maximum size of the Depth of Field blur (in percent of the view width) (note: performance cost scales with size)"""

	@property
	def DepthOfFieldOcclusion(self) -> float: ...
	"""Occlusion tweak factor 1 (0.18 to get natural occlusion, 0.4 to solve layer color leaking issues)"""

	@property
	def DepthOfFieldSkyFocusDistance(self) -> float: ...
	"""Artificial distance to allow the skybox to be in focus (e.g. 200000), <=0 to switch the feature off, only for GaussianDOF, can cost performance"""

	@property
	def DepthOfFieldVignetteSize(self) -> float: ...
	"""Artificial circular mask to (near) blur content outside the radius, only for GaussianDOF, diameter in percent of screen width, costs performance if the mask is used, keep Feather can Radius on default to keep it off"""

	@property
	def MotionBlurAmount(self) -> float: ...
	"""Strength of motion blur, 0:off, should be renamed to intensity"""

	@property
	def MotionBlurMax(self) -> float: ...
	"""max distortion caused by motion blur, in percent of the screen width, 0:off"""

	@property
	def MotionBlurTargetFPS(self) -> int: ...
	"""Defines the target FPS for motion blur. Makes motion blur independent of actual frame rate and relative
to the specified target FPS instead. Higher target FPS results in shorter frames, which means shorter
shutter times and less motion blur. Lower FPS means more motion blur. A value of zero makes the motion
blur dependent on the actual frame rate."""

	@property
	def MotionBlurPerObjectSize(self) -> float: ...
	"""The minimum projected screen radius for a primitive to be drawn in the velocity pass, percentage of screen width. smaller numbers cause more draw calls, default: 4%"""

	@property
	def LPVIntensity(self) -> float: ...
	"""How strong the dynamic GI from the LPV should be. 0.0 is off, 1.0 is the 'normal' value, but higher values can be used to boost the effect"""

	@property
	def LPVVplInjectionBias(self) -> float: ...
	"""Bias applied to light injected into the LPV in cell units. Increase to reduce bleeding through thin walls"""

	@property
	def LPVSize(self) -> float: ...
	"""The size of the LPV volume, in Unreal units"""

	@property
	def LPVSecondaryOcclusionIntensity(self) -> float: ...
	"""Secondary occlusion strength (bounce light shadows). Set to 0 to disable"""

	@property
	def LPVSecondaryBounceIntensity(self) -> float: ...
	"""Secondary bounce light strength (bounce light shadows). Set to 0 to disable"""

	@property
	def LPVGeometryVolumeBias(self) -> float: ...
	"""Bias applied to the geometry volume in cell units. Increase to reduce darkening due to secondary occlusion"""

	@property
	def LPVEmissiveInjectionIntensity(self) -> float: ...
	"""LPVEmissive Injection Intensity"""

	@property
	def LPVDirectionalOcclusionIntensity(self) -> float: ...
	"""Controls the amount of directional occlusion. Requires LPV. Values very close to 1.0 are recommended"""

	@property
	def LPVDirectionalOcclusionRadius(self) -> float: ...
	"""Occlusion Radius - 16 is recommended for most scenes"""

	@property
	def LPVDiffuseOcclusionExponent(self) -> float: ...
	"""Diffuse occlusion exponent - increase for more contrast. 1 to 2 is recommended"""

	@property
	def LPVSpecularOcclusionExponent(self) -> float: ...
	"""Specular occlusion exponent - increase for more contrast. 6 to 9 is recommended"""

	@property
	def LPVDiffuseOcclusionIntensity(self) -> float: ...
	"""Diffuse occlusion intensity - higher values provide increased diffuse occlusion."""

	@property
	def LPVSpecularOcclusionIntensity(self) -> float: ...
	"""Specular occlusion intensity - higher values provide increased specular occlusion."""

	@property
	def ReflectionsType(self) -> int: ...
	"""Sets the reflections type"""

	@property
	def ScreenSpaceReflectionIntensity(self) -> float: ...
	"""Enable/Fade/disable the Screen Space Reflection feature, in percent, avoid numbers between 0 and 1 fo consistency"""

	@property
	def ScreenSpaceReflectionQuality(self) -> float: ...
	"""0=lowest quality..100=maximum quality, only a few quality levels are implemented, no soft transition, 50 is the default for better performance."""

	@property
	def ScreenSpaceReflectionMaxRoughness(self) -> float: ...
	"""Until what roughness we fade the screen space reflections, 0.8 works well, smaller can run faster"""

	@property
	def RayTracingReflectionsMaxRoughness(self) -> float: ...
	"""Sets the maximum roughness until which ray tracing reflections will be visible (lower value is faster). Reflection contribution is smoothly faded when close to roughness threshold. This parameter behaves similarly to ScreenSpaceReflectionMaxRoughness."""

	@property
	def RayTracingReflectionsMaxBounces(self) -> int: ...
	"""Sets the maximum number of ray tracing reflection bounces."""

	@property
	def RayTracingReflectionsSamplesPerPixel(self) -> int: ...
	"""Sets the samples per pixel for ray traced reflections."""

	@property
	def RayTracingReflectionsShadows(self) -> int: ...
	"""Sets the reflected shadows type."""

	@property
	def RayTracingReflectionsTranslucency(self) -> bool: ...
	"""Enables ray tracing translucency in reflections."""

	@property
	def TranslucencyType(self) -> int: ...
	"""Sets the translucency type"""

	@property
	def RayTracingTranslucencyMaxRoughness(self) -> float: ...
	"""Sets the maximum roughness until which ray tracing translucency will be visible (lower value is faster). Translucency contribution is smoothly faded when close to roughness threshold. This parameter behaves similarly to ScreenSpaceReflectionMaxRoughness."""

	@property
	def RayTracingTranslucencyRefractionRays(self) -> int: ...
	"""Sets the maximum number of ray tracing refraction rays."""

	@property
	def RayTracingTranslucencySamplesPerPixel(self) -> int: ...
	"""Sets the samples per pixel for ray traced translucency."""

	@property
	def RayTracingTranslucencyShadows(self) -> int: ...
	"""Sets the translucency shadows type."""

	@property
	def RayTracingTranslucencyRefraction(self) -> bool: ...
	"""Sets whether refraction should be enabled or not (if not rays will not scatter and only travel in the same direction as before the intersection event)."""

	@property
	def PathTracingMaxBounces(self) -> int: ...
	"""Sets the path tracing maximum bounces"""

	@property
	def PathTracingSamplesPerPixel(self) -> int: ...
	"""Sets the samples per pixel for the path tracer."""

	@property
	def LPVFadeRange(self) -> float: ...
	"""LPV Fade range - increase to fade more gradually towards the LPV edges."""

	@property
	def LPVDirectionalOcclusionFadeRange(self) -> float: ...
	"""LPV Directional Occlusion Fade range - increase to fade more gradually towards the LPV edges."""

	@property
	def ScreenPercentage(self) -> float: ...
	"""To render with lower or high resolution than it is presented,
controlled by console variable,
100:off, needs to be <99 to get upsampling and lower to get performance,
>100 for super sampling (slower but higher quality),
only applied in game"""

	@property
	def WeightedBlendables(self) -> WeightedBlendables: ...
	"""Allows custom post process materials to be defined, using a MaterialInstance with the same Material as its parent to allow blending.
For materials this needs to be the 'PostProcess' domain type. This can be used for any UObject object implementing the IBlendableInterface (e.g. could be used to fade weather settings)."""

	pass

class MinimalViewInfo(object):
	"""Minimal View Info"""

	@property
	def Location(self) -> Vector: ...
	"""Location"""

	@property
	def Rotation(self) -> Rotator: ...
	"""Rotation"""

	@property
	def FOV(self) -> float: ...
	"""The horizontal field of view (in degrees) in perspective mode (ignored in orthographic mode)."""

	@property
	def DesiredFOV(self) -> float: ...
	"""The originally desired horizontal field of view before any adjustments to account for different aspect ratios"""

	@property
	def OrthoWidth(self) -> float: ...
	"""The desired width (in world units) of the orthographic view (ignored in Perspective mode)"""

	@property
	def OrthoNearClipPlane(self) -> float: ...
	"""The near plane distance of the orthographic view (in world units)"""

	@property
	def OrthoFarClipPlane(self) -> float: ...
	"""The far plane distance of the orthographic view (in world units)"""

	@property
	def AspectRatio(self) -> float: ...
	"""Aspect Ratio (Width/Height); ignored unless bConstrainAspectRatio is true"""

	@property
	def bConstrainAspectRatio(self) -> bool: ...
	"""If bConstrainAspectRatio is true, black bars will be added if the destination view has a different aspect ratio than this camera requested."""

	@property
	def bUseFieldOfViewForLOD(self) -> bool: ...
	"""If true, account for the field of view angle when computing which level of detail to use for meshes."""

	@property
	def ProjectionMode(self) -> int: ...
	"""The type of camera"""

	@property
	def PostProcessBlendWeight(self) -> float: ...
	"""Indicates if PostProcessSettings should be applied."""

	@property
	def PostProcessSettings(self) -> PostProcessSettings: ...
	"""Post-process settings to use if PostProcessBlendWeight is non-zero."""

	@property
	def OffCenterProjectionOffset(self) -> Vector2D: ...
	"""Off-axis / off-center projection offset as proportion of screen dimensions"""

	pass

class CameraShakeUpdateParams(object):
	"""Parameters for updating a camera shake."""

	pass

class CameraShakeUpdateResult(object):
	"""The result of a camera shake update."""

	pass

class CameraShakeDuration(object):
	"""Camera shake duration."""

	pass

class CameraShakeInfo(object):
	"""Information about a camera shake class."""

	@property
	def Duration(self) -> CameraShakeDuration: ...
	"""The duration of the camera shake"""

	@property
	def BlendIn(self) -> float: ...
	"""How much blending-in the camera shake should have"""

	@property
	def BlendOut(self) -> float: ...
	"""How much blending-out the camera shake should have"""

	pass

class FOscillator(object):
	"""Defines oscillation of a single number."""

	@property
	def Amplitude(self) -> float: ...
	"""Amplitude of the sinusoidal oscillation."""

	@property
	def Frequency(self) -> float: ...
	"""Frequency of the sinusoidal oscillation."""

	@property
	def InitialOffset(self) -> int: ...
	"""Defines how to begin (either at zero, or at a randomized value."""

	@property
	def Waveform(self) -> int: ...
	"""Type of waveform to use for oscillation."""

	pass

class ROscillator(object):
	"""Defines FRotator oscillation."""

	@property
	def Pitch(self) -> FOscillator: ...
	"""Pitch oscillation."""

	@property
	def Yaw(self) -> FOscillator: ...
	"""Yaw oscillation."""

	@property
	def Roll(self) -> FOscillator: ...
	"""Roll oscillation."""

	pass

class VOscillator(object):
	"""Defines FVector oscillation."""

	@property
	def X(self) -> FOscillator: ...
	"""Oscillation in the X axis."""

	@property
	def Y(self) -> FOscillator: ...
	"""Oscillation in the Y axis."""

	@property
	def Z(self) -> FOscillator: ...
	"""Oscillation in the Z axis."""

	pass

class TViewTarget(object):
	"""A ViewTarget is the primary actor the camera is associated with."""

	@property
	def Target(self) -> Actor: ...
	"""Target Actor used to compute POV"""

	@property
	def POV(self) -> MinimalViewInfo: ...
	"""Computed point of view"""

	pass

class ViewTargetTransitionParams(object):
	"""A set of parameters to describe how to transition between view targets."""

	@property
	def BlendTime(self) -> float: ...
	"""Total duration of blend to pending view target. 0 means no blending."""

	@property
	def BlendFunction(self) -> int: ...
	"""Function to apply to the blend parameter."""

	@property
	def BlendExp(self) -> float: ...
	"""Exponent, used by certain blend functions to control the shape of the curve."""

	@property
	def bLockOutgoing(self) -> bool: ...
	"""If true, lock outgoing viewtarget to last frame's camera POV for the remainder of the blend.
This is useful if you plan to teleport the old viewtarget, but don't want to affect the blend."""

	pass

class RuntimeFloatCurve(object):
	"""Runtime Float Curve"""

	@property
	def EditorCurveData(self) -> typing.Any: ...
	"""Editor Curve Data"""

	@property
	def ExternalCurve(self) -> CurveFloat: ...
	"""External Curve"""

	pass

class BaseAttenuationSettings(object):
	"""* Base class for attenuation settings."""

	@property
	def DistanceAlgorithm(self) -> int: ...
	"""The type of attenuation as a function of distance to use."""

	@property
	def AttenuationShape(self) -> int: ...
	"""The shape of the non-custom attenuation method."""

	@property
	def dBAttenuationAtMax(self) -> float: ...
	"""The attenuation volume at the falloff distance in decibels (Only for 'Natural Sound' Distance Algorithm)."""

	@property
	def FalloffMode(self) -> int: ...
	"""Whether to continue attenuating, go silent, or hold last volume value when beyond falloff bounds and
'Attenuation At Max (dB)' is set to a value greater than -60dB.
(Only for 'Natural Sound' Distance Algorithm). */"""

	@property
	def AttenuationShapeExtents(self) -> Vector: ...
	"""The dimensions to use for the attenuation shape. Interpretation of the values differ per shape.
         Sphere  - X is Sphere Radius. Y and Z are unused
         Capsule - X is Capsule Half Height, Y is Capsule Radius, Z is unused
         Box     - X, Y, and Z are the Box's dimensions
         Cone    - X is Cone Radius, Y is Cone Angle, Z is Cone Falloff Angle"""

	@property
	def ConeOffset(self) -> float: ...
	"""The distance back from the sound's origin to begin the cone when using the cone attenuation shape."""

	@property
	def FalloffDistance(self) -> float: ...
	"""The distance over which volume attenuation occurs."""

	@property
	def CustomAttenuationCurve(self) -> RuntimeFloatCurve: ...
	"""The custom volume attenuation curve to use."""

	pass

class SoundAttenuationPluginSettings(object):
	"""Sound Attenuation Plugin Settings"""

	@property
	def SpatializationPluginSettingsArray(self) -> typing.List[unsupported]: ...
	"""Settings to use with spatialization audio plugin. These are defined by the plugin creator. Not all audio plugins utilize this feature. This is an array so multiple plugins can have settings."""

	@property
	def OcclusionPluginSettingsArray(self) -> typing.List[unsupported]: ...
	"""Settings to use with occlusion audio plugin. These are defined by the plugin creator. Not all audio plugins utilize this feature. This  is an array so multiple plugins can have settings."""

	@property
	def ReverbPluginSettingsArray(self) -> typing.List[unsupported]: ...
	"""Settings to use with reverb audio plugin. These are defined by the plugin creator. Not all audio plugins utilize this feature. This  is an array so multiple plugins can have settings."""

	pass

class AttenuationSubmixSendSettings(object):
	"""Attenuation Submix Send Settings"""

	@property
	def Submix(self) -> SoundSubmixBase: ...
	"""Submix to send audio to based on distance."""

	@property
	def SubmixSendMethod(self) -> int: ...
	"""What method to use to use for submix sends."""

	@property
	def SubmixSendLevelMin(self) -> float: ...
	"""The amount to send to the Submix when the sound is located at a distance equal to value specified in the submix send distance min."""

	@property
	def SubmixSendLevelMax(self) -> float: ...
	"""The amount to send to the Submix when the sound is located at a distance equal to value specified in the reverb max send distance."""

	@property
	def SubmixSendDistanceMin(self) -> float: ...
	"""The min distance to send to the Submix."""

	@property
	def SubmixSendDistanceMax(self) -> float: ...
	"""The max distance to send to the Submix."""

	@property
	def ManualSubmixSendLevel(self) -> float: ...
	"""The manual Submix send level to use. Doesn't change as a function of distance."""

	@property
	def CustomSubmixSendCurve(self) -> RuntimeFloatCurve: ...
	"""The custom Submix send curve to use for distance-based send level."""

	pass

class SoundAttenuationSettings(BaseAttenuationSettings):
	"""The settings for attenuating."""

	@property
	def bAttenuate(self) -> bool: ...
	"""Allows distance-based volume attenuation."""

	@property
	def bSpatialize(self) -> bool: ...
	"""Allows the source to be 3D spatialized."""

	@property
	def bAttenuateWithLPF(self) -> bool: ...
	"""Allows simulation of air absorption by applying a filter with a cutoff frequency as a function of distance."""

	@property
	def bEnableListenerFocus(self) -> bool: ...
	"""Enable listener focus-based adjustments."""

	@property
	def bEnableFocusInterpolation(self) -> bool: ...
	"""Enables focus interpolation to smooth transition in and and of focus."""

	@property
	def bEnableOcclusion(self) -> bool: ...
	"""Enables realtime occlusion tracing."""

	@property
	def bUseComplexCollisionForOcclusion(self) -> bool: ...
	"""Enables tracing against complex collision when doing occlusion traces."""

	@property
	def bEnableReverbSend(self) -> bool: ...
	"""Enables adjusting reverb sends based on distance."""

	@property
	def bEnablePriorityAttenuation(self) -> bool: ...
	"""Enables attenuation of sound priority based off distance."""

	@property
	def bApplyNormalizationToStereoSounds(self) -> bool: ...
	"""Enables applying a -6 dB attenuation to stereo assets which are 3d spatialized. Avoids clipping when assets have spread of 0.0 due to channel summing."""

	@property
	def bEnableLogFrequencyScaling(self) -> bool: ...
	"""Enables applying a log scale to frequency values (so frequency sweeping is perceptually linear)."""

	@property
	def bEnableSubmixSends(self) -> bool: ...
	"""Enables submix sends based on distance."""

	@property
	def SpatializationAlgorithm(self) -> int: ...
	"""What method we use to spatialize the sound."""

	@property
	def BinauralRadius(self) -> float: ...
	"""What min radius to use to swap to non-binaural audio when a sound starts playing."""

	@property
	def AbsorptionMethod(self) -> int: ...
	"""What method to use to map distance values to frequency absorption values."""

	@property
	def OcclusionTraceChannel(self) -> int: ...
	"""Which trace channel to use for audio occlusion checks."""

	@property
	def ReverbSendMethod(self) -> int: ...
	"""What method to use to control master reverb sends"""

	@property
	def PriorityAttenuationMethod(self) -> int: ...
	"""What method to use to control priority attenuation"""

	@property
	def OmniRadius(self) -> float: ...
	"""The distance below which a sound is non-spatialized (2D). This prevents near-field audio from flipping as audio crosses the listener's position."""

	@property
	def StereoSpread(self) -> float: ...
	"""The world-space distance between left and right stereo channels when stereo assets are 3D spatialized."""

	@property
	def LPFRadiusMin(self) -> float: ...
	"""The distance min range at which to apply an absorption LPF filter."""

	@property
	def LPFRadiusMax(self) -> float: ...
	"""The max distance range at which to apply an absorption LPF filter. Absorption freq cutoff interpolates between filter frequency ranges between these distance values."""

	@property
	def CustomLowpassAirAbsorptionCurve(self) -> RuntimeFloatCurve: ...
	"""The normalized custom curve to use for the air absorption lowpass frequency values. Does a mapping from defined distance values (x-axis) and defined frequency values (y-axis)"""

	@property
	def CustomHighpassAirAbsorptionCurve(self) -> RuntimeFloatCurve: ...
	"""The normalized custom curve to use for the air absorption highpass frequency values. Does a mapping from defined distance values (x-axis) and defined frequency values (y-axis)"""

	@property
	def LPFFrequencyAtMin(self) -> float: ...
	"""The range of the cutoff frequency (in Hz) of the lowpass absorption filter."""

	@property
	def LPFFrequencyAtMax(self) -> float: ...
	"""The range of the cutoff frequency (in Hz) of the lowpass absorption filter."""

	@property
	def HPFFrequencyAtMin(self) -> float: ...
	"""The range of the cutoff frequency (in Hz) of the highpass absorption filter."""

	@property
	def HPFFrequencyAtMax(self) -> float: ...
	"""The range of the cutoff frequency (in Hz) of the highpass absorption filter."""

	@property
	def FocusAzimuth(self) -> float: ...
	"""Azimuth angle (in degrees) relative to the listener forward vector which defines the focus region of sounds. Sounds playing at an angle less than this will be in focus."""

	@property
	def NonFocusAzimuth(self) -> float: ...
	"""Azimuth angle (in degrees) relative to the listener forward vector which defines the non-focus region of sounds. Sounds playing at an angle greater than this will be out of focus."""

	@property
	def FocusDistanceScale(self) -> float: ...
	"""Amount to scale the distance calculation of sounds that are in-focus. Can be used to make in-focus sounds appear to be closer or further away than they actually are."""

	@property
	def NonFocusDistanceScale(self) -> float: ...
	"""Amount to scale the distance calculation of sounds that are not in-focus. Can be used to make in-focus sounds appear to be closer or further away than they actually are."""

	@property
	def FocusPriorityScale(self) -> float: ...
	"""Amount to scale the priority of sounds that are in focus. Can be used to boost the priority of sounds that are in focus."""

	@property
	def NonFocusPriorityScale(self) -> float: ...
	"""Amount to scale the priority of sounds that are not in-focus. Can be used to reduce the priority of sounds that are not in focus."""

	@property
	def FocusVolumeAttenuation(self) -> float: ...
	"""Amount to attenuate sounds that are in focus. Can be overridden at the sound-level."""

	@property
	def NonFocusVolumeAttenuation(self) -> float: ...
	"""Amount to attenuate sounds that are not in focus. Can be overridden at the sound-level."""

	@property
	def FocusAttackInterpSpeed(self) -> float: ...
	"""Scalar used to increase interpolation speed upwards to the target Focus value"""

	@property
	def FocusReleaseInterpSpeed(self) -> float: ...
	"""Scalar used to increase interpolation speed downwards to the target Focus value"""

	@property
	def OcclusionLowPassFilterFrequency(self) -> float: ...
	"""The low pass filter frequency (in Hz) to apply if the sound playing in this audio component is occluded. This will override the frequency set in LowPassFilterFrequency. A frequency of 0.0 is the device sample rate and will bypass the filter."""

	@property
	def OcclusionVolumeAttenuation(self) -> float: ...
	"""The amount of volume attenuation to apply to sounds which are occluded."""

	@property
	def OcclusionInterpolationTime(self) -> float: ...
	"""The amount of time in seconds to interpolate to the target OcclusionLowPassFilterFrequency when a sound is occluded."""

	@property
	def ReverbWetLevelMin(self) -> float: ...
	"""The amount to send to master reverb when sound is located at a distance equal to value specified in the reverb min send distance."""

	@property
	def ReverbWetLevelMax(self) -> float: ...
	"""The amount to send to master reverb when sound is located at a distance equal to value specified in the reverb max send distance."""

	@property
	def ReverbDistanceMin(self) -> float: ...
	"""The min distance to send to the master reverb."""

	@property
	def ReverbDistanceMax(self) -> float: ...
	"""The max distance to send to the master reverb."""

	@property
	def ManualReverbSendLevel(self) -> float: ...
	"""The manual master reverb send level to use. Doesn't change as a function of distance."""

	@property
	def CustomReverbSendCurve(self) -> RuntimeFloatCurve: ...
	"""The custom reverb send curve to use for distance-based send level."""

	@property
	def SubmixSendSettings(self) -> typing.List[AttenuationSubmixSendSettings]: ...
	"""Set of submix send settings to use to send audio to submixes as a function of distance."""

	@property
	def PriorityAttenuationMin(self) -> float: ...
	"""Interpolated value to scale priority against when the sound is at the minimum priority attenuation distance from the closest listener."""

	@property
	def PriorityAttenuationMax(self) -> float: ...
	"""Interpolated value to scale priority against when the sound is at the maximum priority attenuation distance from the closest listener."""

	@property
	def PriorityAttenuationDistanceMin(self) -> float: ...
	"""The min distance to attenuate priority."""

	@property
	def PriorityAttenuationDistanceMax(self) -> float: ...
	"""The max distance to attenuate priority."""

	@property
	def ManualPriorityAttenuation(self) -> float: ...
	"""Static priority scalar to use (doesn't change as a function of distance)."""

	@property
	def CustomPriorityAttenuationCurve(self) -> RuntimeFloatCurve: ...
	"""The custom curve to use for distance-based priority attenuation."""

	@property
	def PluginSettings(self) -> SoundAttenuationPluginSettings: ...
	"""Sound attenuation plugin settings to use with sounds that play with this attenuation setting."""

	pass

class SoundModulationDestinationSettings(object):
	"""Parameter destination settings allowing modulation control override for parameter destinations opting in to the Modulation System."""

	@property
	def Value(self) -> float: ...
	"""Base value of parameter"""

	@property
	def Modulator(self) -> typing.Any: ...
	"""Modulation source, which provides value to mix with base value."""

	pass

class SoundModulationDefaultSettings(object):
	"""Default parameter destination settings for source audio object."""

	@property
	def VolumeModulationDestination(self) -> SoundModulationDestinationSettings: ...
	"""Volume modulation"""

	@property
	def PitchModulationDestination(self) -> SoundModulationDestinationSettings: ...
	"""Pitch modulation"""

	@property
	def HighpassModulationDestination(self) -> SoundModulationDestinationSettings: ...
	"""Highpass modulation"""

	@property
	def LowpassModulationDestination(self) -> SoundModulationDestinationSettings: ...
	"""Lowpass modulation"""

	pass

class SoundModulationDefaultRoutingSettings(SoundModulationDefaultSettings):
	"""Default parameter destination settings for source audio object."""

	@property
	def VolumeRouting(self) -> int: ...
	"""What volume modulation settings to use"""

	@property
	def PitchRouting(self) -> int: ...
	"""What pitch modulation settings to use"""

	@property
	def HighpassRouting(self) -> int: ...
	"""What high-pass modulation settings to use"""

	@property
	def LowpassRouting(self) -> int: ...
	"""What low-pass modulation settings to use"""

	pass

class SoundSourceBusSendInfo(object):
	"""Sound Source Bus Send Info"""

	@property
	def SourceBusSendLevelControlMethod(self) -> int: ...
	"""Manual: Use Send Level only
Linear: Interpolate between Min and Max Send Levels based on listener distance (between Distance Min and Distance Max)
Custom Curve: Use the float curve to map Send Level to distance (0.0-1.0 on curve maps to Distance Min - Distance Max)"""

	@property
	def SoundSourceBus(self) -> SoundSourceBus: ...
	"""A source Bus to send the audio to. Source buses sonify (make audible) the audio sent to it and are themselves sounds which take up a voice slot in the audio engine."""

	@property
	def AudioBus(self) -> AudioBus: ...
	"""An audio bus to send the audio to. Audio buses can be used to route audio to DSP effects or other purposes. E.g. side-chaining, analysis, etc. Audio buses are not audible unless hooked up to a source bus."""

	@property
	def SendLevel(self) -> float: ...
	"""The amount of audio to send to the bus."""

	@property
	def MinSendLevel(self) -> float: ...
	"""The amount to send to the bus when sound is located at a distance equal to value specified in the min send distance."""

	@property
	def MaxSendLevel(self) -> float: ...
	"""The amount to send to the bus when sound is located at a distance equal to value specified in the max send distance."""

	@property
	def MinSendDistance(self) -> float: ...
	"""The distance at which the min send Level is sent to the bus"""

	@property
	def MaxSendDistance(self) -> float: ...
	"""The distance at which the max send level is sent to the bus"""

	@property
	def CustomSendLevelCurve(self) -> RuntimeFloatCurve: ...
	"""The custom curve to use for distance-based bus send level."""

	pass

class SoundSubmixSpectralAnalysisBandSettings(object):
	"""Sound Submix Spectral Analysis Band Settings"""

	@property
	def BandFrequency(self) -> float: ...
	"""The frequency band for the magnitude to analyze"""

	@property
	def AttackTimeMsec(self) -> int: ...
	"""The attack time for the FFT band interpolation for delegate callback"""

	@property
	def ReleaseTimeMsec(self) -> int: ...
	"""The release time for the FFT band interpolation for delegate callback"""

	@property
	def QFactor(self) -> float: ...
	"""The ratio of the bandwidth divided by the center frequency. Only used when the spectral analysis type is set to Constant Q."""

	pass

class SoundSubmixSendInfo(object):
	"""Class used to send audio to submixes from USoundBase"""

	@property
	def SendLevelControlMethod(self) -> int: ...
	"""Manual: Use Send Level only
Linear: Interpolate between Min and Max Send Levels based on listener distance (between Distance Min and Distance Max)
Custom Curve: Use the float curve to map Send Level to distance (0.0-1.0 on curve maps to Distance Min - Distance Max)"""

	@property
	def SendStage(self) -> int: ...
	"""Defines at what mix stage the send should happen."""

	@property
	def SoundSubmix(self) -> SoundSubmixBase: ...
	"""The submix to send the audio to"""

	@property
	def SendLevel(self) -> float: ...
	"""The amount of audio to send"""

	@property
	def MinSendLevel(self) -> float: ...
	"""The amount to send to master when sound is located at a distance equal to value specified in the min send distance."""

	@property
	def MaxSendLevel(self) -> float: ...
	"""The amount to send to master when sound is located at a distance equal to value specified in the max send distance."""

	@property
	def MinSendDistance(self) -> float: ...
	"""The min distance to send to the master"""

	@property
	def MaxSendDistance(self) -> float: ...
	"""The max distance to send to the master"""

	@property
	def CustomSendLevelCurve(self) -> RuntimeFloatCurve: ...
	"""The custom reverb send curve to use for distance-based send level."""

	pass

class SoundWaveSpectralData(object):
	"""Sound Wave Spectral Data"""

	@property
	def FrequencyHz(self) -> float: ...
	"""The frequency (in Hz) of the spectrum value"""

	@property
	def Magnitude(self) -> float: ...
	"""The magnitude of the spectrum at this frequency"""

	@property
	def NormalizedMagnitude(self) -> float: ...
	"""The normalized magnitude of the spectrum at this frequency"""

	pass

class SoundWaveSpectralDataPerSound(object):
	"""Sound Wave Spectral Data Per Sound"""

	@property
	def SpectralData(self) -> typing.List[SoundWaveSpectralData]: ...
	"""The array of current spectral data for this sound wave"""

	@property
	def PlaybackTime(self) -> float: ...
	"""The current playback time of this sound wave"""

	@property
	def SoundWave(self) -> SoundWave: ...
	"""The sound wave this spectral data is associated with"""

	pass

class SoundWaveEnvelopeDataPerSound(object):
	"""Sound Wave Envelope Data Per Sound"""

	@property
	def Envelope(self) -> float: ...
	"""The current envelope of the playing sound"""

	@property
	def PlaybackTime(self) -> float: ...
	"""The current playback time of this sound wave"""

	@property
	def SoundWave(self) -> SoundWave: ...
	"""The sound wave this envelope data is associated with"""

	pass

class QuartzPulseOverrideStep(object):
	"""Allows the user to specify non-uniform beat durations in odd meters"""

	@property
	def NumberOfPulses(self) -> int: ...
	"""The number of pulses for this beat duration"""

	@property
	def PulseDuration(self) -> int: ...
	"""This Beat duration"""

	pass

class QuartzTimeSignature(object):
	"""Quartz Time Signature"""

	@property
	def NumBeats(self) -> int: ...
	"""numerator"""

	@property
	def BeatType(self) -> int: ...
	"""denominator"""

	@property
	def OptionalPulseOverride(self) -> typing.List[QuartzPulseOverrideStep]: ...
	"""beat override"""

	pass

class QuartzTransportTimeStamp(object):
	"""Transport Time stamp, used for tracking the musical time stamp on a clock"""

	pass

class QuartzQuantizationBoundary(object):
	"""struct used to specify the quantization boundary of an event"""

	@property
	def Quantization(self) -> int: ...
	"""resolution we are interested in"""

	@property
	def Multiplier(self) -> float: ...
	"""how many 'Resolutions' to wait before the onset we care about"""

	@property
	def CountingReferencePoint(self) -> int: ...
	"""Counting Reference Point"""

	pass

class QuartzClockSettings(object):
	"""UStruct version of settings struct used to initialized a clock"""

	@property
	def TimeSignature(self) -> QuartzTimeSignature: ...
	"""Time Signature (defaults to 4/4)"""

	@property
	def bIgnoreLevelChange(self) -> bool: ...
	"""should the clock start Ticking"""

	pass

class AudioComponentParam(object):
	"""Struct used for storing one per-instance named parameter for this AudioComponent.
Certain nodes in the SoundCue may reference parameters by name so they can be adjusted per-instance."""

	@property
	def ParamName(self) -> str: ...
	"""Name of the parameter"""

	@property
	def FloatParam(self) -> float: ...
	"""Value of the parameter when used as a float"""

	@property
	def BoolParam(self) -> bool: ...
	"""Value of the parameter when used as a boolean"""

	@property
	def IntParam(self) -> int: ...
	"""Value of the parameter when used as an integer"""

	@property
	def SoundWaveParam(self) -> SoundWave: ...
	"""Value of the parameter when used as a sound wave"""

	pass

class ExponentialHeightFogData(object):
	"""Data for an individual fog line integral.
This is the data which is not shared between fogs when multiple fogs are set up on a single UExponentialHeightFogComponent"""

	@property
	def FogDensity(self) -> float: ...
	"""Global density factor for this fog."""

	@property
	def FogHeightFalloff(self) -> float: ...
	"""Height density factor, controls how the density increases as height decreases.
Smaller values make the visible transition larger."""

	@property
	def FogHeightOffset(self) -> float: ...
	"""Height offset, relative to the actor position Z."""

	pass

class ForceFeedbackAttenuationSettings(BaseAttenuationSettings):
	"""The struct for defining the properties used when determining attenuation for a force feedback effect"""

	pass

class InterpControlPoint(object):
	"""Interp Control Point"""

	@property
	def PositionControlPoint(self) -> Vector: ...
	"""The position of the point"""

	@property
	def bPositionIsRelative(self) -> bool: ...
	"""Is the location relative to the root components initial location"""

	pass

class LODMappingData(object):
	"""LODMapping Data"""

	@property
	def Mapping(self) -> typing.List[int]: ...
	"""Mapping"""

	@property
	def InverseMapping(self) -> typing.List[int]: ...
	"""Inverse Mapping"""

	pass

class ComponentSync(object):
	"""Component Sync"""

	@property
	def Name(self) -> str: ...
	"""Name"""

	@property
	def SyncOption(self) -> int: ...
	"""Sync Option"""

	pass

class MaterialSpriteElement(object):
	"""Material Sprite Element"""

	@property
	def Material(self) -> MaterialInterface: ...
	"""The material that the sprite is rendered with."""

	@property
	def DistanceToOpacityCurve(self) -> CurveFloat: ...
	"""A curve that maps distance on the X axis to the sprite opacity on the Y axis."""

	@property
	def bSizeIsInScreenSpace(self) -> bool: ...
	"""Whether the size is defined in screen-space or world-space."""

	@property
	def BaseSizeX(self) -> float: ...
	"""The base width of the sprite, multiplied with the DistanceToSizeCurve."""

	@property
	def BaseSizeY(self) -> float: ...
	"""The base height of the sprite, multiplied with the DistanceToSizeCurve."""

	@property
	def DistanceToSizeCurve(self) -> CurveFloat: ...
	"""A curve that maps distance on the X axis to the sprite size on the Y axis."""

	pass

class EngineShowFlagsSetting(object):
	"""Engine Show Flags Setting"""

	@property
	def ShowFlagName(self) -> str: ...
	"""Show Flag Name"""

	@property
	def Enabled(self) -> bool: ...
	"""Enabled"""

	pass

class TentDistribution(object):
	"""Tent Distribution"""

	@property
	def TipAltitude(self) -> float: ...
	"""Tip Altitude"""

	@property
	def TipValue(self) -> float: ...
	"""Tip Value"""

	@property
	def Width(self) -> float: ...
	"""Width"""

	pass

class SplinePoint(object):
	"""Spline Point"""

	@property
	def InputKey(self) -> float: ...
	"""Input Key"""

	@property
	def Position(self) -> Vector: ...
	"""Position"""

	@property
	def ArriveTangent(self) -> Vector: ...
	"""Arrive Tangent"""

	@property
	def LeaveTangent(self) -> Vector: ...
	"""Leave Tangent"""

	@property
	def Rotation(self) -> Rotator: ...
	"""Rotation"""

	@property
	def Scale(self) -> Vector: ...
	"""Scale"""

	@property
	def Type(self) -> int: ...
	"""Type"""

	pass

class EquirectProps(object):
	"""Properties for equirect layers"""

	@property
	def LeftUVRect(self) -> Box2D: ...
	"""Left source texture UVRect, specifying portion of input texture corresponding to left eye."""

	@property
	def RightUVRect(self) -> Box2D: ...
	"""Right source texture UVRect, specifying portion of input texture corresponding to right eye."""

	@property
	def LeftScale(self) -> Vector2D: ...
	"""Left eye's texture coordinate scale after mapping to 2D."""

	@property
	def RightScale(self) -> Vector2D: ...
	"""Right eye's texture coordinate scale after mapping to 2D."""

	@property
	def LeftBias(self) -> Vector2D: ...
	"""Left eye's texture coordinate bias after mapping to 2D."""

	@property
	def RightBias(self) -> Vector2D: ...
	"""Right eye's texture coordinate bias after mapping to 2D."""

	pass

class CanvasIcon(object):
	"""Holds texture information with UV coordinates as well."""

	@property
	def Texture(self) -> Texture: ...
	"""Source texture"""

	@property
	def U(self) -> float: ...
	"""UV coords"""

	@property
	def V(self) -> float: ...
	"""V"""

	@property
	def UL(self) -> float: ...
	"""UL"""

	@property
	def VL(self) -> float: ...
	"""VL"""

	pass

class UniqueNetIdRepl(UniqueNetIdWrapper):
	"""Wrapper for opaque type FUniqueNetId

Makes sure that the opaque aspects of FUniqueNetId are properly handled/serialized
over network RPC and actor replication"""

	pass

class MeshReductionSettings(object):
	"""Settings used to reduce a mesh."""

	@property
	def PercentTriangles(self) -> float: ...
	"""Percentage of triangles to keep. 1.0 = no reduction, 0.0 = no triangles."""

	@property
	def PercentVertices(self) -> float: ...
	"""Percentage of vertices to keep. 1.0 = no reduction, 0.0 = no vertices."""

	@property
	def MaxDeviation(self) -> float: ...
	"""The maximum distance in object space by which the reduced mesh may deviate from the original mesh."""

	@property
	def PixelError(self) -> float: ...
	"""The amount of error in pixels allowed for this LOD."""

	@property
	def WeldingThreshold(self) -> float: ...
	"""Threshold in object space at which vertices are welded together."""

	@property
	def HardAngleThreshold(self) -> float: ...
	"""Angle at which a hard edge is introduced between faces."""

	@property
	def BaseLODModel(self) -> int: ...
	"""Base LODModel"""

	@property
	def SilhouetteImportance(self) -> int: ...
	"""Higher values minimize change to border edges."""

	@property
	def TextureImportance(self) -> int: ...
	"""Higher values reduce texture stretching."""

	@property
	def ShadingImportance(self) -> int: ...
	"""Higher values try to preserve normals better."""

	@property
	def bRecalculateNormals(self) -> bool: ...
	"""Recalculate Normals"""

	@property
	def bGenerateUniqueLightmapUVs(self) -> bool: ...
	"""Generate Unique Lightmap UVs"""

	@property
	def bKeepSymmetry(self) -> bool: ...
	"""Keep Symmetry"""

	@property
	def bVisibilityAided(self) -> bool: ...
	"""Visibility Aided"""

	@property
	def bCullOccluded(self) -> bool: ...
	"""Cull Occluded"""

	@property
	def TerminationCriterion(self) -> int: ...
	"""The method to use when optimizing static mesh LODs"""

	@property
	def VisibilityAggressiveness(self) -> int: ...
	"""Higher values generates fewer samples"""

	@property
	def VertexColorImportance(self) -> int: ...
	"""Higher values minimize change to vertex color data."""

	pass

class MeshProxySettings(object):
	"""Mesh Proxy Settings"""

	@property
	def ScreenSize(self) -> int: ...
	"""Screen size of the resulting proxy mesh in pixels"""

	@property
	def VoxelSize(self) -> float: ...
	"""Override when converting multiple meshes for proxy LOD merging. Warning, large geometry with small sampling has very high memory costs"""

	@property
	def MaterialSettings(self) -> MaterialProxySettings: ...
	"""Material simplification"""

	@property
	def MergeDistance(self) -> float: ...
	"""Distance at which meshes should be merged together, this can close gaps like doors and windows in distant geometry"""

	@property
	def UnresolvedGeometryColor(self) -> Color: ...
	"""Base color assigned to LOD geometry that can't be associated with the source geometry: e.g. doors and windows that have been closed by the Merge Distance"""

	@property
	def MaxRayCastDist(self) -> float: ...
	"""Override search distance used when discovering texture values for simplified geometry. Useful when non-zero Merge Distance setting generates new geometry in concave corners."""

	@property
	def HardAngleThreshold(self) -> float: ...
	"""Angle at which a hard edge is introduced between faces"""

	@property
	def LightMapResolution(self) -> int: ...
	"""Lightmap resolution"""

	@property
	def NormalCalculationMethod(self) -> int: ...
	"""Controls the method used to calculate the normal for the simplified geometry"""

	@property
	def LandscapeCullingPrecision(self) -> int: ...
	"""Level of detail of the landscape that should be used for the culling"""

	@property
	def bCalculateCorrectLODModel(self) -> bool: ...
	"""Determines whether or not the correct LOD models should be calculated given the source meshes and transition size"""

	@property
	def bOverrideVoxelSize(self) -> bool: ...
	"""If true, Spatial Sampling Distance will not be automatically computed based on geometry and you must set it directly"""

	@property
	def bOverrideTransferDistance(self) -> bool: ...
	"""Enable an override for material transfer distance"""

	@property
	def bUseHardAngleThreshold(self) -> bool: ...
	"""Enable the use of hard angle based vertex splitting"""

	@property
	def bComputeLightMapResolution(self) -> bool: ...
	"""If ticked will compute the lightmap resolution by summing the dimensions for each mesh included for merging"""

	@property
	def bRecalculateNormals(self) -> bool: ...
	"""Whether Simplygon should recalculate normals, otherwise the normals channel will be sampled from the original mesh"""

	@property
	def bUseLandscapeCulling(self) -> bool: ...
	"""Whether or not to use available landscape geometry to cull away invisible triangles"""

	@property
	def bAllowAdjacency(self) -> bool: ...
	"""Whether to allow adjacency buffers for tessellation in the merged mesh"""

	@property
	def bAllowDistanceField(self) -> bool: ...
	"""Whether to allow distance field to be computed for this mesh. Disable this to save memory if the merged mesh will only be rendered in the distance."""

	@property
	def bReuseMeshLightmapUVs(self) -> bool: ...
	"""Whether to attempt to re-use the source mesh's lightmap UVs when baking the material or always generate a new set."""

	@property
	def bCreateCollision(self) -> bool: ...
	"""Whether to generate collision for the merged mesh"""

	@property
	def bAllowVertexColors(self) -> bool: ...
	"""Whether to allow vertex colors saved in the merged mesh"""

	@property
	def bGenerateLightmapUVs(self) -> bool: ...
	"""Whether to generate lightmap uvs for the merged mesh"""

	pass

class MeshMergingSettings(object):
	"""Mesh merging settings"""

	@property
	def TargetLightMapResolution(self) -> int: ...
	"""The lightmap resolution used both for generating lightmap UV coordinates, and also set on the generated static mesh"""

	@property
	def OutputUVs(self) -> typing.List[int]: ...
	"""Whether to output the specified UV channels into the merged mesh (only if the source meshes contain valid UVs for the specified channel)"""

	@property
	def MaterialSettings(self) -> MaterialProxySettings: ...
	"""Material simplification"""

	@property
	def GutterSize(self) -> int: ...
	"""The gutter (in texels) to add to each sub-chart for our baked-out material for the top mip level"""

	@property
	def SpecificLOD(self) -> int: ...
	"""A given LOD level to export from the source meshes"""

	@property
	def LODSelectionType(self) -> int: ...
	"""Which selection mode should be used when generating the merged static mesh"""

	@property
	def bGenerateLightMapUV(self) -> bool: ...
	"""Whether to generate lightmap UVs for a merged mesh"""

	@property
	def bComputedLightMapResolution(self) -> bool: ...
	"""Whether or not the lightmap resolution should be computed by summing the lightmap resolutions for the input Mesh Components"""

	@property
	def bPivotPointAtZero(self) -> bool: ...
	"""Whether merged mesh should have pivot at world origin, or at first merged component otherwise"""

	@property
	def bMergePhysicsData(self) -> bool: ...
	"""Whether to merge physics data (collision primitives)"""

	@property
	def bMergeMaterials(self) -> bool: ...
	"""Whether to merge source materials into one flat material, ONLY available when merging a single LOD level, see LODSelectionType"""

	@property
	def bCreateMergedMaterial(self) -> bool: ...
	"""Create a flat material from all source materials, along with a new set of UVs. This material won't be applied to any section by default."""

	@property
	def bBakeVertexDataToMesh(self) -> bool: ...
	"""Whether or not vertex data such as vertex colours should be baked into the resulting mesh"""

	@property
	def bUseVertexDataForBakingMaterial(self) -> bool: ...
	"""Whether or not vertex data such as vertex colours should be used when baking out materials"""

	@property
	def bUseTextureBinning(self) -> bool: ...
	"""Whether or not to calculate varying output texture sizes according to their importance in the final atlas texture"""

	@property
	def bReuseMeshLightmapUVs(self) -> bool: ...
	"""Whether to attempt to re-use the source mesh's lightmap UVs when baking the material or always generate a new set."""

	@property
	def bMergeEquivalentMaterials(self) -> bool: ...
	"""Whether to attempt to merge materials that are deemed equivalent. This can cause artifacts in the merged mesh if world position/actor position etc. is used to determine output color."""

	@property
	def bUseLandscapeCulling(self) -> bool: ...
	"""Whether or not to use available landscape geometry to cull away invisible triangles"""

	@property
	def bIncludeImposters(self) -> bool: ...
	"""Whether or not to include any imposter LODs that are part of the source static meshes"""

	@property
	def bAllowDistanceField(self) -> bool: ...
	"""Whether to allow distance field to be computed for this mesh. Disable this to save memory if the merged mesh will only be rendered in the distance."""

	pass

class MeshInstancingSettings(object):
	"""Mesh instance-replacement settings"""

	@property
	def ActorClassToUse(self) -> Actor: ...
	"""The actor class to attach new instance static mesh components to"""

	@property
	def InstanceReplacementThreshold(self) -> int: ...
	"""The number of static mesh instances needed before a mesh is replaced with an instanced version"""

	@property
	def MeshReplacementMethod(self) -> int: ...
	"""How to replace the original actors when instancing"""

	@property
	def bSkipMeshesWithVertexColors(self) -> bool: ...
	"""Whether to skip the conversion to an instanced static mesh for meshes with vertex colors.
Instanced static meshes do not support vertex colors per-instance, so conversion will lose
this data."""

	@property
	def bUseHLODVolumes(self) -> bool: ...
	"""Whether split up instanced static mesh components based on their intersection with HLOD volumes"""

	@property
	def ISMComponentToUse(self) -> InstancedStaticMeshComponent: ...
	"""Whether to use the Instanced Static Mesh Compoment or the Hierarchical Instanced Static Mesh Compoment"""

	pass

class ReverbSettings(object):
	"""Struct encapsulating settings for reverb effects."""

	@property
	def bApplyReverb(self) -> bool: ...
	"""Whether to apply the reverb settings below."""

	@property
	def ReverbEffect(self) -> ReverbEffect: ...
	"""The reverb asset to employ."""

	@property
	def ReverbPluginEffect(self) -> SoundEffectSubmixPreset: ...
	"""This is used to apply plugin-specific settings when a Reverb Plugin is being used."""

	@property
	def Volume(self) -> float: ...
	"""Volume level of the reverb affect."""

	@property
	def FadeTime(self) -> float: ...
	"""Time to fade from the current reverb settings into this setting, in seconds."""

	pass

class AudioVolumeSubmixSendSettings(object):
	"""Struct to determine dynamic submix send data for use with audio volumes."""

	@property
	def ListenerLocationState(self) -> int: ...
	"""The state the listener needs to be in, relative to the audio volume, for this submix send list to be used for a given sound"""

	@property
	def SubmixSends(self) -> typing.List[SoundSubmixSendInfo]: ...
	"""Submix send array for sounds that are outside the audio volume when the listener is inside the volume"""

	pass

class AudioVolumeSubmixOverrideSettings(object):
	"""Audio Volume Submix Override Settings"""

	@property
	def Submix(self) -> SoundSubmix: ...
	"""The submix to override the effect chain of"""

	@property
	def SubmixEffectChain(self) -> typing.List[SoundEffectSubmixPreset]: ...
	"""The submix effect chain to overrideac"""

	@property
	def CrossfadeTime(self) -> float: ...
	"""The amount of time to crossfade to the override for the submix chain"""

	pass

class CollisionProfileName(object):
	"""Structure representing a collision profile name, this gets a special UI in the editor"""

	@property
	def Name(self) -> str: ...
	"""Name"""

	pass

class CurveTableRowHandle(object):
	"""Handle to a particular row in a table."""

	@property
	def CurveTable(self) -> CurveTable: ...
	"""Pointer to table we want a row from"""

	@property
	def RowName(self) -> str: ...
	"""Name of row in the table that we want"""

	pass

class TableRowBase(object):
	"""Base class for all table row structs to inherit from."""

	pass

class DataTableRowHandle(object):
	"""Handle to a particular row in a table"""

	@property
	def DataTable(self) -> DataTable: ...
	"""Pointer to table we want a row from"""

	@property
	def RowName(self) -> str: ...
	"""Name of row in the table that we want"""

	pass

class DataTableCategoryHandle(object):
	"""Handle to a particular set of rows in a table"""

	@property
	def DataTable(self) -> DataTable: ...
	"""Pointer to table we want a row from"""

	@property
	def ColumnName(self) -> str: ...
	"""Name of column in the table that we want"""

	@property
	def RowContents(self) -> str: ...
	"""Contents of rows in the table that we want"""

	pass

class CullDistanceSizePair(object):
	"""Helper structure containing size and cull distance pair."""

	@property
	def Size(self) -> float: ...
	"""Size to associate with cull distance."""

	@property
	def CullDistance(self) -> float: ...
	"""Cull distance associated with size."""

	pass

class FloatRK4SpringInterpolator(object):
	"""Float RK4Spring Interpolator"""

	pass

class VectorRK4SpringInterpolator(object):
	"""Vector RK4Spring Interpolator"""

	pass

class StaticMaterial(object):
	"""Static Material"""

	@property
	def MaterialInterface(self) -> MaterialInterface: ...
	"""Material Interface"""

	@property
	def MaterialSlotName(self) -> str: ...
	"""This name should be use by the gameplay to avoid error if the skeletal mesh Materials array topology change"""

	@property
	def ImportedMaterialSlotName(self) -> str: ...
	"""This name should be use when we re-import a skeletal mesh so we can order the Materials array like it should be"""

	@property
	def UVChannelData(self) -> MeshUVChannelInfo: ...
	"""Data used for texture streaming relative to each UV channels."""

	pass

class SubsurfaceProfileStruct(object):
	"""struct with all the settings we want in USubsurfaceProfile, separate to make it easer to pass this data around in the engine."""

	@property
	def SurfaceAlbedo(self) -> LinearColor: ...
	"""It should match The base color of the corresponding material as much as possible."""

	@property
	def MeanFreePathColor(self) -> LinearColor: ...
	"""Controls how far light goes into the subsurface in the Red, Green and Blue channel. It is scaled by Mean Free path distance."""

	@property
	def MeanFreePathDistance(self) -> float: ...
	"""Subsurface mean free path distance in world/unreal units (cm)"""

	@property
	def WorldUnitScale(self) -> float: ...
	"""Control the scale of world/unreal units (cm)"""

	@property
	def bEnableBurley(self) -> bool: ...
	"""Effective only when Burley subsurface scattering is enabled in cmd."""

	@property
	def ScatterRadius(self) -> float: ...
	"""in world/unreal units (cm)"""

	@property
	def SubsurfaceColor(self) -> LinearColor: ...
	"""Specifies the how much of the diffuse light gets into the material,
can be seen as a per-channel mix factor between the original image,
and the SSS-filtered image (called 'strength' in SeparableSSS, default there: 0.48, 0.41, 0.28)"""

	@property
	def FalloffColor(self) -> LinearColor: ...
	"""defines the per-channel falloff of the gradients
produced by the subsurface scattering events, can be used to fine tune the color of the gradients
(called 'falloff' in SeparableSSS, default there: 1, 0.37, 0.3)"""

	@property
	def BoundaryColorBleed(self) -> LinearColor: ...
	"""Boundary Color Bleed"""

	@property
	def ExtinctionScale(self) -> float: ...
	"""Extinction Scale"""

	@property
	def NormalScale(self) -> float: ...
	"""Normal Scale"""

	@property
	def ScatteringDistribution(self) -> float: ...
	"""Scattering Distribution"""

	@property
	def IOR(self) -> float: ...
	"""IOR"""

	@property
	def Roughness0(self) -> float: ...
	"""Roughness 0"""

	@property
	def Roughness1(self) -> float: ...
	"""Roughness 1"""

	@property
	def LobeMix(self) -> float: ...
	"""Lobe Mix"""

	@property
	def TransmissionTintColor(self) -> LinearColor: ...
	"""Transmission tint control. It is multiplied on the transmission results. Works only when Burley is enabled."""

	pass

class FindFloorResult(object):
	"""Data about the floor for walking movement, used by CharacterMovementComponent."""

	@property
	def bBlockingHit(self) -> bool: ...
	"""True if there was a blocking hit in the floor test that was NOT in initial penetration.
The HitResult can give more info about other circumstances."""

	@property
	def bWalkableFloor(self) -> bool: ...
	"""True if the hit found a valid walkable floor."""

	@property
	def bLineTrace(self) -> bool: ...
	"""True if the hit found a valid walkable floor using a line trace (rather than a sweep test, which happens when the sweep test fails to yield a walkable surface)."""

	@property
	def FloorDist(self) -> float: ...
	"""The distance to the floor, computed from the swept capsule trace."""

	@property
	def LineDist(self) -> float: ...
	"""The distance to the floor, computed from the trace. Only valid if bLineTrace is true."""

	@property
	def HitResult(self) -> HitResult: ...
	"""Hit result of the test that found a floor. Includes more specific data about the point of impact and surface normal at that point."""

	pass

class InputActionKeyMapping(object):
	"""Defines a mapping between an action and key

@see https://docs.unrealengine.com/latest/INT/Gameplay/Input/index.html"""

	@property
	def ActionName(self) -> str: ...
	"""Friendly name of action, e.g 'jump'"""

	@property
	def bShift(self) -> bool: ...
	"""true if one of the Shift keys must be down when the KeyEvent is received to be acknowledged"""

	@property
	def bCtrl(self) -> bool: ...
	"""true if one of the Ctrl keys must be down when the KeyEvent is received to be acknowledged"""

	@property
	def bAlt(self) -> bool: ...
	"""true if one of the Alt keys must be down when the KeyEvent is received to be acknowledged"""

	@property
	def bCmd(self) -> bool: ...
	"""true if one of the Cmd keys must be down when the KeyEvent is received to be acknowledged"""

	@property
	def Key(self) -> Key: ...
	"""Key to bind it to."""

	pass

class InputAxisKeyMapping(object):
	"""Defines a mapping between an axis and key

@see https://docs.unrealengine.com/latest/INT/Gameplay/Input/index.html"""

	@property
	def AxisName(self) -> str: ...
	"""Friendly name of axis, e.g 'MoveForward'"""

	@property
	def Scale(self) -> float: ...
	"""Multiplier to use for the mapping when accumulating the axis value"""

	@property
	def Key(self) -> Key: ...
	"""Key to bind it to."""

	pass

class InputActionSpeechMapping(object):
	"""Defines a mapping between an action and speech recognition

@see https://docs.unrealengine.com/latest/INT/Gameplay/Input/index.html"""

	pass

class GenericStruct(object):
	"""Generic Struct"""

	@property
	def Data(self) -> int: ...
	"""Data"""

	pass

class DialogueContext(object):
	"""Dialogue Context"""

	@property
	def Speaker(self) -> DialogueVoice: ...
	"""The person speaking the dialogue."""

	@property
	def Targets(self) -> typing.List[DialogueVoice]: ...
	"""The people being spoken to."""

	pass

class PredictProjectilePathParams(object):
	"""Input parameters to PredictProjectilePath functions."""

	@property
	def StartLocation(self) -> Vector: ...
	"""Location of the start of the trace."""

	@property
	def LaunchVelocity(self) -> Vector: ...
	"""Initial launch velocity at the start of the trace."""

	@property
	def bTraceWithCollision(self) -> bool: ...
	"""Whether to trace along the path looking for blocking collision and stopping at the first hit."""

	@property
	def ProjectileRadius(self) -> float: ...
	"""Projectile radius, used when tracing for collision. If <= 0, a line trace is used instead."""

	@property
	def MaxSimTime(self) -> float: ...
	"""Maximum simulation time for the virtual projectile."""

	@property
	def bTraceWithChannel(self) -> bool: ...
	"""Whether or not to use TraceChannel, if tracing with collision."""

	@property
	def TraceChannel(self) -> int: ...
	"""Trace channel to use, if tracing with collision."""

	@property
	def ObjectTypes(self) -> typing.List[int]: ...
	"""Object type to use, if tracing with collision."""

	@property
	def ActorsToIgnore(self) -> typing.List[Actor]: ...
	"""Actors to ignore when tracing with collision."""

	@property
	def SimFrequency(self) -> float: ...
	"""Determines size of each sub-step in the simulation (chopping up MaxSimTime). Recommended between 10 to 30 depending on desired quality versus performance."""

	@property
	def OverrideGravityZ(self) -> float: ...
	"""Optional override of Gravity (if 0, uses WorldGravityZ)."""

	@property
	def DrawDebugType(self) -> int: ...
	"""Debug drawing duration option."""

	@property
	def DrawDebugTime(self) -> float: ...
	"""Duration of debug lines (only relevant for DrawDebugType::Duration)"""

	@property
	def bTraceComplex(self) -> bool: ...
	"""Trace against complex collision (triangles rather than simple primitives) if tracing with collision."""

	pass

class PredictProjectilePathPointData(object):
	"""Data about a single point in a projectile path trace."""

	@property
	def Location(self) -> Vector: ...
	"""Location of this point"""

	@property
	def Velocity(self) -> Vector: ...
	"""Velocity at this point"""

	@property
	def Time(self) -> float: ...
	"""Elapsed time at this point from the start of the trace."""

	pass

class PredictProjectilePathResult(object):
	"""Container for the result of a projectile path trace (using PredictProjectilePath)."""

	@property
	def PathData(self) -> typing.List[PredictProjectilePathPointData]: ...
	"""Info for each point on the path."""

	@property
	def LastTraceDestination(self) -> PredictProjectilePathPointData: ...
	"""Info on the last point we tried to trace to, which may have been beyond the final hit."""

	@property
	def HitResult(self) -> HitResult: ...
	"""Hit along the trace, if tracing with collision was enabled."""

	pass

class ImportanceTexture(object):
	"""Texture processed for importance sampling
Holds marginal PDF of the rows, as well as the PDF of each row"""

	@property
	def Size(self) -> IntPoint: ...
	"""active texture dimensions, capped to 1024 x 1024"""

	@property
	def NumMips(self) -> int: ...
	"""active number of MIP levels"""

	@property
	def MarginalCDF(self) -> typing.List[float]: ...
	"""Unnormalized cumulative density of the image by rows (Size.Y+1)
First entry is zero, final entry is the CDF normalization factor"""

	@property
	def ConditionalCDF(self) -> typing.List[float]: ...
	"""Unnormalized cumulative probability of each pixel in a row (Size.Y row CDFs of Size.X+1)
First entry of each row is zero, final entry in each row is the CDF normalization factor for that row"""

	@property
	def TextureData(self) -> typing.List[Color]: ...
	"""packed copy of MIP level data for filtered sampling (capped to 1024x1024)
local copy seems better than allocating and copying the same data temporarily for each sample"""

	@property
	def Texture(self) -> Texture2D: ...
	"""Original texture object for Break function"""

	@property
	def Weighting(self) -> int: ...
	"""Original importance weight for Break function"""

	pass

class FloatSpringState(object):
	"""Float Spring State"""

	pass

class VectorSpringState(object):
	"""Vector Spring State"""

	pass

class DrawToRenderTargetContext(object):
	"""Draw to Render Target Context"""

	@property
	def RenderTarget(self) -> TextureRenderTarget2D: ...
	"""Render Target"""

	pass

class FormatArgumentData(object):
	"""Used to pass argument/value pairs into FText::Format.
The full C++ struct is located here: Engine/Source/Runtime/Core/Public/Internationalization/Text.h"""

	@property
	def ArgumentName(self) -> str: ...
	"""Argument Name"""

	@property
	def ArgumentValueType(self) -> int: ...
	"""Argument Value Type"""

	@property
	def ArgumentValue(self) -> str: ...
	"""Argument Value"""

	@property
	def ArgumentValueInt(self) -> int: ...
	"""Argument Value Int"""

	@property
	def ArgumentValueFloat(self) -> float: ...
	"""Argument Value Float"""

	@property
	def ArgumentValueGender(self) -> int: ...
	"""Argument Value Gender"""

	pass

class ScalarParameterValue(object):
	"""Scalar Parameter Value"""

	@property
	def ParameterInfo(self) -> MaterialParameterInfo: ...
	"""Parameter Info"""

	@property
	def ParameterValue(self) -> float: ...
	"""Parameter Value"""

	@property
	def ExpressionGUID(self) -> Guid: ...
	"""Expression GUID"""

	pass

class VectorParameterValue(object):
	"""Editable vector parameter."""

	@property
	def ParameterInfo(self) -> MaterialParameterInfo: ...
	"""Parameter Info"""

	@property
	def ParameterValue(self) -> LinearColor: ...
	"""Parameter Value"""

	@property
	def ExpressionGUID(self) -> Guid: ...
	"""Expression GUID"""

	pass

class TextureParameterValue(object):
	"""Editable texture parameter."""

	@property
	def ParameterInfo(self) -> MaterialParameterInfo: ...
	"""Parameter Info"""

	@property
	def ParameterValue(self) -> Texture: ...
	"""Parameter Value"""

	@property
	def ExpressionGUID(self) -> Guid: ...
	"""Expression GUID"""

	pass

class RuntimeVirtualTextureParameterValue(object):
	"""Editable runtime virtual texture parameter."""

	@property
	def ParameterInfo(self) -> MaterialParameterInfo: ...
	"""Parameter Info"""

	@property
	def ParameterValue(self) -> RuntimeVirtualTexture: ...
	"""Parameter Value"""

	@property
	def ExpressionGUID(self) -> Guid: ...
	"""Expression GUID"""

	pass

class FontParameterValue(object):
	"""Editable font parameter."""

	@property
	def ParameterInfo(self) -> MaterialParameterInfo: ...
	"""Parameter Info"""

	@property
	def FontValue(self) -> Font: ...
	"""Font Value"""

	@property
	def FontPage(self) -> int: ...
	"""Font Page"""

	@property
	def ExpressionGUID(self) -> Guid: ...
	"""Expression GUID"""

	pass

class ParticleSysParam(object):
	"""Struct used for a particular named instance parameter for this ParticleSystemComponent."""

	@property
	def Name(self) -> str: ...
	"""The name of the parameter"""

	@property
	def ParamType(self) -> int: ...
	"""The type of parameters
PSPT_None       - There is no data type
PSPT_Scalar     - Use the scalar value
PSPT_ScalarRand - Select a scalar value in the range [Scalar_Low..Scalar)
PSPT_Vector     - Use the vector value
PSPT_VectorRand - Select a vector value in the range [Vector_Low..Vector)
PSPT_Color      - Use the color value
PSPT_Actor      - Use the actor value
PSPT_Material   - Use the material value
PSPT_VectorUnitRand - Select a random unit vector and scale along the range [Vector_Low..Vector)"""

	@property
	def Scalar(self) -> float: ...
	"""Scalar"""

	@property
	def Scalar_Low(self) -> float: ...
	"""Scalar Low"""

	@property
	def Vector(self) -> Vector: ...
	"""Vector"""

	@property
	def Vector_Low(self) -> Vector: ...
	"""Vector Low"""

	@property
	def Color(self) -> Color: ...
	"""Color"""

	@property
	def Actor(self) -> Actor: ...
	"""Actor"""

	@property
	def Material(self) -> MaterialInterface: ...
	"""Material"""

	pass

class PassiveSoundMixModifier(object):
	"""Structure containing information on a SoundMix to activate passively."""

	@property
	def SoundMix(self) -> SoundMix: ...
	"""The SoundMix to activate"""

	@property
	def MinVolumeThreshold(self) -> float: ...
	"""Minimum volume level required to activate SoundMix. Below this value the SoundMix will not be active."""

	@property
	def MaxVolumeThreshold(self) -> float: ...
	"""Maximum volume level required to activate SoundMix. Above this value the SoundMix will not be active."""

	pass

class SourceEffectChainEntry(object):
	"""Source Effect Chain Entry"""

	@property
	def Preset(self) -> SoundEffectSourcePreset: ...
	"""Preset"""

	@property
	def bBypass(self) -> bool: ...
	"""Bypass"""

	pass

class SoundClassAdjuster(object):
	"""Elements of data for sound group volume control"""

	@property
	def SoundClassObject(self) -> SoundClass: ...
	"""The sound class this adjuster affects."""

	@property
	def VolumeAdjuster(self) -> float: ...
	"""A multiplier applied to the volume."""

	@property
	def PitchAdjuster(self) -> float: ...
	"""A multiplier applied to the pitch."""

	@property
	def LowPassFilterFrequency(self) -> float: ...
	"""Lowpass filter cutoff frequency to apply to sound sources."""

	@property
	def bApplyToChildren(self) -> bool: ...
	"""Set to true to apply this adjuster to all children of the sound class."""

	@property
	def VoiceCenterChannelVolumeAdjuster(self) -> float: ...
	"""A multiplier applied to VoiceCenterChannelVolume."""

	pass

class AnimNode_SingleNode(AnimNode_Base):
	"""Local anim node for extensible processing.
Cant be used outside of this context as it has no graph node counterpart"""

	@property
	def SourcePose(self) -> PoseLink: ...
	"""Source Pose"""

	pass

class CachedAnimStateData(object):
	"""This file contains a number of helper structures that can be used to process state-machine-
related data in C++. This includes relevancy, state weights, animation time etc."""

	@property
	def StateMachineName(self) -> str: ...
	"""Name of StateMachine State is in"""

	@property
	def StateName(self) -> str: ...
	"""Name of State to Cache"""

	pass

class CachedAnimStateArray(object):
	"""Cached Anim State Array"""

	@property
	def States(self) -> typing.List[CachedAnimStateData]: ...
	"""Array of states"""

	pass

class CachedAnimAssetPlayerData(object):
	"""Cached Anim Asset Player Data"""

	@property
	def StateMachineName(self) -> str: ...
	"""Name of StateMachine State is in"""

	@property
	def StateName(self) -> str: ...
	"""Name of State to Cache"""

	pass

class CachedAnimRelevancyData(object):
	"""Cached Anim Relevancy Data"""

	@property
	def StateMachineName(self) -> str: ...
	"""Name of StateMachine State is in"""

	@property
	def StateName(self) -> str: ...
	"""Name of State to Cache"""

	pass

class CachedAnimTransitionData(object):
	"""Cached Anim Transition Data"""

	@property
	def StateMachineName(self) -> str: ...
	"""Name of StateMachine State is in"""

	@property
	def FromStateName(self) -> str: ...
	"""Name of From State to Cache"""

	@property
	def ToStateName(self) -> str: ...
	"""Name of To State to Cache"""

	pass

class VoiceSettings(object):
	"""Voice Settings"""

	@property
	def ComponentToAttachTo(self) -> SceneComponent: ...
	"""Optionally attach the voice source to a Scene Component to give the appearance
that the voice is coming from that scene component.
If this is not set, the voice will not be spatialized."""

	@property
	def AttenuationSettings(self) -> SoundAttenuation: ...
	"""Optional attenuation settings to attach to this player's voice.
This should only be used when ComponentToAttachTo is set."""

	@property
	def SourceEffectChain(self) -> SoundEffectSourcePresetChain: ...
	"""Optional audio effects to apply to this player's voice."""

	pass

class SceneViewExtensionIsActiveFunctor(object):
	"""Contains the TFunction that determines if a scene view extension should be valid in the given context given for the current frame.
It also contains Guid to help identify it, given that we can't directly compare TFunctions."""

	pass

class AvoidanceManager(Object):
	"""Avoidance Manager"""

	@property
	def DefaultTimeToLive(self) -> float: ...
	"""How long an avoidance UID must not be updated before the system will put it back in the pool. Actual delay is up to 150% of this value."""

	@property
	def LockTimeAfterAvoid(self) -> float: ...
	"""How long to stay on course (barring collision) after making an avoidance move"""

	@property
	def LockTimeAfterClean(self) -> float: ...
	"""How long to stay on course (barring collision) after making an unobstructed move (should be > 0.0, but can be less than a full frame)"""

	@property
	def DeltaTimeToPredict(self) -> float: ...
	"""This is how far forward in time (seconds) we extend our velocity cones and thus our prediction"""

	@property
	def ArtificialRadiusExpansion(self) -> float: ...
	"""Multiply the radius of all STORED avoidance objects by this value to allow a little extra room for avoidance maneuvers."""

	@property
	def HeightCheckMargin(self) -> float: ...
	"""Allowable height margin between obstacles and agents. This is over and above the difference in agent heights."""

	def GetAvoidanceVelocityForComponent(self, MovementComp: MovementComponent) -> Vector: ...
	"""Calculate avoidance velocity for component (avoids collisions with the supplied component)"""

	def RegisterMovementComponent(self, MovementComp: MovementComponent, AvoidanceWeight: float = ...) -> bool: ...
	"""Register with the given avoidance manager.
@param AvoidanceWeight      When avoiding each other, actors divert course in proportion to their relative weights. Range is 0.0 to 1.0. Special: at 1.0, actor will not divert course at all."""

	def GetNewAvoidanceUID(self) -> int: ...
	"""Get appropriate UID for use when reporting to this function or requesting RVO assistance."""

	def GetObjectCount(self) -> int: ...
	"""Get the number of avoidance objects currently in the manager."""

	pass

class NavLinkDefinition(Object):
	"""Class containing definition of a navigation area"""

	@property
	def Links(self) -> typing.List[NavigationLink]: ...
	"""Links"""

	@property
	def SegmentLinks(self) -> typing.List[NavigationSegmentLink]: ...
	"""Segment Links"""

	pass

class AnimationAsset(Object):
	"""Animation Asset"""

	def GetSkeleton(self) -> Skeleton: ...

	def SetSkeleton(self, NewSkeleton: Skeleton) -> None: ...

	pass

class BlendSpaceBase(AnimationAsset):
	"""Allows multiple animations to be blended between based on input parameters"""

	@property
	def bRotationBlendInMeshSpace(self) -> bool: ...
	"""When you use blend per bone, allows rotation to blend in mesh space. This only works if this does not contain additive animation samples
This is more performance intensive"""

	@property
	def AnimLength(self) -> float: ...
	"""This animation length changes based on current input (resulting in different blend time)*"""

	@property
	def InterpolationParam(self) -> typing.List[unsupported]: ...
	"""Input interpolation parameter for all 3 axis, for each axis input, decide how you'd like to interpolate input to"""

	@property
	def TargetWeightInterpolationSpeedPerSec(self) -> float: ...
	"""Target weight interpolation. When target samples are set, how fast you'd like to get to target. Improve target blending.
i.e. for locomotion, if you interpolate input, when you move from left to right rapidly, you'll interpolate through forward, but if you use target weight interpolation,
you'll skip forward, but interpolate between left to right"""

	@property
	def NotifyTriggerMode(self) -> int: ...
	"""The current mode used by the blendspace to decide which animation notifies to fire. Valid options are:
      - AllAnimations - All notify events will fire
      - HighestWeightedAnimation - Notify events will only fire from the highest weighted animation
      - None - No notify events will fire from any animations"""

	pass

class BlendSpace(BlendSpaceBase):
	"""Contains a grid of data points with weights from sample points in the space"""

	pass

class AimOffsetBlendSpace(BlendSpace):
	"""Aim Offset Blend Space"""

	pass

class BlendSpace1D(BlendSpaceBase):
	"""Blend Space 1D"""

	@property
	def bScaleAnimation(self) -> bool: ...
	"""Drive animation speed by blend input position *"""

	pass

class AimOffsetBlendSpace1D(BlendSpace1D):
	"""Aim Offset Blend Space 1D"""

	pass

class BlueprintCore(Object):
	"""Blueprint Core"""

	@property
	def SkeletonGeneratedClass(self) -> Object: ...
	"""Pointer to the skeleton class; this is regenerated any time a member variable or function is added but
      is usually incomplete (no code or hidden autogenerated variables are added to it)"""

	@property
	def GeneratedClass(self) -> Object: ...
	"""Pointer to the 'most recent' fully generated class"""

	@property
	def bLegacyNeedToPurgeSkelRefs(self) -> bool: ...
	"""BackCompat:  Whether or not we need to purge references in this blueprint to the skeleton generated during compile-on-load"""

	pass

class Blueprint(BlueprintCore):
	"""Blueprints are special assets that provide an intuitive, node-based interface that can be used to create new types of Actors
and script level events; giving designers and gameplay programmers the tools to quickly create and iterate gameplay from
within Unreal Editor without ever needing to write a line of code."""

	@property
	def ParentClass(self) -> Object: ...
	"""Pointer to the parent class that the generated class should derive from. This *can* be null under rare circumstances,
one such case can be created by creating a blueprint (A) based on another blueprint (B), shutting down the editor, and
deleting the parent blueprint. Exported as Alphabetical in GetAssetRegistryTags"""

	@property
	def BlueprintType(self) -> int: ...
	"""The type of this blueprint"""

	@property
	def bRecompileOnLoad(self) -> bool: ...
	"""Whether or not this blueprint should recompile itself on load"""

	@property
	def bHasBeenRegenerated(self) -> bool: ...
	"""When the class generated by this blueprint is loaded, it will be recompiled the first time.  After that initial recompile, subsequent loads will skip the regeneration step"""

	@property
	def bIsRegeneratingOnLoad(self) -> bool: ...
	"""State flag to indicate whether or not the Blueprint is currently being regenerated on load"""

	@property
	def BlueprintSystemVersion(self) -> int: ...
	"""The version of the blueprint system that was used to  create this blueprint"""

	@property
	def SimpleConstructionScript(self) -> typing.Any: ...
	"""'Simple' construction script - graph of components to instance"""

	@property
	def ComponentTemplates(self) -> typing.List[ActorComponent]: ...
	"""Array of component template objects, used by AddComponent function"""

	@property
	def Timelines(self) -> typing.List[TimelineTemplate]: ...
	"""Array of templates for timelines that should be created"""

	@property
	def ComponentClassOverrides(self) -> typing.List[unsupported]: ...
	"""Array of blueprint overrides of component classes in parent classes"""

	@property
	def InheritableComponentHandler(self) -> typing.Any: ...
	"""Stores data to override (in children classes) components (created by SCS) from parent classes"""

	pass

class AnimBlueprint(Blueprint):
	"""An Anim Blueprint is essentially a specialized Blueprint whose graphs control the animation of a Skeletal Mesh.
It can perform blending of animations, directly control the bones of the skeleton, and output a final pose
for a Skeletal Mesh each frame."""

	@property
	def TargetSkeleton(self) -> typing.Any: ...
	"""This is the target skeleton asset for anim instances created from this blueprint; all animations
referenced by the BP should be compatible with this skeleton.  For advanced use only, it is easy
to cause errors if this is modified without updating or replacing all referenced animations."""

	@property
	def Groups(self) -> typing.List[unsupported]: ...
	"""List of animation sync groups"""

	@property
	def bUseMultiThreadedAnimationUpdate(self) -> bool: ...
	"""Allows this anim Blueprint to update its native update, blend tree, montages and asset players on
a worker thread. The compiler will attempt to pick up any issues that may occur with threaded update.
For updates to run in multiple threads both this flag and the project setting 'Allow Multi Threaded
Animation Update' should be set."""

	@property
	def bWarnAboutBlueprintUsage(self) -> bool: ...
	"""Selecting this option will cause the compiler to emit warnings whenever a call into Blueprint
is made from the animation graph. This can help track down optimizations that need to be made."""

	pass

class AnimSequenceBase(AnimationAsset):
	"""Anim Sequence Base"""

	@property
	def Notifies(self) -> typing.List[AnimNotifyEvent]: ...
	"""Animation notifies, sorted by time (earliest notification first)."""

	@property
	def SequenceLength(self) -> float: ...
	"""Length (in seconds) of this AnimSequence if played back with a speed of 1.0."""

	@property
	def RateScale(self) -> float: ...
	"""Number for tweaking playback rate of this animation globally."""

	@property
	def RawCurveData(self) -> typing.Any: ...
	"""Raw uncompressed float curve data"""

	def GetPlayLength(self) -> float: ...
	"""Returns the total play length of the montage, if played back with a speed of 1.0."""

	pass

class AnimCompositeBase(AnimSequenceBase):
	"""Anim Composite Base"""

	pass

class AnimComposite(AnimCompositeBase):
	"""Anim Composite"""

	@property
	def AnimationTrack(self) -> typing.Any: ...
	"""Serializable data that stores section/anim pairing *"""

	pass

class BoneMaskFilter(Object):
	"""Bone Mask Filter"""

	@property
	def BlendPoses(self) -> typing.List[unsupported]: ...
	"""Blend Poses"""

	pass

class AnimInstance(Object):
	"""Anim Instance"""

	@property
	def CurrentSkeleton(self) -> typing.Any: ...
	"""This is used to extract animation. If Mesh exists, this will be overwritten by Mesh->Skeleton"""

	@property
	def RootMotionMode(self) -> int: ...
	"""Sets where this blueprint pulls Root Motion from"""

	@property
	def bUseMultiThreadedAnimationUpdate(self) -> bool: ...
	"""Allows this anim instance to update its native update, blend tree, montages and asset players on
a worker thread. This flag is propagated from the UAnimBlueprint to this instance by the compiler.
The compiler will attempt to pick up any issues that may occur with threaded update.
For updates to run in multiple threads both this flag and the project setting 'Allow Multi Threaded
Animation Update' should be set."""

	@property
	def bUsingCopyPoseFromMesh(self) -> bool: ...
	"""If this AnimInstance has nodes using 'CopyPoseFromMesh' this will be true."""

	@property
	def bReceiveNotifiesFromLinkedInstances(self) -> bool: ...
	"""Whether to process notifies from any linked anim instances"""

	@property
	def bPropagateNotifiesToLinkedInstances(self) -> bool: ...
	"""Whether to propagate notifies to any linked anim instances"""

	@property
	def OnMontageBlendingOut(self) -> typing.Any: ...
	"""Called when a montage starts blending out, whether interrupted or finished"""

	@property
	def OnMontageStarted(self) -> typing.Any: ...
	"""Called when a montage has started"""

	@property
	def OnMontageEnded(self) -> typing.Any: ...
	"""Called when a montage has ended, whether interrupted or finished"""

	@property
	def OnAllMontageInstancesEnded(self) -> typing.Any: ...
	"""Called when all Montage instances have ended."""

	@property
	def NotifyQueue(self) -> typing.Any: ...
	"""Animation Notifies that has been triggered in the latest tick *"""

	@property
	def ActiveAnimNotifyState(self) -> typing.List[AnimNotifyEvent]: ...
	"""Currently Active AnimNotifyState, stored as a copy of the event as we need to
              call NotifyEnd on the event after a deletion in the editor. After this the event
              is removed correctly."""

	def ResetDynamics(self, InTeleportType: int): ...
	"""Reset any dynamics running simulation-style updates (e.g. on teleport, time skip etc.)"""

	def GetSyncGroupPosition(self, InSyncGroupName: str) -> MarkerSyncAnimPosition: ...
	"""Get Sync Group Position"""

	def IsSyncGroupBetweenMarkers(self, InSyncGroupName: str, PreviousMarker: str, NextMarker: str, bRespectMarkerOrder: bool = ...) -> bool: ...
	"""Is Sync Group Between Markers"""

	def HasMarkerBeenHitThisFrame(self, SyncGroup: str, MarkerName: str) -> bool: ...
	"""Has Marker Been Hit This Frame"""

	def GetTimeToClosestMarker(self, SyncGroup: str, MarkerName: str) -> typing.Tuple[bool, float]: ...
	"""--- AI communication end ---"""

	def CalculateDirection(self, Velocity: Vector, BaseRotation: Rotator) -> float: ...
	"""Returns degree of the angle betwee velocity and Rotation forward vector
The range of return will be from [-180, 180], and this can be used to feed blendspace directional value"""

	def ClearMorphTargets(self): ...
	"""Clears the current morph targets."""

	def SetMorphTarget(self, MorphTargetName: str, Value: float): ...
	"""Sets a morph target to a certain weight."""

	def GetCurrentStateName(self, MachineIndex: int) -> str: ...
	"""Returns the name of a currently active state in a state machine."""

	def GetAllCurveNames(self) -> typing.List[str]: ...
	"""This returns all curve names"""

	def GetActiveCurveNames(self, CurveType: int) -> typing.List[str]: ...
	"""This returns last up-to-date list of active curve names"""

	def GetCurveValue(self, CurveName: str) -> float: ...
	"""Returns the value of a named curve."""

	def GetRelevantAnimTimeFraction(self, MachineIndex: int, StateIndex: int) -> float: ...
	"""Get the current accumulated time as a fraction of the length of the most relevant animation in the source state"""

	def GetRelevantAnimTime(self, MachineIndex: int, StateIndex: int) -> float: ...
	"""Get the current accumulated time in seconds for the most relevant animation in the source state"""

	def GetRelevantAnimLength(self, MachineIndex: int, StateIndex: int) -> float: ...
	"""Get the length in seconds of the most relevant animation in the source state"""

	def GetRelevantAnimTimeRemainingFraction(self, MachineIndex: int, StateIndex: int) -> float: ...
	"""Get the time remaining as a fraction of the duration for the most relevant animation in the source state"""

	def GetRelevantAnimTimeRemaining(self, MachineIndex: int, StateIndex: int) -> float: ...
	"""Get the time remaining in seconds for the most relevant animation in the source state"""

	def GetInstanceTransitionTimeElapsedFraction(self, MachineIndex: int, TransitionIndex: int) -> float: ...
	"""Get the elapsed time as a fraction of the crossfade duration of a specified transition"""

	def GetInstanceTransitionTimeElapsed(self, MachineIndex: int, TransitionIndex: int) -> float: ...
	"""Get the elapsed time in seconds of a specified transition"""

	def GetInstanceTransitionCrossfadeDuration(self, MachineIndex: int, TransitionIndex: int) -> float: ...
	"""Get the crossfade duration of a specified transition"""

	def GetInstanceCurrentStateElapsedTime(self, MachineIndex: int) -> float: ...
	"""Get the current elapsed time of a state within the specified state machine"""

	def GetInstanceStateWeight(self, MachineIndex: int, StateIndex: int) -> float: ...
	"""Get the blend weight of a specified state"""

	def GetInstanceMachineWeight(self, MachineIndex: int) -> float: ...
	"""Get the blend weight of a specified state machine"""

	def GetInstanceAssetPlayerTimeFromEndFraction(self, AssetPlayerIndex: int) -> float: ...
	"""Get the time as a fraction of the asset length of an animation in an asset player node"""

	def GetInstanceAssetPlayerTimeFromEnd(self, AssetPlayerIndex: int) -> float: ...
	"""Get the time in seconds from the end of an animation in an asset player node"""

	def GetInstanceAssetPlayerTimeFraction(self, AssetPlayerIndex: int) -> float: ...
	"""Get the current accumulated time as a fraction for an asset player node"""

	def GetInstanceAssetPlayerTime(self, AssetPlayerIndex: int) -> float: ...
	"""Get the current accumulated time in seconds for an asset player node"""

	def GetInstanceAssetPlayerLength(self, AssetPlayerIndex: int) -> float: ...
	"""Gets the length in seconds of the asset referenced in an asset player node"""

	def SetRootMotionMode(self, Value: int): ...
	"""Set RootMotionMode"""

	def GetLinkedAnimLayerInstanceByClass(self, InClass: AnimInstance) -> AnimInstance: ...
	"""Gets the first layer linked instance corresponding to the specified class"""

	def GetLinkedAnimLayerInstanceByGroupAndClass(self, InGroup: str, InClass: AnimInstance) -> AnimInstance: ...
	"""Gets layer linked instance that matches group and class"""

	def GetLinkedAnimLayerInstancesByGroup(self, InGroup: str) -> typing.List[AnimInstance]: ...
	"""Runs through all nodes, attempting to find all distinct layer linked instances in the group"""

	def GetLinkedAnimLayerInstanceByGroup(self, InGroup: str) -> AnimInstance: ...
	"""Gets the layer linked instance corresponding to the specified group"""

	def UnlinkAnimClassLayers(self, InClass: AnimInstance): ...
	"""Runs through all layer nodes, attempting to find layer nodes that are currently running the specified class, then resets each to its default value.
State sharing rules are as with SetLayerOverlay.
If InClass is null, does nothing."""

	def LinkAnimClassLayers(self, InClass: AnimInstance): ...
	"""Runs through all layer nodes, attempting to find layer nodes that are implemented by the specified class, then sets up a linked instance of the class for each.
Allocates one linked instance to run each of the groups specified in the class, so state is shared. If a layer is not grouped (ie. NAME_None), then state is not shared
and a separate linked instance is allocated for each layer node.
If InClass is null, then all layers are reset to their defaults."""

	def LinkAnimGraphByTag(self, InTag: str, InClass: AnimInstance): ...
	"""Runs through all nodes, attempting to find a linked instance by name/tag, then sets the class of each node if the tag matches"""

	def GetLinkedAnimGraphInstancesByTag(self, InTag: str) -> typing.List[AnimInstance]: ...
	"""Runs through all nodes, attempting to find all linked instances that match the name/tag"""

	def GetLinkedAnimGraphInstanceByTag(self, InTag: str) -> AnimInstance: ...
	"""Runs through all nodes, attempting to find the first linked instance by name/tag"""

	def GetCurrentActiveMontage(self) -> AnimMontage: ...
	"""Get a current Active Montage in this AnimInstance.
              Note that there might be multiple Active at the same time. This will only return the first active one it finds. *"""

	def IsAnyMontagePlaying(self) -> bool: ...
	"""Returns true if any montage is playing currently. Doesn't mean it's active though, it could be blending out."""

	def Montage_GetPlayRate(self, Montage: AnimMontage) -> float: ...
	"""Get PlayRate for Montage.
      If Montage reference is NULL, PlayRate for any Active Montage will be returned.
      If Montage is not playing, 0 is returned."""

	def Montage_GetBlendTime(self, Montage: AnimMontage) -> float: ...
	"""Get the current blend time of the Montage.
      If Montage reference is NULL, it will return the current blend time on the first active Montage found."""

	def Montage_GetIsStopped(self, Montage: AnimMontage) -> bool: ...
	"""return true if Montage is not currently active. (not valid or blending out)"""

	def Montage_SetPosition(self, Montage: AnimMontage, NewPosition: float): ...
	"""Set position."""

	def Montage_GetPosition(self, Montage: AnimMontage) -> float: ...
	"""Get Current Montage Position"""

	def Montage_GetCurrentSection(self, Montage: AnimMontage = ...) -> str: ...
	"""Returns the name of the current animation montage section."""

	def Montage_IsPlaying(self, Montage: AnimMontage) -> bool: ...
	"""Returns true if the animation montage is currently active and playing.
      If reference is NULL, it will return true is ANY montage is currently active and playing."""

	def Montage_IsActive(self, Montage: AnimMontage) -> bool: ...
	"""Returns true if the animation montage is active. If the Montage reference is NULL, it will return true if any Montage is active."""

	def Montage_SetPlayRate(self, Montage: AnimMontage, NewPlayRate: float = ...): ...
	"""Change AnimMontage play rate. NewPlayRate = 1.0 is the default playback rate."""

	def Montage_SetNextSection(self, SectionNameToChange: str, NextSection: str, Montage: AnimMontage = ...): ...
	"""Relink new next section AFTER SectionNameToChange in run-time
    You can link section order the way you like in editor, but in run-time if you'd like to change it dynamically,
    use this function to relink the next section
    For example, you can have Start->Loop->Loop->Loop.... but when you want it to end, you can relink
    next section of Loop to be End to finish the montage, in which case, it stops looping by Loop->End.

@param SectionNameToChange : This should be the name of the Montage Section after which you want to insert a new next section
@param NextSection   : new next section"""

	def Montage_JumpToSectionsEnd(self, SectionName: str, Montage: AnimMontage = ...): ...
	"""Makes a montage jump to the end of a named section. If Montage reference is NULL, it will do that to all active montages."""

	def Montage_JumpToSection(self, SectionName: str, Montage: AnimMontage = ...): ...
	"""Makes a montage jump to a named section. If Montage reference is NULL, it will do that to all active montages."""

	def Montage_Resume(self, Montage: AnimMontage): ...
	"""Resumes a paused animation montage. If reference is NULL, it will resume ALL active montages."""

	def Montage_Pause(self, Montage: AnimMontage = ...): ...
	"""Pauses the animation montage. If reference is NULL, it will pause ALL active montages."""

	def Montage_StopGroupByName(self, InBlendOutTime: float, GroupName: str): ...
	"""Stops all active montages belonging to a group."""

	def Montage_Stop(self, InBlendOutTime: float, Montage: AnimMontage = ...): ...
	"""Stops the animation montage. If reference is NULL, it will stop ALL active montages."""

	def Montage_Play(self, MontageToPlay: AnimMontage, InPlayRate: float = ..., ReturnValueType: int = ..., InTimeToStartMontageAt: float = ..., bStopAllMontages: bool = ...) -> float: ...
	"""Plays an animation montage. Returns the length of the animation montage in seconds. Returns 0.f if failed to play."""

	def IsPlayingSlotAnimation(self, Asset: AnimSequenceBase, SlotNodeName: str) -> bool: ...
	"""Return true if it's playing the slot animation"""

	def StopSlotAnimation(self, InBlendOutTime: float = ..., SlotNodeName: str = ...): ...
	"""Stops currently playing slot animation slot or all"""

	def PlaySlotAnimationAsDynamicMontage(self, Asset: AnimSequenceBase, SlotNodeName: str, BlendInTime: float = ..., BlendOutTime: float = ..., InPlayRate: float = ..., LoopCount: int = ..., BlendOutTriggerTime: float = ..., InTimeToStartMontageAt: float = ...) -> AnimMontage: ...
	"""Play normal animation asset on the slot node by creating a dynamic UAnimMontage. You can only play one asset (whether montage or animsequence) at a time per SlotGroup."""

	def PlaySlotAnimation(self, Asset: AnimSequenceBase, SlotNodeName: str, BlendInTime: float = ..., BlendOutTime: float = ..., InPlayRate: float = ..., LoopCount: int = ...) -> float: ...
	"""Play Slot Animation"""

	def GetOwningComponent(self) -> SkeletalMeshComponent: ...
	"""Returns the skeletal mesh component that has created this AnimInstance"""

	def GetOwningActor(self) -> Actor: ...
	"""Returns the owning actor of this AnimInstance"""

	def SetPropagateNotifiesToLinkedInstances(self, bSet: bool): ...
	"""Set whether to propagate notifies to any linked anim instances"""

	def GetPropagateNotifiesToLinkedInstances(self) -> bool: ...
	"""Get whether to propagate notifies to any linked anim instances"""

	def SetReceiveNotifiesFromLinkedInstances(self, bSet: bool): ...
	"""Set whether to process notifies from any linked anim instances"""

	def GetReceiveNotifiesFromLinkedInstances(self) -> bool: ...
	"""Get whether to process notifies from any linked anim instances"""

	def SnapshotPose(self, Snapshot: PoseSnapshot): ...
	"""Takes a snapshot of the current skeletal mesh component pose and saves it to the specified snapshot.
The snapshot is taken at the current LOD, so if for example you took the snapshot at LOD1
and then used it at LOD0 any bones not in LOD1 will use the reference pose"""

	def SavePoseSnapshot(self, SnapshotName: str): ...
	"""Takes a snapshot of the current skeletal mesh component pose & saves it internally.
This snapshot can then be retrieved by name in the animation blueprint for blending.
The snapshot is taken at the current LOD, so if for example you took the snapshot at LOD1 and then used it at LOD0 any bones not in LOD1 will use the reference pose"""

	def TryGetPawnOwner(self) -> Pawn: ...
	"""kismet event functions"""

	pass

class AnimMetaData(Object):
	"""Anim Meta Data"""

	pass

class AnimMontage(AnimCompositeBase):
	"""* Any property you're adding to AnimMontage and parent class has to be considered for Child Asset
*
* Child Asset is considered to be only asset mapping feature using everything else in the class
* For example, you can just use all parent's setting  for the montage, but only remap assets
* This isn't magic bullet unfortunately and it is consistent effort of keeping the data synced with parent
* If you add new property, please make sure those property has to be copied for children.
* If it does, please add the copy in the function RefreshParentAssetData"""

	@property
	def BlendIn(self) -> typing.Any: ...
	"""Blend in option."""

	@property
	def BlendOut(self) -> typing.Any: ...
	"""Blend out option. This is only used when it blends out itself. If it's interrupted by other montages, it will use new montage's BlendIn option to blend out."""

	@property
	def BlendOutTriggerTime(self) -> float: ...
	"""Time from Sequence End to trigger blend out.
<0 means using BlendOutTime, so BlendOut finishes as Montage ends.
>=0 means using 'SequenceEnd - BlendOutTriggerTime' to trigger blend out."""

	@property
	def SyncGroup(self) -> str: ...
	"""If you're using marker based sync for this montage, make sure to add sync group name. For now we only support one group"""

	@property
	def SyncSlotIndex(self) -> int: ...
	"""wip: until we have UI working"""

	@property
	def MarkerData(self) -> typing.Any: ...
	"""Marker Data"""

	@property
	def CompositeSections(self) -> typing.List[unsupported]: ...
	"""composite section."""

	@property
	def SlotAnimTracks(self) -> typing.List[unsupported]: ...
	"""slot data, each slot contains anim track"""

	@property
	def bEnableRootMotionTranslation(self) -> bool: ...
	"""If this is on, it will allow extracting root motion translation. DEPRECATED in 4.5 root motion is controlled by anim sequences *"""

	@property
	def bEnableRootMotionRotation(self) -> bool: ...
	"""If this is on, it will allow extracting root motion rotation. DEPRECATED in 4.5 root motion is controlled by anim sequences *"""

	@property
	def bEnableAutoBlendOut(self) -> bool: ...
	"""When it hits end, it automatically blends out. If this is false, it won't blend out but keep the last pose until stopped explicitly"""

	@property
	def RootMotionRootLock(self) -> int: ...
	"""Root Bone will be locked to that position when extracting root motion. DEPRECATED in 4.5 root motion is controlled by anim sequences *"""

	@property
	def BranchingPointStateNotifyIndices(self) -> typing.List[int]: ...
	"""Keep track of which AnimNotify_State are marked as BranchingPoints, so we can update their state when the Montage is ticked"""

	@property
	def TimeStretchCurve(self) -> typing.Any: ...
	"""Time Stretch Curve"""

	@property
	def TimeStretchCurveName(self) -> str: ...
	"""Name of optional TimeStretchCurveName to look for in Montage."""

	def GetDefaultBlendOutTime(self) -> float: ...
	"""Get Default Blend Out Time"""

	pass

class AnimNotify(Object):
	"""Anim Notify"""

	def GetNotifyName(self) -> str: ...
	"""Implementable event to get a custom name for the notify"""

	pass

class AnimNotify_PauseClothingSimulation(AnimNotify):
	"""Anim Notify Pause Clothing Simulation"""

	pass

class AnimNotify_PlayParticleEffect(AnimNotify):
	"""Anim Notify Play Particle Effect"""

	@property
	def PSTemplate(self) -> ParticleSystem: ...
	"""Particle System to Spawn"""

	@property
	def LocationOffset(self) -> Vector: ...
	"""Location offset from the socket"""

	@property
	def RotationOffset(self) -> Rotator: ...
	"""Rotation offset from socket"""

	@property
	def Scale(self) -> Vector: ...
	"""Scale to spawn the particle system at"""

	@property
	def Attached(self) -> bool: ...
	"""Should attach to the bone/socket"""

	@property
	def SocketName(self) -> str: ...
	"""SocketName to attach to"""

	pass

class AnimNotify_PlaySound(AnimNotify):
	"""Anim Notify Play Sound"""

	@property
	def Sound(self) -> SoundBase: ...
	"""Sound to Play"""

	@property
	def VolumeMultiplier(self) -> float: ...
	"""Volume Multiplier"""

	@property
	def PitchMultiplier(self) -> float: ...
	"""Pitch Multiplier"""

	@property
	def bFollow(self) -> bool: ...
	"""If this sound should follow its owner"""

	@property
	def AttachName(self) -> str: ...
	"""Socket or bone name to attach sound to"""

	pass

class AnimNotify_ResetClothingSimulation(AnimNotify):
	"""Anim Notify Reset Clothing Simulation"""

	pass

class AnimNotify_ResetDynamics(AnimNotify):
	"""Anim Notify Reset Dynamics"""

	pass

class AnimNotify_ResumeClothingSimulation(AnimNotify):
	"""Anim Notify Resume Clothing Simulation"""

	pass

class AnimNotifyState(Object):
	"""Anim Notify State"""

	def GetNotifyName(self) -> str: ...
	"""Implementable event to get a custom name for the notify"""

	pass

class AnimNotifyState_DisableRootMotion(AnimNotifyState):
	"""Anim Notify State Disable Root Motion"""

	pass

class AnimNotifyState_TimedParticleEffect(AnimNotifyState):
	"""Timed Particle Effect Notify
Allows a looping particle effect to be played in an animation that will activate
at the beginning of the notify and deactivate at the end."""

	@property
	def PSTemplate(self) -> ParticleSystem: ...
	"""The particle system to spawn for the notify state"""

	@property
	def SocketName(self) -> str: ...
	"""The socket or bone to attach the system to"""

	@property
	def LocationOffset(self) -> Vector: ...
	"""Offset from the socket or bone to place the particle system"""

	@property
	def RotationOffset(self) -> Rotator: ...
	"""Rotation offset from the socket or bone for the particle system"""

	@property
	def bDestroyAtEnd(self) -> bool: ...
	"""Whether the particle system should be immediately destroyed at the end of the notify state or be allowed to finish"""

	pass

class AnimNotifyState_Trail(AnimNotifyState):
	"""Anim Notify State Trail"""

	@property
	def PSTemplate(self) -> ParticleSystem: ...
	"""The particle system to use for this trail."""

	@property
	def FirstSocketName(self) -> str: ...
	"""Name of the first socket defining this trail."""

	@property
	def SecondSocketName(self) -> str: ...
	"""Name of the second socket defining this trail."""

	@property
	def WidthScaleMode(self) -> int: ...
	"""Controls the way width scale is applied. In each method a width scale of 1.0 will mean the width is unchanged from the position of the sockets. A width scale of 0.0 will cause a trail of zero width.
From Centre = Trail width is scaled outwards from the centre point between the two sockets.
From First = Trail width is scaled outwards from the position of the first socket.
From Second = Trail width is scaled outwards from the position of the Second socket."""

	@property
	def WidthScaleCurve(self) -> str: ...
	"""Name of the curve to drive the width scale."""

	@property
	def bRecycleSpawnedSystems(self) -> bool: ...
	"""Recycle Spawned Systems"""

	pass

class AnimSequence(AnimSequenceBase):
	"""Anim Sequence"""

	@property
	def BoneCompressionSettings(self) -> typing.Any: ...
	"""The bone compression settings used to compress bones in this sequence."""

	@property
	def CurveCompressionSettings(self) -> typing.Any: ...
	"""The curve compression settings used to compress curves in this sequence."""

	@property
	def AdditiveAnimType(self) -> int: ...
	"""Additive animation type. *"""

	@property
	def RefPoseType(self) -> int: ...
	"""Additive refrerence pose type. Refer above enum type"""

	@property
	def RefPoseSeq(self) -> AnimSequence: ...
	"""Additive reference animation if it's relevant - i.e. AnimScaled or AnimFrame *"""

	@property
	def RefFrameIndex(self) -> int: ...
	"""Additve reference frame if RefPoseType == AnimFrame *"""

	@property
	def RetargetSource(self) -> str: ...
	"""Base pose to use when retargeting"""

	@property
	def Interpolation(self) -> int: ...
	"""This defines how values between keys are calculated *"""

	@property
	def bEnableRootMotion(self) -> bool: ...
	"""If this is on, it will allow extracting of root motion *"""

	@property
	def RootMotionRootLock(self) -> int: ...
	"""Root Bone will be locked to that position when extracting root motion.*"""

	@property
	def bForceRootLock(self) -> bool: ...
	"""Force Root Bone Lock even if Root Motion is not enabled"""

	@property
	def bUseNormalizedRootMotionScale(self) -> bool: ...
	"""If this is on, it will use a normalized scale value for the root motion extracted: FVector(1.0, 1.0, 1.0) *"""

	@property
	def bRootMotionSettingsCopiedFromMontage(self) -> bool: ...
	"""Have we copied root motion settings from an owning montage"""

	@property
	def AuthoredSyncMarkers(self) -> typing.List[AnimSyncMarker]: ...
	"""Authored Sync markers"""

	def GetBoneTransform(self, TrackIndex: int, FrameTime: float, bUseRawData: bool) -> Transform: ...

	def ExtractRootMotion(self, StartTime: float, DeltaTime: float, bAllowLooping: float) -> Transform: ...

	pass

class AnimSingleNodeInstance(AnimInstance):
	"""Anim Single Node Instance"""

	@property
	def CurrentAsset(self) -> AnimationAsset: ...
	"""Current Asset being played *"""

	@property
	def PostEvaluateAnimEvent(self) -> typing.Any: ...
	"""Post Evaluate Anim Event"""

	def SetPreviewCurveOverride(self, PoseName: str, Value: float, bRemoveIfZero: bool): ...
	"""Set pose value"""

	def GetAnimationAsset(self) -> AnimationAsset: ...
	"""Get the currently used asset"""

	def SetAnimationAsset(self, NewAsset: AnimationAsset, bIsLooping: bool = ..., InPlayRate: float = ...): ...
	"""Set New Asset - calls InitializeAnimation, for now we need MeshComponent *"""

	def StopAnim(self): ...
	"""Stop Anim"""

	def PlayAnim(self, bIsLooping: bool = ..., InPlayRate: float = ..., InStartPosition: float = ...): ...
	"""For AnimSequence specific *"""

	def GetLength(self) -> float: ...
	"""Get Length"""

	def SetPlaying(self, bIsPlaying: bool): ...
	"""Set Playing"""

	def SetBlendSpaceInput(self, InBlendInput: Vector): ...
	"""Set Blend Space Input"""

	def SetPositionWithPreviousTime(self, InPosition: float, InPreviousTime: float, bFireNotifies: bool = ...): ...
	"""Set Position with Previous Time"""

	def SetPosition(self, InPosition: float, bFireNotifies: bool = ...): ...
	"""Set Position"""

	def SetReverse(self, bInReverse: bool): ...
	"""Set Reverse"""

	def SetPlayRate(self, InPlayRate: float): ...
	"""Set Play Rate"""

	def SetLooping(self, bIsLooping: bool): ...
	"""Set Looping"""

	pass

class AnimStreamable(AnimSequenceBase):
	"""Anim Streamable"""

	@property
	def NumFrames(self) -> int: ...
	"""Number of raw frames in this sequence (not used by engine - just for informational purposes)."""

	@property
	def Interpolation(self) -> int: ...
	"""This defines how values between keys are calculated *"""

	@property
	def RetargetSource(self) -> str: ...
	"""Base pose to use when retargeting"""

	@property
	def BoneCompressionSettings(self) -> typing.Any: ...
	"""The bone compression settings used to compress bones in this sequence."""

	@property
	def CurveCompressionSettings(self) -> typing.Any: ...
	"""The curve compression settings used to compress curves in this sequence."""

	@property
	def bEnableRootMotion(self) -> bool: ...
	"""If this is on, it will allow extracting of root motion *"""

	@property
	def RootMotionRootLock(self) -> int: ...
	"""Root Bone will be locked to that position when extracting root motion.*"""

	@property
	def bForceRootLock(self) -> bool: ...
	"""Force Root Bone Lock even if Root Motion is not enabled"""

	@property
	def bUseNormalizedRootMotionScale(self) -> bool: ...
	"""If this is on, it will use a normalized scale value for the root motion extracted: FVector(1.0, 1.0, 1.0) *"""

	pass

class CurveSourceInterface(Interface):
	"""Curve Source Interface"""

	def GetCurves(self) -> typing.List[NamedCurveValue]: ...
	"""Evaluate all curves that this source provides"""

	def GetCurveValue(self, CurveName: str) -> float: ...
	"""Get the value for a specified curve"""

	def GetBindingName(self) -> str: ...
	"""Get the name that this curve source can be bound to by.
Clients of this curve source will use this name to identify this source."""

	pass

class PoseAsset(AnimationAsset):
	"""* Pose Asset that can be blended by weight of curves"""

	@property
	def RetargetSource(self) -> str: ...
	"""Base pose to use when retargeting"""

	pass

class Actor(Object):
	"""Actor is the base class for an Object that can be placed or spawned in a level.
Actors may contain a collection of ActorComponents, which can be used to control how actors move, how they are rendered, etc.
The other main function of an Actor is the replication of properties and function calls across the network during play."""

	@property
	def PrimaryActorTick(self) -> typing.Any: ...
	"""Primary Actor tick function, which calls TickActor().
Tick functions can be configured to control whether ticking is enabled, at what time during a frame the update occurs, and to set up tick dependencies.
See: https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Engine/FTickFunction/
See: AddTickPrerequisiteActor(), AddTickPrerequisiteComponent()"""

	@property
	def bNetTemporary(self) -> bool: ...
	"""If true, when the actor is spawned it will be sent to the client but receive no further replication updates from the server afterwards."""

	@property
	def bNetStartup(self) -> bool: ...
	"""If true, this actor was loaded directly from the map, and for networking purposes can be addressed by its full path name"""

	@property
	def bOnlyRelevantToOwner(self) -> bool: ...
	"""If true, this actor is only relevant to its owner. If this flag is changed during play, all non-owner channels would need to be explicitly closed."""

	@property
	def bAlwaysRelevant(self) -> bool: ...
	"""Always relevant for network (overrides bOnlyRelevantToOwner)."""

	@property
	def bExchangedRoles(self) -> bool: ...
	"""Whether we have already exchanged Role/RemoteRole on the client, as when removing then re-adding a streaming level.
Causes all initialization to be performed again even though the actor may not have actually been reloaded."""

	@property
	def bNetLoadOnClient(self) -> bool: ...
	"""This actor will be loaded on network clients during map load"""

	@property
	def bNetUseOwnerRelevancy(self) -> bool: ...
	"""If actor has valid Owner, call Owner's IsNetRelevantFor and GetNetPriority"""

	@property
	def bRelevantForNetworkReplays(self) -> bool: ...
	"""If true, this actor will be replicated to network replays (default is true)"""

	@property
	def bRelevantForLevelBounds(self) -> bool: ...
	"""If true, this actor's component's bounds will be included in the level's
bounding box unless the Actor's class has overridden IsLevelBoundsRelevant"""

	@property
	def bReplayRewindable(self) -> bool: ...
	"""If true, this actor will only be destroyed during scrubbing if the replay is set to a time before the actor existed.
Otherwise, RewindForReplay will be called if we detect the actor needs to be reset.
Note, this Actor must not be destroyed by gamecode, and RollbackViaDeletion may not be used."""

	@property
	def bAllowTickBeforeBeginPlay(self) -> bool: ...
	"""Whether we allow this Actor to tick before it receives the BeginPlay event.
Normally we don't tick actors until after BeginPlay; this setting allows this behavior to be overridden.
This Actor must be able to tick for this setting to be relevant."""

	@property
	def bBlockInput(self) -> bool: ...
	"""If true, all input on the stack below this actor will not be considered"""

	@property
	def bCollideWhenPlacing(self) -> bool: ...
	"""This actor collides with the world when placing in the editor, even if RootComponent collision is disabled. Does not affect spawning, See: SpawnCollisionHandlingMethod"""

	@property
	def bFindCameraComponentWhenViewTarget(self) -> bool: ...
	"""If true, this actor should search for an owned camera component to view through when used as a view target."""

	@property
	def bGenerateOverlapEventsDuringLevelStreaming(self) -> bool: ...
	"""If true, this actor will generate overlap Begin/End events when spawned as part of level streaming, which includes initial level load.
You might enable this is in the case where a streaming level loads around an actor and you want Begin/End overlap events to trigger.
See: UpdateOverlapsMethodDuringLevelStreaming"""

	@property
	def bIgnoresOriginShifting(self) -> bool: ...
	"""Whether this actor should not be affected by world origin shifting."""

	@property
	def bEnableAutoLODGeneration(self) -> bool: ...
	"""If true, and if World setting has bEnableHierarchicalLOD equal to true, then it will generate LODActor from groups of clustered Actor"""

	@property
	def bIsEditorOnlyActor(self) -> bool: ...
	"""Whether this actor is editor-only. Use with care, as if this actor is referenced by anything else that reference will be NULL in cooked builds"""

	@property
	def bActorSeamlessTraveled(self) -> bool: ...
	"""Indicates the actor was pulled through a seamless travel."""

	@property
	def InitialLifeSpan(self) -> float: ...
	"""How long this Actor lives before dying, 0=forever. Note this is the INITIAL value and should not be modified once play has begun."""

	@property
	def CustomTimeDilation(self) -> float: ...
	"""Allow each actor to run at a different time speed. The DeltaTime for a frame is multiplied by the global TimeDilation (in WorldSettings) and this CustomTimeDilation for this actor's tick."""

	@property
	def NetDormancy(self) -> int: ...
	"""Dormancy setting for actor to take itself off of the replication list without being destroyed on clients."""

	@property
	def SpawnCollisionHandlingMethod(self) -> int: ...
	"""Controls how to handle spawning this actor in a situation where it's colliding with something else. 'Default' means AlwaysSpawn here."""

	@property
	def AutoReceiveInput(self) -> int: ...
	"""Automatically registers this actor to receive input from a player."""

	@property
	def InputPriority(self) -> int: ...
	"""The priority of this input component when pushed in to the stack."""

	@property
	def InputComponent(self) -> InputComponent: ...
	"""Component that handles input for this actor, if input is enabled."""

	@property
	def NetCullDistanceSquared(self) -> float: ...
	"""Square of the max distance from the client's viewpoint that this actor is relevant and will be replicated."""

	@property
	def NetTag(self) -> int: ...
	"""Internal - used by UNetDriver"""

	@property
	def NetUpdateFrequency(self) -> float: ...
	"""How often (per second) this actor will be considered for replication, used to determine NetUpdateTime"""

	@property
	def MinNetUpdateFrequency(self) -> float: ...
	"""Used to determine what rate to throttle down to when replicated properties are changing infrequently"""

	@property
	def NetPriority(self) -> float: ...
	"""Priority for this actor when checking for replication in a low bandwidth or saturated situation, higher priority means it is more likely to replicate"""

	@property
	def Children(self) -> typing.List[Actor]: ...
	"""Array of all Actors whose Owner is this actor, these are not necessarily spawned by UChildActorComponent"""

	@property
	def Layers(self) -> typing.List[str]: ...
	"""Layers the actor belongs to.  This is outside of the editoronly data to allow hiding of LD-specified layers at runtime for profiling."""

	@property
	def Tags(self) -> typing.List[str]: ...
	"""Array of tags that can be used for grouping and categorizing."""

	@property
	def OnTakeAnyDamage(self) -> typing.Any: ...
	"""Called when the actor is damaged in any way."""

	@property
	def OnTakePointDamage(self) -> typing.Any: ...
	"""Called when the actor is damaged by point damage."""

	@property
	def OnTakeRadialDamage(self) -> typing.Any: ...
	"""Called when the actor is damaged by radial damage."""

	@property
	def OnActorBeginOverlap(self) -> typing.Any: ...
	"""Called when another actor begins to overlap this actor, for example a player walking into a trigger.
For events when objects have a blocking collision, for example a player hitting a wall, see 'Hit' events.
@note Components on both this and the other Actor must have bGenerateOverlapEvents set to true to generate overlap events."""

	@property
	def OnActorEndOverlap(self) -> typing.Any: ...
	"""Called when another actor stops overlapping this actor.
@note Components on both this and the other Actor must have bGenerateOverlapEvents set to true to generate overlap events."""

	@property
	def OnBeginCursorOver(self) -> typing.Any: ...
	"""Called when the mouse cursor is moved over this actor if mouse over events are enabled in the player controller."""

	@property
	def OnEndCursorOver(self) -> typing.Any: ...
	"""Called when the mouse cursor is moved off this actor if mouse over events are enabled in the player controller."""

	@property
	def OnClicked(self) -> typing.Any: ...
	"""Called when the left mouse button is clicked while the mouse is over this actor and click events are enabled in the player controller."""

	@property
	def OnReleased(self) -> typing.Any: ...
	"""Called when the left mouse button is released while the mouse is over this actor and click events are enabled in the player controller."""

	@property
	def OnInputTouchBegin(self) -> typing.Any: ...
	"""Called when a touch input is received over this actor when touch events are enabled in the player controller."""

	@property
	def OnInputTouchEnd(self) -> typing.Any: ...
	"""Called when a touch input is received over this component when touch events are enabled in the player controller."""

	@property
	def OnInputTouchEnter(self) -> typing.Any: ...
	"""Called when a finger is moved over this actor when touch over events are enabled in the player controller."""

	@property
	def OnInputTouchLeave(self) -> typing.Any: ...
	"""Called when a finger is moved off this actor when touch over events are enabled in the player controller."""

	@property
	def OnActorHit(self) -> typing.Any: ...
	"""Called when this Actor hits (or is hit by) something solid. This could happen due to things like Character movement, using Set Location with 'sweep' enabled, or physics simulation.
For events when objects overlap (e.g. walking into a trigger) see the 'Overlap' event.
@note For collisions during physics simulation to generate hit events, 'Simulation Generates Hit Events' must be enabled."""

	@property
	def OnDestroyed(self) -> typing.Any: ...
	"""Event triggered when the actor has been explicitly destroyed."""

	@property
	def OnEndPlay(self) -> typing.Any: ...
	"""Event triggered when the actor is being deleted or removed from a level."""

	@property
	def BlueprintCreatedComponents(self) -> typing.List[ActorComponent]: ...
	"""Array of ActorComponents that are created by blueprints and serialized per-instance."""

	def MakeNoise(self, Loudness: float = ..., NoiseInstigator: Pawn = ..., NoiseLocation: Vector = ..., MaxRange: float = ..., Tag: str = ...): ...
	"""Trigger a noise caused by a given Pawn, at a given location.
Note that the NoiseInstigator Pawn MUST have a PawnNoiseEmitterComponent for the noise to be detected by a PawnSensingComponent.
Senders of MakeNoise should have an Instigator if they are not pawns, or pass a NoiseInstigator.

@param Loudness The relative loudness of this noise. Usual range is 0 (no noise) to 1 (full volume). If MaxRange is used, this scales the max range, otherwise it affects the hearing range specified by the sensor.
@param NoiseInstigator Pawn responsible for this noise.  Uses the actor's Instigator if NoiseInstigator is null
@param NoiseLocation Position of noise source.  If zero vector, use the actor's location.
@param MaxRange Max range at which the sound may be heard. A value of 0 indicates no max range (though perception may have its own range). Loudness scales the range. (Note: not supported for legacy PawnSensingComponent, only for AIPerception)
@param Tag Identifier for the noise."""

	def GetComponentsByInterface(self, Interface) -> typing.List[ActorComponent]: ...
	"""Gets all the components that implements the given interface."""

	def GetComponentsByTag(self, ComponentClass: ActorComponent, Tag: str) -> typing.List[ActorComponent]: ...
	"""Gets all the components that inherit from the given class with a given tag."""

	def GetComponentsByClass(self, ComponentClass: ActorComponent) -> typing.List[ActorComponent]: ...
	"""Gets all the components that inherit from the given class.
Currently returns an array of UActorComponent which must be cast to the correct type.
This intended to only be used by blueprints. Use GetComponents() in C++."""

	def GetComponentByClass(self, ComponentClass: ActorComponent) -> ActorComponent: ...
	"""Searches components array and returns first encountered component of the specified class"""

	def GetActorEyesViewPoint(self) -> typing.Tuple[Vector, Rotator]: ...
	"""Returns the point of view of the actor.
Note that this doesn't mean the camera, but the 'eyes' of the actor.
For example, for a Pawn, this would define the eye height location,
and view rotation (which is different from the pawn rotation which has a zeroed pitch component).
A camera first person view will typically use this view point. Most traces (weapon, AI) will be done from this view point.

@param       OutLocation - location of view point
@param       OutRotation - view rotation of actor."""

	def PrestreamTextures(self, Seconds: float, bEnableStreaming: bool, CinematicTextureGroups: int = ...): ...
	"""Calls PrestreamTextures() for all the actor's meshcomponents.
@param Seconds - Number of seconds to force all mip-levels to be resident
@param bEnableStreaming      - Whether to start (true) or stop (false) streaming
@param CinematicTextureGroups - Bitfield indicating which texture groups that use extra high-resolution mips"""

	def ForceNetUpdate(self): ...
	"""Force actor to be updated to clients/demo net drivers"""

	def WasRecentlyRendered(self, Tolerance: float = ...) -> bool: ...
	"""Returns true if this actor has been rendered 'recently', with a tolerance in seconds to define what 'recent' means.
e.g.: If a tolerance of 0.1 is used, this function will return true only if the actor was rendered in the last 0.1 seconds of game time.

@param Tolerance  How many seconds ago the actor last render time can be and still count as having been 'recently' rendered.
@return Whether this actor was recently rendered."""

	def SetTickGroup(self, NewTickGroup: int): ...
	"""Sets the ticking group for this actor.
@param NewTickGroup the new value to assign"""

	def GetAttachedActors(self, bResetArray: bool = ...) -> typing.List[Actor]: ...
	"""Find all Actors which are attached directly to a component in this actor"""

	def GetAttachParentSocketName(self) -> str: ...
	"""Walk up the attachment chain from RootComponent until we encounter a different actor, and return the socket name in the component. If we are not attached to a component in a different actor, returns NAME_None"""

	def GetAttachParentActor(self) -> Actor: ...
	"""Walk up the attachment chain from RootComponent until we encounter a different actor, and return it. If we are not attached to a component in a different actor, returns nullptr"""

	def Teleport(self, DestLocation: Vector, DestRotation: Rotator) -> bool: ...
	"""Teleport this actor to a new location. If the actor doesn't fit exactly at the location specified, tries to slightly move it out of walls and such.

@param DestLocation The target destination point
@param DestRotation The target rotation at the destination
@return true if the actor has been successfully moved, or false if it couldn't fit."""

	def GetParentActor(self) -> Actor: ...
	"""If this Actor was created by a Child Actor Component returns the Actor that owns that Child Actor Component"""

	def GetParentComponent(self) -> ChildActorComponent: ...
	"""If this Actor was created by a Child Actor Component returns that Child Actor Component"""

	def GetAllChildActors(self, bIncludeDescendants: bool = ...) -> typing.List[Actor]: ...
	"""Returns a list of all actors spawned by our Child Actor Components, including children of children.
This does not return the contents of the Children array"""

	def IsChildActor(self) -> bool: ...
	"""Returns whether this Actor was spawned by a child actor component"""

	def FlushNetDormancy(self): ...
	"""Forces dormant actor to replicate but doesn't change NetDormancy state (i.e., they will go dormant again if left dormant)"""

	def SetNetDormancy(self, NewDormancy: int): ...
	"""Puts actor in dormant networking state"""

	def IsOverlappingActor(self, Other: Actor) -> bool: ...
	"""Check whether any component of this Actor is overlapping any component of another Actor.
@param Other The other Actor to test against
@return Whether any component of this Actor is overlapping any component of another Actor."""

	def GetOwner(self) -> Actor: ...
	"""Get the owner of this Actor, used primarily for network replication."""

	def SetOwner(self, NewOwner: Actor): ...
	"""Set the owner of this Actor, used primarily for network replication.
@param NewOwner      The Actor who takes over ownership of this Actor"""

	def OnRep_ReplicatedMovement(self): ...
	"""ReplicatedMovement struct replication event"""

	def GetActorTickInterval(self) -> float: ...
	"""Returns the tick interval of this actor's primary tick function"""

	def SetActorTickInterval(self, TickInterval: float): ...
	"""Sets the tick interval of this actor's primary tick function. Will not enable a disabled tick function. Takes effect on next tick.
@param TickInterval  The rate at which this actor should be ticking"""

	def IsActorTickEnabled(self) -> bool: ...
	"""Returns whether this actor has tick enabled or not"""

	def SetActorTickEnabled(self, bEnabled: bool): ...
	"""Set this actor's tick functions to be enabled or disabled. Only has an effect if the function is registered
This only modifies the tick function on actor itself
@param       bEnabled        Whether it should be enabled or not"""

	def GetLifeSpan(self) -> float: ...
	"""Get the remaining lifespan of this actor. If zero is returned the actor lives forever."""

	def SetLifeSpan(self, InLifespan: float): ...
	"""Set the lifespan of this actor. When it expires the object will be destroyed. If requested lifespan is 0, the timer is cleared and the actor will not be destroyed."""

	def GetOverlappingComponents(self) -> typing.List[PrimitiveComponent]: ...
	"""Returns list of components this actor is overlapping."""

	def GetOverlappingActors(self, ClassFilter: Actor = ...) -> typing.List[Actor]: ...
	"""Returns list of actors this actor is overlapping (any component overlapping any component). Does not return itself.
@param OverlappingActors             [out] Returned list of overlapping actors
@param ClassFilter                   [optional] If set, only returns actors of this class or subclasses"""

	def IsActorBeingDestroyed(self) -> bool: ...
	"""Returns true if this actor is currently being destroyed, some gameplay events may be unsafe"""

	def GetGameTimeSinceCreation(self) -> float: ...
	"""The number of seconds (in game time) since this Actor was created, relative to Get Game Time In Seconds."""

	def SetTickableWhenPaused(self, bTickableWhenPaused: bool): ...
	"""Sets whether this actor can tick when paused."""

	def GetTickableWhenPaused(self) -> bool: ...
	"""Gets whether this actor can tick when paused."""

	def RemoveTickPrerequisiteComponent(self, PrerequisiteComponent: ActorComponent): ...
	"""Remove tick dependency on PrerequisiteComponent."""

	def RemoveTickPrerequisiteActor(self, PrerequisiteActor: Actor): ...
	"""Remove tick dependency on PrerequisiteActor."""

	def AddTickPrerequisiteComponent(self, PrerequisiteComponent: ActorComponent): ...
	"""Make this actor tick after PrerequisiteComponent. This only applies to this actor's tick function; dependencies for owned components must be set up separately if desired."""

	def AddTickPrerequisiteActor(self, PrerequisiteActor: Actor): ...
	"""Make this actor tick after PrerequisiteActor. This only applies to this actor's tick function; dependencies for owned components must be set up separately if desired."""

	def GetActorTimeDilation(self) -> float: ...
	"""Get ActorTimeDilation - this can be used for input control or speed control for slomo.
We don't want to scale input globally because input can be used for UI, which do not care for TimeDilation."""

	def ActorHasTag(self, Tag: str) -> bool: ...
	"""See if this actor's Tags array contains the supplied name tag"""

	def DetachFromActor(self, LocationRule: int = ..., RotationRule: int = ..., ScaleRule: int = ...): ...
	"""Detaches the RootComponent of this Actor from any SceneComponent it is currently attached to.
@param  LocationRule                         How to handle translation when detaching.
@param  RotationRule                         How to handle rotation when detaching.
@param  ScaleRule                            How to handle scale when detaching."""

	def DetachRootComponentFromParent(self, bMaintainWorldPosition: bool = ...): ...
	"""Detach Root Component from Parent"""

	def AttachToActor(self, ParentActor: Actor, SocketName: str, LocationRule: int, RotationRule: int, ScaleRule: int, bWeldSimulatedBodies: bool): ...
	"""Attaches the RootComponent of this Actor to the supplied actor, optionally at a named socket.
@param ParentActor                           Actor to attach this actor's RootComponent to
@param SocketName                            Socket name to attach to, if any
@param LocationRule                          How to handle translation when attaching.
@param RotationRule                          How to handle rotation when attaching.
@param ScaleRule                                     How to handle scale when attaching.
@param bWeldSimulatedBodies          Whether to weld together simulated physics bodies."""

	def K2_AttachRootComponentToActor(self, InParentActor: Actor, InSocketName: str = ..., AttachLocationType: int = ..., bWeldSimulatedBodies: bool = ...): ...
	"""K2 Attach Root Component to Actor"""

	def AttachToComponent(self, Parent: SceneComponent, SocketName: str, LocationRule: int, RotationRule: int, ScaleRule: int, bWeldSimulatedBodies: bool): ...
	"""Attaches the RootComponent of this Actor to the supplied component, optionally at a named socket. It is not valid to call this on components that are not Registered.
@param Parent                                        Parent to attach to.
@param SocketName                            Optional socket to attach to on the parent.
@param LocationRule                          How to handle translation when attaching.
@param RotationRule                          How to handle rotation when attaching.
@param ScaleRule                                     How to handle scale when attaching.
@param bWeldSimulatedBodies          Whether to weld together simulated physics bodies."""

	def K2_AttachRootComponentTo(self, InParent: SceneComponent, InSocketName: str = ..., AttachLocationType: int = ..., bWeldSimulatedBodies: bool = ...): ...
	"""K2 Attach Root Component To"""

	def FinishAddComponent(self, Component: ActorComponent, bManualAttachment: bool, RelativeTransform: Transform): ...
	"""Completes the creation of a new actor component. Called either from blueprint after
expose on spawn properties are set, or directly from AddComponent

@see UK2Node_AddComponent    DO NOT CALL MANUALLY - BLUEPRINT INTERNAL USE ONLY (for Add Component nodes)

@param Component                                             The component created in AddComponent to finish creation of
@param bManualAttachment                             Whether manual or automatic attachment is to be used
@param RelativeTransform                             The relative transform between the new component and its attach parent (automatic only)"""

	def AddComponentByClass(self, Class: ActorComponent, bManualAttachment: bool, RelativeTransform: Transform, bDeferredFinish: bool) -> ActorComponent: ...
	"""Creates a new component and assigns ownership to the Actor this is
called for. Automatic attachment causes the first component created to
become the root, and all subsequent components to be attached under that
root. When bManualAttachment is set, automatic attachment is
skipped and it is up to the user to attach the resulting component (or
set it up as the root) themselves.

@see UK2Node_AddComponentByClass             DO NOT CALL MANUALLY - BLUEPRINT INTERNAL USE ONLY (for Add Component nodes)

@param Class                                         The class of component to create
@param bManualAttachment                             Whether manual or automatic attachment is to be used
@param RelativeTransform                             The relative transform between the new component and its attach parent (automatic only)
@param bDeferredFinish                               Whether or not to immediately complete the creation and registration process for this component. Will be false if there are expose on spawn properties being set"""

	def AddComponent(self, TemplateName: str, bManualAttachment: bool, RelativeTransform: Transform, ComponentTemplateContext: Object, bDeferredFinish: bool = ...) -> ActorComponent: ...
	"""Creates a new component and assigns ownership to the Actor this is
called for. Automatic attachment causes the first component created to
become the root, and all subsequent components to be attached under that
root. When bManualAttachment is set, automatic attachment is
skipped and it is up to the user to attach the resulting component (or
set it up as the root) themselves.

@see UK2Node_AddComponent    DO NOT CALL MANUALLY - BLUEPRINT INTERNAL USE ONLY (for Add Component nodes)

@param TemplateName                                  The name of the Component Template to use.
@param bManualAttachment                             Whether manual or automatic attachment is to be used
@param RelativeTransform                             The relative transform between the new component and its attach parent (automatic only)
@param ComponentTemplateContext              Optional UBlueprintGeneratedClass reference to use to find the template in. If null (or not a BPGC), component is sought in this Actor's class
@param bDeferredFinish                               Whether or not to immediately complete the creation and registration process for this component. Will be false if there are expose on spawn properties being set"""

	def HasAuthority(self) -> bool: ...
	"""Returns whether this actor has network authority"""

	def DestroyActor(self): ...
	"""Destroy the actor"""

	def GetActorEnableCollision(self) -> bool: ...
	"""Get current state of collision for the whole actor"""

	def SetActorEnableCollision(self, bNewActorEnableCollision: bool): ...
	"""Allows enabling/disabling collision for the whole actor"""

	def SetActorHiddenInGame(self, bNewHidden: bool): ...
	"""Sets the actor to be hidden in the game
@param  bNewHidden      Whether or not to hide the actor and all its components"""

	def GetActorRelativeScale3D(self) -> Vector: ...
	"""Return the actor's relative scale 3d"""

	def SetActorRelativeScale3D(self, NewRelativeScale: Vector): ...
	"""Set the actor's RootComponent to the specified relative scale 3d
@param NewRelativeScale      New scale to set the actor's RootComponent to"""

	def SetActorRelativeTransform(self, NewRelativeTransform: Transform, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Set the actor's RootComponent to the specified relative transform
@param NewRelativeTransform          New relative transform of the actor's root component
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire swept volume."""

	def SetActorRelativeRotation(self, NewRelativeRotation: Rotator, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Set the actor's RootComponent to the specified relative rotation
@param NewRelativeRotation   New relative rotation of the actor's root component
@param bSweep                                Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                             Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                             Whether we teleport the physics state (if physics collision is enabled for this object).
                                                             If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                             If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                             If CCD is on and not teleporting, this will affect objects along the entire swept volume."""

	def SetActorRelativeLocation(self, NewRelativeLocation: Vector, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Set the actor's RootComponent to the specified relative location.
@param NewRelativeLocation   New relative location of the actor's root component
@param bSweep                                Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                             Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                             Whether we teleport the physics state (if physics collision is enabled for this object).
                                                             If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                             If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                             If CCD is on and not teleporting, this will affect objects along the entire swept volume."""

	def AddActorLocalTransform(self, NewTransform: Transform, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the transform of this component in its local reference frame
@param NewTransform          The change in transform in local space.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire swept volume."""

	def AddActorLocalRotation(self, DeltaRotation: Rotator, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the rotation of this component in its local reference frame
@param DeltaRotation         The change in rotation in local space.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire swept volume."""

	def AddActorLocalOffset(self, DeltaLocation: Vector, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the location of this component in its local reference frame.
@param DelatLocation         The change in location in local space.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire swept volume."""

	def SetActorTransform(self, NewTransform: Transform, bSweep: bool, bTeleport: bool) -> typing.Tuple[bool, HitResult]: ...
	"""Set the Actors transform to the specified one.
@param NewTransform          The new transform.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire swept volume."""

	def AddActorWorldTransformKeepScale(self, DeltaTransform: Transform, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the transform of this actor in world space. Scale is unchanged."""

	def AddActorWorldTransform(self, DeltaTransform: Transform, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the transform of this actor in world space. Ignores scale and sets it to (1,1,1)."""

	def AddActorWorldRotation(self, DeltaRotation: Rotator, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the rotation of this actor in world space.

@param DeltaRotation         The change in rotation.
@param bSweep                        Whether to sweep to the target rotation (not currently supported for rotation).
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire swept volume.
@param SweepHitResult        The hit result from the move if swept."""

	def AddActorWorldOffset(self, DeltaLocation: Vector, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the location of this actor in world space.

@param DeltaLocation         The change in location.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire swept volume.
@param SweepHitResult        The hit result from the move if swept."""

	def GetHorizontalDotProductTo(self, OtherActor: Actor) -> float: ...
	"""Returns the dot product from this Actor to OtherActor, ignoring Z. Returns -2.0 on failure. Returns 0.0 for coincidental actors."""

	def GetDotProductTo(self, OtherActor: Actor) -> float: ...
	"""Returns the dot product from this Actor to OtherActor. Returns -2.0 on failure. Returns 0.0 for coincidental actors."""

	def GetVerticalDistanceTo(self, OtherActor: Actor) -> float: ...
	"""Returns the distance from this Actor to OtherActor, ignoring XY."""

	def GetHorizontalDistanceTo(self, OtherActor: Actor) -> float: ...
	"""Returns the distance from this Actor to OtherActor, ignoring Z."""

	def GetSquaredDistanceTo(self, OtherActor: Actor) -> float: ...
	"""Returns the squared distance from this Actor to OtherActor."""

	def GetDistanceTo(self, OtherActor: Actor) -> float: ...
	"""Returns the distance from this Actor to OtherActor."""

	def GetActorScale3D(self) -> Vector: ...
	"""Returns the Actor's world-space scale."""

	def SetActorScale3D(self, NewScale3D: Vector): ...
	"""Set the Actor's world-space scale."""

	def SetActorLocationAndRotation(self, NewLocation: Vector, NewRotation: Rotator, bSweep: bool, bTeleport: bool) -> typing.Tuple[bool, HitResult]: ...
	"""Move the actor instantly to the specified location and rotation.

@param NewLocation           The new location to teleport the Actor to.
@param NewRotation           The new rotation for the Actor.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire swept volume.
@param SweepHitResult        The hit result from the move if swept.
@return      Whether the rotation was successfully set."""

	def SetActorRotation(self, NewRotation: Rotator, bTeleportPhysics: bool) -> bool: ...
	"""Set the Actor's rotation instantly to the specified rotation.

@param       NewRotation     The new rotation for the Actor.
@param       bTeleportPhysics Whether we teleport the physics state (if physics collision is enabled for this object).
                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
@return      Whether the rotation was successfully set."""

	def GetVelocity(self) -> Vector: ...
	"""Returns velocity (in cm/s (Unreal Units/second) of the rootcomponent if it is either using physics or has an associated MovementComponent"""

	def K2_GetRootComponent(self) -> SceneComponent: ...
	"""Returns the RootComponent of this Actor"""

	def GetActorBounds(self, bOnlyCollidingComponents: bool, bIncludeFromChildActors: bool = ...) -> typing.Tuple[Vector, Vector]: ...
	"""Returns the bounding box of all components that make up this Actor (excluding ChildActorComponents).
@param       bOnlyCollidingComponents        If true, will only return the bounding box for components with collision enabled.
@param       Origin                                          Set to the center of the actor in world space
@param       BoxExtent                                       Set to half the actor's size in 3d space
@param       bIncludeFromChildActors         If true then recurse in to ChildActor components"""

	def GetActorRightVector(self) -> Vector: ...
	"""Get the right (Y) vector (length 1.0) from this Actor, in world space."""

	def GetActorUpVector(self) -> Vector: ...
	"""Get the up (Z) vector (length 1.0) from this Actor, in world space."""

	def GetActorForwardVector(self) -> Vector: ...
	"""Get the forward (X) vector (length 1.0) from this Actor, in world space."""

	def GetActorRotation(self) -> Rotator: ...
	"""Returns rotation of the RootComponent of this Actor."""

	def SetActorLocation(self, NewLocation: Vector, bSweep: bool, bTeleport: bool) -> typing.Tuple[bool, HitResult]: ...
	"""Move the Actor to the specified location.
@param NewLocation   The new location to move the Actor to.
@param bSweep                Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                             Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport             Whether we teleport the physics state (if physics collision is enabled for this object).
                                             If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                             If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                             If CCD is on and not teleporting, this will affect objects along the entire swept volume.
@param SweepHitResult        The hit result from the move if swept.
@return      Whether the location was successfully set (if not swept), or whether movement occurred at all (if swept)."""

	def GetActorLocation(self) -> Vector: ...
	"""Returns the location of the RootComponent of this Actor"""

	def GetActorTransform(self) -> Transform: ...
	"""Get the actor-to-world transform.
@return The transform that transforms from actor space to world space."""

	def GetInstigatorController(self) -> Controller: ...
	"""Returns the instigator's controller for this actor, or nullptr if there is none."""

	def GetInstigator(self) -> Pawn: ...
	"""Returns the instigator for this actor, or nullptr if there is none."""

	def GetInputVectorAxisValue(self, InputAxisKey: Key) -> Vector: ...
	"""Gets the value of the input axis key if input is enabled for this actor."""

	def GetInputAxisKeyValue(self, InputAxisKey: Key) -> float: ...
	"""Gets the value of the input axis key if input is enabled for this actor."""

	def GetInputAxisValue(self, InputAxisName: str) -> float: ...
	"""Gets the value of the input axis if input is enabled for this actor."""

	def DisableInput(self, PlayerController: PlayerController): ...
	"""Removes this actor from the stack of input being handled by a PlayerController.
@param PlayerController The PlayerController whose input events we no longer want to receive. If null, this actor will stop receiving input from all PlayerControllers."""

	def EnableInput(self, PlayerController: PlayerController): ...
	"""Pushes this actor on to the stack of input being handled by a PlayerController.
@param PlayerController The PlayerController whose input events we want to receive."""

	def OnRep_Instigator(self): ...
	"""Called on clients when Instigator is replicated."""

	def OnRep_AttachmentReplication(self): ...
	"""Called on client when updated AttachmentReplication value is received for this actor."""

	def GetRemoteRole(self) -> int: ...
	"""Returns how much control the remote machine has over this actor."""

	def GetLocalRole(self) -> int: ...
	"""Returns how much control the local machine has over this actor."""

	def SetReplicateMovement(self, bInReplicateMovement: bool): ...
	"""Set whether this actor's movement replicates to network clients.
@param bInReplicateMovement Whether this Actor's movement replicates to clients."""

	def SetReplicates(self, bInReplicates: bool): ...
	"""Set whether this actor replicates to network clients. When this actor is spawned on the server it will be sent to clients as well.
Properties flagged for replication will update on clients if they change on the server.
Internally changes the RemoteRole property and handles the cases where the actor needs to be added to the network actor list.
@param bInReplicates Whether this Actor replicates to network clients.
@see https://docs.unrealengine.com/latest/INT/Gameplay/Networking/Replication/"""

	def SetAutoDestroyWhenFinished(self, bVal: bool): ...
	"""Set Auto Destroy when Finished"""

	def TearOff(self): ...
	"""Networking - Server - TearOff this actor to stop replication to clients. Will set bTearOff to true."""

	def OnRep_ReplicateMovement(self): ...
	"""Called on client when updated bReplicateMovement value is received for this actor."""

	def DispatchBeginPlay(self) -> None: ...

	def GetComponents(self) -> typing.List[ActorComponent]: ...

	def GetComponent(self) -> ActorComponent: ...

	def AddInstanceComponent(self, Component: ActorComponent) -> None: ...

	def RemoveInstanceComponent(self, Component: ActorComponent) -> None: ...

	def ClearInstanceComponents(self, bDestroyComponents: bool) -> None: ...

	def GetInstanceComponents(self) -> typing.List[ActorComponent]: ...

	def AddActorComponent(self, Class: Class, Name: str, ParentComponent: SceneComponent = ...) -> ActorComponent: ...

	def AddActorRootComponent(self, Class: Class, Name: str) -> SceneComponent: ...

	def GetWorld(self) -> World: ...

	def Destroy(self) -> None: ...

	pass

class SkeletalMeshActor(Actor):
	"""SkeletalMeshActor is an instance of a USkeletalMesh in the world.
Skeletal meshes are deformable meshes that can be animated and change their geometry at run-time.
Skeletal meshes dragged into the level from the Content Browser are automatically converted to StaticMeshActors.

See: https://docs.unrealengine.com/latest/INT/Engine/Content/Types/SkeletalMeshes/
See: USkeletalMesh"""

	@property
	def bShouldDoAnimNotifies(self) -> bool: ...
	"""Whether or not this actor should respond to anim notifies - CURRENTLY ONLY AFFECTS PlayParticleEffect NOTIFIES*"""

	@property
	def ReplicatedMesh(self) -> SkeletalMesh: ...
	"""Used to replicate mesh to clients"""

	@property
	def ReplicatedPhysAsset(self) -> PhysicsAsset: ...
	"""Used to replicate physics asset to clients"""

	@property
	def ReplicatedMaterial0(self) -> MaterialInterface: ...
	"""used to replicate the material in index 0"""

	@property
	def ReplicatedMaterial1(self) -> MaterialInterface: ...
	"""Replicated Material 1"""

	def OnRep_ReplicatedMaterial1(self): ...
	"""On Rep Replicated Material 1"""

	def OnRep_ReplicatedMaterial0(self): ...
	"""On Rep Replicated Material 0"""

	def OnRep_ReplicatedPhysAsset(self): ...
	"""On Rep Replicated Phys Asset"""

	def OnRep_ReplicatedMesh(self): ...
	"""Replication Notification Callbacks"""

	pass

class Info(Actor):
	"""Info is the base class of an Actor that isn't meant to have a physical representation in the world, used primarily
for 'manager' type classes that hold settings data about the world, but might need to be an Actor for replication purposes."""

	pass

class ActorComponent(Object):
	"""ActorComponent is the base class for components that define reusable behavior that can be added to different types of Actors.
ActorComponents that have a transform are known as SceneComponents and those that can be rendered are PrimitiveComponents.

See: [ActorComponent](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Actors/Components/index.html#actorcomponents)
See: USceneComponent
See: UPrimitiveComponent"""

	@property
	def PrimaryComponentTick(self) -> typing.Any: ...
	"""Main tick function for the Component"""

	@property
	def ComponentTags(self) -> typing.List[str]: ...
	"""Array of tags that can be used for grouping and categorizing. Can also be accessed from scripting."""

	@property
	def bAutoActivate(self) -> bool: ...
	"""Whether the component is activated at creation or must be explicitly activated."""

	@property
	def bEditableWhenInherited(self) -> bool: ...
	"""True if this component can be modified when it was inherited from a parent actor class"""

	@property
	def bIsEditorOnly(self) -> bool: ...
	"""If true, the component will be excluded from non-editor builds"""

	@property
	def CreationMethod(self) -> int: ...
	"""Describes how a component instance will be created"""

	@property
	def OnComponentActivated(self) -> typing.Any: ...
	"""Called when the component has been activated, with parameter indicating if it was from a reset"""

	@property
	def OnComponentDeactivated(self) -> typing.Any: ...
	"""Called when the component has been deactivated"""

	def RemoveTickPrerequisiteComponent(self, PrerequisiteComponent: ActorComponent): ...
	"""Remove tick dependency on PrerequisiteComponent."""

	def RemoveTickPrerequisiteActor(self, PrerequisiteActor: Actor): ...
	"""Remove tick dependency on PrerequisiteActor."""

	def AddTickPrerequisiteComponent(self, PrerequisiteComponent: ActorComponent): ...
	"""Make this component tick after PrerequisiteComponent."""

	def AddTickPrerequisiteActor(self, PrerequisiteActor: Actor): ...
	"""Make this component tick after PrerequisiteActor"""

	def SetTickGroup(self, NewTickGroup: int): ...
	"""Changes the ticking group for this component"""

	def DestroyComponent(self, Object: Object): ...
	"""Unregister and mark for pending kill a component.  This may not be used to destroy a component that is owned by an actor unless the owning actor is calling the function."""

	def GetComponentTickInterval(self) -> float: ...
	"""Returns the tick interval for this component's primary tick function, which is the frequency in seconds at which it will be executed"""

	def SetComponentTickIntervalAndCooldown(self, TickInterval: float): ...
	"""Sets the tick interval for this component's primary tick function. Does not enable the tick interval. Takes effect imediately.
@param TickInterval   The duration between ticks for this component's primary tick function"""

	def SetComponentTickInterval(self, TickInterval: float): ...
	"""Sets the tick interval for this component's primary tick function. Does not enable the tick interval. Takes effect on next tick.
@param TickInterval   The duration between ticks for this component's primary tick function"""

	def IsComponentTickEnabled(self) -> bool: ...
	"""Returns whether this component has tick enabled or not"""

	def SetComponentTickEnabled(self, bEnabled: bool): ...
	"""Set this component's tick functions to be enabled or disabled. Only has an effect if the function is registered

@param       bEnabled - Whether it should be enabled or not"""

	def SetIsReplicated(self, ShouldReplicate: bool): ...
	"""Enable or disable replication. This is the equivalent of RemoteRole for actors (only a bool is required for components)"""

	def SetTickableWhenPaused(self, bTickableWhenPaused: bool): ...
	"""Sets whether this component can tick when paused."""

	def SetAutoActivate(self, bNewAutoActivate: bool): ...
	"""Sets whether the component should be auto activate or not. Only safe during construction scripts.
@param bNewAutoActivate - The new auto activate state of the component"""

	def IsActive(self) -> bool: ...
	"""Returns whether the component is active or not
@return - The active state of the component."""

	def ToggleActive(self): ...
	"""Toggles the active state of the component"""

	def SetActive(self, bNewActive: bool, bReset: bool = ...): ...
	"""Sets whether the component is active or not
@param bNewActive - The new active state of the component
@param bReset - Whether the activation should happen even if ShouldActivate returns false."""

	def Deactivate(self): ...
	"""Deactivates the SceneComponent."""

	def Activate(self, bReset: bool = ...): ...
	"""Activates the SceneComponent, should be overridden by native child classes.
@param bReset - Whether the activation should happen even if ShouldActivate returns false."""

	def ComponentHasTag(self, Tag: str) -> bool: ...
	"""See if this component contains the supplied tag"""

	def GetOwner(self) -> Actor: ...
	"""Follow the Outer chain to get the  AActor  that 'Owns' this component"""

	def OnRep_IsActive(self): ...
	"""Handles replication of active state, handles ticking by default but should be overridden as needed"""

	def IsBeingDestroyed(self) -> bool: ...
	"""Returns whether the component is in the process of being destroyed."""

	def IsRegistered(self) -> bool: ...

	def RegisterComponent(self) -> None: ...

	def UnregisterComponent(self) -> None: ...

	def GetWorld(self) -> World: ...

	def DestroySelfComponent(self) -> None: ...

	pass

class SceneComponent(ActorComponent):
	"""A SceneComponent has a transform and supports attachment, but has no rendering or collision capabilities.
Useful as a 'dummy' component in the hierarchy to offset others.
See: [Scene Components](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Actors/Components/index.html#scenecomponents)"""

	@property
	def ComponentVelocity(self) -> Vector: ...
	"""Velocity of the component.
See: GetComponentVelocity()"""

	@property
	def bHiddenInGame(self) -> bool: ...
	"""Whether to hide the primitive in game, if the primitive is Visible."""

	@property
	def bBoundsChangeTriggersStreamingDataRebuild(self) -> bool: ...
	"""If true, a change in the bounds of the component will call trigger a streaming data rebuild"""

	@property
	def bUseAttachParentBound(self) -> bool: ...
	"""If true, this component uses its parents bounds when attached.
This can be a significant optimization with many components attached together."""

	@property
	def Mobility(self) -> int: ...
	"""How often this component is allowed to move, used to make various optimizations. Only safe to set in constructor."""

	@property
	def DetailMode(self) -> int: ...
	"""If detail mode is >= system detail mode, primitive won't be rendered."""

	@property
	def PhysicsVolumeChangedDelegate(self) -> typing.Any: ...
	"""Delegate that will be called when PhysicsVolume has been changed *"""

	def SetMobility(self, NewMobility: int): ...
	"""Set how often this component is allowed to move during runtime. Causes a component re-register if the component is already registered"""

	def SetWorldLocationAndRotation(self, NewLocation: Vector, NewRotation: Rotator, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Set the relative location and rotation of the component to put it at the supplied pose in world space.
@param NewLocation           New location in world space for the component.
@param NewRotation           New rotation in world space for the component.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def SetAbsolute(self, bNewAbsoluteLocation: bool = ..., bNewAbsoluteRotation: bool = ..., bNewAbsoluteScale: bool = ...): ...
	"""Set which parts of the relative transform should be relative to parent, and which should be relative to world"""

	def SetRelativeLocationAndRotation(self, NewLocation: Vector, NewRotation: Rotator, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Set the location and rotation of the component relative to its parent
@param NewLocation           New location of the component relative to its parent.
@param NewRotation           New rotation of the component relative to its parent.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def GetPhysicsVolume(self) -> PhysicsVolume: ...
	"""Get the PhysicsVolume overlapping this component."""

	def SetHiddenInGame(self, NewHidden: bool, bPropagateToChildren: bool = ...): ...
	"""Changes the value of bHiddenInGame, if false this will disable Visibility during gameplay"""

	def ToggleVisibility(self, bPropagateToChildren: bool = ...): ...
	"""Toggle visibility of the component"""

	def SetVisibility(self, bNewVisibility: bool, bPropagateToChildren: bool = ...): ...
	"""Set visibility of the component, if during game use this to turn on/off"""

	def IsVisible(self) -> bool: ...
	"""Returns true if this component is visible in the current context"""

	def GetComponentVelocity(self) -> Vector: ...
	"""Get velocity of the component: either ComponentVelocity, or the velocity of the physics body if simulating physics.
@return Velocity of the component"""

	def DoesSocketExist(self, InSocketName: str) -> bool: ...
	"""Return true if socket with the given name exists
@param InSocketName Name of the socket or the bone to get the transform"""

	def GetSocketRotation(self, InSocketName: str) -> Rotator: ...
	"""Get world-space socket or bone  FRotator rotation.
@param InSocketName Name of the socket or the bone to get the transform
@return Socket transform in world space if socket if found. Otherwise it will return component's transform in world space."""

	def GetSocketLocation(self, InSocketName: str) -> Vector: ...
	"""Get world-space socket or bone location.
@param InSocketName Name of the socket or the bone to get the transform
@return Socket transform in world space if socket if found. Otherwise it will return component's transform in world space."""

	def GetSocketTransform(self, InSocketName: str, TransformSpace: int = ...) -> Transform: ...
	"""Get world-space socket transform.
@param InSocketName Name of the socket or the bone to get the transform
@return Socket transform in world space if socket if found. Otherwise it will return component's transform in world space."""

	def GetAllSocketNames(self) -> typing.List[str]: ...
	"""Gets the names of all the sockets on the component.
@return Get the names of all the sockets on the component."""

	def DetachFromComponent(self, LocationRule: int = ..., RotationRule: int = ..., ScaleRule: int = ..., bCallModify: bool = ...): ...
	"""Detach this component from whatever it is attached to. Automatically unwelds components that are welded together (See WeldTo)
@param LocationRule                          How to handle translations when detaching.
@param RotationRule                          How to handle rotation when detaching.
@param ScaleRule                                     How to handle scales when detaching.
@param bCallModify                           If true, call Modify() on the component and the current attach parent component"""

	def DetachFromParent(self, bMaintainWorldPosition: bool = ..., bCallModify: bool = ...): ...
	"""Detach from Parent"""

	def AttachToComponent(self, Parent: SceneComponent, SocketName: str, LocationRule: int, RotationRule: int, ScaleRule: int, bWeldSimulatedBodies: bool) -> bool: ...
	"""Attach this component to another scene component, optionally at a named socket. It is valid to call this on components whether or not they have been Registered.
@param  Parent                                        Parent to attach to.
@param  SocketName                            Optional socket to attach to on the parent.
@param  LocationRule                          How to handle translation when attaching.
@param  RotationRule                          How to handle rotation when attaching.
@param  ScaleRule                                     How to handle scale when attaching.
@param  bWeldSimulatedBodies          Whether to weld together simulated physics bodies.
@return True if attachment is successful (or already attached to requested parent/socket), false if attachment is rejected and there is no change in AttachParent."""

	def K2_AttachTo(self, InParent: SceneComponent, InSocketName: str = ..., AttachType: int = ..., bWeldSimulatedBodies: bool = ...) -> bool: ...
	"""K2 Attach To"""

	def GetChildrenComponents(self, bIncludeAllDescendants: bool) -> typing.List[SceneComponent]: ...
	"""Gets all components that are attached to this component, possibly recursively
@param bIncludeAllDescendants Whether to include all descendants in the list of children (i.e. grandchildren, great grandchildren, etc.)
@param Children The list of attached child components"""

	def GetChildComponent(self, ChildIndex: int) -> SceneComponent: ...
	"""Gets the attached child component at the specified location"""

	def GetNumChildrenComponents(self) -> int: ...
	"""Gets the number of attached children components"""

	def GetParentComponents(self) -> typing.List[SceneComponent]: ...
	"""Gets all attachment parent components up to and including the root component"""

	def GetAttachSocketName(self) -> str: ...
	"""Get the socket we are attached to."""

	def GetAttachParent(self) -> SceneComponent: ...
	"""Get the SceneComponent we are attached to."""

	def IsAnySimulatingPhysics(self) -> bool: ...
	"""Returns whether the specified body is currently using physics simulation"""

	def IsSimulatingPhysics(self, BoneName: str = ...) -> bool: ...
	"""Returns whether the specified body is currently using physics simulation"""

	def GetRightVector(self) -> Vector: ...
	"""Get the right (Y) unit direction vector from this component, in world space."""

	def GetUpVector(self) -> Vector: ...
	"""Get the up (Z) unit direction vector from this component, in world space."""

	def GetForwardVector(self) -> Vector: ...
	"""Get the forward (X) unit direction vector from this component, in world space."""

	def GetWorldTransform(self) -> Transform: ...
	"""Get the current component-to-world transform for this component"""

	def GetWorldScale(self) -> Vector: ...
	"""Returns scale of the component, in world space."""

	def GetWorldRotation(self) -> Rotator: ...
	"""Returns rotation of the component, in world space."""

	def GetWorldLocation(self) -> Vector: ...
	"""Return location of the component, in world space"""

	def AddWorldTransformKeepScale(self, DeltaTransform: Transform, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the transform of the component in world space. Scale is unchanged.
@param DeltaTransform        Change in transform in world space for the component. Scale is ignored since we preserve the original scale.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def AddWorldTransform(self, DeltaTransform: Transform, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the transform of the component in world space. Ignores scale and sets it to (1,1,1).
@param DeltaTransform        Change in transform in world space for the component. Scale is ignored.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def AddWorldRotation(self, DeltaRotation: Rotator, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the rotation of the component in world space.
@param DeltaRotation         Change in rotation in world space for the component.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def AddWorldOffset(self, DeltaLocation: Vector, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the location of the component in world space.
@param DeltaLocation         Change in location in world space for the component.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def SetWorldTransform(self, NewTransform: Transform, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Set the transform of the component in world space.
@param NewTransform          New transform in world space for the component.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def SetWorldScale3D(self, NewScale: Vector): ...
	"""Set the relative scale of the component to put it at the supplied scale in world space.
@param NewScale              New scale in world space for this component."""

	def SetWorldRotation(self, NewRotation: Rotator, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""* Put this component at the specified rotation in world space. Updates relative rotation to achieve the final world rotation.
* @param NewRotation           New rotation in world space for the component.
* @param SweepHitResult        Hit result from any impact if sweep is true.
* @param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
* @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
*                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
*                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
*                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def SetWorldLocation(self, NewLocation: Vector, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Put this component at the specified location in world space. Updates relative location to achieve the final world location.
@param NewLocation           New location in world space for the component.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def AddLocalTransform(self, DeltaTransform: Transform, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the transform of the component in its local reference frame. Scale is unchanged.
@param DeltaTransform        Change in transform of the component in its local reference frame. Scale is unchanged.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def AddLocalRotation(self, DeltaRotation: Rotator, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the rotation of the component in its local reference frame
@param DeltaRotation         Change in rotation of the component in its local reference frame.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts)."""

	def AddLocalOffset(self, DeltaLocation: Vector, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the location of the component in its local reference frame
@param DeltaLocation         Change in location of the component in its local reference frame.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def AddRelativeRotation(self, DeltaRotation: Rotator, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta the rotation of the component relative to its parent
@param DeltaRotation         Change in rotation of the component relative to is parent.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts)."""

	def AddRelativeLocation(self, DeltaLocation: Vector, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Adds a delta to the translation of the component relative to its parent
@param DeltaLocation         Change in location of the component relative to its parent
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
                                                     Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
                                                     If CCD is on and not teleporting, this will affect objects along the entire sweep volume."""

	def SetRelativeScale3D(self, NewScale3D: Vector): ...
	"""Set the non-uniform scale of the component relative to its parent"""

	def ResetRelativeTransform(self): ...
	"""Reset the transform of the component relative to its parent. Sets relative location to zero, relative rotation to no rotation, and Scale to 1."""

	def GetRelativeTransform(self) -> Transform: ...
	"""Returns the transform of the component relative to its parent"""

	def SetRelativeTransform(self, NewTransform: Transform, bSweep: bool, bTeleport: bool) -> HitResult: ...
	"""Set the transform of the component relative to its parent
@param NewTransform          New transform of the component relative to its parent.
@param SweepHitResult        Hit result from any impact if sweep is true.
@param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
@param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
                                                     If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
                                                     If false, physics velocity is updated based on the change in position (affecting ragdoll parts)."""

	def SetShouldUpdatePhysicsVolume(self, bInShouldUpdatePhysicsVolume: bool): ...
	"""Sets whether or not the cached PhysicsVolume this component overlaps should be updated when the component is moved."""

	def GetShouldUpdatePhysicsVolume(self) -> bool: ...
	"""Gets whether or not the cached PhysicsVolume this component overlaps should be updated when the component is moved."""

	def SetupAttachment(self, ParentComponent: SceneComponent, SocketName: str) -> None: ...

	def GetRelativeLocation(self) -> Vector: ...

	def SetRelativeLocation(self, NewLocation: Vector, bSweep: bool = ..., bTeleport: bool = ...) -> HitResult: ...

	def GetRelativeRotation(self) -> Rotator: ...

	def SetRelativeRotation(self, NewRotation: Rotator, bSweep: bool = ..., bTeleport: bool = ...) -> HitResult: ...

	def GetRelativeScale3D(self) -> Vector: ...

	pass

class CameraActor(Actor):
	"""A CameraActor is a camera viewpoint that can be placed in a level."""

	def GetAutoActivatePlayerIndex(self) -> int: ...
	"""Returns index of the player for whom we auto-activate, or INDEX_NONE (-1) if disabled."""

	pass

class CameraAnim(Object):
	"""A predefined animation to be played on a camera"""

	@property
	def CameraInterpGroup(self) -> InterpGroup: ...
	"""The UInterpGroup that holds our actual interpolation data."""

	@property
	def AnimLength(self) -> float: ...
	"""Length, in seconds."""

	@property
	def BoundingBox(self) -> Box: ...
	"""AABB in local space."""

	@property
	def bRelativeToInitialTransform(self) -> bool: ...
	"""If true, assume all transform keys are intended be offsets from the start of the animation. This allows the animation to be authored at any world location and be applied as a delta to the camera.
If false, assume all transform keys are authored relative to the world origin. Positions will be directly applied as deltas to the camera."""

	@property
	def bRelativeToInitialFOV(self) -> bool: ...
	"""If true, assume all FOV keys are intended be offsets from the start of the animation.
If false, assume all FOV keys are authored relative to the current FOV of the camera at the start of the animation."""

	@property
	def BaseFOV(self) -> float: ...
	"""The base FOV that all FOV keys are relative to."""

	@property
	def BasePostProcessSettings(self) -> PostProcessSettings: ...
	"""Default PP settings to put on the animated camera. For modifying PP without keyframes."""

	@property
	def BasePostProcessBlendWeight(self) -> float: ...
	"""Default PP blend weight to put on the animated camera. For modifying PP without keyframes."""

	pass

class CameraAnimInst(Object):
	"""Camera Anim Inst"""

	@property
	def CamAnim(self) -> CameraAnim: ...
	"""which CameraAnim this is an instance of"""

	@property
	def PlayRate(self) -> float: ...
	"""Multiplier for playback rate.  1.0 = normal."""

	@property
	def MoveTrack(self) -> InterpTrackMove: ...
	"""cached movement track from the currently playing anim so we don't have to go find it every frame"""

	@property
	def MoveInst(self) -> typing.Any: ...
	"""Move Inst"""

	@property
	def PlaySpace(self) -> int: ...
	"""Play Space"""

	def SetScale(self, NewDuration: float): ...
	"""Changes the scale of the animation while playing."""

	def SetDuration(self, NewDuration: float): ...
	"""Changes the running duration of this active anim, while maintaining playback position."""

	def Stop(self, bImmediate: bool = ...): ...
	"""Stops this instance playing whatever animation it is playing."""

	pass

class CameraComponent(SceneComponent):
	"""Represents a camera viewpoint and settings, such as projection type, field of view, and post-process overrides.
The default behavior for an actor used as the camera view target is to look for an attached camera component and use its location, rotation, and settings."""

	@property
	def FieldOfView(self) -> float: ...
	"""The horizontal field of view (in degrees) in perspective mode (ignored in Orthographic mode)"""

	@property
	def OrthoWidth(self) -> float: ...
	"""The desired width (in world units) of the orthographic view (ignored in Perspective mode)"""

	@property
	def OrthoNearClipPlane(self) -> float: ...
	"""The near plane distance of the orthographic view (in world units)"""

	@property
	def OrthoFarClipPlane(self) -> float: ...
	"""The far plane distance of the orthographic view (in world units)"""

	@property
	def AspectRatio(self) -> float: ...
	"""Aspect Ratio (Width/Height)"""

	@property
	def bConstrainAspectRatio(self) -> bool: ...
	"""If bConstrainAspectRatio is true, black bars will be added if the destination view has a different aspect ratio than this camera requested."""

	@property
	def bUseFieldOfViewForLOD(self) -> bool: ...
	"""If true, account for the field of view angle when computing which level of detail to use for meshes."""

	@property
	def bLockToHmd(self) -> bool: ...
	"""True if the camera's orientation and position should be locked to the HMD"""

	@property
	def bUsePawnControlRotation(self) -> bool: ...
	"""If this camera component is placed on a pawn, should it use the view/control rotation of the pawn where possible?
See: APawn::GetViewRotation()"""

	@property
	def ProjectionMode(self) -> int: ...
	"""The type of camera"""

	@property
	def PostProcessBlendWeight(self) -> float: ...
	"""Indicates if PostProcessSettings should be used when using this Camera to view through."""

	@property
	def PostProcessSettings(self) -> PostProcessSettings: ...
	"""Post process settings to use for this camera. Don't forget to check the properties you want to override"""

	def RemoveBlendable(self, InBlendableObject): ...
	"""Removes a blendable."""

	def AddOrUpdateBlendable(self, InBlendableObject, InWeight: float = ...): ...
	"""Adds an Blendable (implements IBlendableInterface) to the array of Blendables (if it doesn't exist) and update the weight"""

	def GetCameraView(self, DeltaTime: float) -> MinimalViewInfo: ...
	"""Returns camera's Point of View.
Called by Camera class. Subclass and postprocess to add any effects."""

	def SetPostProcessBlendWeight(self, InPostProcessBlendWeight: float): ...
	"""Set Post Process Blend Weight"""

	def SetProjectionMode(self, InProjectionMode: int): ...
	"""Set Projection Mode"""

	def SetUseFieldOfViewForLOD(self, bInUseFieldOfViewForLOD: bool): ...
	"""Set Use Field Of View for LOD"""

	def SetConstraintAspectRatio(self, bInConstrainAspectRatio: bool): ...
	"""Set Constraint Aspect Ratio"""

	def SetAspectRatio(self, InAspectRatio: float): ...
	"""Set Aspect Ratio"""

	def SetOrthoFarClipPlane(self, InOrthoFarClipPlane: float): ...
	"""Set Ortho Far Clip Plane"""

	def SetOrthoNearClipPlane(self, InOrthoNearClipPlane: float): ...
	"""Set Ortho Near Clip Plane"""

	def SetOrthoWidth(self, InOrthoWidth: float): ...
	"""Set Ortho Width"""

	def SetFieldOfView(self, InFieldOfView: float): ...
	"""Set Field Of View"""

	pass

class CameraModifier(Object):
	"""A CameraModifier is a base class for objects that may adjust the final camera properties after
being computed by the APlayerCameraManager (See: ModifyCamera). A CameraModifier
can be stateful, and is associated uniquely with a specific APlayerCameraManager."""

	@property
	def bDebug(self) -> bool: ...
	"""If true, enables certain debug visualization features."""

	@property
	def bExclusive(self) -> bool: ...
	"""If true, no other modifiers of same priority allowed."""

	@property
	def Priority(self) -> int: ...
	"""Priority value that determines the order in which modifiers are applied. 0 = highest priority, 255 = lowest."""

	def EnableModifier(self): ...
	"""Enables this modifier."""

	def DisableModifier(self, bImmediate: bool = ...): ...
	"""Disables this modifier.
@param  bImmediate  - true to disable with no blend out, false (default) to allow blend out"""

	def GetViewTarget(self) -> Actor: ...
	"""@return Returns the actor the camera is currently viewing."""

	def IsDisabled(self) -> bool: ...
	"""@return Returns true if modifier is disabled, false otherwise."""

	pass

class CameraModifier_CameraShake(CameraModifier):
	"""A UCameraModifier_CameraShake is a camera modifier that can apply a UCameraShakeBase to
the owning camera."""

	pass

class CameraShakeBase(Object):
	"""A CameraShake is an asset that defines how to shake the camera in
a particular way. CameraShakes can be authored as either oscillating shakes,
animated shakes, or both.

An oscillating shake will sinusoidally vibrate various camera parameters over time. Each location
and rotation axis can be oscillated independently with different parameters to create complex and
random-feeling shakes. These are easier to author and tweak, but can still feel mechanical and are
limited to vibration-style shakes, such as earthquakes.

Animated shakes play keyframed camera animations.  These can take more effort to author, but enable
more natural-feeling results and things like directional shakes.  For instance, you can have an explosion
to the camera's right push it primarily to the left."""

	@property
	def bSingleInstance(self) -> bool: ...
	"""If true to only allow a single instance of this shake class to play at any given time.
Subsequent attempts to play this shake will simply restart the timer."""

	@property
	def ShakeScale(self) -> float: ...
	"""The overall scale to apply to the shake. Only valid when the shake is active."""

	pass

class MatineeCameraShake(CameraShakeBase):
	"""Legacy camera shake which can do either oscillation or run camera anims."""

	@property
	def OscillationDuration(self) -> float: ...
	"""Duration in seconds of current screen shake. Less than 0 means indefinite, 0 means no oscillation."""

	@property
	def OscillationBlendInTime(self) -> float: ...
	"""Duration of the blend-in, where the oscillation scales from 0 to 1."""

	@property
	def OscillationBlendOutTime(self) -> float: ...
	"""Duration of the blend-out, where the oscillation scales from 1 to 0."""

	@property
	def RotOscillation(self) -> ROscillator: ...
	"""Rotational oscillation"""

	@property
	def LocOscillation(self) -> VOscillator: ...
	"""Positional oscillation"""

	@property
	def FOVOscillation(self) -> FOscillator: ...
	"""FOV oscillation"""

	@property
	def AnimPlayRate(self) -> float: ...
	"""Scalar defining how fast to play the anim."""

	@property
	def AnimScale(self) -> float: ...
	"""Scalar defining how 'intense' to play the anim."""

	@property
	def AnimBlendInTime(self) -> float: ...
	"""Linear blend-in time."""

	@property
	def AnimBlendOutTime(self) -> float: ...
	"""Linear blend-out time."""

	@property
	def RandomAnimSegmentDuration(self) -> float: ...
	"""When bRandomAnimSegment is true, this defines how long the anim should play."""

	@property
	def Anim(self) -> CameraAnim: ...
	"""Source camera animation to play. Can be null."""

	@property
	def bRandomAnimSegment(self) -> bool: ...
	"""If true, play a random snippet of the animation of length Duration.  Implies bLoop and bRandomStartTime = true for the CameraAnim.
If false, play the full anim once, non-looped. Useful for getting variety out of a single looped CameraAnim asset."""

	@property
	def OscillatorTimeRemaining(self) -> float: ...
	"""Time remaining for oscillation shakes. Less than 0.f means shake infinitely."""

	@property
	def AnimInst(self) -> CameraAnimInst: ...
	"""The playing instance of the CameraAnim-based shake, if any."""

	def ReceiveIsFinished(self) -> bool: ...
	"""Called to allow a shake to decide when it's finished playing."""

	pass

class CameraShakeSourceActor(Actor):
	"""Camera Shake Source Actor"""

	pass

class CameraShakeSourceComponent(SceneComponent):
	"""Camera Shake Source Component"""

	@property
	def Attenuation(self) -> int: ...
	"""The attenuation profile for how camera shakes' intensity falls off with distance"""

	@property
	def InnerAttenuationRadius(self) -> float: ...
	"""Under this distance from the source, the camera shakes are at full intensity"""

	@property
	def OuterAttenuationRadius(self) -> float: ...
	"""Outside of this distance from the source, the camera shakes don't apply at all"""

	@property
	def CameraShake(self) -> CameraShakeBase: ...
	"""Camera Shake"""

	@property
	def bAutoStart(self) -> bool: ...
	"""Auto Start"""

	def GetAttenuationFactor(self, Location: Vector) -> float: ...
	"""Computes an attenuation factor from this source"""

	def StopAllCameraShakes(self, bImmediately: bool = ...): ...
	"""Stops all currently active camera shakes that are originating from this source from all player controllers"""

	def StopAllCameraShakesOfType(self, InCameraShake: CameraShakeBase, bImmediately: bool = ...): ...
	"""Stops a camera shake originating from this source"""

	def StartCameraShake(self, InCameraShake: CameraShakeBase, Scale: float = ..., PlaySpace: int = ..., UserPlaySpaceRot: Rotator = ...): ...
	"""Starts a new camera shake originating from this source, and apply it on all player controllers"""

	def Start(self): ...
	"""Start"""

	pass

class PlayerCameraManager(Actor):
	"""A PlayerCameraManager is responsible for managing the camera for a particular
player. It defines the final view properties used by other systems (e.g. the renderer),
meaning you can think of it as your virtual eyeball in the world. It can compute the
final camera properties directly, or it can arbitrate/blend between other objects or
actors that influence the camera (e.g. blending from one CameraActor to another).

The PlayerCameraManagers primary external responsibility is to reliably respond to
various Get*() functions, such as GetCameraViewPoint. Most everything else is
implementation detail and overrideable by user projects.

By default, a PlayerCameraManager maintains a 'view target', which is the primary actor
the camera is associated with. It can also apply various 'post' effects to the final
view state, such as camera animations, shakes, post-process effects or special
effects such as dirt on the lens.

See: https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Camera/"""

	@property
	def PCOwner(self) -> PlayerController: ...
	"""PlayerController that owns this Camera actor"""

	@property
	def DefaultFOV(self) -> float: ...
	"""FOV to use by default."""

	@property
	def DefaultOrthoWidth(self) -> float: ...
	"""The default desired width (in world units) of the orthographic view (ignored in Perspective mode)"""

	@property
	def DefaultAspectRatio(self) -> float: ...
	"""Default aspect ratio (used when a view target override the aspect ratio and bConstrainAspectRatio is set; most of the time the value from a camera component will be used instead)"""

	@property
	def CameraCache(self) -> typing.Any: ...
	"""Camera Cache"""

	@property
	def LastFrameCameraCache(self) -> typing.Any: ...
	"""Last Frame Camera Cache"""

	@property
	def ViewTarget(self) -> TViewTarget: ...
	"""Current ViewTarget"""

	@property
	def PendingViewTarget(self) -> TViewTarget: ...
	"""Pending view target for blending"""

	@property
	def DefaultModifiers(self) -> typing.List[CameraModifier]: ...
	"""List of modifiers to create by default for this camera"""

	@property
	def FreeCamDistance(self) -> float: ...
	"""Distance to place free camera from view target (used in certain CameraStyles)"""

	@property
	def FreeCamOffset(self) -> Vector: ...
	"""Offset to Z free camera position (used in certain CameraStyles)"""

	@property
	def ViewTargetOffset(self) -> Vector: ...
	"""Offset to view target (used in certain CameraStyles)"""

	@property
	def OnAudioFadeChangeEvent(self) -> typing.Any: ...
	"""If bound, broadcast on fade start (with fade time) instead of manually altering audio device's master volume directly"""

	@property
	def ActiveAnims(self) -> typing.List[CameraAnimInst]: ...
	"""Array of camera anim instances that are currently playing and in-use"""

	@property
	def bIsOrthographic(self) -> bool: ...
	"""True when this camera should use an orthographic perspective instead of FOV"""

	@property
	def bDefaultConstrainAspectRatio(self) -> bool: ...
	"""True if black bars should be added if the destination view has a different aspect ratio (only used when a view target doesn't specify whether or not to constrain the aspect ratio; most of the time the value from a camera component is used instead)"""

	@property
	def bClientSimulatingViewTarget(self) -> bool: ...
	"""True if clients are handling setting their own viewtarget and the server should not replicate it (e.g. during certain Matinee sequences)"""

	@property
	def bUseClientSideCameraUpdates(self) -> bool: ...
	"""True if server will use camera positions replicated from the client instead of calculating them locally."""

	@property
	def bGameCameraCutThisFrame(self) -> bool: ...
	"""True if we did a camera cut this frame. Automatically reset to false every frame.
This flag affects various things in the renderer (such as whether to use the occlusion queries from last frame, and motion blur)."""

	@property
	def ViewPitchMin(self) -> float: ...
	"""Minimum view pitch, in degrees."""

	@property
	def ViewPitchMax(self) -> float: ...
	"""Maximum view pitch, in degrees."""

	@property
	def ViewYawMin(self) -> float: ...
	"""Minimum view yaw, in degrees."""

	@property
	def ViewYawMax(self) -> float: ...
	"""Maximum view yaw, in degrees."""

	@property
	def ViewRollMin(self) -> float: ...
	"""Minimum view roll, in degrees."""

	@property
	def ViewRollMax(self) -> float: ...
	"""Maximum view roll, in degrees."""

	def SetGameCameraCutThisFrame(self): ...
	"""Sets the bGameCameraCutThisFrame flag to true (indicating we did a camera cut this frame; useful for game code to call, e.g., when performing a teleport that should be seamless)"""

	def StopAllCameraAnims(self, bImmediate: bool = ...): ...
	"""Stop playing all CameraAnims on this CameraManager.
@param bImmediate    True to stop it right now and ignore blend out, false to let it blend out as indicated."""

	def StopCameraAnimInst(self, AnimInst: CameraAnimInst, bImmediate: bool = ...): ...
	"""Stops the given CameraAnimInst from playing.  The given pointer should be considered invalid after this.
@param bImmediate    True to stop it right now and ignore blend out, false to let it blend out as indicated."""

	def StopAllInstancesOfCameraAnim(self, Anim: CameraAnim, bImmediate: bool = ...): ...
	"""Stop playing all instances of the indicated CameraAnim.
@param bImmediate    True to stop it right now and ignore blend out, false to let it blend out as indicated."""

	def PlayCameraAnim(self, Anim: CameraAnim, Rate: float = ..., Scale: float = ..., BlendInTime: float = ..., BlendOutTime: float = ..., bLoop: bool = ..., bRandomStartTime: bool = ..., Duration: float = ..., PlaySpace: int = ..., UserPlaySpaceRot: Rotator = ...) -> CameraAnimInst: ...
	"""Play the indicated CameraAnim on this camera.

@param Anim The animation that should play on this instance.
@param Rate                          How fast to play the animation. 1.0 is normal.
@param Scale                         How 'intense' to play the animation. 1.0 is normal.
@param BlendInTime           Time to linearly ramp in.
@param BlendOutTime          Time to linearly ramp out.
@param bLoop                         True to loop the animation if it hits the end.
@param bRandomStartTime      Whether or not to choose a random time to start playing. Useful with bLoop=true and a duration to randomize things like shakes.
@param Duration                      Optional total playtime for this animation, including blends. 0 means to use animations natural duration, or infinite if looping.
@param PlaySpace                     Which space to play the animation in.
@param UserPlaySpaceRot  Custom play space, used when PlaySpace is UserDefined.
@return The CameraAnim instance, which can be stored to manipulate/stop the anim after the fact."""

	def SetManualCameraFade(self, InFadeAmount: float, Color: LinearColor, bInFadeAudio: bool): ...
	"""Turns on camera fading at the given opacity. Does not auto-animate, allowing user to animate themselves.
Call StopCameraFade to turn fading back off."""

	def StopCameraFade(self): ...
	"""Stops camera fading."""

	def StartCameraFade(self, FromAlpha: float, ToAlpha: float, Duration: float, Color: LinearColor, bShouldFadeAudio: bool = ..., bHoldWhenFinished: bool = ...): ...
	"""Does a camera fade to/from a solid color.  Animates automatically.
@param FromAlpha - Alpha at which to begin the fade. Range [0..1], where 0 is fully transparent and 1 is fully opaque solid color.
@param ToAlpha - Alpha at which to finish the fade.
@param Duration - How long the fade should take, in seconds.
@param Color - Color to fade to/from.
@param bShouldFadeAudio - True to fade audio volume along with the alpha of the solid color.
@param bHoldWhenFinished - True for fade to hold at the ToAlpha until explicitly stopped (e.g. with StopCameraFade)"""

	def StopAllCameraShakesFromSource(self, SourceComponent: CameraShakeSourceComponent, bImmediately: bool = ...): ...
	"""Stops playing all shakes originating from the given source."""

	def StopAllInstancesOfCameraShakeFromSource(self, Shake: CameraShakeBase, SourceComponent: CameraShakeSourceComponent, bImmediately: bool = ...): ...
	"""Stops playing all shakes of the given class originating from the given source."""

	def StopAllCameraShakes(self, bImmediately: bool = ...): ...
	"""Stops all active camera shakes on this camera."""

	def StopAllInstancesOfCameraShake(self, Shake: CameraShakeBase, bImmediately: bool = ...): ...
	"""Stops playing all shakes of the given class."""

	def StopCameraShake(self, ShakeInstance: CameraShakeBase, bImmediately: bool = ...): ...
	"""Immediately stops the given shake instance and invalidates it."""

	def StartMatineeCameraShakeFromSource(self, ShakeClass: MatineeCameraShake, SourceComponent: CameraShakeSourceComponent, Scale: float = ..., PlaySpace: int = ..., UserPlaySpaceRot: Rotator = ...) -> MatineeCameraShake: ...
	"""Backwards compatible method used by core BP redirectors. This is needed because the return value is specifically a Matinee camera shake,
which some BP logic often uses directly to set oscillator/anim properties."""

	def StartCameraShakeFromSource(self, ShakeClass: CameraShakeBase, SourceComponent: CameraShakeSourceComponent, Scale: float = ..., PlaySpace: int = ..., UserPlaySpaceRot: Rotator = ...) -> CameraShakeBase: ...
	"""Plays a camera shake on this camera.
@param Shake - The class of camera shake to play.
@param SourceComponent - The source from which the camera shake originates.
@param Scale - Applies an additional constant scale on top of the dynamic scale computed with the distance to the source
@param PlaySpace - Which coordinate system to play the shake in (affects oscillations and camera anims)
@param UserPlaySpaceRot - Coordinate system to play shake when PlaySpace == CAPS_UserDefined."""

	def StartMatineeCameraShake(self, ShakeClass: MatineeCameraShake, Scale: float = ..., PlaySpace: int = ..., UserPlaySpaceRot: Rotator = ...) -> MatineeCameraShake: ...
	"""Backwards compatible method used by core BP redirectors. This is needed because the return value is specifically a Matinee camera shake,
which some BP logic often uses directly to set oscillator/anim properties."""

	def StartCameraShake(self, ShakeClass: CameraShakeBase, Scale: float = ..., PlaySpace: int = ..., UserPlaySpaceRot: Rotator = ...) -> CameraShakeBase: ...
	"""Plays a camera shake on this camera.
@param Shake - The class of camera shake to play.
@param Scale - Scalar defining how 'intense' to play the shake. 1.0 is normal (as authored).
@param PlaySpace - Which coordinate system to play the shake in (affects oscillations and camera anims)
@param UserPlaySpaceRot - Coordinate system to play shake when PlaySpace == CAPS_UserDefined."""

	def ClearCameraLensEffects(self): ...
	"""Removes all camera lens effects."""

	def RemoveCameraLensEffect(self, Emitter: EmitterCameraLensEffectBase): ...
	"""Removes the given lens effect from the camera.
@param Emitter - the emitter actor to remove from the camera"""

	def AddCameraLensEffect(self, LensEffectEmitterClass: EmitterCameraLensEffectBase) -> EmitterCameraLensEffectBase: ...
	"""Creates a camera lens effect of the given class on this camera.
@param LensEffectEmitterClass - Class of lens effect emitter to create.
@return Returns the new emitter actor."""

	def GetCameraLocation(self) -> Vector: ...
	"""Returns camera's current location."""

	def GetCameraRotation(self) -> Rotator: ...
	"""Returns camera's current rotation."""

	def GetFOVAngle(self) -> float: ...
	"""Returns the camera's current full FOV angle, in degrees."""

	def RemoveCameraModifier(self, ModifierToRemove: CameraModifier) -> bool: ...
	"""Removes the given camera modifier from this camera (if it's on the camera in the first place) and discards it.
@return True if successfully removed, false otherwise."""

	def FindCameraModifierByClass(self, ModifierClass: CameraModifier) -> CameraModifier: ...
	"""Returns camera modifier for this camera of the given class, if it exists.
Exact class match only. If there are multiple modifiers of the same class, the first one is returned."""

	def AddNewCameraModifier(self, ModifierClass: CameraModifier) -> CameraModifier: ...
	"""Creates and initializes a new camera modifier of the specified class.
@param ModifierClass - The class of camera modifier to create.
@return Returns the newly created camera modifier."""

	def GetOwningPlayerController(self) -> PlayerController: ...
	"""Returns the PlayerController that owns this camera."""

	def OnPhotographyMultiPartCaptureEnd(self): ...
	"""Event triggered upon the end of a multi-part photograph capture, when manual
free-roaming photographic camera control is about to be returned to the user.
Here you may re-enable whatever was turned off within
OnPhotographyMultiPartCaptureStart."""

	def OnPhotographyMultiPartCaptureStart(self): ...
	"""Event triggered upon the start of a multi-part photograph capture (i.e. a
stereoscopic or 360-degree shot).  This is an ideal time to turn off
rendering effects that tile badly (UI, subtitles, vignette, very aggressive
bloom, etc; most of these are automatically disabled when
r.Photography.AutoPostprocess is 1)."""

	def OnPhotographySessionEnd(self): ...
	"""Event triggered upon leaving Photography mode (after unpausing, if
r.Photography.AutoPause is 1)."""

	def OnPhotographySessionStart(self): ...
	"""Event triggered upon entering Photography mode (before pausing, if
r.Photography.AutoPause is 1)."""

	def PhotographyCameraModify(self, NewCameraLocation: Vector, PreviousCameraLocation: Vector, OriginalCameraLocation: Vector) -> Vector: ...
	"""Implementable blueprint hook to allow a PlayerCameraManager subclass to
constrain or otherwise modify the camera during free-camera photography.
For example, a blueprint may wish to limit the distance from the camera's
original point, or forbid the camera from passing through walls.
NewCameraLocation contains the proposed new camera location.
PreviousCameraLocation contains the camera location in the previous frame.
OriginalCameraLocation contains the camera location before the game was put
into photography mode.
Return ResultCameraLocation as modified according to your constraints."""

	pass

class ApplicationLifecycleComponent(ActorComponent):
	"""Component to handle receiving notifications from the OS about application state (activated, suspended, termination, etc)."""

	@property
	def ApplicationWillDeactivateDelegate(self) -> typing.Any: ...
	"""This is called when the application is about to be deactivated (e.g., due to a phone call or SMS or the sleep button).
The game should be paused if possible, etc..."""

	@property
	def ApplicationHasReactivatedDelegate(self) -> typing.Any: ...
	"""Called when the application has been reactivated (reverse any processing done in the Deactivate delegate)"""

	@property
	def ApplicationWillEnterBackgroundDelegate(self) -> typing.Any: ...
	"""This is called when the application is being backgrounded (e.g., due to switching
to another app or closing it via the home button)
The game should release shared resources, save state, etc..., since it can be
terminated from the background state without any further warning."""

	@property
	def ApplicationHasEnteredForegroundDelegate(self) -> typing.Any: ...
	"""Called when the application is returning to the foreground (reverse any processing done in the EnterBackground delegate)"""

	@property
	def ApplicationWillTerminateDelegate(self) -> typing.Any: ...
	"""This *may* be called when the application is getting terminated by the OS.
There is no guarantee that this will ever be called on a mobile device,
save state when ApplicationWillEnterBackgroundDelegate is called instead."""

	@property
	def ApplicationShouldUnloadResourcesDelegate(self) -> typing.Any: ...
	"""Called when the OS is running low on resources and asks the application to free up any cached resources, drop graphics quality etc."""

	@property
	def ApplicationReceivedStartupArgumentsDelegate(self) -> typing.Any: ...
	"""Called with arguments passed to the application on statup, perhaps meta data passed on by another application which launched this one."""

	@property
	def OnTemperatureChangeDelegate(self) -> typing.Any: ...
	"""Called when temperature level has changed, and receives the severity"""

	@property
	def OnLowPowerModeDelegate(self) -> typing.Any: ...
	"""Called when we are in low power mode"""

	pass

class PrimitiveComponent(SceneComponent):
	"""PrimitiveComponents are SceneComponents that contain or generate some sort of geometry, generally to be rendered or used as collision data.
There are several subclasses for the various types of geometry, but the most common by far are the ShapeComponents (Capsule, Sphere, Box), StaticMeshComponent, and SkeletalMeshComponent.
ShapeComponents generate geometry that is used for collision detection but are not rendered, while StaticMeshComponents and SkeletalMeshComponents contain pre-built geometry that is rendered, but can also be used for collision detection."""

	@property
	def MinDrawDistance(self) -> float: ...
	"""The minimum distance at which the primitive should be rendered,
measured in world space units from the center of the primitive's bounding sphere to the camera position."""

	@property
	def LDMaxDrawDistance(self) -> float: ...
	"""Max draw distance exposed to LDs. The real max draw distance is the min (disregarding 0) of this and volumes affecting this object."""

	@property
	def CachedMaxDrawDistance(self) -> float: ...
	"""The distance to cull this primitive at.
A CachedMaxDrawDistance of 0 indicates that the primitive should not be culled by distance."""

	@property
	def DepthPriorityGroup(self) -> int: ...
	"""The scene depth priority group to draw the primitive in."""

	@property
	def ViewOwnerDepthPriorityGroup(self) -> int: ...
	"""The scene depth priority group to draw the primitive in, if it's being viewed by its owner."""

	@property
	def IndirectLightingCacheQuality(self) -> int: ...
	"""Quality of indirect lighting for Movable primitives.  This has a large effect on Indirect Lighting Cache update time."""

	@property
	def LightmapType(self) -> int: ...
	"""Controls the type of lightmap used for this component."""

	@property
	def bUseMaxLODAsImposter(self) -> bool: ...
	"""Use the Maximum LOD Mesh (imposter) instead of including Mesh data from this component in the Proxy Generation process"""

	@property
	def bBatchImpostersAsInstances(self) -> bool: ...
	"""If true, the proxy generation process will use instancing to render this imposter"""

	@property
	def bNeverDistanceCull(self) -> bool: ...
	"""When enabled this object will not be culled by distance. This is ignored if a child of a HLOD."""

	@property
	def bAlwaysCreatePhysicsState(self) -> bool: ...
	"""Indicates if we'd like to create physics state all the time (for collision and simulation).
If you set this to false, it still will create physics state if collision or simulation activated.
This can help performance if you'd like to avoid overhead of creating physics state when triggers"""

	@property
	def bMultiBodyOverlap(self) -> bool: ...
	"""If true, this component will generate individual overlaps for each overlapping physics body if it is a multi-body component. When false, this component will
generate only one overlap, regardless of how many physics bodies it has and how many of them are overlapping another component/body. This flag has no
influence on single body components."""

	@property
	def bTraceComplexOnMove(self) -> bool: ...
	"""If true, component sweeps with this component should trace against complex collision during movement (for example, each triangle of a mesh).
If false, collision will be resolved against simple collision bounds instead.
See: MoveComponent()"""

	@property
	def bReturnMaterialOnMove(self) -> bool: ...
	"""If true, component sweeps will return the material in their hit result.
See: MoveComponent(), FHitResult"""

	@property
	def bUseViewOwnerDepthPriorityGroup(self) -> bool: ...
	"""True if the primitive should be rendered using ViewOwnerDepthPriorityGroup if viewed by its owner."""

	@property
	def bAllowCullDistanceVolume(self) -> bool: ...
	"""Whether to accept cull distance volumes to modify cached cull distance."""

	@property
	def bHasMotionBlurVelocityMeshes(self) -> bool: ...
	"""True if the primitive has motion blur velocity meshes"""

	@property
	def bVisibleInReflectionCaptures(self) -> bool: ...
	"""If true, this component will be visible in reflection captures."""

	@property
	def bVisibleInRealTimeSkyCaptures(self) -> bool: ...
	"""If true, this component will be visible in real-time sky light reflection captures."""

	@property
	def bVisibleInRayTracing(self) -> bool: ...
	"""If true, this component will be visible in ray tracing effects. Turning this off will remove it from ray traced reflections, shadows, etc."""

	@property
	def bRenderInMainPass(self) -> bool: ...
	"""If true, this component will be rendered in the main pass (z prepass, basepass, transparency)"""

	@property
	def bRenderInDepthPass(self) -> bool: ...
	"""If true, this component will be rendered in the depth pass even if it's not rendered in the main pass"""

	@property
	def bReceivesDecals(self) -> bool: ...
	"""Whether the primitive receives decals."""

	@property
	def bOwnerNoSee(self) -> bool: ...
	"""If this is True, this component won't be visible when the view actor is the component's owner, directly or indirectly."""

	@property
	def bOnlyOwnerSee(self) -> bool: ...
	"""If this is True, this component will only be visible when the view actor is the component's owner, directly or indirectly."""

	@property
	def bTreatAsBackgroundForOcclusion(self) -> bool: ...
	"""Treat this primitive as part of the background for occlusion purposes. This can be used as an optimization to reduce the cost of rendering skyboxes, large ground planes that are part of the vista, etc."""

	@property
	def bUseAsOccluder(self) -> bool: ...
	"""Whether to render the primitive in the depth only pass.
This should generally be true for all objects, and let the renderer make decisions about whether to render objects in the depth only pass.
@todo - if any rendering features rely on a complete depth only pass, this variable needs to go away."""

	@property
	def bSelectable(self) -> bool: ...
	"""If this is True, this component can be selected in the editor."""

	@property
	def bForceMipStreaming(self) -> bool: ...
	"""If true, forces mips for textures used by this component to be resident when this component's level is loaded."""

	@property
	def bHasPerInstanceHitProxies(self) -> bool: ...
	"""If true a hit-proxy will be generated for each instance of instanced static meshes"""

	@property
	def CastShadow(self) -> bool: ...
	"""Controls whether the primitive component should cast a shadow or not."""

	@property
	def bAffectDynamicIndirectLighting(self) -> bool: ...
	"""Controls whether the primitive should inject light into the Light Propagation Volume.  This flag is only used if CastShadow is true. *"""

	@property
	def bAffectDistanceFieldLighting(self) -> bool: ...
	"""Controls whether the primitive should affect dynamic distance field lighting methods.  This flag is only used if CastShadow is true. *"""

	@property
	def bCastDynamicShadow(self) -> bool: ...
	"""Controls whether the primitive should cast shadows in the case of non precomputed shadowing.  This flag is only used if CastShadow is true. *"""

	@property
	def bCastStaticShadow(self) -> bool: ...
	"""Whether the object should cast a static shadow from shadow casting lights.  This flag is only used if CastShadow is true."""

	@property
	def bCastVolumetricTranslucentShadow(self) -> bool: ...
	"""Whether the object should cast a volumetric translucent shadow.
Volumetric translucent shadows are useful for primitives with smoothly changing opacity like particles representing a volume,
But have artifacts when used on highly opaque surfaces."""

	@property
	def bCastContactShadow(self) -> bool: ...
	"""Whether the object should cast contact shadows.
This flag is only used if CastShadow is true."""

	@property
	def bSelfShadowOnly(self) -> bool: ...
	"""When enabled, the component will only cast a shadow on itself and not other components in the world.
This is especially useful for first person weapons, and forces bCastInsetShadow to be enabled."""

	@property
	def bCastFarShadow(self) -> bool: ...
	"""When enabled, the component will be rendering into the far shadow cascades (only for directional lights)."""

	@property
	def bCastInsetShadow(self) -> bool: ...
	"""Whether this component should create a per-object shadow that gives higher effective shadow resolution.
Useful for cinematic character shadowing. Assumed to be enabled if bSelfShadowOnly is enabled."""

	@property
	def bCastCinematicShadow(self) -> bool: ...
	"""Whether this component should cast shadows from lights that have bCastShadowsFromCinematicObjectsOnly enabled.
This is useful for characters in a cinematic with special cinematic lights, where the cost of shadowmap rendering of the environment is undesired."""

	@property
	def bCastHiddenShadow(self) -> bool: ...
	"""If true, the primitive will cast shadows even if bHidden is true.
Controls whether the primitive should cast shadows when hidden.
This flag is only used if CastShadow is true."""

	@property
	def bCastShadowAsTwoSided(self) -> bool: ...
	"""Whether this primitive should cast dynamic shadows as if it were a two sided material."""

	@property
	def bLightAttachmentsAsGroup(self) -> bool: ...
	"""Whether to light this component and any attachments as a group.  This only has effect on the root component of an attachment tree.
When enabled, attached component shadowing settings like bCastInsetShadow, bCastVolumetricTranslucentShadow, etc, will be ignored.
This is useful for improving performance when multiple movable components are attached together."""

	@property
	def bExcludeFromLightAttachmentGroup(self) -> bool: ...
	"""If set, then it overrides any bLightAttachmentsAsGroup set in a parent."""

	@property
	def bReceiveMobileCSMShadows(self) -> bool: ...
	"""Mobile only:
If disabled this component will not receive CSM shadows. (Components that do not receive CSM may have reduced shading cost)"""

	@property
	def bSingleSampleShadowFromStationaryLights(self) -> bool: ...
	"""Whether the whole component should be shadowed as one from stationary lights, which makes shadow receiving much cheaper.
When enabled shadowing data comes from the volume lighting samples precomputed by Lightmass, which are very sparse.
This is currently only used on stationary directional lights."""

	@property
	def bIgnoreRadialImpulse(self) -> bool: ...
	"""Will ignore radial impulses applied to this component."""

	@property
	def bIgnoreRadialForce(self) -> bool: ...
	"""Will ignore radial forces applied to this component."""

	@property
	def bApplyImpulseOnDamage(self) -> bool: ...
	"""True for damage to this component to apply physics impulse, false to opt out of these impulses."""

	@property
	def bReplicatePhysicsToAutonomousProxy(self) -> bool: ...
	"""True if physics should be replicated to autonomous proxies. This should be true for
              server-authoritative simulations, and false for client authoritative simulations."""

	@property
	def bFillCollisionUnderneathForNavmesh(self) -> bool: ...
	"""If set, navmesh will not be generated under the surface of the geometry"""

	@property
	def AlwaysLoadOnClient(self) -> bool: ...
	"""If this is True, this component must always be loaded on clients, even if Hidden and CollisionEnabled is NoCollision."""

	@property
	def AlwaysLoadOnServer(self) -> bool: ...
	"""If this is True, this component must always be loaded on servers, even if Hidden and CollisionEnabled is NoCollision"""

	@property
	def bUseEditorCompositing(self) -> bool: ...
	"""Composite the drawing of this component onto the scene after post processing (only applies to editor drawing)"""

	@property
	def bRenderCustomDepth(self) -> bool: ...
	"""If true, this component will be rendered in the CustomDepth pass (usually used for outlines)"""

	@property
	def bHasCustomNavigableGeometry(self) -> int: ...
	"""If true then DoCustomNavigableGeometryExport will be called to collect navigable geometry of this component."""

	@property
	def CanCharacterStepUpOn(self) -> int: ...
	"""Determine whether a Character can step up onto this component.
This controls whether they can try to step up on it when they bump in to it, not whether they can walk on it after landing on it.
See: FWalkableSlopeOverride"""

	@property
	def LightingChannels(self) -> LightingChannels: ...
	"""Channels that this component should be in.  Lights with matching channels will affect the component.
These channels only apply to opaque materials, direct lighting, and dynamic lighting and shadowing."""

	@property
	def CustomDepthStencilWriteMask(self) -> int: ...
	"""Mask used for stencil buffer writes."""

	@property
	def CustomDepthStencilValue(self) -> int: ...
	"""Optionally write this 0-255 value to the stencil buffer in CustomDepth pass (Requires project setting or r.CustomDepth == 3)"""

	@property
	def TranslucencySortPriority(self) -> int: ...
	"""Translucent objects with a lower sort priority draw behind objects with a higher priority.
Translucent objects with the same priority are rendered from back-to-front based on their bounds origin.
This setting is also used to sort objects being drawn into a runtime virtual texture.

Ignored if the object is not translucent.  The default priority is zero.
Warning: This should never be set to a non-default value unless you know what you are doing, as it will prevent the renderer from sorting correctly.
It is especially problematic on dynamic gameplay effects."""

	@property
	def VisibilityId(self) -> int: ...
	"""Used for precomputed visibility"""

	@property
	def RuntimeVirtualTextures(self) -> typing.List[RuntimeVirtualTexture]: ...
	"""Array of runtime virtual textures into which we draw the mesh for this actor.
The material also needs to be set up to output to a virtual texture."""

	@property
	def VirtualTextureLodBias(self) -> int: ...
	"""Bias to the LOD selected for rendering to runtime virtual textures."""

	@property
	def VirtualTextureCullMips(self) -> int: ...
	"""Number of lower mips in the runtime virtual texture to skip for rendering this primitive.
Larger values reduce the effective draw distance in the runtime virtual texture.
This culling method doesn't take into account primitive size or virtual texture size."""

	@property
	def VirtualTextureMinCoverage(self) -> int: ...
	"""Set the minimum pixel coverage before culling from the runtime virtual texture.
Larger values reduce the effective draw distance in the runtime virtual texture."""

	@property
	def VirtualTextureRenderPassType(self) -> int: ...
	"""Controls if this component draws in the main pass as well as in the virtual texture."""

	@property
	def LpvBiasMultiplier(self) -> float: ...
	"""Multiplier used to scale the Light Propagation Volume light injection bias, to reduce light bleeding.
Set to 0 for no bias, 1 for default or higher for increased biasing (e.g. for
thin geometry such as walls)"""

	@property
	def BoundsScale(self) -> float: ...
	"""Scales the bounds of the object.
This is useful when using World Position Offset to animate the vertices of the object outside of its bounds.
Warning: Increasing the bounds of an object will reduce performance and shadow quality!
Currently only used by StaticMeshComponent and SkeletalMeshComponent."""

	@property
	def MoveIgnoreActors(self) -> typing.List[Actor]: ...
	"""Set of actors to ignore during component sweeps in MoveComponent().
All components owned by these actors will be ignored when this component moves or updates overlaps.
Components on the other Actor may also need to be told to do the same when they move.
Does not affect movement of this component when simulating physics.
See: IgnoreActorWhenMoving()"""

	@property
	def MoveIgnoreComponents(self) -> typing.List[PrimitiveComponent]: ...
	"""Set of components to ignore during component sweeps in MoveComponent().
These components will be ignored when this component moves or updates overlaps.
The other components may also need to be told to do the same when they move.
Does not affect movement of this component when simulating physics.
See: IgnoreComponentWhenMoving()"""

	@property
	def BodyInstance(self) -> typing.Any: ...
	"""Physics scene information for this component, holds a single rigid body with multiple shapes."""

	@property
	def OnComponentHit(self) -> typing.Any: ...
	"""Event called when a component hits (or is hit by) something solid. This could happen due to things like Character movement, using Set Location with 'sweep' enabled, or physics simulation.
For events when objects overlap (e.g. walking into a trigger) see the 'Overlap' event.

@note For collisions during physics simulation to generate hit events, 'Simulation Generates Hit Events' must be enabled for this component.
@note When receiving a hit from another object's movement, the directions of 'Hit.Normal' and 'Hit.ImpactNormal'
will be adjusted to indicate force from the other object against this object.
@note NormalImpulse will be filled in for physics-simulating bodies, but will be zero for swept-component blocking collisions."""

	@property
	def OnComponentBeginOverlap(self) -> typing.Any: ...
	"""Event called when something starts to overlaps this component, for example a player walking into a trigger.
For events when objects have a blocking collision, for example a player hitting a wall, see 'Hit' events.

@note Both this component and the other one must have GetGenerateOverlapEvents() set to true to generate overlap events.
@note When receiving an overlap from another object's movement, the directions of 'Hit.Normal' and 'Hit.ImpactNormal'
will be adjusted to indicate force from the other object against this object."""

	@property
	def OnComponentEndOverlap(self) -> typing.Any: ...
	"""Event called when something stops overlapping this component
@note Both this component and the other one must have GetGenerateOverlapEvents() set to true to generate overlap events."""

	@property
	def OnComponentWake(self) -> typing.Any: ...
	"""Event called when the underlying physics objects is woken up"""

	@property
	def OnComponentSleep(self) -> typing.Any: ...
	"""Event called when the underlying physics objects is put to sleep"""

	@property
	def OnBeginCursorOver(self) -> typing.Any: ...
	"""Event called when the mouse cursor is moved over this component and mouse over events are enabled in the player controller"""

	@property
	def OnEndCursorOver(self) -> typing.Any: ...
	"""Event called when the mouse cursor is moved off this component and mouse over events are enabled in the player controller"""

	@property
	def OnClicked(self) -> typing.Any: ...
	"""Event called when the left mouse button is clicked while the mouse is over this component and click events are enabled in the player controller"""

	@property
	def OnReleased(self) -> typing.Any: ...
	"""Event called when the left mouse button is released while the mouse is over this component click events are enabled in the player controller"""

	@property
	def OnInputTouchBegin(self) -> typing.Any: ...
	"""Event called when a touch input is received over this component when touch events are enabled in the player controller"""

	@property
	def OnInputTouchEnd(self) -> typing.Any: ...
	"""Event called when a touch input is released over this component when touch events are enabled in the player controller"""

	@property
	def OnInputTouchEnter(self) -> typing.Any: ...
	"""Event called when a finger is moved over this component when touch over events are enabled in the player controller"""

	@property
	def OnInputTouchLeave(self) -> typing.Any: ...
	"""Event called when a finger is moved off this component when touch over events are enabled in the player controller"""

	def CanCharacterStepUp(self, Pawn: Pawn) -> bool: ...
	"""Return true if the given Pawn can step up onto this component.
This controls whether they can try to step up on it when they bump in to it, not whether they can walk on it after landing on it.
@param Pawn the Pawn that wants to step onto this component.
@see CanCharacterStepUpOn"""

	def SetCullDistance(self, NewCullDistance: float): ...
	"""Changes the value of CullDistance.
@param NewCullDistance - The value to assign to CullDistance."""

	def SetPhysMaterialOverride(self, NewPhysMaterial: PhysicalMaterial): ...
	"""Changes the current PhysMaterialOverride for this component.
Note that if physics is already running on this component, this will _not_ alter its mass/inertia etc,
it will only change its surface properties like friction."""

	def SetCollisionResponseToAllChannels(self, NewResponse: int): ...
	"""Changes all ResponseToChannels container for this PrimitiveComponent. to be NewResponse

@param       NewResponse  What the new response should be to the supplied Channel"""

	def SetCollisionResponseToChannel(self, Channel: int, NewResponse: int): ...
	"""Changes a member of the ResponseToChannels container for this PrimitiveComponent.

@param       Channel      The channel to change the response of
@param       NewResponse  What the new response should be to the supplied Channel"""

	def IsAnyRigidBodyAwake(self) -> bool: ...
	"""Returns if any body in this component is currently awake and simulating."""

	def SetAllUseCCD(self, InUseCCD: bool): ...
	"""Set whether all bodies in this component should use Continuous Collision Detection"""

	def SetUseCCD(self, InUseCCD: bool, BoneName: str = ...): ...
	"""Set whether this component should use Continuous Collision Detection"""

	def ScaleByMomentOfInertia(self, InputVector: Vector, BoneName: str = ...) -> Vector: ...
	"""Scales the given vector by the world space moment of inertia. Useful for computing the torque needed to rotate an object."""

	def GetInertiaTensor(self, BoneName: str = ...) -> Vector: ...
	"""Returns the inertia tensor of this component in kg cm^2. The inertia tensor is in local component space."""

	def GetMass(self) -> float: ...
	"""Returns the mass of this component in kg."""

	def SetMassOverrideInKg(self, BoneName: str = ..., MassInKg: float = ..., bOverrideMass: bool = ...): ...
	"""Override the mass (in Kg) of a single physics body.
Note that in the case where multiple bodies are attached together, the override mass will be set for the entire group.
Set the Override Mass to false if you want to reset the body's mass to the auto-calculated physx mass."""

	def SetAllMassScale(self, InMassScale: float = ...): ...
	"""Change the mass scale used fo all bodies in this component"""

	def GetMassScale(self, BoneName: str = ...) -> float: ...
	"""Returns the mass scale used to calculate the mass of a single physics body"""

	def SetMassScale(self, BoneName: str = ..., InMassScale: float = ...): ...
	"""Change the mass scale used to calculate the mass of a single physics body"""

	def GetAngularDamping(self) -> float: ...
	"""Returns the angular damping of this component."""

	def SetAngularDamping(self, InDamping: float): ...
	"""Sets the angular damping of this component."""

	def GetLinearDamping(self) -> float: ...
	"""Returns the linear damping of this component."""

	def SetLinearDamping(self, InDamping: float): ...
	"""Sets the linear damping of this component."""

	def IsGravityEnabled(self) -> bool: ...
	"""Returns whether this component is affected by gravity. Returns always false if the component is not simulated."""

	def SetEnableGravity(self, bGravityEnabled: bool): ...
	"""Enables/disables whether this component is affected by gravity. This applies only to components with bSimulatePhysics set to true."""

	def WakeAllRigidBodies(self): ...
	"""Ensure simulation is running for all bodies in this component."""

	def SetAllPhysicsAngularVelocityInRadians(self, NewAngVel: Vector, bAddToCurrent: bool = ...): ...
	"""Set the angular velocity of all bodies in this component.

@param NewAngVel                New angular velocity to apply to physics, in radians per second.
@param bAddToCurrent    If true, NewAngVel is added to the existing angular velocity of all bodies."""

	def SetAllPhysicsAngularVelocityInDegrees(self, NewAngVel: Vector, bAddToCurrent: bool = ...): ...
	"""Set the angular velocity of all bodies in this component.

@param NewAngVel                New angular velocity to apply to physics, in degrees per second.
@param bAddToCurrent    If true, NewAngVel is added to the existing angular velocity of all bodies."""

	def GetCollisionObjectType(self) -> int: ...
	"""Gets the collision object type"""

	def GetCollisionResponseToChannel(self, Channel: int) -> int: ...
	"""Gets the response type given a specific channel"""

	def IsPhysicsCollisionEnabled(self) -> bool: ...
	"""Utility to see if there is any physics collision enabled on this component."""

	def IsQueryCollisionEnabled(self) -> bool: ...
	"""Utility to see if there is any query collision enabled on this component."""

	def IsCollisionEnabled(self) -> bool: ...
	"""Utility to see if there is any form of collision (query or physics) enabled on this component."""

	def GetCollisionEnabled(self) -> int: ...
	"""Returns the form of collision for this component"""

	def GetClosestPointOnCollision(self, Point: Vector, BoneName: str = ...) -> typing.Tuple[float, Vector]: ...
	"""Returns the distance and closest point to the collision surface.
Component must have simple collision to be queried for closest point.

@param Point                          World 3D vector
@param OutPointOnBody         Point on the surface of collision closest to Point
@param BoneName                       If a SkeletalMeshComponent, name of body to set center of mass of. 'None' indicates root body.

@return               Success if returns > 0.f, if returns 0.f, it is either not convex or inside of the point
                              If returns < 0.f, this primitive does not have collsion"""

	def GetNumMaterials(self) -> int: ...
	"""Return number of material elements in this primitive"""

	def SetRenderInMainPass(self, bValue: bool): ...
	"""Sets bRenderInMainPass property and marks the render state dirty."""

	def SetCustomDepthStencilWriteMask(self, WriteMaskBit: int): ...
	"""Sets the CustomDepth stencil write mask and marks the render state dirty."""

	def SetCustomDepthStencilValue(self, Value: int): ...
	"""Sets the CustomDepth stencil value (0 - 255) and marks the render state dirty."""

	def SetRenderCustomDepth(self, bValue: bool): ...
	"""Sets the bRenderCustomDepth property and marks the render state dirty."""

	def SphereOverlapComponent(self, InSphereCentre: Vector, InSphereRadius: float, bTraceComplex: bool, bShowTrace: bool, bPersistentShowTrace: bool) -> typing.Tuple[bool, Vector, Vector, str, HitResult]: ...
	"""Perform a sphere overlap against a single component
@param InSphereCentre The centre of the sphere to overlap with the component
@param InSphereRadius The Radius of the sphere to overlap with the component
@param bTraceComplex Whether or not to trace the complex physics representation or just the simple representation
@param bShowTrace Whether or not to draw the trace in the world (for debugging)
@param bPersistentShowTrace Whether or not to make the debugging draw stay in the world permanently"""

	def BoxOverlapComponent(self, InBoxCentre: Vector, InBox: Box, bTraceComplex: bool, bShowTrace: bool, bPersistentShowTrace: bool) -> typing.Tuple[bool, Vector, Vector, str, HitResult]: ...
	"""Perform a box overlap against a single component as an AABB (No rotation)
@param InBoxCentre The centre of the box to overlap with the component
@param InBox Description of the box to use in the overlap
@param bTraceComplex Whether or not to trace the complex physics representation or just the simple representation
@param bShowTrace Whether or not to draw the trace in the world (for debugging)
@param bPersistentShowTrace Whether or not to make the debugging draw stay in the world permanently"""

	def SphereTraceComponent(self, TraceStart: Vector, TraceEnd: Vector, SphereRadius: float, bTraceComplex: bool, bShowTrace: bool, bPersistentShowTrace: bool) -> typing.Tuple[bool, Vector, Vector, str, HitResult]: ...
	"""Perform a sphere trace against a single component
@param TraceStart The start of the trace in world-space
@param TraceEnd The end of the trace in world-space
@param SphereRadius Radius of the sphere to trace against the component
@param bTraceComplex Whether or not to trace the complex physics representation or just the simple representation
@param bShowTrace Whether or not to draw the trace in the world (for debugging)
@param bPersistentShowTrace Whether or not to make the debugging draw stay in the world permanently"""

	def LineTraceComponent(self, TraceStart: Vector, TraceEnd: Vector, bTraceComplex: bool, bShowTrace: bool, bPersistentShowTrace: bool) -> typing.Tuple[bool, Vector, Vector, str, HitResult]: ...
	"""Perform a line trace against a single component
@param TraceStart The start of the trace in world-space
@param TraceEnd The end of the trace in world-space
@param bTraceComplex Whether or not to trace the complex physics representation or just the simple representation
@param bShowTrace Whether or not to draw the trace in the world (for debugging)
@param bPersistentShowTrace Whether or not to make the debugging draw stay in the world permanently"""

	def SetCollisionObjectType(self, Channel: int): ...
	"""Changes the collision channel that this object uses when it moves
@param      Channel     The new channel for this component to use"""

	def GetCollisionProfileName(self) -> str: ...
	"""Get the collision profile name"""

	def SetCollisionProfileName(self, InCollisionProfileName: str, bUpdateOverlaps: bool = ...): ...
	"""Set Collision Profile Name
This function is called by constructors when they set ProfileName
This will change current CollisionProfileName to be this, and overwrite Collision Setting

@param InCollisionProfileName : New Profile Name"""

	def SetCollisionEnabled(self, NewType: int): ...
	"""Controls what kind of collision is enabled for this body"""

	def SetReceivesDecals(self, bNewReceivesDecals: bool): ...
	"""Changes the value of bReceivesDecals."""

	def SetTranslucentSortPriority(self, NewTranslucentSortPriority: int): ...
	"""Changes the value of TranslucentSortPriority."""

	def SetSingleSampleShadowFromStationaryLights(self, bNewSingleSampleShadowFromStationaryLights: bool): ...
	"""Changes the value of bSingleSampleShadowFromStationaryLights."""

	def SetExcludeFromLightAttachmentGroup(self, bInExcludeFromLightAttachmentGroup: bool): ...
	"""Changes the value of ExcludeFromLightAttachmentGroup."""

	def SetLightAttachmentsAsGroup(self, bInLightAttachmentsAsGroup: bool): ...
	"""Changes the value of LightAttachmentsAsGroup."""

	def SetCastInsetShadow(self, bInCastInsetShadow: bool): ...
	"""Changes the value of CastInsetShadow."""

	def SetCastShadow(self, NewCastShadow: bool): ...
	"""Changes the value of CastShadow."""

	def SetOnlyOwnerSee(self, bNewOnlyOwnerSee: bool): ...
	"""Changes the value of bOnlyOwnerSee."""

	def SetOwnerNoSee(self, bNewOwnerNoSee: bool): ...
	"""Changes the value of bOwnerNoSee."""

	def SetNotifyRigidBodyCollision(self, bNewNotifyRigidBodyCollision: bool): ...
	"""Changes the value of bNotifyRigidBodyCollision"""

	def PutRigidBodyToSleep(self, BoneName: str = ...): ...
	"""Force a single body back to sleep.
@param  BoneName        If a SkeletalMeshComponent, name of body to put to sleep. 'None' indicates root body."""

	def WakeRigidBody(self, BoneName: str = ...): ...
	"""'Wake' physics simulation for a single body.
@param  BoneName        If a SkeletalMeshComponent, name of body to wake. 'None' indicates root body."""

	def SetCenterOfMass(self, CenterOfMassOffset: Vector, BoneName: str = ...): ...
	"""Set the center of mass of a single body. This will offset the physx-calculated center of mass.
Note that in the case where multiple bodies are attached together, the center of mass will be set for the entire group.
@param CenterOfMassOffset               User specified offset for the center of mass of this object, from the calculated location.
@param BoneName                 If a SkeletalMeshComponent, name of body to set center of mass of. 'None' indicates root body."""

	def GetCenterOfMass(self, BoneName: str = ...) -> Vector: ...
	"""Get the center of mass of a single body. In the case of a welded body this will return the center of mass of the entire welded body (including its parent and children)
Objects that are not simulated return (0,0,0) as they do not have COM
@param BoneName                 If a SkeletalMeshComponent, name of body to get center of mass of. 'None' indicates root body."""

	def GetPhysicsAngularVelocityInRadians(self, BoneName: str = ...) -> Vector: ...
	"""Get the angular velocity of a single body, in radians per second.
@param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body."""

	def GetPhysicsAngularVelocityInDegrees(self, BoneName: str = ...) -> Vector: ...
	"""Get the angular velocity of a single body, in degrees per second.
@param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body."""

	def SetPhysicsMaxAngularVelocityInRadians(self, NewMaxAngVel: float, bAddToCurrent: bool = ..., BoneName: str = ...): ...
	"""Set the maximum angular velocity of a single body.

@param NewMaxAngVel             New maximum angular velocity to apply to body, in radians per second.
@param bAddToCurrent    If true, NewMaxAngVel is added to the existing maximum angular velocity of the body.
@param BoneName                 If a SkeletalMeshComponent, name of body to modify maximum angular velocity of. 'None' indicates root body."""

	def SetPhysicsMaxAngularVelocityInDegrees(self, NewMaxAngVel: float, bAddToCurrent: bool = ..., BoneName: str = ...): ...
	"""Set the maximum angular velocity of a single body.

@param NewMaxAngVel             New maximum angular velocity to apply to body, in degrees per second.
@param bAddToCurrent    If true, NewMaxAngVel is added to the existing maximum angular velocity of the body.
@param BoneName                 If a SkeletalMeshComponent, name of body to modify maximum angular velocity of. 'None' indicates root body."""

	def SetPhysicsAngularVelocityInDegrees(self, NewAngVel: Vector, bAddToCurrent: bool = ..., BoneName: str = ...): ...
	"""Set the angular velocity of a single body.
This should be used cautiously - it may be better to use AddTorque or AddImpulse.

@param NewAngVel                New angular velocity to apply to body, in degrees per second.
@param bAddToCurrent    If true, NewAngVel is added to the existing angular velocity of the body.
@param BoneName                 If a SkeletalMeshComponent, name of body to modify angular velocity of. 'None' indicates root body."""

	def SetPhysicsAngularVelocityInRadians(self, NewAngVel: Vector, bAddToCurrent: bool = ..., BoneName: str = ...): ...
	"""Set the angular velocity of a single body.
This should be used cautiously - it may be better to use AddTorque or AddImpulse.

@param NewAngVel                New angular velocity to apply to body, in radians per second.
@param bAddToCurrent    If true, NewAngVel is added to the existing angular velocity of the body.
@param BoneName                 If a SkeletalMeshComponent, name of body to modify angular velocity of. 'None' indicates root body."""

	def SetAllPhysicsLinearVelocity(self, NewVel: Vector, bAddToCurrent: bool = ...): ...
	"""Set the linear velocity of all bodies in this component.

@param NewVel                   New linear velocity to apply to physics.
@param bAddToCurrent    If true, NewVel is added to the existing velocity of the body."""

	def GetPhysicsLinearVelocityAtPoint(self, Point: Vector, BoneName: str = ...) -> Vector: ...
	"""Get the linear velocity of a point on a single body.
@param Point                    Point is specified in world space.
@param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body."""

	def GetPhysicsLinearVelocity(self, BoneName: str = ...) -> Vector: ...
	"""Get the linear velocity of a single body.
@param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body."""

	def SetPhysicsLinearVelocity(self, NewVel: Vector, bAddToCurrent: bool = ..., BoneName: str = ...): ...
	"""Set the linear velocity of a single body.
This should be used cautiously - it may be better to use AddForce or AddImpulse.

@param NewVel                   New linear velocity to apply to physics.
@param bAddToCurrent    If true, NewVel is added to the existing velocity of the body.
@param BoneName                 If a SkeletalMeshComponent, name of body to modify velocity of. 'None' indicates root body."""

	def AddTorqueInDegrees(self, Torque: Vector, BoneName: str = ..., bAccelChange: bool = ...): ...
	"""Add a torque to a single rigid body.
@param Torque           Torque to apply. Direction is axis of rotation and magnitude is strength of torque.
@param BoneName         If a SkeletalMeshComponent, name of body to apply torque to. 'None' indicates root body.
@param bAccelChange If true, Torque is taken as a change in angular acceleration instead of a physical torque (i.e. mass will have no effect)."""

	def AddTorqueInRadians(self, Torque: Vector, BoneName: str = ..., bAccelChange: bool = ...): ...
	"""Add a torque to a single rigid body.
@param Torque           Torque to apply. Direction is axis of rotation and magnitude is strength of torque.
@param BoneName         If a SkeletalMeshComponent, name of body to apply torque to. 'None' indicates root body.
@param bAccelChange If true, Torque is taken as a change in angular acceleration instead of a physical torque (i.e. mass will have no effect)."""

	def AddRadialForce(self, Origin: Vector, Radius: float, Strength: float, Falloff: int, bAccelChange: bool = ...): ...
	"""Add a force to all bodies in this component, originating from the supplied world-space location.

@param Origin           Origin of force in world space.
@param Radius           Radius within which to apply the force.
@param Strength         Strength of force to apply.
@param Falloff              Allows you to control the strength of the force as a function of distance from Origin.
@param bAccelChange If true, Strength is taken as a change in acceleration instead of a physical force (i.e. mass will have no effect)."""

	def AddForceAtLocationLocal(self, Force: Vector, Location: Vector, BoneName: str = ...): ...
	"""Add a force to a single rigid body at a particular location. Both Force and Location should be in body space.
This is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.

@param Force            Force vector to apply. Magnitude indicates strength of force.
@param Location         Location to apply force, in component space.
@param BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body."""

	def AddForceAtLocation(self, Force: Vector, Location: Vector, BoneName: str = ...): ...
	"""Add a force to a single rigid body at a particular location in world space.
This is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.

@param Force            Force vector to apply. Magnitude indicates strength of force.
@param Location         Location to apply force, in world space.
@param BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body."""

	def AddForce(self, Force: Vector, BoneName: str = ..., bAccelChange: bool = ...): ...
	"""Add a force to a single rigid body.
This is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.

@param  Force            Force vector to apply. Magnitude indicates strength of force.
@param  BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body.
@param  bAccelChange If true, Force is taken as a change in acceleration instead of a physical force (i.e. mass will have no effect)."""

	def AddRadialImpulse(self, Origin: Vector, Radius: float, Strength: float, Falloff: int, bVelChange: bool = ...): ...
	"""Add an impulse to all rigid bodies in this component, radiating out from the specified position.

@param Origin                Point of origin for the radial impulse blast, in world space
@param Radius                Size of radial impulse. Beyond this distance from Origin, there will be no affect.
@param Strength              Maximum strength of impulse applied to body.
@param Falloff               Allows you to control the strength of the impulse as a function of distance from Origin.
@param bVelChange    If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no effect)."""

	def AddImpulseAtLocation(self, Impulse: Vector, Location: Vector, BoneName: str = ...): ...
	"""Add an impulse to a single rigid body at a specific location.

@param  Impulse         Magnitude and direction of impulse to apply.
@param  Location        Point in world space to apply impulse at.
@param  BoneName        If a SkeletalMeshComponent, name of bone to apply impulse to. 'None' indicates root body."""

	def AddAngularImpulseInDegrees(self, Impulse: Vector, BoneName: str = ..., bVelChange: bool = ...): ...
	"""Add an angular impulse to a single rigid body. Good for one time instant burst.

@param  AngularImpulse  Magnitude and direction of impulse to apply. Direction is axis of rotation.
@param  BoneName        If a SkeletalMeshComponent, name of body to apply angular impulse to. 'None' indicates root body.
@param  bVelChange      If true, the Strength is taken as a change in angular velocity instead of an impulse (ie. mass will have no effect)."""

	def AddAngularImpulseInRadians(self, Impulse: Vector, BoneName: str = ..., bVelChange: bool = ...): ...
	"""Add an angular impulse to a single rigid body. Good for one time instant burst.

@param  AngularImpulse  Magnitude and direction of impulse to apply. Direction is axis of rotation.
@param  BoneName        If a SkeletalMeshComponent, name of body to apply angular impulse to. 'None' indicates root body.
@param  bVelChange      If true, the Strength is taken as a change in angular velocity instead of an impulse (ie. mass will have no effect)."""

	def AddImpulse(self, Impulse: Vector, BoneName: str = ..., bVelChange: bool = ...): ...
	"""Add an impulse to a single rigid body. Good for one time instant burst.

@param  Impulse         Magnitude and direction of impulse to apply.
@param  BoneName        If a SkeletalMeshComponent, name of body to apply impulse to. 'None' indicates root body.
@param  bVelChange      If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no effect)."""

	def SetConstraintMode(self, ConstraintMode: int): ...
	"""Sets the constraint mode of the component.
@param ConstraintMode The type of constraint to use."""

	def SetSimulatePhysics(self, bSimulate: bool): ...
	"""Sets whether or not a single body should use physics simulation, or should be 'fixed' (kinematic).
Note that if this component is currently attached to something, beginning simulation will detach it.

@param  bSimulate       New simulation state for single body"""

	def SetWalkableSlopeOverride(self, NewOverride: WalkableSlopeOverride): ...
	"""Sets a new slope override for this component instance."""

	def GetWalkableSlopeOverride(self) -> WalkableSlopeOverride: ...
	"""Returns the slope override struct for this component."""

	def GetMaterialFromCollisionFaceIndex(self, FaceIndex: int) -> typing.Tuple[MaterialInterface, int]: ...
	"""Try and retrieve the material applied to a particular collision face of mesh. Used with face index returned from collision trace.
     @param  FaceIndex               Face index from hit result that was hit by a trace
     @param  SectionIndex    Section of the mesh that the face belongs to
     @return                                 Material applied to section that the hit face belongs to"""

	def CreateDynamicMaterialInstance(self, ElementIndex: int, SourceMaterial: MaterialInterface = ..., OptionalName: str = ...) -> MaterialInstanceDynamic: ...
	"""Creates a Dynamic Material Instance for the specified element index, optionally from the supplied material.
@param ElementIndex - The index of the skin to replace the material for.  If invalid, the material is unchanged and NULL is returned."""

	def SetMaterialByName(self, MaterialSlotName: str, Material: MaterialInterface): ...
	"""Changes the material applied to an element of the mesh.
@param MaterialSlotName - The slot name to access the material of.
@return the material used by the indexed element of this mesh."""

	def SetMaterial(self, ElementIndex: int, Material: MaterialInterface): ...
	"""Changes the material applied to an element of the mesh.
@param ElementIndex - The element to access the material of.
@return the material used by the indexed element of this mesh."""

	def GetMaterial(self, ElementIndex: int) -> MaterialInterface: ...
	"""Returns the material used by the element at the specified index
@param ElementIndex - The element to access the material of.
@return the material used by the indexed element of this mesh."""

	def SetBoundsScale(self, NewBoundsScale: float = ...): ...
	"""Scale the bounds of this object, used for frustum culling. Useful for features like WorldPositionOffset."""

	def GetOverlappingComponents(self) -> typing.List[PrimitiveComponent]: ...
	"""Returns unique list of components this component is overlapping."""

	def GetOverlappingActors(self, ClassFilter: Actor = ...) -> typing.List[Actor]: ...
	"""Returns a list of actors that this component is overlapping.
@param OverlappingActors             [out] Returned list of overlapping actors
@param ClassFilter                   [optional] If set, only returns actors of this class or subclasses"""

	def IsOverlappingActor(self, Other: Actor) -> bool: ...
	"""Check whether this component is overlapping any component of the given Actor.
@param Other Actor to test this component against.
@return Whether this component is overlapping any component of the given Actor."""

	def IsOverlappingComponent(self, OtherComp: PrimitiveComponent) -> bool: ...
	"""Check whether this component is overlapping another component.
@param OtherComp Component to test this component against.
@return Whether this component is overlapping another component."""

	def SetDefaultCustomPrimitiveDataVector4(self, DataIndex: int, Value: Vector4): ...
	"""Set default custom primitive data, four floats at once, from index DataIndex to index DataIndex + 3, and marks the render state dirty"""

	def SetDefaultCustomPrimitiveDataVector3(self, DataIndex: int, Value: Vector): ...
	"""Set default custom primitive data, three floats at once, from index DataIndex to index DataIndex + 2, and marks the render state dirty"""

	def SetDefaultCustomPrimitiveDataVector2(self, DataIndex: int, Value: Vector2D): ...
	"""Set default custom primitive data, two floats at once, from index DataIndex to index DataIndex + 1, and marks the render state dirty"""

	def SetDefaultCustomPrimitiveDataFloat(self, DataIndex: int, Value: float): ...
	"""Set default custom primitive data at index DataIndex, and marks the render state dirty"""

	def SetCustomPrimitiveDataVector4(self, DataIndex: int, Value: Vector4): ...
	"""Set custom primitive data, four floats at once, from index DataIndex to index DataIndex + 3. This sets the run-time data only, so it doesn't serialize."""

	def SetCustomPrimitiveDataVector3(self, DataIndex: int, Value: Vector): ...
	"""Set custom primitive data, three floats at once, from index DataIndex to index DataIndex + 2. This sets the run-time data only, so it doesn't serialize."""

	def SetCustomPrimitiveDataVector2(self, DataIndex: int, Value: Vector2D): ...
	"""Set custom primitive data, two floats at once, from index DataIndex to index DataIndex + 1. This sets the run-time data only, so it doesn't serialize."""

	def SetCustomPrimitiveDataFloat(self, DataIndex: int, Value: float): ...
	"""Set custom primitive data at index DataIndex. This sets the run-time data only, so it doesn't serialize."""

	def ClearMoveIgnoreComponents(self): ...
	"""Clear the list of components we ignore when moving."""

	def CopyArrayOfMoveIgnoreComponents(self) -> typing.List[PrimitiveComponent]: ...
	"""Returns the list of actors we currently ignore when moving."""

	def IgnoreComponentWhenMoving(self, Component: PrimitiveComponent, bShouldIgnore: bool): ...
	"""Tells this component whether to ignore collision with another component when this component is moved.
The other components may also need to be told to do the same when they move.
Does not affect movement of this component when simulating physics."""

	def ClearMoveIgnoreActors(self): ...
	"""Clear the list of actors we ignore when moving."""

	def CopyArrayOfMoveIgnoreActors(self) -> typing.List[Actor]: ...
	"""Returns the list of actors we currently ignore when moving."""

	def IgnoreActorWhenMoving(self, Actor: Actor, bShouldIgnore: bool): ...
	"""Tells this component whether to ignore collision with all components of a specific Actor when this component is moved.
Components on the other Actor may also need to be told to do the same when they move.
Does not affect movement of this component when simulating physics."""

	def WasRecentlyRendered(self, Tolerance: float = ...) -> bool: ...
	"""Returns true if this component has been rendered 'recently', with a tolerance in seconds to define what 'recent' means.
e.g.: If a tolerance of 0.1 is used, this function will return true only if the actor was rendered in the last 0.1 seconds of game time.

@param Tolerance  How many seconds ago the actor last render time can be and still count as having been 'recently' rendered.
@return Whether this actor was recently rendered."""

	def SetLightingChannels(self, bChannel0: bool, bChannel1: bool, bChannel2: bool): ...
	"""Set Lighting Channels"""

	def SetGenerateOverlapEvents(self, bInGenerateOverlapEvents: bool): ...
	"""Modifies value returned by GetGenerateOverlapEvents()"""

	def GetGenerateOverlapEvents(self) -> bool: ...
	"""If true, this component will generate overlap events when it is overlapping other components (eg Begin Overlap).
Both components (this and the other) must have this enabled for overlap events to occur.

@see [Overlap Events](https://docs.unrealengine.com/latest/INT/Engine/Physics/Collision/index.html#overlapandgenerateoverlapevents)
@see UpdateOverlaps(), BeginComponentOverlap(), EndComponentOverlap()"""

	pass

class ArrowComponent(PrimitiveComponent):
	"""A simple arrow rendered using lines. Useful for indicating which way an object is facing."""

	@property
	def ArrowColor(self) -> Color: ...
	"""Color to draw arrow"""

	@property
	def ArrowSize(self) -> float: ...
	"""Relative size to scale drawn arrow by"""

	@property
	def ArrowLength(self) -> float: ...
	"""Total length of drawn arrow including head"""

	@property
	def ScreenSize(self) -> float: ...
	"""The size on screen to limit this arrow to (in screen space)"""

	@property
	def bIsScreenSizeScaled(self) -> bool: ...
	"""Set to limit the screen size of this arrow"""

	@property
	def bTreatAsASprite(self) -> bool: ...
	"""If true, don't show the arrow when EngineShowFlags.BillboardSprites is disabled."""

	def SetArrowColor(self, NewColor: LinearColor): ...
	"""Updates the arrow's colour, and tells it to refresh"""

	pass

class AudioComponent(SceneComponent):
	"""AudioComponent is used to play a Sound

See: https://docs.unrealengine.com/latest/INT/Audio/Overview/index.html
See: USoundBase"""

	@property
	def Sound(self) -> SoundBase: ...
	"""The sound to be played"""

	@property
	def InstanceParameters(self) -> typing.List[AudioComponentParam]: ...
	"""Array of per-instance parameters for this AudioComponent."""

	@property
	def SoundClassOverride(self) -> SoundClass: ...
	"""Optional sound group this AudioComponent belongs to"""

	@property
	def bAutoDestroy(self) -> bool: ...
	"""Auto destroy this component on completion"""

	@property
	def bStopWhenOwnerDestroyed(self) -> bool: ...
	"""Stop sound when owner is destroyed"""

	@property
	def bShouldRemainActiveIfDropped(self) -> bool: ...
	"""Whether the wave instances should remain active if they're dropped by the prioritization code. Useful for e.g. vehicle sounds that shouldn't cut out."""

	@property
	def bAllowSpatialization(self) -> bool: ...
	"""Overrides spatialization enablement in either the attenuation asset or on this audio component's attenuation settings override."""

	@property
	def bOverrideAttenuation(self) -> bool: ...
	"""Allows defining attenuation settings directly on this audio component without using an attenuation settings asset."""

	@property
	def bOverrideSubtitlePriority(self) -> bool: ...
	"""Whether or not to override the sound's subtitle priority."""

	@property
	def bIsUISound(self) -> bool: ...
	"""Whether or not this sound plays when the game is paused in the UI"""

	@property
	def bEnableLowPassFilter(self) -> bool: ...
	"""Whether or not to apply a low-pass filter to the sound that plays in this audio component."""

	@property
	def bOverridePriority(self) -> bool: ...
	"""Override Priority"""

	@property
	def bSuppressSubtitles(self) -> bool: ...
	"""If true, subtitles in the sound data will be ignored."""

	@property
	def bAutoManageAttachment(self) -> bool: ...
	"""True if we should automatically attach to AutoAttachParent when Played, and detach from our parent when playback is completed.
This overrides any current attachment that may be present at the time of activation (deferring initial attachment until activation, if AutoAttachParent is null).
If enabled, this AudioComponent's WorldLocation will no longer be reliable when not currently playing audio, and any attach children will also be detached/attached along with it.
When enabled, detachment occurs regardless of whether AutoAttachParent is assigned, and the relative transform from the time of activation is restored.
This also disables attachment on dedicated servers, where we don't actually activate even if bAutoActivate is true.
See: AutoAttachParent, AutoAttachSocketName, AutoAttachLocationType"""

	@property
	def AudioComponentUserID(self) -> str: ...
	"""Configurable, serialized ID for audio plugins"""

	@property
	def PitchModulationMin(self) -> float: ...
	"""The lower bound to use when randomly determining a pitch multiplier"""

	@property
	def PitchModulationMax(self) -> float: ...
	"""The upper bound to use when randomly determining a pitch multiplier"""

	@property
	def VolumeModulationMin(self) -> float: ...
	"""The lower bound to use when randomly determining a volume multiplier"""

	@property
	def VolumeModulationMax(self) -> float: ...
	"""The upper bound to use when randomly determining a volume multiplier"""

	@property
	def VolumeMultiplier(self) -> float: ...
	"""A volume multiplier to apply to sounds generated by this component"""

	@property
	def EnvelopeFollowerAttackTime(self) -> int: ...
	"""The attack time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the envelope value of sounds played with this audio component. Only used in audio mixer."""

	@property
	def EnvelopeFollowerReleaseTime(self) -> int: ...
	"""The release time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the envelope value of sounds played with this audio component. Only used in audio mixer."""

	@property
	def Priority(self) -> float: ...
	"""A priority value that is used for sounds that play on this component that scales against final output volume."""

	@property
	def SubtitlePriority(self) -> float: ...
	"""Used by the subtitle manager to prioritize subtitles wave instances spawned by this component."""

	@property
	def SourceEffectChain(self) -> SoundEffectSourcePresetChain: ...
	"""Source Effect Chain"""

	@property
	def PitchMultiplier(self) -> float: ...
	"""A pitch multiplier to apply to sounds generated by this component"""

	@property
	def LowPassFilterFrequency(self) -> float: ...
	"""The frequency of the lowpass filter (in hertz) to apply to this voice. A frequency of 0.0 is the device sample rate and will bypass the filter."""

	@property
	def AttenuationSettings(self) -> SoundAttenuation: ...
	"""If bOverrideSettings is false, the asset to use to determine attenuation properties for sounds generated by this component"""

	@property
	def AttenuationOverrides(self) -> SoundAttenuationSettings: ...
	"""If bOverrideSettings is true, the attenuation properties to use for sounds generated by this component"""

	@property
	def ConcurrencySet(self) -> typing.Set[SoundConcurrency]: ...
	"""What sound concurrency rules to use for sounds generated by this audio component"""

	@property
	def AutoAttachLocationRule(self) -> int: ...
	"""Options for how we handle our location when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
See: bAutoManageAttachment, EAttachmentRule"""

	@property
	def AutoAttachRotationRule(self) -> int: ...
	"""Options for how we handle our rotation when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
See: bAutoManageAttachment, EAttachmentRule"""

	@property
	def AutoAttachScaleRule(self) -> int: ...
	"""Options for how we handle our scale when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
See: bAutoManageAttachment, EAttachmentRule"""

	@property
	def ModulationRouting(self) -> SoundModulationDefaultRoutingSettings: ...
	"""Modulation Routing"""

	@property
	def OnAudioPlayStateChanged(self) -> typing.Any: ...
	"""Called when PlayState changes"""

	@property
	def OnAudioVirtualizationChanged(self) -> typing.Any: ...
	"""Called when virtualization state changes"""

	@property
	def OnAudioFinished(self) -> typing.Any: ...
	"""called when we finish playing audio, either because it played to completion or because a Stop() call turned it off early"""

	@property
	def OnAudioPlaybackPercent(self) -> typing.Any: ...
	"""Called as a sound plays on the audio component to allow BP to perform actions based on playback percentage.
Computed as samples played divided by total samples, taking into account pitch.
Not currently implemented on all platforms."""

	@property
	def OnAudioSingleEnvelopeValue(self) -> typing.Any: ...
	"""On Audio Single Envelope Value"""

	@property
	def OnAudioMultiEnvelopeValue(self) -> typing.Any: ...
	"""On Audio Multi Envelope Value"""

	@property
	def OnQueueSubtitles(self) -> typing.Any: ...
	"""Called when subtitles are sent to the SubtitleManager.  Set this delegate if you want to hijack the subtitles for other purposes"""

	@property
	def AutoAttachParent(self) -> SceneComponent: ...
	"""Component we automatically attach to when activated, if bAutoManageAttachment is true.
If null during registration, we assign the existing AttachParent and defer attachment until we activate.
See: bAutoManageAttachment"""

	@property
	def AutoAttachSocketName(self) -> str: ...
	"""Socket we automatically attach to on the AutoAttachParent, if bAutoManageAttachment is true.
See: bAutoManageAttachment"""

	def GetAttenuationSettingsToApply(self) -> typing.Tuple[bool, SoundAttenuationSettings]: ...
	"""BP Get Attenuation Settings to Apply"""

	def GetCookedEnvelopeDataForAllPlayingSounds(self) -> typing.Tuple[bool, typing.List[SoundWaveEnvelopeDataPerSound]]: ...
	"""Retrieves the current-time envelope data of the sounds playing audio component.
Envelope data is not averaged or interpolated. Instead an array of data with all playing sound waves with cooked data is returned.
Returns true if there is data and the audio component is playing."""

	def GetCookedEnvelopeData(self) -> typing.Tuple[bool, float]: ...
	"""Retrieves the current-time cooked envelope data of the playing audio component.
Cooked data is interpolated and averaged across all playing sound waves.
Returns true if there is data and the audio component is playing."""

	def GetCookedFFTDataForAllPlayingSounds(self) -> typing.Tuple[bool, typing.List[SoundWaveSpectralDataPerSound]]: ...
	"""Retrieves the current-time cooked spectral data of the sounds playing audio component.
Spectral data is not averaged or interpolated. Instead an array of data with all playing sound waves with cooked data is returned.
Returns true if there is data and the audio component is playing."""

	def GetCookedFFTData(self, FrequenciesToGet: typing.List[float]) -> typing.Tuple[bool, typing.List[SoundWaveSpectralData]]: ...
	"""Retrieves the current-time cooked spectral data of the sounds playing on the audio component.
Spectral data is averaged and interpolated for all playing sounds on this audio component.
Returns true if there is data and the audio component is playing."""

	def HasCookedAmplitudeEnvelopeData(self) -> bool: ...
	"""Queries if the sound wave playing in this audio component has cooked amplitude analyses."""

	def HasCookedFFTData(self) -> bool: ...
	"""Queries if the sound wave playing in this audio component has cooked FFT data."""

	def SetLowPassFilterFrequency(self, InLowPassFilterFrequency: float): ...
	"""Sets lowpass filter frequency of the audio component."""

	def SetLowPassFilterEnabled(self, InLowPassFilterEnabled: bool): ...
	"""Sets whether or not the low pass filter is enabled on the audio component."""

	def SetAudioBusSendPostEffect(self, AudioBus: AudioBus, SourceBusSendLevel: float): ...
	"""Sets how much audio the sound should send to the given Audio Bus (POST Source Effects).
              if the Audio Bus Send doesn't already exist, it will be added to the overrides on the active sound"""

	def SetAudioBusSendPreEffect(self, AudioBus: AudioBus, AudioBusSendLevel: float): ...
	"""Sets how much audio the sound should send to the given Audio Bus (PRE Source Effects).
      if the Bus Send doesn't already exist, it will be added to the overrides on the active sound"""

	def SetSourceBusSendPostEffect(self, SoundSourceBus: SoundSourceBus, SourceBusSendLevel: float): ...
	"""Sets how much audio the sound should send to the given Source Bus (POST Source Effects).
              if the Bus Send doesn't already exist, it will be added to the overrides on the active sound"""

	def SetSourceBusSendPreEffect(self, SoundSourceBus: SoundSourceBus, SourceBusSendLevel: float): ...
	"""Sets how much audio the sound should send to the given Source Bus (PRE Source Effects).
              if the Bus Send doesn't already exist, it will be added to the overrides on the active sound"""

	def SetSubmixSend(self, Submix: SoundSubmixBase, SendLevel: float): ...
	"""Sets how much audio the sound should send to the given submix."""

	def AdjustAttenuation(self, InAttenuationSettings: SoundAttenuationSettings): ...
	"""Modify the attenuation settings of the audio component"""

	def SetUISound(self, bInUISound: bool): ...
	"""Set whether sounds generated by this audio component should be considered UI sounds"""

	def SetPitchMultiplier(self, NewPitchMultiplier: float): ...
	"""Set a new pitch multiplier"""

	def SetVolumeMultiplier(self, NewVolumeMultiplier: float): ...
	"""Set a new volume multiplier"""

	def SetIntParameter(self, InName: str, InInt: int): ...
	"""Set an integer instance parameter for use in sound cues played by this audio component"""

	def SetBoolParameter(self, InName: str, InBool: bool): ...
	"""Set a boolean instance parameter for use in sound cues played by this audio component"""

	def SetWaveParameter(self, InName: str, InWave: SoundWave): ...
	"""Set a sound wave instance parameter for use in sound cues played by this audio component"""

	def SetFloatParameter(self, InName: str, InFloat: float): ...
	"""Set a float instance parameter for use in sound cues played by this audio component"""

	def AdjustVolume(self, AdjustVolumeDuration: float, AdjustVolumeLevel: float, FadeCurve: int = ...): ...
	"""This will allow one to adjust the volume of an AudioComponent on the fly"""

	def GetPlayState(self) -> int: ...
	"""Returns the enumerated play states of the audio component."""

	def IsVirtualized(self) -> bool: ...
	"""Returns if the sound is virtualized."""

	def IsPlaying(self) -> bool: ...
	"""Returns if the sound playing any audio. Doesn't indicate the play state. Use GetPlayState() to get the actual play state."""

	def SetPaused(self, bPause: bool): ...
	"""Pause an audio component playing its sound cue, issue any delegates if needed"""

	def StopDelayed(self, DelayTime: float): ...
	"""Cues request to stop sound after the provided delay (In Seconds), stopping immediately if delay is zero or negative"""

	def Stop(self): ...
	"""Stop an audio component's sound, issue any delegates if needed"""

	def PlayQuantized(self, WorldContextObject: Object, InClockHandle, InQuantizationBoundary: QuartzQuantizationBoundary, InDelegate, InStartTime: float = ..., InFadeInDuration: float = ..., InFadeVolumeLevel: float = ..., InFadeCurve: int = ...): ...
	"""Start a sound playing on an audio component on a given quantization boundary with the handle to an existing clock"""

	def Play(self, StartTime: float = ...): ...
	"""Start a sound playing on an audio component"""

	def FadeOut(self, FadeOutDuration: float, FadeVolumeLevel: float, FadeCurve: int = ...): ...
	"""This is used in place of 'stop' when it is desired to fade the volume of the sound before stopping.

If FadeTime is 0.0, this is the same as calling Stop().
If FadeTime is > 0.0, this will adjust the volume multiplier to FadeVolumeLevel over FadeInTime seconds
and then stop the sound.

@param FadeOutDuration how long it should take to reach the FadeVolumeLevel
@param FadeVolumeLevel the percentage of the AudioComponents's calculated volume in which to fade to"""

	def FadeIn(self, FadeInDuration: float, FadeVolumeLevel: float = ..., StartTime: float = ..., FadeCurve: int = ...): ...
	"""This can be used in place of 'play' when it is desired to fade in the sound over time.

If FadeTime is 0.0, the change in volume is instant.
If FadeTime is > 0.0, the multiplier will be increased from 0 to FadeVolumeLevel over FadeIn seconds.

@param FadeInDuration how long it should take to reach the FadeVolumeLevel
@param FadeVolumeLevel the percentage of the AudioComponents's calculated volume to fade to"""

	def SetSound(self, NewSound: SoundBase): ...
	"""Set what sound is played by this component"""

	pass

class BillboardComponent(PrimitiveComponent):
	"""A 2d texture that will be rendered always facing the camera."""

	@property
	def Sprite(self) -> Texture2D: ...
	"""Sprite"""

	@property
	def bIsScreenSizeScaled(self) -> bool: ...
	"""Is Screen Size Scaled"""

	@property
	def ScreenSize(self) -> float: ...
	"""Screen Size"""

	@property
	def U(self) -> float: ...
	"""U"""

	@property
	def UL(self) -> float: ...
	"""UL"""

	@property
	def V(self) -> float: ...
	"""V"""

	@property
	def VL(self) -> float: ...
	"""VL"""

	def SetSpriteAndUV(self, NewSprite: Texture2D, NewU: int, NewUL: int, NewV: int, NewVL: int): ...
	"""Change the sprite texture and the UV's used by this component"""

	def SetUV(self, NewU: int, NewUL: int, NewV: int, NewVL: int): ...
	"""Change the sprite's UVs"""

	def SetSprite(self, NewSprite: Texture2D): ...
	"""Change the sprite texture used by this component"""

	pass

class BoundsCopyComponent(ActorComponent):
	"""Component used to copy the bounds of another Actor."""

	@property
	def BoundsSourceActor(self) -> typing.Any: ...
	"""Actor to copy the bounds from to set up the transform."""

	@property
	def bUseCollidingComponentsForSourceBounds(self) -> bool: ...
	"""If true, the source actor's bounds will include its colliding components bounds."""

	@property
	def bKeepOwnBoundsScale(self) -> bool: ...
	"""If true, the actor's scale will be changed so that after adjustment, its own bounds match the source bounds."""

	@property
	def bUseCollidingComponentsForOwnBounds(self) -> bool: ...
	"""If true, the actor's own bounds will include its colliding components bounds."""

	@property
	def PostTransform(self) -> Transform: ...
	"""Transform to apply to final result."""

	@property
	def bCopyXBounds(self) -> bool: ...
	"""Copy XBounds"""

	@property
	def bCopyYBounds(self) -> bool: ...
	"""Copy YBounds"""

	@property
	def bCopyZBounds(self) -> bool: ...
	"""Copy ZBounds"""

	pass

class ShapeComponent(PrimitiveComponent):
	"""ShapeComponent is a PrimitiveComponent that is represented by a simple geometrical shape (sphere, capsule, box, etc)."""

	@property
	def ShapeBodySetup(self) -> typing.Any: ...
	"""Description of collision"""

	@property
	def AreaClass(self) -> NavAreaBase: ...
	"""Navigation area type (empty = default obstacle)"""

	@property
	def ShapeColor(self) -> Color: ...
	"""Color used to draw the shape."""

	@property
	def bDrawOnlyIfSelected(self) -> bool: ...
	"""Only show this component if the actor is selected"""

	@property
	def bShouldCollideWhenPlacing(self) -> bool: ...
	"""If true it allows Collision when placing even if collision is not enabled"""

	@property
	def bDynamicObstacle(self) -> bool: ...
	"""If set, shape will be exported for navigation as dynamic modifier instead of using regular collision data"""

	pass

class BoxComponent(ShapeComponent):
	"""A box generally used for simple collision. Bounds are rendered as lines in the editor."""

	def GetUnscaledBoxExtent(self) -> Vector: ...
	"""@return the box extent, ignoring component scale."""

	def GetScaledBoxExtent(self) -> Vector: ...
	"""@return the box extent, scaled by the component scale."""

	def SetBoxExtent(self, InBoxExtent: Vector, bUpdateOverlaps: bool = ...): ...
	"""Change the box extent size. This is the unscaled size, before component scale is applied.
@param       InBoxExtent: new extent (radius) for the box.
@param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor."""

	pass

class ReflectionCaptureComponent(SceneComponent):
	"""-> will be exported to EngineDecalClasses.h"""

	@property
	def CaptureOffsetComponent(self) -> BillboardComponent: ...
	"""Capture Offset Component"""

	@property
	def ReflectionSourceType(self) -> int: ...
	"""Indicates where to get the reflection source from."""

	@property
	def MobileReflectionCompression(self) -> int: ...
	"""Indicates if the Reflection will be compressed for mobile. If set to default it will take the project wide setting."""

	@property
	def Cubemap(self) -> TextureCube: ...
	"""Cubemap to use for reflection if ReflectionSourceType is set to RS_SpecifiedCubemap."""

	@property
	def SourceCubemapAngle(self) -> float: ...
	"""Angle to rotate the source cubemap when SourceType is set to SLS_SpecifiedCubemap."""

	@property
	def Brightness(self) -> float: ...
	"""A brightness control to scale the captured scene's reflection intensity."""

	@property
	def bModifyMaxValueRGBM(self) -> bool: ...
	"""Indicates if we want to manually modify the MaxRGBM value."""

	@property
	def MaxValueRGBM(self) -> float: ...
	"""M values for RGBM, it will dynamically be generated by taking the highest RGB value into account. Explictly modifying it will require a Reflection Re-Capture."""

	@property
	def CaptureOffset(self) -> Vector: ...
	"""World space offset to apply before capturing."""

	@property
	def MapBuildDataId(self) -> Guid: ...
	"""Guid for map build data"""

	pass

class BoxReflectionCaptureComponent(ReflectionCaptureComponent):
	"""-> will be exported to EngineDecalClasses.h"""

	@property
	def BoxTransitionDistance(self) -> float: ...
	"""Adjust capture transition distance"""

	@property
	def PreviewInfluenceBox(self) -> BoxComponent: ...
	"""Preview Influence Box"""

	@property
	def PreviewCaptureBox(self) -> BoxComponent: ...
	"""Preview Capture Box"""

	pass

class BrushComponent(PrimitiveComponent):
	"""A brush component defines a shape that can be modified within the editor. They are used both as part of BSP building, and for volumes.
See: https://docs.unrealengine.com/latest/INT/Engine/Actors/Volumes
See: https://docs.unrealengine.com/latest/INT/Engine/Actors/Brushes"""

	@property
	def Brush(self) -> typing.Any: ...
	"""Brush"""

	@property
	def BrushBodySetup(self) -> typing.Any: ...
	"""Description of collision"""

	pass

class CapsuleComponent(ShapeComponent):
	"""A capsule generally used for simple collision. Bounds are rendered as lines in the editor."""

	def GetShapeScale(self) -> float: ...
	"""Get the scale used by this shape. This is a uniform scale that is the minimum of any non-uniform scaling.
@return the scale used by this shape."""

	def GetUnscaledCapsuleSize_WithoutHemisphere(self) -> typing.Tuple[float, float]: ...
	"""Returns the capsule radius and half-height, ignoring component scaling. Half-height excludes the hemisphere end cap.
@param OutRadius Radius of the capsule, ignoring component scaling.
@param OutHalfHeightWithoutHemisphere Half-height of the capsule, scaled by the component scale. Excludes the hemisphere end cap.
@return The capsule radius and half-height (excluding hemisphere end cap), ignoring component scaling."""

	def GetUnscaledCapsuleSize(self) -> typing.Tuple[float, float]: ...
	"""Returns the capsule radius and half-height scaled by the component scale. Half-height includes the hemisphere end cap.
@param OutRadius Radius of the capsule, scaled by the component scale.
@param OutHalfHeight Half-height of the capsule, scaled by the component scale. Includes the hemisphere end cap.
@return The capsule radius and half-height scaled by the component scale."""

	def GetUnscaledCapsuleHalfHeight_WithoutHemisphere(self) -> float: ...
	"""Returns the capsule half-height minus radius (to exclude the hemisphere), ignoring component scaling. This excludes the hemisphere end cap.
From the center of the capsule this is the vertical distance along the straight cylindrical portion to the point just before the curve of top hemisphere begins.
@return The capsule half-height minus radius, ignoring component scaling."""

	def GetUnscaledCapsuleHalfHeight(self) -> float: ...
	"""Returns the capsule half-height, ignoring component scaling. This includes the hemisphere end cap.
@return The capsule radius, ignoring component scaling."""

	def GetUnscaledCapsuleRadius(self) -> float: ...
	"""Returns the capsule radius, ignoring component scaling.
@return the capsule radius, ignoring component scaling."""

	def GetScaledCapsuleSize_WithoutHemisphere(self) -> typing.Tuple[float, float]: ...
	"""Returns the capsule radius and half-height scaled by the component scale. Half-height excludes the hemisphere end cap.
@param OutRadius Radius of the capsule, ignoring component scaling.
@param OutHalfHeightWithoutHemisphere Half-height of the capsule, scaled by the component scale. Excludes the hemisphere end cap.
@return The capsule radius and half-height scaled by the component scale."""

	def GetScaledCapsuleSize(self) -> typing.Tuple[float, float]: ...
	"""Returns the capsule radius and half-height scaled by the component scale. Half-height includes the hemisphere end cap.
@param OutRadius Radius of the capsule, scaled by the component scale.
@param OutHalfHeight Half-height of the capsule, scaled by the component scale. Includes the hemisphere end cap.
@return The capsule radius and half-height scaled by the component scale."""

	def GetScaledCapsuleHalfHeight_WithoutHemisphere(self) -> float: ...
	"""Returns the capsule half-height minus radius (to exclude the hemisphere), scaled by the component scale.
From the center of the capsule this is the vertical distance along the straight cylindrical portion to the point just before the curve of top hemisphere begins.
@return The capsule half-height minus radius, scaled by the component scale."""

	def GetScaledCapsuleHalfHeight(self) -> float: ...
	"""Returns the capsule half-height scaled by the component scale. This includes both the cylinder and hemisphere cap.
@return The capsule half-height scaled by the component scale."""

	def GetScaledCapsuleRadius(self) -> float: ...
	"""Returns the capsule radius scaled by the component scale.
@return The capsule radius scaled by the component scale."""

	def SetCapsuleHalfHeight(self, HalfHeight: float, bUpdateOverlaps: bool = ...): ...
	"""Set the capsule half-height. This is the unscaled half-height, before component scale is applied.
If this capsule collides, updates touching array for owner actor.
@param       HalfHeight : half-height, from capsule center to end of top or bottom hemisphere.
@param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor."""

	def SetCapsuleRadius(self, Radius: float, bUpdateOverlaps: bool = ...): ...
	"""Set the capsule radius. This is the unscaled radius, before component scale is applied.
If this capsule collides, updates touching array for owner actor.
@param       Radius : radius of end-cap hemispheres and center cylinder.
@param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor."""

	def SetCapsuleSize(self, InRadius: float, InHalfHeight: float, bUpdateOverlaps: bool = ...): ...
	"""Change the capsule size. This is the unscaled size, before component scale is applied.
@param       InRadius : radius of end-cap hemispheres and center cylinder.
@param       InHalfHeight : half-height, from capsule center to end of top or bottom hemisphere.
@param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor."""

	pass

class ChildActorComponent(SceneComponent):
	"""A component that spawns an Actor when registered, and destroys it when unregistered."""

	def SetChildActorClass(self, InClass: Actor): ...
	"""Sets the class to use for the child actor.
If called on a template component (owned by a CDO), the properties of any existing child actor template will be copied as best possible to the template.
If called on a component instance in a world (and the class is changing), the created ChildActor will use the class defaults as template.
@param InClass The Actor subclass to spawn as a child actor"""

	pass

class DecalComponent(SceneComponent):
	"""A material that is rendered onto the surface of a mesh. A kind of 'bumper sticker' for a model.

See: https://docs.unrealengine.com/latest/INT/Engine/Actors/DecalActor
See: UDecalActor"""

	@property
	def SortOrder(self) -> int: ...
	"""Controls the order in which decal elements are rendered.  Higher values draw later (on top).
Setting many different sort orders on many different decals prevents sorting by state and can reduce performance."""

	@property
	def FadeScreenSize(self) -> float: ...
	"""Fade Screen Size"""

	@property
	def FadeStartDelay(self) -> float: ...
	"""Time in seconds to wait before beginning to fade out the decal. Set fade duration and start delay to 0 to make persistent."""

	@property
	def FadeDuration(self) -> float: ...
	"""Time in seconds for the decal to fade out. Set fade duration and start delay to 0 to make persistent. Only fades in active simulation or game."""

	@property
	def FadeInDuration(self) -> float: ...
	"""Fade in Duration"""

	@property
	def FadeInStartDelay(self) -> float: ...
	"""Fade in Start Delay"""

	@property
	def bDestroyOwnerAfterFade(self) -> bool: ...
	"""Automatically destroys the owning actor after fully fading out."""

	@property
	def DecalSize(self) -> Vector: ...
	"""Decal size in local space (does not include the component scale), technically redundant but there for convenience"""

	def CreateDynamicMaterialInstance(self) -> MaterialInstanceDynamic: ...
	"""Utility to allocate a new Dynamic Material Instance, set its parent to the currently applied material, and assign it"""

	def GetDecalMaterial(self) -> MaterialInterface: ...
	"""Accessor for decal material"""

	def SetDecalMaterial(self, NewDecalMaterial: MaterialInterface): ...
	"""setting decal material on decal component. This will force the decal to reattach"""

	def SetSortOrder(self, Value: int): ...
	"""Sets the sort order for the decal component. Higher values draw later (on top). This will force the decal to reattach"""

	def SetFadeScreenSize(self, NewFadeScreenSize: float): ...
	"""Set the FadeScreenSize for this decal component"""

	def SetFadeIn(self, StartDelay: float, Duaration: float): ...
	"""Set Fade In"""

	def SetFadeOut(self, StartDelay: float, Duration: float, DestroyOwnerAfterFade: bool = ...): ...
	"""Sets the decal's fade start time, duration and if the owning actor should be destroyed after the decal is fully faded out.
The default value of 0 for FadeStartDelay and FadeDuration makes the decal persistent. See DecalLifetimeOpacity material
node to control the look of 'fading out.'

@param StartDelay - Time in seconds to wait before beginning to fade out the decal.
@param Duration - Time in second for the decal to fade out.
@param DestroyOwnerAfterFade - Should the owning actor automatically be destroyed after it is completely faded out."""

	def GetFadeInDuration(self) -> float: ...
	"""Get Fade in Duration"""

	def GetFadeInStartDelay(self) -> float: ...
	"""Get Fade in Start Delay"""

	def GetFadeDuration(self) -> float: ...
	"""Get Fade Duration"""

	def GetFadeStartDelay(self) -> float: ...
	"""Get Fade Start Delay"""

	pass

class LightComponentBase(SceneComponent):
	"""Light Component Base"""

	@property
	def LightGuid(self) -> Guid: ...
	"""GUID used to associate a light component with precomputed shadowing information across levels.
The GUID changes whenever the light position changes."""

	@property
	def Intensity(self) -> float: ...
	"""Total energy that the light emits."""

	@property
	def LightColor(self) -> Color: ...
	"""Filter color of the light.
Note that this can change the light's effective intensity."""

	@property
	def bAffectsWorld(self) -> bool: ...
	"""Whether the light can affect the world, or whether it is disabled.
A disabled light will not contribute to the scene in any way.  This setting cannot be changed at runtime and unbuilds lighting when changed.
Setting this to false has the same effect as deleting the light, so it is useful for non-destructive experiments."""

	@property
	def CastShadows(self) -> bool: ...
	"""Whether the light should cast any shadows."""

	@property
	def CastStaticShadows(self) -> bool: ...
	"""Whether the light should cast shadows from static objects.  Also requires Cast Shadows to be set to True."""

	@property
	def CastDynamicShadows(self) -> bool: ...
	"""Whether the light should cast shadows from dynamic objects.  Also requires Cast Shadows to be set to True."""

	@property
	def bAffectTranslucentLighting(self) -> bool: ...
	"""Whether the light affects translucency or not.  Disabling this can save GPU time when there are many small lights."""

	@property
	def bTransmission(self) -> bool: ...
	"""Whether light from this light transmits through surfaces with subsurface scattering profiles. Requires light to be movable."""

	@property
	def bCastVolumetricShadow(self) -> bool: ...
	"""Whether the light shadows volumetric fog.  Disabling this can save GPU time."""

	@property
	def bCastDeepShadow(self) -> bool: ...
	"""Whether the light should cast high quality hair-strands self-shadowing. When this option is enabled, an extra GPU cost for this light."""

	@property
	def bCastRaytracedShadow(self) -> bool: ...
	"""Whether the light shadows are computed with shadow-mapping or ray-tracing (when available)."""

	@property
	def bAffectReflection(self) -> bool: ...
	"""Whether the light affects objects in reflections, when ray-traced reflection is enabled."""

	@property
	def bAffectGlobalIllumination(self) -> bool: ...
	"""Whether the light affects global illumination, when ray-traced global illumination is enabled."""

	@property
	def DeepShadowLayerDistribution(self) -> float: ...
	"""Change the deep shadow layers distribution 0:linear distribution (uniform layer distribution), 1:exponential (more details on near small details)."""

	@property
	def IndirectLightingIntensity(self) -> float: ...
	"""Scales the indirect lighting contribution from this light.
A value of 0 disables any GI from this light. Default is 1."""

	@property
	def VolumetricScatteringIntensity(self) -> float: ...
	"""Intensity of the volumetric scattering from this light.  This scales Intensity and LightColor."""

	@property
	def SamplesPerPixel(self) -> int: ...
	"""Samples per pixel for ray tracing"""

	def SetSamplesPerPixel(self, NewValue: int): ...
	"""Set Samples Per Pixel"""

	def SetCastRaytracedShadow(self, bNewValue: bool): ...
	"""Set Cast Raytraced Shadow"""

	def SetAffectGlobalIllumination(self, bNewValue: bool): ...
	"""Set Affect Global Illumination"""

	def SetAffectReflection(self, bNewValue: bool): ...
	"""Set Affect Reflection"""

	def SetCastDeepShadow(self, bNewValue: bool): ...
	"""Set Cast Deep Shadow"""

	def SetCastVolumetricShadow(self, bNewValue: bool): ...
	"""Set Cast Volumetric Shadow"""

	def GetLightColor(self) -> LinearColor: ...
	"""Gets the light color as a linear color"""

	def SetCastShadows(self, bNewValue: bool): ...
	"""Sets whether this light casts shadows"""

	pass

class LightComponent(LightComponentBase):
	"""Light Component"""

	@property
	def Temperature(self) -> float: ...
	"""Color temperature in Kelvin of the blackbody illuminant.
White (D65) is 6500K."""

	@property
	def MaxDrawDistance(self) -> float: ...
	"""Max Draw Distance"""

	@property
	def MaxDistanceFadeRange(self) -> float: ...
	"""Max Distance Fade Range"""

	@property
	def bUseTemperature(self) -> bool: ...
	"""false: use white (D65) as illuminant."""

	@property
	def SpecularScale(self) -> float: ...
	"""Multiplier on specular highlights. Use only with great care! Any value besides 1 is not physical!
Can be used to artistically remove highlights mimicking polarizing filters or photo touch up."""

	@property
	def ShadowResolutionScale(self) -> float: ...
	"""Scales the resolution of shadowmaps used to shadow this light.  By default shadowmap resolution is chosen based on screen size of the caster.
Note: shadowmap resolution is still clamped by 'r.Shadow.MaxResolution'"""

	@property
	def ShadowBias(self) -> float: ...
	"""Controls how accurate self shadowing of whole scene shadows from this light are.
At 0, shadows will start at the their caster surface, but there will be many self shadowing artifacts.
larger values, shadows will start further from their caster, and there won't be self shadowing artifacts but object might appear to fly.
around 0.5 seems to be a good tradeoff. This also affects the soft transition of shadows"""

	@property
	def ShadowSlopeBias(self) -> float: ...
	"""Controls how accurate self shadowing of whole scene shadows from this light are. This works in addition to shadow bias, by increasing the
amount of bias depending on the slope of a surface.
At 0, shadows will start at the their caster surface, but there will be many self shadowing artifacts.
larger values, shadows will start further from their caster, and there won't be self shadowing artifacts but object might appear to fly.
around 0.5 seems to be a good tradeoff. This also affects the soft transition of shadows"""

	@property
	def ShadowSharpen(self) -> float: ...
	"""Amount to sharpen shadow filtering"""

	@property
	def ContactShadowLength(self) -> float: ...
	"""Length of screen space ray trace for sharp contact shadows. Zero is disabled."""

	@property
	def ContactShadowLengthInWS(self) -> bool: ...
	"""Where Length of screen space ray trace for sharp contact shadows is in world space units or in screen space units."""

	@property
	def CastTranslucentShadows(self) -> bool: ...
	"""Whether the light is allowed to cast dynamic shadows from translucency."""

	@property
	def bCastShadowsFromCinematicObjectsOnly(self) -> bool: ...
	"""Whether the light should only cast shadows from components marked as bCastCinematicShadows.
This is useful for setting up cinematic Movable spotlights aimed at characters and avoiding the shadow depth rendering costs of the background.
Note: this only works with dynamic shadow maps, not with static shadowing or Ray Traced Distance Field shadows."""

	@property
	def bAffectDynamicIndirectLighting(self) -> bool: ...
	"""Whether the light should be injected into the Light Propagation Volume"""

	@property
	def bForceCachedShadowsForMovablePrimitives(self) -> bool: ...
	"""Enables cached shadows for movable primitives for this light even if r.shadow.cachedshadowscastfrommovableprimitives is 0"""

	@property
	def LightingChannels(self) -> LightingChannels: ...
	"""Channels that this light should affect.
These channels only apply to opaque materials, direct lighting, and dynamic lighting and shadowing."""

	@property
	def LightFunctionMaterial(self) -> MaterialInterface: ...
	"""The light function material to be applied to this light.
Note that only non-lightmapped lights (UseDirectLightMap=False) can have a light function."""

	@property
	def LightFunctionScale(self) -> Vector: ...
	"""Scales the light function projection.  X and Y scale in the directions perpendicular to the light's direction, Z scales along the light direction."""

	@property
	def IESTexture(self) -> TextureLightProfile: ...
	"""IES texture (light profiles from real world measured data)"""

	@property
	def bUseIESBrightness(self) -> bool: ...
	"""true: take light brightness from IES profile, false: use the light brightness - the maximum light in one direction is used to define no masking. Use with InverseSquareFalloff. Will be disabled if a valid IES profile texture is not supplied."""

	@property
	def IESBrightnessScale(self) -> float: ...
	"""Global scale for IES brightness contribution. Only available when 'Use IES Brightness' is selected, and a valid IES profile texture is set"""

	@property
	def LightFunctionFadeDistance(self) -> float: ...
	"""Distance at which the light function should be completely faded to DisabledBrightness.
This is useful for hiding aliasing from light functions applied in the distance."""

	@property
	def DisabledBrightness(self) -> float: ...
	"""Brightness factor applied to the light when the light function is specified but disabled, for example in scene captures that use SceneCapView_LitNoShadows.
This should be set to the average brightness of the light function material's emissive input, which should be between 0 and 1."""

	@property
	def bEnableLightShaftBloom(self) -> bool: ...
	"""Whether to render light shaft bloom from this light.
For directional lights, the color around the light direction will be blurred radially and added back to the scene.
for point lights, the color on pixels closer than the light's SourceRadius will be blurred radially and added back to the scene."""

	@property
	def BloomScale(self) -> float: ...
	"""Scales the additive color."""

	@property
	def BloomThreshold(self) -> float: ...
	"""Scene color must be larger than this to create bloom in the light shafts."""

	@property
	def BloomMaxBrightness(self) -> float: ...
	"""After exposure is applied, scene color brightness larger than BloomMaxBrightness will be rescaled down to BloomMaxBrightness."""

	@property
	def BloomTint(self) -> Color: ...
	"""Multiplies against scene color to create the bloom color."""

	@property
	def bUseRayTracedDistanceFieldShadows(self) -> bool: ...
	"""Whether to use ray traced distance field area shadows.  The project setting bGenerateMeshDistanceFields must be enabled for this to have effect.
Distance field shadows support area lights so they create soft shadows with sharp contacts.
They have less aliasing artifacts than standard shadowmaps, but inherit all the limitations of distance field representations (only uniform scale, no deformation).
These shadows have a low per-object cost (and don't depend on triangle count) so they are effective for distant shadows from a dynamic sun."""

	@property
	def RayStartOffsetDepthScale(self) -> float: ...
	"""Controls how large of an offset ray traced shadows have from the receiving surface as the camera gets further away.
This can be useful to hide self-shadowing artifacts from low resolution distance fields on huge static meshes."""

	def SetLightingChannels(self, bChannel0: bool, bChannel1: bool, bChannel2: bool): ...
	"""Set Lighting Channels"""

	def SetForceCachedShadowsForMovablePrimitives(self, bNewValue: bool): ...
	"""Set Force Cached Shadows for Movable Primitives"""

	def SetSpecularScale(self, NewValue: float): ...
	"""Set Specular Scale"""

	def SetShadowSlopeBias(self, NewValue: float): ...
	"""Set Shadow Slope Bias"""

	def SetShadowBias(self, NewValue: float): ...
	"""Set Shadow Bias"""

	def SetIESBrightnessScale(self, NewValue: float): ...
	"""Set IESBrightness Scale"""

	def SetUseIESBrightness(self, bNewValue: bool): ...
	"""Set Use IESBrightness"""

	def SetIESTexture(self, NewValue: TextureLightProfile): ...
	"""Set IESTexture"""

	def SetBloomTint(self, NewValue: Color): ...
	"""Set Bloom Tint"""

	def SetBloomMaxBrightness(self, NewValue: float): ...
	"""Set Bloom Max Brightness"""

	def SetBloomThreshold(self, NewValue: float): ...
	"""Set Bloom Threshold"""

	def SetBloomScale(self, NewValue: float): ...
	"""Set Bloom Scale"""

	def SetEnableLightShaftBloom(self, bNewValue: bool): ...
	"""Set Enable Light Shaft Bloom"""

	def SetTransmission(self, bNewValue: bool): ...
	"""Set Transmission"""

	def SetAffectTranslucentLighting(self, bNewValue: bool): ...
	"""Set Affect Translucent Lighting"""

	def SetAffectDynamicIndirectLighting(self, bNewValue: bool): ...
	"""Set Affect Dynamic Indirect Lighting"""

	def SetLightFunctionDisabledBrightness(self, NewValue: float): ...
	"""Set Light Function Disabled Brightness"""

	def SetLightFunctionFadeDistance(self, NewLightFunctionFadeDistance: float): ...
	"""Set Light Function Fade Distance"""

	def SetLightFunctionScale(self, NewLightFunctionScale: Vector): ...
	"""Set Light Function Scale"""

	def SetLightFunctionMaterial(self, NewLightFunctionMaterial: MaterialInterface): ...
	"""Set Light Function Material"""

	def SetTemperature(self, NewTemperature: float): ...
	"""Set Temperature"""

	def SetLightColor(self, NewLightColor: LinearColor, bSRGB: bool = ...): ...
	"""Set color of the light"""

	def SetVolumetricScatteringIntensity(self, NewIntensity: float): ...
	"""Set Volumetric Scattering Intensity"""

	def SetIndirectLightingIntensity(self, NewIntensity: float): ...
	"""Set Indirect Lighting Intensity"""

	def SetIntensity(self, NewIntensity: float): ...
	"""Set intensity of the light"""

	pass

class DirectionalLightComponent(LightComponent):
	"""A light component that has parallel rays. Will provide a uniform lighting across any affected surface (eg. The Sun). This will affect all objects in the defined light-mass importance volume."""

	@property
	def ShadowCascadeBiasDistribution(self) -> float: ...
	"""Controls the depth bias scaling across cascades. This allows to mitigage the shadow acne difference on shadow cascades transition.
A value of 1 scales shadow bias based on each cascade size (Default).
A value of 0 scales shadow bias uniformly accross all cacascade."""

	@property
	def bEnableLightShaftOcclusion(self) -> bool: ...
	"""Whether to occlude fog and atmosphere inscattering with screenspace blurred occlusion from this light."""

	@property
	def OcclusionMaskDarkness(self) -> float: ...
	"""Controls how dark the occlusion masking is, a value of 1 results in no darkening term."""

	@property
	def OcclusionDepthRange(self) -> float: ...
	"""Everything closer to the camera than this distance will occlude light shafts."""

	@property
	def LightShaftOverrideDirection(self) -> Vector: ...
	"""Can be used to make light shafts come from somewhere other than the light's actual direction.
This will only be used when non-zero.  It does not have to be normalized."""

	@property
	def DynamicShadowDistanceMovableLight(self) -> float: ...
	"""How far Cascaded Shadow Map dynamic shadows will cover for a movable light, measured from the camera.
A value of 0 disables the dynamic shadow."""

	@property
	def DynamicShadowDistanceStationaryLight(self) -> float: ...
	"""How far Cascaded Shadow Map dynamic shadows will cover for a stationary light, measured from the camera.
A value of 0 disables the dynamic shadow."""

	@property
	def DynamicShadowCascades(self) -> int: ...
	"""Number of cascades to split the view frustum into for the whole scene dynamic shadow.
More cascades result in better shadow resolution, but adds significant rendering cost."""

	@property
	def CascadeDistributionExponent(self) -> float: ...
	"""Controls whether the cascades are distributed closer to the camera (larger exponent) or further from the camera (smaller exponent).
An exponent of 1 means that cascade transitions will happen at a distance proportional to their resolution."""

	@property
	def CascadeTransitionFraction(self) -> float: ...
	"""Proportion of the fade region between cascades.
Pixels within the fade region of two cascades have their shadows blended to avoid hard transitions between quality levels.
A value of zero eliminates the fade region, creating hard transitions.
Higher values increase the size of the fade region, creating a more gradual transition between cascades.
The value is expressed as a percentage proportion (i.e. 0.1 = 10% overlap).
Ideal values are the smallest possible which still hide the transition.
An increased fade region size causes an increase in shadow rendering cost."""

	@property
	def ShadowDistanceFadeoutFraction(self) -> float: ...
	"""Controls the size of the fade out region at the far extent of the dynamic shadow's influence.
This is specified as a fraction of DynamicShadowDistance."""

	@property
	def bUseInsetShadowsForMovableObjects(self) -> bool: ...
	"""Stationary lights only: Whether to use per-object inset shadows for movable components, even though cascaded shadow maps are enabled.
This allows dynamic objects to have a shadow even when they are outside of the cascaded shadow map, which is important when DynamicShadowDistanceStationaryLight is small.
If DynamicShadowDistanceStationaryLight is large (currently > 8000), this will be forced off.
Disabling this can reduce shadowing cost significantly with many movable objects."""

	@property
	def FarShadowCascadeCount(self) -> int: ...
	"""0: no DistantShadowCascades, otherwise the count of cascades between WholeSceneDynamicShadowRadius and DistantShadowDistance that are covered by distant shadow cascades."""

	@property
	def FarShadowDistance(self) -> float: ...
	"""Distance at which the far shadow cascade should end.  Far shadows will cover the range between 'Dynamic Shadow Distance' and this distance."""

	@property
	def DistanceFieldShadowDistance(self) -> float: ...
	"""Distance at which the ray traced shadow cascade should end.  Distance field shadows will cover the range between 'Dynamic Shadow Distance' this distance."""

	@property
	def LightSourceAngle(self) -> float: ...
	"""Angle subtended by light source in degrees (also known as angular diameter).
Defaults to 0.5357 which is the angle for our sun."""

	@property
	def LightSourceSoftAngle(self) -> float: ...
	"""Angle subtended by soft light source in degrees."""

	@property
	def ShadowSourceAngleFactor(self) -> float: ...
	"""Shadow source angle factor, relative to the light source angle.
Defaults to 1.0 to coincide with light source angle."""

	@property
	def TraceDistance(self) -> float: ...
	"""Determines how far shadows can be cast, in world units.  Larger values increase the shadowing cost."""

	@property
	def bUsedAsAtmosphereSunLight(self) -> bool: ...
	"""Whether the directional light can interact with the atmosphere, cloud and generate a visual disk. All of which compose the visual sky."""

	@property
	def AtmosphereSunLightIndex(self) -> int: ...
	"""Two atmosphere lights are supported. For instance: a sun and a moon, or two suns."""

	@property
	def AtmosphereSunDiskColorScale(self) -> LinearColor: ...
	"""A color multiplied with the sun disk luminance."""

	@property
	def bPerPixelAtmosphereTransmittance(self) -> bool: ...
	"""Whether to apply atmosphere transmittance per pixel on opaque meshes, instead of using the light global transmittance."""

	@property
	def bCastShadowsOnClouds(self) -> bool: ...
	"""Whether the light should cast any shadows from opaque meshes onto clouds. This is disabled for AtmosphereLight1."""

	@property
	def bCastShadowsOnAtmosphere(self) -> bool: ...
	"""Whether the light should cast any shadows from opaque meshes onto the atmosphere."""

	@property
	def bCastCloudShadows(self) -> bool: ...
	"""Whether the light should cast any shadows from clouds onto the atmosphere and other scene elements."""

	@property
	def CloudShadowStrength(self) -> float: ...
	"""The overall strength of the cloud shadow, higher value will block more light."""

	@property
	def CloudShadowOnAtmosphereStrength(self) -> float: ...
	"""The strength of the shadow on atmosphere. Disabled when 0."""

	@property
	def CloudShadowOnSurfaceStrength(self) -> float: ...
	"""The strength of the shadow on opaque and transparent meshes. Disabled when 0."""

	@property
	def CloudShadowDepthBias(self) -> float: ...
	"""The bias applied to the shadow front depth of the volumetric cloud shadow map."""

	@property
	def CloudShadowExtent(self) -> float: ...
	"""The world space radius of the cloud shadow map around the camera in kilometers."""

	@property
	def CloudShadowMapResolutionScale(self) -> float: ...
	"""Scale the cloud shadow map resolution, base resolution is 512. The resolution is still clamped to 'r.VolumetricCloud.ShadowMap.MaxResolution'."""

	@property
	def CloudShadowRaySampleCountScale(self) -> float: ...
	"""Scale the shadow map tracing sample count.
The sample count resolution is still clamped according to scalability setting to 'r.VolumetricCloud.ShadowMap.RaySampleMaxCount'."""

	@property
	def CloudScatteredLuminanceScale(self) -> LinearColor: ...
	"""Scales the lights contribution when scattered in cloud participating media. This can help counter balance the fact that our multiple scattering solution is only an approximation."""

	@property
	def LightmassSettings(self) -> typing.Any: ...
	"""The Lightmass settings for this object."""

	@property
	def bCastModulatedShadows(self) -> bool: ...
	"""Whether the light should cast modulated shadows from dynamic objects (mobile only).  Also requires Cast Shadows to be set to True."""

	@property
	def ModulatedShadowColor(self) -> Color: ...
	"""Color to modulate against the scene color when rendering modulated shadows. (mobile only)"""

	@property
	def ShadowAmount(self) -> float: ...
	"""Control the amount of shadow occlusion. A value of 0 means no occlusion, thus no shadow."""

	def SetAtmosphereSunLightIndex(self, NewValue: int): ...
	"""Set Atmosphere Sun Light Index"""

	def SetAtmosphereSunLight(self, bNewValue: bool): ...
	"""Set Atmosphere Sun Light"""

	def SetShadowAmount(self, NewValue: float): ...
	"""Set Shadow Amount"""

	def SetLightShaftOverrideDirection(self, NewValue: Vector): ...
	"""Set Light Shaft Override Direction"""

	def SetOcclusionMaskDarkness(self, NewValue: float): ...
	"""Set Occlusion Mask Darkness"""

	def SetEnableLightShaftOcclusion(self, bNewValue: bool): ...
	"""Set Enable Light Shaft Occlusion"""

	def SetShadowDistanceFadeoutFraction(self, NewValue: float): ...
	"""Set Shadow Distance Fadeout Fraction"""

	def SetCascadeTransitionFraction(self, NewValue: float): ...
	"""Set Cascade Transition Fraction"""

	def SetCascadeDistributionExponent(self, NewValue: float): ...
	"""Set Cascade Distribution Exponent"""

	def SetDynamicShadowCascades(self, NewValue: int): ...
	"""Set Dynamic Shadow Cascades"""

	def SetDynamicShadowDistanceStationaryLight(self, NewValue: float): ...
	"""Set Dynamic Shadow Distance Stationary Light"""

	def SetDynamicShadowDistanceMovableLight(self, NewValue: float): ...
	"""Set Dynamic Shadow Distance Movable Light"""

	pass

class DrawFrustumComponent(PrimitiveComponent):
	"""Utility component for drawing a view frustum. Origin is at the component location, frustum points down position X axis."""

	@property
	def FrustumColor(self) -> Color: ...
	"""Color to draw the wireframe frustum."""

	@property
	def FrustumAngle(self) -> float: ...
	"""Angle of longest dimension of view shape.
If the angle is 0 then an orthographic projection is used"""

	@property
	def FrustumAspectRatio(self) -> float: ...
	"""Ratio of horizontal size over vertical size."""

	@property
	def FrustumStartDist(self) -> float: ...
	"""Distance from origin to start drawing the frustum."""

	@property
	def FrustumEndDist(self) -> float: ...
	"""Distance from origin to stop drawing the frustum."""

	@property
	def Texture(self) -> Texture: ...
	"""optional texture to show on the near plane"""

	pass

class SphereComponent(ShapeComponent):
	"""A sphere generally used for simple collision. Bounds are rendered as lines in the editor."""

	def GetShapeScale(self) -> float: ...
	"""Get the scale used by this shape. This is a uniform scale that is the minimum of any non-uniform scaling.
@return the scale used by this shape."""

	def GetUnscaledSphereRadius(self) -> float: ...
	"""@return the radius of the sphere, ignoring component scale."""

	def GetScaledSphereRadius(self) -> float: ...
	"""@return the radius of the sphere, with component scale applied."""

	def SetSphereRadius(self, InSphereRadius: float, bUpdateOverlaps: bool = ...): ...
	"""Change the sphere radius. This is the unscaled radius, before component scale is applied.
@param       InSphereRadius: the new sphere radius
@param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor."""

	pass

class DrawSphereComponent(SphereComponent):
	"""A sphere generally used for simple collision. Bounds are rendered as lines in the editor."""

	pass

class ExponentialHeightFogComponent(SceneComponent):
	"""Used to create fogging effects such as clouds but with a density that is related to the height of the fog."""

	@property
	def FogDensity(self) -> float: ...
	"""Global density factor."""

	@property
	def FogHeightFalloff(self) -> float: ...
	"""Height density factor, controls how the density increases as height decreases.
Smaller values make the visible transition larger."""

	@property
	def SecondFogData(self) -> ExponentialHeightFogData: ...
	"""Settings for the second fog. Setting the density of this to 0 means it doesn't have any influence."""

	@property
	def FogInscatteringColor(self) -> LinearColor: ...
	"""Fog Inscattering Color"""

	@property
	def InscatteringColorCubemap(self) -> TextureCube: ...
	"""Cubemap that can be specified for fog color, which is useful to make distant, heavily fogged scene elements match the sky.
When the cubemap is specified, FogInscatteringColor is ignored and Directional inscattering is disabled."""

	@property
	def InscatteringColorCubemapAngle(self) -> float: ...
	"""Angle to rotate the InscatteringColorCubemap around the Z axis."""

	@property
	def InscatteringTextureTint(self) -> LinearColor: ...
	"""Tint color used when InscatteringColorCubemap is specified, for quick edits without having to reimport InscatteringColorCubemap."""

	@property
	def FullyDirectionalInscatteringColorDistance(self) -> float: ...
	"""Distance at which InscatteringColorCubemap should be used directly for the Inscattering Color."""

	@property
	def NonDirectionalInscatteringColorDistance(self) -> float: ...
	"""Distance at which only the average color of InscatteringColorCubemap should be used as Inscattering Color."""

	@property
	def DirectionalInscatteringExponent(self) -> float: ...
	"""Controls the size of the directional inscattering cone, which is used to approximate inscattering from a directional light.
Note: there must be a directional light with bUsedAsAtmosphereSunLight enabled for DirectionalInscattering to be used."""

	@property
	def DirectionalInscatteringStartDistance(self) -> float: ...
	"""Controls the start distance from the viewer of the directional inscattering, which is used to approximate inscattering from a directional light.
Note: there must be a directional light with bUsedAsAtmosphereSunLight enabled for DirectionalInscattering to be used."""

	@property
	def DirectionalInscatteringColor(self) -> LinearColor: ...
	"""Controls the color of the directional inscattering, which is used to approximate inscattering from a directional light.
Note: there must be a directional light with bUsedAsAtmosphereSunLight enabled for DirectionalInscattering to be used."""

	@property
	def FogMaxOpacity(self) -> float: ...
	"""Maximum opacity of the fog.
A value of 1 means the fog can become fully opaque at a distance and replace scene color completely,
A value of 0 means the fog color will not be factored in at all."""

	@property
	def StartDistance(self) -> float: ...
	"""Distance from the camera that the fog will start, in world units."""

	@property
	def FogCutoffDistance(self) -> float: ...
	"""Scene elements past this distance will not have fog applied.  This is useful for excluding skyboxes which already have fog baked in."""

	@property
	def bEnableVolumetricFog(self) -> bool: ...
	"""Whether to enable Volumetric fog.  Scalability settings control the resolution of the fog simulation.
Note that Volumetric fog currently does not support StartDistance, FogMaxOpacity and FogCutoffDistance.
Volumetric fog also can't match exponential height fog in general as exponential height fog has non-physical behavior."""

	@property
	def VolumetricFogScatteringDistribution(self) -> float: ...
	"""Controls the scattering phase function - how much incoming light scatters in various directions.
A distribution value of 0 scatters equally in all directions, while .9 scatters predominantly in the light direction.
In order to have visible volumetric fog light shafts from the side, the distribution will need to be closer to 0."""

	@property
	def VolumetricFogAlbedo(self) -> Color: ...
	"""The height fog particle reflectiveness used by volumetric fog.
Water particles in air have an albedo near white, while dust has slightly darker value."""

	@property
	def VolumetricFogEmissive(self) -> LinearColor: ...
	"""Light emitted by height fog.  This is a density so more light is emitted the further you are looking through the fog.
In most cases skylight is a better choice, however right now volumetric fog does not support precomputed lighting,
So stationary skylights are unshadowed and static skylights don't affect volumetric fog at all."""

	@property
	def VolumetricFogExtinctionScale(self) -> float: ...
	"""Scales the height fog particle extinction amount used by volumetric fog.  Values larger than 1 cause fog particles everywhere absorb more light."""

	@property
	def VolumetricFogDistance(self) -> float: ...
	"""Distance over which volumetric fog should be computed.  Larger values extend the effect into the distance but expose under-sampling artifacts in details."""

	@property
	def VolumetricFogStaticLightingScatteringIntensity(self) -> float: ...
	"""Volumetric Fog Static Lighting Scattering Intensity"""

	@property
	def bOverrideLightColorsWithFogInscatteringColors(self) -> bool: ...
	"""Whether to use FogInscatteringColor for the Sky Light volumetric scattering color and DirectionalInscatteringColor for the Directional Light scattering color.
Make sure your directional light has 'Atmosphere Sun Light' enabled!
Enabling this allows Volumetric fog to better match Height fog in the distance, but produces non-physical volumetric lighting that may not match surface lighting."""

	def SetVolumetricFogDistance(self, NewValue: float): ...
	"""Set Volumetric Fog Distance"""

	def SetVolumetricFogEmissive(self, NewValue: LinearColor): ...
	"""Set Volumetric Fog Emissive"""

	def SetVolumetricFogAlbedo(self, NewValue: Color): ...
	"""Set Volumetric Fog Albedo"""

	def SetVolumetricFogExtinctionScale(self, NewValue: float): ...
	"""Set Volumetric Fog Extinction Scale"""

	def SetVolumetricFogScatteringDistribution(self, NewValue: float): ...
	"""Set Volumetric Fog Scattering Distribution"""

	def SetVolumetricFog(self, bNewValue: bool): ...
	"""Set Volumetric Fog"""

	def SetFogCutoffDistance(self, Value: float): ...
	"""Set Fog Cutoff Distance"""

	def SetStartDistance(self, Value: float): ...
	"""Set Start Distance"""

	def SetFogMaxOpacity(self, Value: float): ...
	"""Set Fog Max Opacity"""

	def SetFogHeightFalloff(self, Value: float): ...
	"""Set Fog Height Falloff"""

	def SetDirectionalInscatteringColor(self, Value: LinearColor): ...
	"""Set Directional Inscattering Color"""

	def SetDirectionalInscatteringStartDistance(self, Value: float): ...
	"""Set Directional Inscattering Start Distance"""

	def SetDirectionalInscatteringExponent(self, Value: float): ...
	"""Set Directional Inscattering Exponent"""

	def SetInscatteringTextureTint(self, Value: LinearColor): ...
	"""Set Inscattering Texture Tint"""

	def SetNonDirectionalInscatteringColorDistance(self, Value: float): ...
	"""Set Non Directional Inscattering Color Distance"""

	def SetFullyDirectionalInscatteringColorDistance(self, Value: float): ...
	"""Set Fully Directional Inscattering Color Distance"""

	def SetInscatteringColorCubemapAngle(self, Value: float): ...
	"""Set Inscattering Color Cubemap Angle"""

	def SetInscatteringColorCubemap(self, Value: TextureCube): ...
	"""Set Inscattering Color Cubemap"""

	def SetFogInscatteringColor(self, Value: LinearColor): ...
	"""Set Fog Inscattering Color"""

	def SetFogDensity(self, Value: float): ...
	"""Set Fog Density"""

	pass

class ForceFeedbackComponent(SceneComponent):
	"""ForceFeedbackComponent allows placing a rumble effect in to the world and having it apply to player characters who come near it"""

	@property
	def ForceFeedbackEffect(self) -> ForceFeedbackEffect: ...
	"""The feedback effect to be played"""

	@property
	def bAutoDestroy(self) -> bool: ...
	"""Auto destroy this component on completion"""

	@property
	def bStopWhenOwnerDestroyed(self) -> bool: ...
	"""Stop effect when owner is destroyed"""

	@property
	def bLooping(self) -> bool: ...
	"""Looping"""

	@property
	def bIgnoreTimeDilation(self) -> bool: ...
	"""Should the playback of the forcefeedback pattern ignore time dilation and use the app's delta time"""

	@property
	def bOverrideAttenuation(self) -> bool: ...
	"""Should the Attenuation Settings asset be used (false) or should the properties set directly on the component be used for attenuation properties"""

	@property
	def IntensityMultiplier(self) -> float: ...
	"""The intensity multiplier to apply to effects generated by this component"""

	@property
	def AttenuationSettings(self) -> ForceFeedbackAttenuation: ...
	"""If bOverrideSettings is false, the asset to use to determine attenuation properties for effects generated by this component"""

	@property
	def AttenuationOverrides(self) -> ForceFeedbackAttenuationSettings: ...
	"""If bOverrideSettings is true, the attenuation properties to use for effects generated by this component"""

	@property
	def OnForceFeedbackFinished(self) -> typing.Any: ...
	"""called when we finish playing audio, either because it played to completion or because a Stop() call turned it off early"""

	def GetAttenuationSettingsToApply(self) -> typing.Tuple[bool, ForceFeedbackAttenuationSettings]: ...
	"""BP Get Attenuation Settings to Apply"""

	def AdjustAttenuation(self, InAttenuationSettings: ForceFeedbackAttenuationSettings): ...
	"""Modify the attenuation settings of the component"""

	def SetIntensityMultiplier(self, NewIntensityMultiplier: float): ...
	"""Set a new intensity multiplier"""

	def Stop(self): ...
	"""Stop playing the feedback effect"""

	def Play(self, StartTime: float = ...): ...
	"""Start a feedback effect playing"""

	def SetForceFeedbackEffect(self, NewForceFeedbackEffect: ForceFeedbackEffect): ...
	"""Set what force feedback effect is played by this component"""

	pass

class MeshComponent(PrimitiveComponent):
	"""MeshComponent is an abstract base for any component that is an instance of a renderable collection of triangles.

See: UStaticMeshComponent
See: USkeletalMeshComponent"""

	@property
	def OverrideMaterials(self) -> typing.List[MaterialInterface]: ...
	"""Material overrides."""

	def SetVectorParameterValueOnMaterials(self, ParameterName: str, ParameterValue: Vector): ...
	"""Set all occurrences of Vector Material Parameters with ParameterName in the set of materials of the SkeletalMesh to ParameterValue"""

	def SetScalarParameterValueOnMaterials(self, ParameterName: str, ParameterValue: float): ...
	"""Set all occurrences of Scalar Material Parameters with ParameterName in the set of materials of the SkeletalMesh to ParameterValue"""

	def PrestreamTextures(self, Seconds: float, bPrioritizeCharacterTextures: bool, CinematicTextureGroups: int = ...): ...
	"""Tell the streaming system to start loading all textures with all mip-levels.
@param Seconds                                                  Number of seconds to force all mip-levels to be resident
@param bPrioritizeCharacterTextures             Whether character textures should be prioritized for a while by the streaming system
@param CinematicTextureGroups                   Bitfield indicating which texture groups that use extra high-resolution mips"""

	def IsMaterialSlotNameValid(self, MaterialSlotName: str) -> bool: ...
	"""Is Material Slot Name Valid"""

	def GetMaterialSlotNames(self) -> typing.List[str]: ...
	"""Get Material Slot Names"""

	def GetMaterialIndex(self, MaterialSlotName: str) -> int: ...
	"""Get Material Index"""

	def GetMaterials(self) -> typing.List[MaterialInterface]: ...
	"""Get Materials"""

	pass

class StaticMeshComponent(MeshComponent):
	"""StaticMeshComponent is used to create an instance of a UStaticMesh.
A static mesh is a piece of geometry that consists of a static set of polygons.

See: https://docs.unrealengine.com/latest/INT/Engine/Content/Types/StaticMeshes/
See: UStaticMesh"""

	@property
	def ForcedLodModel(self) -> int: ...
	"""If 0, auto-select LOD level. if >0, force to (ForcedLodModel-1)."""

	@property
	def PreviousLODLevel(self) -> int: ...
	"""LOD that was desired for rendering this StaticMeshComponent last frame."""

	@property
	def MinLOD(self) -> int: ...
	"""Specifies the smallest LOD that will be used for this component.
This is ignored if ForcedLodModel is enabled."""

	@property
	def SubDivisionStepSize(self) -> int: ...
	"""Subdivision step size for static vertex lighting."""

	@property
	def WireframeColorOverride(self) -> Color: ...
	"""Wireframe color to use if bOverrideWireframeColor is true"""

	@property
	def bEvaluateWorldPositionOffset(self) -> bool: ...
	"""Evaluate World Position Offset"""

	@property
	def bOverrideWireframeColor(self) -> bool: ...
	"""If true, WireframeColorOverride will be used. If false, color is determined based on mobility and physics simulation settings"""

	@property
	def bOverrideMinLOD(self) -> bool: ...
	"""Whether to override the MinLOD setting of the static mesh asset with the MinLOD of this component."""

	@property
	def bOverrideNavigationExport(self) -> bool: ...
	"""If true, bForceNavigationObstacle flag will take priority over navigation data stored in StaticMesh"""

	@property
	def bForceNavigationObstacle(self) -> bool: ...
	"""Allows overriding navigation export behavior per component: full collisions or dynamic obstacle"""

	@property
	def bDisallowMeshPaintPerInstance(self) -> bool: ...
	"""If true, mesh painting is disallowed on this instance. Set if vertex colors are overridden in a construction script."""

	@property
	def bIgnoreInstanceForTextureStreaming(self) -> bool: ...
	"""Ignore this instance of this static mesh when calculating streaming information.
This can be useful when doing things like applying character textures to static geometry,
to avoid them using distance-based streaming."""

	@property
	def bOverrideLightMapRes(self) -> bool: ...
	"""Whether to override the lightmap resolution defined in the static mesh."""

	@property
	def bCastDistanceFieldIndirectShadow(self) -> bool: ...
	"""Whether to use the mesh distance field representation (when present) for shadowing indirect lighting (from lightmaps or skylight) on Movable components.
This works like capsule shadows on skeletal meshes, except using the mesh distance field so no physics asset is required.
The StaticMesh must have 'Generate Mesh Distance Field' enabled, or the project must have 'Generate Mesh Distance Fields' enabled for this feature to work."""

	@property
	def bOverrideDistanceFieldSelfShadowBias(self) -> bool: ...
	"""Whether to override the DistanceFieldSelfShadowBias setting of the static mesh asset with the DistanceFieldSelfShadowBias of this component."""

	@property
	def bUseSubDivisions(self) -> bool: ...
	"""Whether to use subdivisions or just the triangle's vertices."""

	@property
	def bUseDefaultCollision(self) -> bool: ...
	"""Use the collision profile specified in the StaticMesh asset."""

	@property
	def bReverseCulling(self) -> bool: ...
	"""Controls whether the static mesh component's backface culling should be reversed"""

	@property
	def OverriddenLightMapRes(self) -> int: ...
	"""Light map resolution to use on this component, used if bOverrideLightMapRes is true and there is a valid StaticMesh."""

	@property
	def DistanceFieldIndirectShadowMinVisibility(self) -> float: ...
	"""Controls how dark the dynamic indirect shadow can be."""

	@property
	def DistanceFieldSelfShadowBias(self) -> float: ...
	"""Useful for reducing self shadowing from distance field methods when using world position offset to animate the mesh's vertices."""

	@property
	def StreamingDistanceMultiplier(self) -> float: ...
	"""Allows adjusting the desired resolution of streaming textures that uses UV 0.  1.0 is the default, whereas a higher value increases the streamed-in resolution."""

	@property
	def LODData(self) -> typing.List[unsupported]: ...
	"""Static mesh LOD data.  Contains static lighting data along with instanced mesh vertex colors."""

	@property
	def StreamingTextureData(self) -> typing.List[unsupported]: ...
	"""The list of texture, bounds and scales. As computed in the texture streaming build process."""

	@property
	def LightmassSettings(self) -> typing.Any: ...
	"""The Lightmass settings for this object."""

	def SetReverseCulling(self, ReverseCulling: bool): ...
	"""Set forced reverse culling"""

	def GetLocalBounds(self) -> typing.Tuple[Vector, Vector]: ...
	"""Get Local bounds"""

	def SetEvaluateWorldPositionOffsetInRayTracing(self, NewValue: bool): ...
	"""Set Evaluate World Position Offset in Ray Tracing"""

	def SetDistanceFieldSelfShadowBias(self, NewValue: float): ...
	"""Sets the component's DistanceFieldSelfShadowBias.  bOverrideDistanceFieldSelfShadowBias must be enabled for this to have an effect."""

	def SetForcedLodModel(self, NewForcedLodModel: int): ...
	"""Set Forced Lod Model"""

	def SetStaticMesh(self, NewMesh: StaticMesh) -> bool: ...
	"""Change the StaticMesh used by this instance."""

	def OnRep_StaticMesh(self, OldStaticMesh: StaticMesh): ...
	"""On Rep Static Mesh"""

	pass

class InstancedStaticMeshComponent(StaticMeshComponent):
	"""A component that efficiently renders multiple instances of the same StaticMesh."""

	@property
	def PerInstanceSMData(self) -> typing.List[unsupported]: ...
	"""Array of instances, bulk serialized."""

	@property
	def NumCustomDataFloats(self) -> int: ...
	"""Defines the number of floats that will be available per instance for custom data"""

	@property
	def PerInstanceSMCustomData(self) -> typing.List[float]: ...
	"""Array of custom data for instances. This will contains NumCustomDataFloats*InstanceCount entries. The entries are represented sequantially, in instance order. Can be read in a material and manipulated through Blueprints.
    Example: If NumCustomDataFloats is 1, then each entry will belong to an instance. Custom data 0 will belong to Instance 0. Custom data 1 will belong to Instance 1 etc.
    Example: If NumCustomDataFloats is 2, then each pair of sequential entries belong to an instance. Custom data 0 and 1 will belong to Instance 0. Custom data 2 and 3 will belong to Instance 2 etc."""

	@property
	def InstancingRandomSeed(self) -> int: ...
	"""Value used to seed the random number stream that generates random numbers for each of this mesh's instances.
      The random number is stored in a buffer accessible to materials through the PerInstanceRandom expression. If
      this is set to zero (default), it will be populated automatically by the editor."""

	@property
	def InstanceStartCullDistance(self) -> int: ...
	"""Distance from camera at which each instance begins to fade out."""

	@property
	def InstanceEndCullDistance(self) -> int: ...
	"""Distance from camera at which each instance completely fades out."""

	@property
	def InstanceReorderTable(self) -> typing.List[int]: ...
	"""Mapping from PerInstanceSMData order to instance render buffer order. If empty, the PerInstanceSMData order is used."""

	def GetInstancesOverlappingBox(self, Box: Box, bBoxInWorldSpace: bool = ...) -> typing.List[int]: ...
	"""Returns the instances with instance bounds overlapping the specified box. The return value is an array of instance indices."""

	def GetInstancesOverlappingSphere(self, Center: Vector, Radius: float, bSphereInWorldSpace: bool = ...) -> typing.List[int]: ...
	"""Returns the instances with instance bounds overlapping the specified sphere. The return value is an array of instance indices."""

	def SetCullDistances(self, StartCullDistance: int, EndCullDistance: int): ...
	"""Sets the fading start and culling end distances for this component."""

	def GetInstanceCount(self) -> int: ...
	"""Get the number of instances in this component."""

	def ClearInstances(self): ...
	"""Clear all instances being rendered by this component."""

	def RemoveInstance(self, InstanceIndex: int) -> bool: ...
	"""Remove the instance specified. Returns True on success. Note that this will leave the array in order, but may shrink it."""

	def BatchUpdateInstancesTransform(self, StartInstanceIndex: int, NumInstances: int, NewInstancesTransform: Transform, bWorldSpace: bool = ..., bMarkRenderStateDirty: bool = ..., bTeleport: bool = ...) -> bool: ...
	"""Update the transform for a number of instances.

@param StartInstanceIndex             The starting index of the instances to update
@param NumInstances                   The number of instances to update
@param NewInstancesTransform  The new transform
@param bWorldSpace                    If true, the new transform is interpreted as a World Space transform, otherwise it is interpreted as Local Space
@param bMarkRenderStateDirty  If true, the change should be visible immediately. If you are updating many instances you should only set this to true for the last instance.
@param bTeleport                              Whether or not the instances physics should be moved normally, or teleported (moved instantly, ignoring velocity).
@return                                               True on success."""

	def BatchUpdateInstancesTransforms(self, StartInstanceIndex: int, NewInstancesTransforms: typing.List[Transform], bWorldSpace: bool = ..., bMarkRenderStateDirty: bool = ..., bTeleport: bool = ...) -> bool: ...
	"""Update the transform for an array of instances.

@param StartInstanceIndex             The starting index of the instances to update
@param NewInstancesTransforms The new transforms
@param bWorldSpace                    If true, the new transforms are interpreted as a World Space transform, otherwise it is interpreted as Local Space
@param bMarkRenderStateDirty  If true, the change should be visible immediately. If you are updating many instances you should only set this to true for the last instance.
@param bTeleport                              Whether or not the instances physics should be moved normally, or teleported (moved instantly, ignoring velocity).
@return                                               True on success."""

	def UpdateInstanceTransform(self, InstanceIndex: int, NewInstanceTransform: Transform, bWorldSpace: bool = ..., bMarkRenderStateDirty: bool = ..., bTeleport: bool = ...) -> bool: ...
	"""Update the transform for the instance specified.

@param InstanceIndex                  The index of the instance to update
@param NewInstanceTransform   The new transform
@param bWorldSpace                    If true, the new transform is interpreted as a World Space transform, otherwise it is interpreted as Local Space
@param bMarkRenderStateDirty  If true, the change should be visible immediately. If you are updating many instances you should only set this to true for the last instance.
@param bTeleport                              Whether or not the instance's physics should be moved normally, or teleported (moved instantly, ignoring velocity).
@return                                               True on success."""

	def GetInstanceTransform(self, InstanceIndex: int, bWorldSpace: bool = ...) -> typing.Tuple[bool, Transform]: ...
	"""Get the transform for the instance specified. Instance is returned in local space of this component unless bWorldSpace is set.  Returns True on success."""

	def SetCustomDataValue(self, InstanceIndex: int, CustomDataIndex: int, CustomDataValue: float, bMarkRenderStateDirty: bool = ...) -> bool: ...
	"""Update custom data for specific instance"""

	def AddInstanceWorldSpace(self, WorldTransform: Transform) -> int: ...
	"""Add an instance to this component. Transform is given in world space."""

	def AddInstances(self, InstanceTransforms: typing.List[Transform], bShouldReturnIndices: bool) -> typing.List[int]: ...
	"""Add multiple instances to this component. Transform is given in local space of this component."""

	def AddInstance(self, InstanceTransform: Transform) -> int: ...
	"""Add an instance to this component. Transform is given in local space of this component."""

	pass

class HierarchicalInstancedStaticMeshComponent(InstancedStaticMeshComponent):
	"""Hierarchical Instanced Static Mesh Component"""

	@property
	def SortedInstances(self) -> typing.List[int]: ...
	"""Table for remaping instances from cluster tree to PerInstanceSMData order"""

	@property
	def NumBuiltInstances(self) -> int: ...
	"""The number of instances in the ClusterTree. Subsequent instances will always be rendered."""

	@property
	def BuiltInstanceBounds(self) -> Box: ...
	"""Bounding box of any built instances (cached from the ClusterTree)"""

	@property
	def UnbuiltInstanceBounds(self) -> Box: ...
	"""Bounding box of any unbuilt instances"""

	@property
	def UnbuiltInstanceBoundsList(self) -> typing.List[Box]: ...
	"""Bounds of each individual unbuilt instance, used for LOD calculation"""

	@property
	def bEnableDensityScaling(self) -> bool: ...
	"""Enable for detail meshes that don't really affect the game. Disable for anything important.
Typically, this will be enabled for small meshes without collision (e.g. grass) and disabled for large meshes with collision (e.g. trees)"""

	@property
	def OcclusionLayerNumNodes(self) -> int: ...
	"""The number of nodes in the occlusion layer"""

	@property
	def CacheMeshExtendedBounds(self) -> BoxSphereBounds: ...
	"""The last mesh bounds that was cache"""

	@property
	def bDisableCollision(self) -> bool: ...
	"""Disable Collision"""

	@property
	def InstanceCountToRender(self) -> int: ...
	"""Instances to render (including removed one until the build is complete)"""

	def RemoveInstances(self, InstancesToRemove: typing.List[int]) -> bool: ...
	"""Removes all the instances with indices specified in the InstancesToRemove array. Returns true on success."""

	pass

class InputComponent(ActorComponent):
	"""Implement an Actor component for input bindings.

An Input Component is a transient component that enables an Actor to bind various forms of input events to delegate functions.
Input components are processed from a stack managed by the PlayerController and processed by the PlayerInput.
Each binding can consume the input event preventing other components on the input stack from processing the input.

See: https://docs.unrealengine.com/latest/INT/Gameplay/Input/index.html"""

	def GetAxisValue(self, AxisName: str) -> float: ...

	def GetAxisKeyValue(self, AxisKey: Key) -> float: ...

	def GetVectorAxisValue(self, AxisKey: Key) -> Vector: ...

	def HasBindings(self) -> bool: ...

	def BindAction(self, ActionName: str, Key: int, Callback: typing.Callable) -> None: ...

	def BindAxis(self, AxisName: str, Callback: typing.Callable) -> None: ...

	pass

class MovementComponent(ActorComponent):
	"""MovementComponent is an abstract component class that defines functionality for moving a PrimitiveComponent (our UpdatedComponent) each tick.
Base functionality includes:
   - Restricting movement to a plane or axis.
   - Utility functions for special handling of collision results (SlideAlongSurface(), ComputeSlideVector(), TwoWallAdjust()).
   - Utility functions for moving when there may be initial penetration (SafeMoveUpdatedComponent(), ResolvePenetration()).
   - Automatically registering the component tick and finding a component to move on the owning Actor.
Normally the root component of the owning actor is moved, however another component may be selected (see SetUpdatedComponent()).
During swept (non-teleporting) movement only collision of UpdatedComponent is considered, attached components will teleport to the end location ignoring collision."""

	@property
	def UpdatedComponent(self) -> SceneComponent: ...
	"""The component we move and update.
If this is null at startup and bAutoRegisterUpdatedComponent is true, the owning Actor's root component will automatically be set as our UpdatedComponent at startup.
See: bAutoRegisterUpdatedComponent, SetUpdatedComponent(), UpdatedPrimitive"""

	@property
	def UpdatedPrimitive(self) -> PrimitiveComponent: ...
	"""UpdatedComponent, cast as a UPrimitiveComponent. May be invalid if UpdatedComponent was null or not a UPrimitiveComponent."""

	@property
	def Velocity(self) -> Vector: ...
	"""Current velocity of updated component."""

	@property
	def bUpdateOnlyIfRendered(self) -> bool: ...
	"""If true, skips TickComponent() if UpdatedComponent was not recently rendered."""

	@property
	def bAutoUpdateTickRegistration(self) -> bool: ...
	"""If true, whenever the updated component is changed, this component will enable or disable its tick dependent on whether it has something to update.
This will NOT enable tick at startup if bAutoActivate is false, because presumably you have a good reason for not wanting it to start ticking initially."""

	@property
	def bTickBeforeOwner(self) -> bool: ...
	"""If true, after registration we will add a tick dependency to tick before our owner (if we can both tick).
This is important when our tick causes an update in the owner's position, so that when the owner ticks it uses the most recent position without lag.
Disabling this can improve performance if both objects tick but the order of ticks doesn't matter."""

	@property
	def bAutoRegisterUpdatedComponent(self) -> bool: ...
	"""If true, registers the owner's Root component as the UpdatedComponent if there is not one currently assigned."""

	@property
	def bConstrainToPlane(self) -> bool: ...
	"""If true, movement will be constrained to a plane.
See: PlaneConstraintNormal, PlaneConstraintOrigin, PlaneConstraintAxisSetting"""

	@property
	def bSnapToPlaneAtStart(self) -> bool: ...
	"""If true and plane constraints are enabled, then the updated component will be snapped to the plane when first attached."""

	@property
	def bAutoRegisterPhysicsVolumeUpdates(self) -> bool: ...
	"""If true, then applies the value of bComponentShouldUpdatePhysicsVolume to the UpdatedComponent. If false, will not change bShouldUpdatePhysicsVolume on the UpdatedComponent at all.
See: bComponentShouldUpdatePhysicsVolume"""

	@property
	def bComponentShouldUpdatePhysicsVolume(self) -> bool: ...
	"""If true, enables bShouldUpdatePhysicsVolume on the UpdatedComponent during initialization from SetUpdatedComponent(), otherwise disables such updates.
Only enabled if bAutoRegisterPhysicsVolumeUpdates is true.
WARNING: UpdatePhysicsVolume is potentially expensive if overlap events are also *disabled* because it requires a separate query against all physics volumes in the world."""

	def SnapUpdatedComponentToPlane(self): ...
	"""Snap the updated component to the plane constraint, if enabled."""

	def ConstrainNormalToPlane(self, Normal: Vector) -> Vector: ...
	"""Constrain a normal vector (of unit length) to the plane constraint, if enabled."""

	def ConstrainLocationToPlane(self, Location: Vector) -> Vector: ...
	"""Constrain a position vector to the plane constraint, if enabled."""

	def ConstrainDirectionToPlane(self, Direction: Vector) -> Vector: ...
	"""Constrain a direction vector to the plane constraint, if enabled.
@see SetPlaneConstraint"""

	def GetPlaneConstraintOrigin(self) -> Vector: ...
	"""Get the plane constraint origin. This defines the behavior of snapping a position to the plane, such as by SnapUpdatedComponentToPlane().
@return The origin of the plane that constrains movement, if the plane constraint is enabled."""

	def GetPlaneConstraintNormal(self) -> Vector: ...
	"""Returns the normal of the plane that constrains movement, enforced if the plane constraint is enabled."""

	def SetPlaneConstraintEnabled(self, bEnabled: bool): ...
	"""Sets whether or not the plane constraint is enabled."""

	def SetPlaneConstraintOrigin(self, PlaneOrigin: Vector): ...
	"""Sets the origin of the plane that constrains movement, enforced if the plane constraint is enabled."""

	def SetPlaneConstraintFromVectors(self, Forward: Vector, Up: Vector): ...
	"""Uses the Forward and Up vectors to compute the plane that constrains movement, enforced if the plane constraint is enabled."""

	def SetPlaneConstraintNormal(self, PlaneNormal: Vector): ...
	"""Sets the normal of the plane that constrains movement, enforced if the plane constraint is enabled.
Changing the normal automatically sets PlaneConstraintAxisSetting to 'Custom'.

@param PlaneNormal   The normal of the plane. If non-zero in length, it will be normalized."""

	def GetPlaneConstraintAxisSetting(self) -> int: ...
	"""Get the plane constraint axis setting."""

	def SetPlaneConstraintAxisSetting(self, NewAxisSetting: int): ...
	"""Set the plane constraint axis setting.
Changing this setting will modify the current value of PlaneConstraintNormal.

@param  NewAxisSetting New plane constraint axis setting."""

	def MoveUpdatedComponent(self, Delta: Vector, NewRotation: Rotator, bSweep: bool = ..., bTeleport: bool = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Moves our UpdatedComponent by the given Delta, and sets rotation to NewRotation.
Respects the plane constraint, if enabled.
@return True if some movement occurred, false if no movement occurred. Result of any impact will be stored in OutHit."""

	def SetUpdatedComponent(self, NewUpdatedComponent: SceneComponent): ...
	"""Assign the component we move and update."""

	def PhysicsVolumeChanged(self, NewVolume: PhysicsVolume): ...
	"""Delegate when PhysicsVolume of UpdatedComponent has been changed *"""

	def GetPhysicsVolume(self) -> PhysicsVolume: ...
	"""Returns the PhysicsVolume this MovementComponent is using, or the world's default physics volume if none. *"""

	def StopMovementImmediately(self): ...
	"""Stops movement immediately (zeroes velocity, usually zeros acceleration for components with acceleration)."""

	def IsExceedingMaxSpeed(self, MaxSpeed: float) -> bool: ...
	"""Returns true if the current velocity is exceeding the given max speed (usually the result of GetMaxSpeed()), within a small error tolerance.
Note that under normal circumstances updates cause by acceleration will not cause this to be true, however external forces or changes in the max speed limit
can cause the max speed to be violated."""

	def GetModifiedMaxSpeed(self) -> float: ...
	"""Returns the result of GetMaxSpeed() * GetMaxSpeedModifier()."""

	def GetMaxSpeed(self) -> float: ...
	"""Returns maximum speed of component in current movement mode."""

	def GetGravityZ(self) -> float: ...
	"""Returns gravity that affects this component"""

	pass

class InterpToMovementComponent(MovementComponent):
	"""Move the root component between a series of points over a given time *

See: UMovementComponent"""

	@property
	def Duration(self) -> float: ...
	"""How long to take to move from the first point to the last (or vice versa)"""

	@property
	def bPauseOnImpact(self) -> bool: ...
	"""If true, will pause movement on impact. If false it will behave as if the end of the movement range was reached based on the BehaviourType."""

	@property
	def bSweep(self) -> bool: ...
	"""If true, will sweep for blocking collision during movement. If false, it will simply teleport to the next position and ignore collision."""

	@property
	def TeleportType(self) -> int: ...
	"""Physics teleport type."""

	@property
	def BehaviourType(self) -> int: ...
	"""Movement behaviour of the component"""

	@property
	def bCheckIfStillInWorld(self) -> bool: ...
	"""Do we want this comp to perform CheckStillInWorld checks?"""

	@property
	def bForceSubStepping(self) -> bool: ...
	"""If true, forces sub-stepping to break up movement into discrete smaller steps to improve accuracy of the trajectory.
Objects that move in a straight line typically do *not* need to set this, as movement always uses continuous collision detection (sweeps) so collision is not missed.
Sub-stepping is automatically enabled when under the effects of gravity or when homing towards a target.
See: MaxSimulationTimeStep, MaxSimulationIterations"""

	@property
	def OnInterpToReverse(self) -> typing.Any: ...
	"""Called when InterpTo impacts something and reverse is enabled."""

	@property
	def OnInterpToStop(self) -> typing.Any: ...
	"""Called when InterpTo has come to a stop."""

	@property
	def OnWaitBeginDelegate(self) -> typing.Any: ...
	"""Called when InterpTo has come to a stop but will resume when possible."""

	@property
	def OnWaitEndDelegate(self) -> typing.Any: ...
	"""Called when InterpTo has resumed following a stop."""

	@property
	def OnResetDelegate(self) -> typing.Any: ...
	"""Called when InterpTo reached the end and reset back to start ."""

	@property
	def MaxSimulationTimeStep(self) -> float: ...
	"""Max time delta for each discrete simulation step.
Lowering this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.

WARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.
See: MaxSimulationIterations, bForceSubStepping"""

	@property
	def MaxSimulationIterations(self) -> int: ...
	"""Max number of iterations used for each discrete simulation step.
Increasing this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.

WARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.
See: MaxSimulationTimeStep, bForceSubStepping"""

	@property
	def ControlPoints(self) -> typing.List[InterpControlPoint]: ...
	"""List of control points to visit."""

	def FinaliseControlPoints(self): ...
	"""Initialise the control points array. Call after adding control points if they are add after begin play ."""

	def RestartMovement(self, InitialDirection: float = ...): ...
	"""Reset to start. Sets time to zero and direction to 1."""

	def StopSimulating(self, HitResult: HitResult): ...
	"""Clears the reference to UpdatedComponent, fires stop event, and stops ticking."""

	pass

class LightmassPortalComponent(SceneComponent):
	"""Lightmass Portal Component"""

	@property
	def PreviewBox(self) -> BoxComponent: ...
	"""Preview Box"""

	pass

class LineBatchComponent(PrimitiveComponent):
	"""The line batch component buffers and draws lines (and some other line-based shapes) in a scene.
    This can be useful for debug drawing, but is not very performant for runtime use."""

	pass

class LocalLightComponent(LightComponent):
	"""A light component which emits light from a single point equally in all directions."""

	@property
	def IntensityUnits(self) -> int: ...
	"""Units used for the intensity.
The peak luminous intensity is measured in candelas,
while the luminous power is measured in lumens."""

	@property
	def AttenuationRadius(self) -> float: ...
	"""Bounds the light's visible influence.
This clamping of the light's influence is not physically correct but very important for performance, larger lights cost more."""

	@property
	def LightmassSettings(self) -> typing.Any: ...
	"""The Lightmass settings for this object."""

	@staticmethod
	def GetUnitsConversionFactor(SrcUnits: int, TargetUnits: int, CosHalfConeAngle: float = ...) -> float: ...
	"""Get Units Conversion Factor"""

	def SetIntensityUnits(self, NewIntensityUnits: int): ...
	"""Set the units used for the intensity of the light"""

	def SetAttenuationRadius(self, NewRadius: float): ...
	"""Set Attenuation Radius"""

	pass

class LODSyncComponent(ActorComponent):
	"""Implement an Actor component for LOD Sync of different components

This is a component that allows multiple different components to sync together of their LOD

This allows to find the highest LOD of all the parts, and sync to that LOD"""

	@property
	def NumLODs(self) -> int: ...
	"""if -1, it's default and it will calculate the max number of LODs from all sub components
if not, it is a number of LODs (not the max index of LODs)"""

	@property
	def ForcedLOD(self) -> int: ...
	"""if -1, it's automatically switching"""

	@property
	def ComponentsToSync(self) -> typing.List[ComponentSync]: ...
	"""Array of components whose LOD may drive or be driven by this component.
Components that are flagged as 'Drive' are treated as being in priority order, with the last component having highest priority. The highest priority
visible component will set the LOD for all other components. If no components are visible, then the highest priority non-visible component will set LOD."""

	@property
	def CustomLODMapping(self) -> typing.Dict[str, str]: ...
	"""by default, the mapping will be one to one
but if you want custom, add here."""

	def GetLODSyncDebugText(self) -> str: ...
	"""Returns a string detailing"""

	pass

class MaterialBillboardComponent(PrimitiveComponent):
	"""A 2d material that will be rendered always facing the camera."""

	@property
	def Elements(self) -> typing.List[MaterialSpriteElement]: ...
	"""Current array of material billboard elements"""

	def AddElement(self, Material: MaterialInterface, DistanceToOpacityCurve: CurveFloat, bSizeIsInScreenSpace: bool, BaseSizeX: float, BaseSizeY: float, DistanceToSizeCurve: CurveFloat): ...
	"""Adds an element to the sprite."""

	def SetElements(self, NewElements: typing.List[MaterialSpriteElement]): ...
	"""Set all elements of this material billboard component"""

	pass

class ModelComponent(PrimitiveComponent):
	"""ModelComponents are PrimitiveComponents that represent elements of BSP geometry in a ULevel object.
They are used exclusively by ULevel and are not intended as general-purpose components.

See: ULevel"""

	@property
	def ModelBodySetup(self) -> typing.Any: ...
	"""Description of collision"""

	pass

class PawnNoiseEmitterComponent(ActorComponent):
	"""PawnNoiseEmitterComponent tracks noise event data used by SensingComponents to hear a Pawn.
This component is intended to exist on either a Pawn or its Controller. It does nothing on network clients."""

	@property
	def LastRemoteNoisePosition(self) -> Vector: ...
	"""Most recent noise made by this pawn not at its own location"""

	@property
	def NoiseLifetime(self) -> float: ...
	"""After this amount of time, new sound events will overwrite previous sounds even if they are not louder (allows old sounds to decay)"""

	def MakeNoise(self, NoiseMaker: Actor, Loudness: float, NoiseLocation: Vector): ...
	"""Cache noises instigated by the owning pawn for AI sensing
@param NoiseMaker - is the actual actor which made the noise
@param Loudness - is the relative loudness of the noise (0.0 to 1.0)
@param NoiseLocation - is the position of the noise"""

	pass

class SceneCaptureComponent(SceneComponent):
	"""-> will be exported to EngineDecalClasses.h"""

	@property
	def PrimitiveRenderMode(self) -> int: ...
	"""Controls what primitives get rendered into the scene capture."""

	@property
	def CaptureSource(self) -> int: ...
	"""Capture Source"""

	@property
	def bCaptureEveryFrame(self) -> bool: ...
	"""Whether to update the capture's contents every frame.  If disabled, the component will render once on load and then only when moved."""

	@property
	def bCaptureOnMovement(self) -> bool: ...
	"""Whether to update the capture's contents on movement.  Disable if you are going to capture manually from blueprint."""

	@property
	def bAlwaysPersistRenderingState(self) -> bool: ...
	"""Whether to persist the rendering state even if bCaptureEveryFrame==false.  This allows velocities for Motion Blur and Temporal AA to be computed."""

	@property
	def HiddenComponents(self) -> typing.List[PrimitiveComponent]: ...
	"""The components won't rendered by current component."""

	@property
	def HiddenActors(self) -> typing.List[Actor]: ...
	"""The actors to hide in the scene capture."""

	@property
	def ShowOnlyComponents(self) -> typing.List[PrimitiveComponent]: ...
	"""The only components to be rendered by this scene capture, if PrimitiveRenderMode is set to UseShowOnlyList."""

	@property
	def ShowOnlyActors(self) -> typing.List[Actor]: ...
	"""The only actors to be rendered by this scene capture, if PrimitiveRenderMode is set to UseShowOnlyList."""

	@property
	def LODDistanceFactor(self) -> float: ...
	"""Scales the distance used by LOD. Set to values greater than 1 to cause the scene capture to use lower LODs than the main view to speed up the scene capture pass."""

	@property
	def MaxViewDistanceOverride(self) -> float: ...
	"""if > 0, sets a maximum render distance override.  Can be used to cull distant objects from a reflection if the reflecting plane is in an enclosed area like a hallway or room"""

	@property
	def CaptureSortPriority(self) -> int: ...
	"""Capture priority within the frame to sort scene capture on GPU to resolve interdependencies between multiple capture components. Highest come first."""

	@property
	def bUseRayTracingIfEnabled(self) -> bool: ...
	"""Whether to use ray tracing for this capture. Ray Tracing must be enabled in the project."""

	@property
	def ShowFlagSettings(self) -> typing.List[EngineShowFlagsSetting]: ...
	"""ShowFlags for the SceneCapture's ViewFamily, to control rendering settings for this view. Hidden but accessible through details customization"""

	@property
	def ProfilingEventName(self) -> str: ...
	"""Name of the profiling event."""

	def SetCaptureSortPriority(self, NewCaptureSortPriority: int): ...
	"""Changes the value of TranslucentSortPriority."""

	def ClearHiddenComponents(self): ...
	"""Clears the hidden list."""

	def ClearShowOnlyComponents(self): ...
	"""Clears the Show Only list."""

	def RemoveShowOnlyActorComponents(self, InActor: Actor, bIncludeFromChildActors: bool = ...): ...
	"""Removes an actor's components from the Show Only list.
@param bIncludeFromChildActors Whether to remove the components from child actors"""

	def RemoveShowOnlyComponent(self, InComponent: PrimitiveComponent): ...
	"""Removes a component from the Show Only list."""

	def ShowOnlyActorComponents(self, InActor: Actor, bIncludeFromChildActors: bool = ...): ...
	"""Adds all primitive components in the actor to our list of show-only components.
@param bIncludeFromChildActors Whether to include the components from child actors"""

	def ShowOnlyComponent(self, InComponent: PrimitiveComponent): ...
	"""Adds the component to our list of show-only components."""

	def HideActorComponents(self, InActor: Actor, bIncludeFromChildActors: bool = ...): ...
	"""Adds all primitive components in the actor to our list of hidden components.
@param bIncludeFromChildActors Whether to include the components from child actors"""

	def HideComponent(self, InComponent: PrimitiveComponent): ...
	"""Adds the component to our list of hidden components."""

	pass

class PlanarReflectionComponent(SceneCaptureComponent):
	"""UPlanarReflectionComponent"""

	@property
	def PreviewBox(self) -> BoxComponent: ...
	"""Preview Box"""

	@property
	def NormalDistortionStrength(self) -> float: ...
	"""Controls the strength of normals when distorting the planar reflection."""

	@property
	def PrefilterRoughness(self) -> float: ...
	"""The roughness value to prefilter the planar reflection texture with, useful for hiding low resolution.  Larger values have larger GPU cost."""

	@property
	def PrefilterRoughnessDistance(self) -> float: ...
	"""The distance at which the prefilter roughness value will be achieved."""

	@property
	def ScreenPercentage(self) -> int: ...
	"""Downsample percent, can be used to reduce GPU time rendering the planar reflection."""

	@property
	def ExtraFOV(self) -> float: ...
	"""Additional FOV used when rendering to the reflection texture.
This is useful when normal distortion is causing reads outside the reflection texture.
Larger values increase rendering thread and GPU cost, as more objects and triangles have to be rendered into the planar reflection."""

	@property
	def DistanceFromPlaneFadeoutStart(self) -> float: ...
	"""Receiving pixels at this distance from the reflection plane will begin to fade out the planar reflection."""

	@property
	def DistanceFromPlaneFadeoutEnd(self) -> float: ...
	"""Receiving pixels at this distance from the reflection plane will have completely faded out the planar reflection."""

	@property
	def AngleFromPlaneFadeStart(self) -> float: ...
	"""Receiving pixels whose normal is at this angle from the reflection plane will begin to fade out the planar reflection."""

	@property
	def AngleFromPlaneFadeEnd(self) -> float: ...
	"""Receiving pixels whose normal is at this angle from the reflection plane will have completely faded out the planar reflection."""

	@property
	def bShowPreviewPlane(self) -> bool: ...
	"""Show Preview Plane"""

	@property
	def bRenderSceneTwoSided(self) -> bool: ...
	"""Whether to render the scene as two-sided, which can be useful to hide artifacts where normal distortion would read 'under' an object that has been clipped by the reflection plane.
With this setting enabled, the backfaces of a mesh would be displayed in the clipped region instead of the background which is potentially a bright sky.
Be sure to add the water plane to HiddenActors if enabling this, as the water plane will now block the reflection."""

	pass

class PlaneReflectionCaptureComponent(ReflectionCaptureComponent):
	"""-> will be exported to EngineDecalClasses.h"""

	@property
	def InfluenceRadiusScale(self) -> float: ...
	"""Radius of the area that can receive reflections from this capture."""

	@property
	def PreviewInfluenceRadius(self) -> DrawSphereComponent: ...
	"""Preview Influence Radius"""

	@property
	def PreviewCaptureBox(self) -> BoxComponent: ...
	"""Preview Capture Box"""

	pass

class PlatformEventsComponent(ActorComponent):
	"""Component to handle receiving notifications from the OS about platform events."""

	@property
	def PlatformChangedToLaptopModeDelegate(self) -> typing.Any: ...
	"""This is called when a convertible laptop changed into laptop mode."""

	@property
	def PlatformChangedToTabletModeDelegate(self) -> typing.Any: ...
	"""This is called when a convertible laptop changed into tablet mode."""

	def SupportsConvertibleLaptops(self) -> bool: ...
	"""Check whether the platform supports convertible laptops.

Note: This does not necessarily mean that the platform is a convertible laptop.
For example, convertible laptops running Windows 7 or older will return false,
and regular laptops running Windows 8 or newer will return true.

@return true for convertible laptop platforms, false otherwise.
@see IsInLaptopMode, IsInTabletMode"""

	def IsInTabletMode(self) -> bool: ...
	"""Check whether a convertible laptop is laptop mode.

@return true if in tablet mode, false otherwise or if not a convertible laptop.
@see IsInLaptopMode, SupportsConvertibleLaptops"""

	def IsInLaptopMode(self) -> bool: ...
	"""Check whether a convertible laptop is laptop mode.

@return true if in laptop mode, false otherwise or if not a convertible laptop.
@see IsInTabletMode, SupportsConvertibleLaptops"""

	pass

class PointLightComponent(LocalLightComponent):
	"""A light component which emits light from a single point equally in all directions."""

	@property
	def bUseInverseSquaredFalloff(self) -> bool: ...
	"""Whether to use physically based inverse squared distance falloff, where AttenuationRadius is only clamping the light's contribution.
Disabling inverse squared falloff can be useful when placing fill lights (don't want a super bright spot near the light).
When enabled, the light's Intensity is in units of lumens, where 1700 lumens is a 100W lightbulb.
When disabled, the light's Intensity is a brightness scale."""

	@property
	def LightFalloffExponent(self) -> float: ...
	"""Controls the radial falloff of the light when UseInverseSquaredFalloff is disabled.
2 is almost linear and very unrealistic and around 8 it looks reasonable.
With large exponents, the light has contribution to only a small area of its influence radius but still costs the same as low exponents."""

	@property
	def SourceRadius(self) -> float: ...
	"""Radius of light source shape.
Note that light sources shapes which intersect shadow casting geometry can cause shadowing artifacts."""

	@property
	def SoftSourceRadius(self) -> float: ...
	"""Soft radius of light source shape.
Note that light sources shapes which intersect shadow casting geometry can cause shadowing artifacts."""

	@property
	def SourceLength(self) -> float: ...
	"""Length of light source shape.
Note that light sources shapes which intersect shadow casting geometry can cause shadowing artifacts."""

	def SetSourceLength(self, NewValue: float): ...
	"""Set Source Length"""

	def SetSoftSourceRadius(self, bNewValue: float): ...
	"""Set Soft Source Radius"""

	def SetSourceRadius(self, bNewValue: float): ...
	"""Set Source Radius"""

	def SetLightFalloffExponent(self, NewLightFalloffExponent: float): ...
	"""Set Light Falloff Exponent"""

	pass

class SkinnedMeshComponent(MeshComponent):
	"""Skinned mesh component that supports bone skinned mesh rendering.
This class does not support animation.

See: USkeletalMeshComponent"""

	@property
	def SkeletalMesh(self) -> SkeletalMesh: ...
	"""The skeletal mesh used by this component."""

	@property
	def MasterPoseComponent(self) -> SkinnedMeshComponent: ...
	"""If set, this SkeletalMeshComponent will not use its SpaceBase for bone transform, but will
use the component space transforms from the MasterPoseComponent. This is used when constructing a character using multiple skeletal meshes sharing the same
skeleton within the same Actor."""

	@property
	def SkinCacheUsage(self) -> typing.List[int]: ...
	"""How this Component's LOD uses the skin cache feature. Auto will defer to the asset's (SkeletalMesh) option. If Ray Tracing is enabled, will imply Enabled"""

	@property
	def VertexOffsetUsage(self) -> typing.List[VertexOffsetUsage]: ...
	"""Vertex Offset Usage"""

	@property
	def PhysicsAssetOverride(self) -> PhysicsAsset: ...
	"""PhysicsAsset is set in SkeletalMesh by default, but you can override with this value"""

	@property
	def ForcedLodModel(self) -> int: ...
	"""Forced Lod Model"""

	@property
	def MinLodModel(self) -> int: ...
	"""This is the min LOD that this component will use.  (e.g. if set to 2 then only 2+ LOD Models will be used.) This is useful to set on
meshes which are known to be a certain distance away and still want to have better LODs when zoomed in on them."""

	@property
	def StreamingDistanceMultiplier(self) -> float: ...
	"""Allows adjusting the desired streaming distance of streaming textures that uses UV 0.
1.0 is the default, whereas a higher value makes the textures stream in sooner from far away.
A lower value (0.0-1.0) makes the textures stream in later (you have to be closer).
Value can be < 0 (from legcay content, or code changes)"""

	@property
	def LODInfo(self) -> typing.List[unsupported]: ...
	"""LOD array info. Each index will correspond to the LOD index *"""

	@property
	def VisibilityBasedAnimTickOption(self) -> int: ...
	"""* This is tick animation frequency option based on this component rendered or not or using montage
*  You can change this default value in the INI file
* Mostly related with performance"""

	@property
	def bOverrideMinLod(self) -> bool: ...
	"""Whether we should use the min lod specified in MinLodModel for this component instead of the min lod in the mesh"""

	@property
	def bUseBoundsFromMasterPoseComponent(self) -> bool: ...
	"""When true, we will just using the bounds from our MasterPoseComponent.  This is useful for when we have a Mesh Parented
to the main SkelMesh (e.g. outline mesh or a full body overdraw effect that is toggled) that is always going to be the same
bounds as parent.  We want to do no calculations in that case."""

	@property
	def bForceWireframe(self) -> bool: ...
	"""Forces the mesh to draw in wireframe mode."""

	@property
	def bDisableMorphTarget(self) -> bool: ...
	"""Disable Morphtarget for this component."""

	@property
	def bHideSkin(self) -> bool: ...
	"""Don't bother rendering the skin."""

	@property
	def bPerBoneMotionBlur(self) -> bool: ...
	"""If true, use per-bone motion blur on this skeletal mesh (requires additional rendering, can be disabled to save performance)."""

	@property
	def bComponentUseFixedSkelBounds(self) -> bool: ...
	"""When true, skip using the physics asset etc. and always use the fixed bounds defined in the SkeletalMesh."""

	@property
	def bConsiderAllBodiesForBounds(self) -> bool: ...
	"""If true, when updating bounds from a PhysicsAsset, consider _all_ BodySetups, not just those flagged with bConsiderForBounds."""

	@property
	def bSyncAttachParentLOD(self) -> bool: ...
	"""If true, this component uses its parents LOD when attached if available
ForcedLOD can override this change. By default, it will use parent LOD."""

	@property
	def bCanHighlightSelectedSections(self) -> bool: ...
	"""Whether or not we can highlight selected sections - this should really only be done in the editor"""

	@property
	def bRecentlyRendered(self) -> bool: ...
	"""true if mesh has been recently rendered, false otherwise"""

	@property
	def bCastCapsuleDirectShadow(self) -> bool: ...
	"""Whether to use the capsule representation (when present) from a skeletal mesh's ShadowPhysicsAsset for direct shadowing from lights.
This type of shadowing is approximate but handles extremely wide area shadowing well.  The softness of the shadow depends on the light's LightSourceAngle / SourceRadius.
This flag will force bCastInsetShadow to be enabled."""

	@property
	def bCastCapsuleIndirectShadow(self) -> bool: ...
	"""Whether to use the capsule representation (when present) from a skeletal mesh's ShadowPhysicsAsset for shadowing indirect lighting (from lightmaps or skylight)."""

	@property
	def bCPUSkinning(self) -> bool: ...
	"""CPUSkinning"""

	@property
	def bEnableUpdateRateOptimizations(self) -> bool: ...
	"""if TRUE, Owner will determine how often animation will be updated and evaluated. See AnimUpdateRateTick()
This allows to skip frames for performance. (For example based on visibility and size on screen)."""

	@property
	def bDisplayDebugUpdateRateOptimizations(self) -> bool: ...
	"""Enable on screen debugging of update rate optimization.
Red = Skipping 0 frames, Green = skipping 1 frame, Blue = skipping 2 frames, black = skipping more than 2 frames.
@todo: turn this into a console command."""

	@property
	def bRenderStatic(self) -> bool: ...
	"""If true, render as static in reference pose."""

	@property
	def bIgnoreMasterPoseComponentLOD(self) -> bool: ...
	"""Flag that when set will ensure UpdateLODStatus will not take the MasterPoseComponent's current LOD in consideration when determining the correct LOD level (this requires MasterPoseComponent's LOD to always be >= determined LOD otherwise bone transforms could be missing"""

	@property
	def CapsuleIndirectShadowMinVisibility(self) -> float: ...
	"""Controls how dark the capsule indirect shadow can be."""

	def SetRenderStatic(self, bNewValue: bool): ...
	"""Set whether this skinned mesh should be rendered as static mesh in a reference pose

@param       whether this skinned mesh should be rendered as static"""

	def IsMaterialSectionShown(self, MaterialID: int, LODIndex: int) -> bool: ...
	"""Returns whether a specific material section is currently hidden on this component (by using ShowMaterialSection)"""

	def ShowAllMaterialSections(self, LODIndex: int): ...
	"""Clear any material visibility modifications made by ShowMaterialSection"""

	def ShowMaterialSection(self, MaterialID: int, SectionIndex: int, bShow: bool, LODIndex: int): ...
	"""Allows hiding of a particular material (by ID) on this instance of a SkeletalMesh.

@param MaterialID - Index of the material show/hide
@param bShow - True to show the material, false to hide it
@param LODIndex - Index of the LOD to modify material visibility within"""

	def IsBoneHiddenByName(self, BoneName: str) -> bool: ...
	"""Determines if the specified bone is hidden.

@param  BoneName            Name of bone to check

@return true if hidden"""

	def UnHideBoneByName(self, BoneName: str): ...
	"""UnHide the specified bone with name.  Currently this just enforces a scale of 0 for the hidden bones.
Compared to HideBone By Index - This keeps track of list of bones and update when LOD changes
@param  BoneName            Name of bone to unhide"""

	def HideBoneByName(self, BoneName: str, PhysBodyOption: int): ...
	"""Hides the specified bone with name.  Currently this just enforces a scale of 0 for the hidden bones.
Compared to HideBone By Index - This keeps track of list of bones and update when LOD changes

@param  BoneName            Name of bone to hide
@param  PhysBodyOption          Option for physics bodies that attach to the bones to be hidden"""

	def FindClosestBone_K2(self, TestLocation: Vector, IgnoreScale: float = ..., bRequirePhysicsAsset: bool = ...) -> typing.Tuple[str, Vector]: ...
	"""finds the closest bone to the given location

@param TestLocation the location to test against
@param BoneLocation (optional, out) if specified, set to the world space location of the bone that was found, or (0,0,0) if no bone was found
@param IgnoreScale (optional) if specified, only bones with scaling larger than the specified factor are considered
@param bRequirePhysicsAsset (optional) if true, only bones with physics will be considered

@return the name of the bone that was found, or 'None' if no bone was found"""

	def TransformFromBoneSpace(self, BoneName: str, InPosition: Vector, InRotation: Rotator) -> typing.Tuple[Vector, Rotator]: ...
	"""Transform a location/rotation in bone relative space to world space.

@param BoneName Name of bone
@param InPosition Input position
@param InRotation Input rotation
@param OutPosition (out) Transformed position
@param OutRotation (out) Transformed rotation"""

	def TransformToBoneSpace(self, BoneName: str, InPosition: Vector, InRotation: Rotator) -> typing.Tuple[Vector, Rotator]: ...
	"""Transform a location/rotation from world space to bone relative space.
This is handy if you know the location in world space for a bone attachment, as AttachComponent takes location/rotation in bone-relative space.

@param BoneName Name of bone
@param InPosition Input position
@param InRotation Input rotation
@param OutPosition (out) Transformed position
@param OutRotation (out) Transformed rotation"""

	def GetRefPosePosition(self, BoneIndex: int) -> Vector: ...
	"""Gets the local-space position of a bone in the reference pose.

@param BoneIndex Index of the bone

@return Local space reference position"""

	def BoneIsChildOf(self, BoneName: str, ParentBoneName: str) -> bool: ...
	"""Tests if BoneName is child of (or equal to) ParentBoneName.

@param BoneName Name of the bone
@param ParentBone Name to check

@return true if child (strictly, not same). false otherwise
Note - will return false if ChildBoneIndex is the same as ParentBoneIndex ie. must be strictly a child."""

	def SetMasterPoseComponent(self, NewMasterBoneComponent: SkinnedMeshComponent, bForceUpdate: bool = ...): ...
	"""Set MasterPoseComponent for this component

@param NewMasterBoneComponent New MasterPoseComponent"""

	def SetPostSkinningOffsets(self, LODIndex: int, Offsets: typing.List[Vector]): ...
	"""Set Post Skinning Offsets"""

	def SetPreSkinningOffsets(self, LODIndex: int, Offsets: typing.List[Vector]): ...
	"""Set Pre Skinning Offsets"""

	def SetVertexOffsetUsage(self, LODIndex: int, Usage: int): ...
	"""Set Vertex Offset Usage"""

	def GetVertexOffsetUsage(self, LODIndex: int) -> int: ...
	"""Get Vertex Offset Usage"""

	def IsUsingSkinWeightProfile(self) -> bool: ...
	"""Check whether or not a Skin Weight Profile is currently set"""

	def GetCurrentSkinWeightProfileName(self) -> str: ...
	"""Return the name of the Skin Weight Profile that is currently set otherwise returns 'None'"""

	def UnloadSkinWeightProfile(self, InProfileName: str): ...
	"""Unload a Skin Weight Profile's skin weight buffer (if created)"""

	def ClearSkinWeightProfile(self): ...
	"""Clear the Skin Weight Profile from this component, in case it is set"""

	def SetSkinWeightProfile(self, InProfileName: str) -> bool: ...
	"""Setup an override Skin Weight Profile for this component"""

	def ClearSkinWeightOverride(self, LODIndex: int): ...
	"""Clear any applied skin weight override"""

	def SetSkinWeightOverride(self, LODIndex: int, SkinWeights: typing.List[SkelMeshSkinWeightInfo]): ...
	"""Allow override of skin weights on a per-component basis."""

	def ClearVertexColorOverride(self, LODIndex: int): ...
	"""Clear any applied vertex color override"""

	def SetVertexColorOverride_LinearColor(self, LODIndex: int, VertexColors: typing.List[LinearColor]): ...
	"""Allow override of vertex colors on a per-component basis, taking array of Blueprint-friendly LinearColors."""

	def GetTwistAndSwingAngleOfDeltaRotationFromRefPose(self, BoneName: str) -> typing.Tuple[bool, float, float]: ...
	"""Get Twist and Swing Angle in Degree of Delta Rotation from Reference Pose in Local space

First this function gets rotation of current, and rotation of ref pose in local space, and
And gets twist/swing angle value from refpose aligned.

@param BoneName Name of the bone
@param OutTwistAngle TwistAngle in degree
@param OutSwingAngle SwingAngle in degree

@return true if succeed. False otherwise. Often due to incorrect bone name."""

	def GetDeltaTransformFromRefPose(self, BoneName: str, BaseName: str = ...) -> Transform: ...
	"""Get delta transform from reference pose based on BaseNode.
This uses last frame up-to-date transform, so it will have a frame delay if you use this info in the AnimGraph

@param BoneName Name of the bone
@param BaseName Name of the base bone - if none, it will use parent as a base

@return the delta transform from refpose in that given space (BaseName)"""

	def GetParentBone(self, BoneName: str) -> str: ...
	"""Get Parent Bone of the input bone

@param BoneName Name of the bone

@return the name of the parent bone for the specified bone. Returns 'None' if the bone does not exist or it is the root bone"""

	def SetSkeletalMesh(self, NewMesh: SkeletalMesh, bReinitPose: bool = ...): ...
	"""Change the SkeletalMesh that is rendered for this Component. Will re-initialize the animation tree etc.

@param NewMesh New mesh to set for this component
@param bReinitPose Whether we should keep current pose or reinitialize."""

	def GetSocketBoneName(self, InSocketName: str) -> str: ...
	"""Returns bone name linked to a given named socket on the skeletal mesh component.
If you're unsure to deal with sockets or bones names, you can use this function to filter through, and always return the bone name.

@param       bone name or socket name

@return      bone name"""

	def GetBoneName(self, BoneIndex: int) -> str: ...
	"""Get Bone Name from index
@param BoneIndex Index of the bone

@return the name of the bone at the specified index"""

	def GetBoneIndex(self, BoneName: str) -> int: ...
	"""Find the index of bone by name. Looks in the current SkeletalMesh being used by this SkeletalMeshComponent.

@param BoneName Name of bone to look up

@return Index of the named bone in the current SkeletalMesh. Will return INDEX_NONE if bone not found.

@see USkeletalMesh::GetBoneIndex."""

	def GetNumBones(self) -> int: ...
	"""Returns the number of bones in the skeleton."""

	def SetCapsuleIndirectShadowMinVisibility(self, NewValue: float): ...
	"""Set Capsule Indirect Shadow Min Visibility"""

	def SetCastCapsuleIndirectShadow(self, bNewValue: bool): ...
	"""Set Cast Capsule Indirect Shadow"""

	def SetCastCapsuleDirectShadow(self, bNewValue: bool): ...
	"""Set Cast Capsule Direct Shadow"""

	def GetForcedLOD(self) -> int: ...
	"""Get ForcedLodModel of the mesh component. Note that the actual forced LOD level is the return value minus one and zero means no forced LOD"""

	def SetForcedLOD(self, InNewForcedLOD: int): ...
	"""Set ForcedLodModel of the mesh component

@param       InNewForcedLOD  Set new ForcedLODModel that forces to set the incoming LOD. Range from [1, Max Number of LOD]. This will affect in the next tick update."""

	def SetMinLOD(self, InNewMinLOD: int): ...
	"""Set MinLodModel of the mesh component

@param       InNewMinLOD     Set new MinLodModel that make sure the LOD does not go below of this value. Range from [0, Max Number of LOD - 1]. This will affect in the next tick update."""

	def GetNumLODs(self) -> int: ...
	"""Get the number of LODs on this component"""

	def SetPhysicsAsset(self, NewPhysicsAsset: PhysicsAsset, bForceReInit: bool = ...): ...
	"""Override the Physics Asset of the mesh. It uses SkeletalMesh.PhysicsAsset, but if you'd like to override use this function

@param       NewPhysicsAsset New PhysicsAsset
@param       bForceReInit    Force reinitialize"""

	pass

class PoseableMeshComponent(SkinnedMeshComponent):
	"""UPoseableMeshComponent that allows bone transforms to be driven by blueprint."""

	def CopyPoseFromSkeletalComponent(self, InComponentToCopy: SkeletalMeshComponent): ...
	"""Copy Pose from Skeletal Component"""

	def ResetBoneTransformByName(self, BoneName: str): ...
	"""Reset Bone Transform by Name"""

	def GetBoneScaleByName(self, BoneName: str, BoneSpace: int) -> Vector: ...
	"""Get Bone Scale by Name"""

	def GetBoneRotationByName(self, BoneName: str, BoneSpace: int) -> Rotator: ...
	"""Get Bone Rotation by Name"""

	def GetBoneLocationByName(self, BoneName: str, BoneSpace: int) -> Vector: ...
	"""Get Bone Location by Name"""

	def GetBoneTransformByName(self, BoneName: str, BoneSpace: int) -> Transform: ...
	"""Get Bone Transform by Name"""

	def SetBoneScaleByName(self, BoneName: str, InScale3D: Vector, BoneSpace: int): ...
	"""Set Bone Scale by Name"""

	def SetBoneRotationByName(self, BoneName: str, InRotation: Rotator, BoneSpace: int): ...
	"""Set Bone Rotation by Name"""

	def SetBoneLocationByName(self, BoneName: str, InLocation: Vector, BoneSpace: int): ...
	"""Set Bone Location by Name"""

	def SetBoneTransformByName(self, BoneName: str, InTransform: Transform, BoneSpace: int): ...
	"""Set Bone Transform by Name"""

	pass

class PostProcessComponent(SceneComponent):
	"""PostProcessComponent. Enables Post process controls for blueprints.
   Will use a parent UShapeComponent to provide volume data if available."""

	@property
	def Settings(self) -> PostProcessSettings: ...
	"""Post process settings to use for this volume."""

	@property
	def Priority(self) -> float: ...
	"""Priority of this volume. In the case of overlapping volumes the one with the highest priority
overrides the lower priority ones. The order is undefined if two or more overlapping volumes have the same priority."""

	@property
	def BlendRadius(self) -> float: ...
	"""World space radius around the volume that is used for blending (only if not unbound)."""

	@property
	def BlendWeight(self) -> float: ...
	"""0:no effect, 1:full effect"""

	@property
	def bEnabled(self) -> bool: ...
	"""Whether this volume is enabled or not."""

	@property
	def bUnbound(self) -> bool: ...
	"""set this to false to use the parent shape component as volume bounds. True affects the whole world regardless."""

	def AddOrUpdateBlendable(self, InBlendableObject, InWeight: float = ...): ...
	"""Adds an Blendable (implements IBlendableInterface) to the array of Blendables (if it doesn't exist) and update the weight"""

	pass

class RectLightComponent(LocalLightComponent):
	"""A light component which emits light from a rectangle."""

	@property
	def SourceWidth(self) -> float: ...
	"""Width of light source rect.
Note that light sources shapes which intersect shadow casting geometry can cause shadowing artifacts."""

	@property
	def SourceHeight(self) -> float: ...
	"""Height of light source rect.
Note that light sources shapes which intersect shadow casting geometry can cause shadowing artifacts."""

	@property
	def BarnDoorAngle(self) -> float: ...
	"""Angle of barn door attached to the light source rect."""

	@property
	def BarnDoorLength(self) -> float: ...
	"""Length of barn door attached to the light source rect."""

	@property
	def SourceTexture(self) -> Texture: ...
	"""Texture mapped to the light source rectangle"""

	def SetBarnDoorLength(self, NewValue: float): ...
	"""Set Barn Door Length"""

	def SetBarnDoorAngle(self, NewValue: float): ...
	"""Set Barn Door Angle"""

	def SetSourceHeight(self, NewValue: float): ...
	"""Set Source Height"""

	def SetSourceWidth(self, bNewValue: float): ...
	"""Set Source Width"""

	def SetSourceTexture(self, bNewValue: Texture): ...
	"""Set Source Texture"""

	pass

class RuntimeVirtualTextureComponent(SceneComponent):
	"""Component used to place a URuntimeVirtualTexture in the world."""

	def Invalidate(self, WorldBounds: BoxSphereBounds): ...
	"""This function marks an area of the runtime virtual texture as dirty.
@param WorldBounds : The world space bounds of the pages to invalidate."""

	pass

class SceneCaptureComponent2D(SceneCaptureComponent):
	"""Used to capture a 'snapshot' of the scene from a single plane and feed it to a render target."""

	@property
	def ProjectionType(self) -> int: ...
	"""Projection Type"""

	@property
	def FOVAngle(self) -> float: ...
	"""Camera field of view (in degrees)."""

	@property
	def OrthoWidth(self) -> float: ...
	"""The desired width (in world units) of the orthographic view (ignored in Perspective mode)"""

	@property
	def TextureTarget(self) -> TextureRenderTarget2D: ...
	"""Output render target of the scene capture that can be read in materals."""

	@property
	def CompositeMode(self) -> int: ...
	"""When enabled, the scene capture will composite into the render target instead of overwriting its contents."""

	@property
	def PostProcessSettings(self) -> PostProcessSettings: ...
	"""Post Process Settings"""

	@property
	def PostProcessBlendWeight(self) -> float: ...
	"""Range (0.0, 1.0) where 0 indicates no effect, 1 indicates full effect."""

	@property
	def bOverride_CustomNearClippingPlane(self) -> bool: ...
	"""Override Custom Near Clipping Plane"""

	@property
	def CustomNearClippingPlane(self) -> float: ...
	"""Set bOverride_CustomNearClippingPlane to true if you want to use a custom clipping plane instead of GNearClippingPlane."""

	@property
	def bUseCustomProjectionMatrix(self) -> bool: ...
	"""Whether a custom projection matrix will be used during rendering. Use with caution. Does not currently affect culling"""

	@property
	def CustomProjectionMatrix(self) -> Matrix: ...
	"""The custom projection matrix to use"""

	@property
	def bEnableClipPlane(self) -> bool: ...
	"""Enables a clip plane while rendering the scene capture which is useful for portals.
The global clip plane must be enabled in the renderer project settings for this to work."""

	@property
	def ClipPlaneBase(self) -> Vector: ...
	"""Base position for the clip plane, can be any position on the plane."""

	@property
	def ClipPlaneNormal(self) -> Vector: ...
	"""Normal for the plane."""

	@property
	def bCameraCutThisFrame(self) -> bool: ...
	"""True if we did a camera cut this frame. Automatically reset to false at every capture.
This flag affects various things in the renderer (such as whether to use the occlusion queries from last frame, and motion blur).
Similar to UPlayerCameraManager::bGameCameraCutThisFrame."""

	@property
	def bConsiderUnrenderedOpaquePixelAsFullyTranslucent(self) -> bool: ...
	"""Treat unrendered opaque pixels as fully translucent. This is important for effects such as exponential weight fog, so it does not get applied on unrendered opaque pixels."""

	@property
	def bDisableFlipCopyGLES(self) -> bool: ...
	"""Scene captures render an extra flip pass for LDR color on GLES so that the final output is oriented correctly.
This check disabled the extra flip pass, improving performance, but causes the capture to be flipped vertically.
(Does not affect scene captures on other non-GLES renderers or with non-LDR output)"""

	def CaptureScene(self): ...
	"""Render the scene to the texture target immediately.
This should not be used if bCaptureEveryFrame is enabled, or the scene capture will render redundantly."""

	def AddOrUpdateBlendable(self, InBlendableObject, InWeight: float = ...): ...
	"""Adds an Blendable (implements IBlendableInterface) to the array of Blendables (if it doesn't exist) and update the weight"""

	pass

class SceneCaptureComponentCube(SceneCaptureComponent):
	"""Used to capture a 'snapshot' of the scene from a 6 planes and feed it to a render target."""

	@property
	def TextureTarget(self) -> TextureRenderTargetCube: ...
	"""Temporary render target that can be used by the editor."""

	@property
	def bCaptureRotation(self) -> bool: ...
	"""Preserve the rotation of the actor when updating the capture. The default behavior is to capture the cube aligned to the world axis system."""

	@property
	def TextureTargetLeft(self) -> TextureRenderTargetCube: ...
	"""Omni-directional Stereo Capture

If vr.ODSCapture is enabled and both left, right and ODS render targets are set,
we'll ignore the texture target and instead do an omni-directional stereo capture.
Warped cube maps will be rendered into the left and right texture targets using the
IPD property for stereo offset. We will then reconstruct a stereo lat-long with the left
eye stacked on top of the right eye in the ODS target.
See: https://developers.google.com/vr/jump/rendering-ods-content.pdf"""

	@property
	def TextureTargetRight(self) -> TextureRenderTargetCube: ...
	"""Texture Target Right"""

	@property
	def TextureTargetODS(self) -> TextureRenderTarget2D: ...
	"""Texture Target ODS"""

	@property
	def IPD(self) -> float: ...
	"""IPD"""

	def CaptureScene(self): ...
	"""Render the scene to the texture target immediately.
This should not be used if bCaptureEveryFrame is enabled, or the scene capture will render redundantly."""

	pass

class SkeletalMeshComponent(SkinnedMeshComponent):
	"""SkeletalMeshComponent is used to create an instance of an animated SkeletalMesh asset.

See: https://docs.unrealengine.com/latest/INT/Engine/Content/Types/SkeletalMeshes/
See: USkeletalMesh"""

	@property
	def AnimBlueprintGeneratedClass(self) -> Object: ...
	"""Anim Blueprint Generated Class"""

	@property
	def AnimClass(self) -> AnimInstance: ...
	"""The AnimBlueprint class to use. Use 'SetAnimInstanceClass' to change at runtime."""

	@property
	def AnimScriptInstance(self) -> AnimInstance: ...
	"""The active animation graph program instance."""

	@property
	def PostProcessAnimInstance(self) -> AnimInstance: ...
	"""An instance created from the PostPhysicsBlueprint property of the skeletal mesh we're using,
Runs after (and receives pose from) the main anim instance."""

	@property
	def AnimationData(self) -> SingleAnimationPlayData: ...
	"""Animation Data"""

	@property
	def RootBoneTranslation(self) -> Vector: ...
	"""Offset of the root bone from the reference pose. Used to offset bounding box."""

	@property
	def LineCheckBoundsScale(self) -> Vector: ...
	"""If bEnableLineCheckWithBounds is true, scale the bounds by this value before doing line check."""

	@property
	def GlobalAnimRateScale(self) -> float: ...
	"""Used to scale speed of all animations on this skeletal mesh."""

	@property
	def KinematicBonesUpdateType(self) -> int: ...
	"""If we are running physics, should we update non-simulated bones based on the animation bone positions."""

	@property
	def PhysicsTransformUpdateMode(self) -> int: ...
	"""Whether physics simulation updates component transform."""

	@property
	def bUpdateOverlapsOnAnimationFinalize(self) -> bool: ...
	"""Controls whether blending in physics bones will refresh overlaps on this component, defaults to true but can be disabled in cases where we know anim->physics blending doesn't meaningfully change overlaps"""

	@property
	def bHasValidBodies(self) -> bool: ...
	"""If true, there is at least one body in the current PhysicsAsset with a valid bone in the current SkeletalMesh"""

	@property
	def bBlendPhysics(self) -> bool: ...
	"""Enables blending in of physics bodies whether Simulate or not"""

	@property
	def bEnablePhysicsOnDedicatedServer(self) -> bool: ...
	"""If true, simulate physics for this component on a dedicated server.
This should be set if simulating physics and replicating with a dedicated server.
    Note: This property cannot be changed at runtime."""

	@property
	def bUpdateJointsFromAnimation(self) -> bool: ...
	"""If we should pass joint position to joints each frame, so that they can be used by motorized joints to drive the
ragdoll based on the animation."""

	@property
	def bDisableClothSimulation(self) -> bool: ...
	"""Disable cloth simulation and play original animation without simulation"""

	@property
	def bCollideWithEnvironment(self) -> bool: ...
	"""can't collide with part of environment if total collision volumes exceed 16 capsules or 32 planes per convex"""

	@property
	def bCollideWithAttachedChildren(self) -> bool: ...
	"""can't collide with part of attached children if total collision volumes exceed 16 capsules or 32 planes per convex"""

	@property
	def bLocalSpaceSimulation(self) -> bool: ...
	"""It's worth trying this option when you feel that the current cloth simulation is unstable.
The scale of the actor is maintained during the simulation.
It is possible to add the inertia effects to the simulation, through the inertiaScale parameter of the clothing material.
So with an inertiaScale of 1.0 there should be no visible difference between local space and global space simulation.
Known issues: - Currently there's simulation issues when this feature is used in 3.x (DE4076) So if localSpaceSim is enabled there's no inertia effect when the global pose of the clothing actor changes."""

	@property
	def bResetAfterTeleport(self) -> bool: ...
	"""reset the clothing after moving the clothing position (called teleport)"""

	@property
	def bDeferKinematicBoneUpdate(self) -> bool: ...
	"""Whether animation and world transform updates are deferred. If this is on, the kinematic bodies (scene query data) will not update until the next time the physics simulation is run"""

	@property
	def bNoSkeletonUpdate(self) -> bool: ...
	"""Skips Ticking and Bone Refresh."""

	@property
	def bPauseAnims(self) -> bool: ...
	"""pauses this component's animations (doesn't tick them, but still refreshes bones)"""

	@property
	def bUseRefPoseOnInitAnim(self) -> bool: ...
	"""On InitAnim should we set to ref pose (if false use first tick of animation data)"""

	@property
	def bEnablePerPolyCollision(self) -> bool: ...
	"""Uses skinned data for collision data."""

	@property
	def bForceRefpose(self) -> bool: ...
	"""If true, force the mesh into the reference pose - is an optimization."""

	@property
	def bOnlyAllowAutonomousTickPose(self) -> bool: ...
	"""If true TickPose() will not be called from the Component's TickComponent function.
It will instead be called from Autonomous networking updates. See ACharacter."""

	@property
	def bIsAutonomousTickPose(self) -> bool: ...
	"""True if calling TickPose() from Autonomous networking updates. See ACharacter."""

	@property
	def bOldForceRefPose(self) -> bool: ...
	"""If bForceRefPose was set last tick."""

	@property
	def bShowPrePhysBones(self) -> bool: ...
	"""Bool that enables debug drawing of the skeleton before it is passed to the physics. Useful for debugging animation-driven physics."""

	@property
	def bRequiredBonesUpToDate(self) -> bool: ...
	"""If false, indicates that on the next call to UpdateSkelPose the RequiredBones array should be recalculated."""

	@property
	def bAnimTreeInitialised(self) -> bool: ...
	"""If true, AnimTree has been initialised."""

	@property
	def bIncludeComponentLocationIntoBounds(self) -> bool: ...
	"""If true, the Location of this Component will be included into its bounds calculation
(this can be useful when using SMU_OnlyTickPoseWhenRendered on a character that moves away from the root and no bones are left near the origin of the component)"""

	@property
	def bEnableLineCheckWithBounds(self) -> bool: ...
	"""If true, line checks will test against the bounding box of this skeletal mesh component and return a hit if there is a collision."""

	@property
	def bPropagateCurvesToSlaves(self) -> bool: ...
	"""If true, propagates calls to ApplyAnimationCurvesToComponent for slave components, only needed if slave components do not tick themselves"""

	@property
	def bSkipKinematicUpdateWhenInterpolating(self) -> bool: ...
	"""Whether to skip UpdateKinematicBonesToAnim() when interpolating. Kinematic bones are updated to the target interpolation pose only on ticks when they are evaluated."""

	@property
	def bSkipBoundsUpdateWhenInterpolating(self) -> bool: ...
	"""Whether to skip bounds update when interpolating. Bounds are updated to the target interpolation pose only on ticks when they are evaluated."""

	@property
	def CachedAnimCurveUidVersion(self) -> int: ...
	"""Cache AnimCurveUidVersion from Skeleton and this will be used to identify if it needs to be updated"""

	@property
	def ClothBlendWeight(self) -> float: ...
	"""weight to blend between simulated results and key-framed positions
if weight is 1.0, shows only cloth simulation results and 0.0 will show only skinned results"""

	@property
	def bWaitForParallelClothTask(self) -> bool: ...
	"""Whether we should stall the Cloth tick task until the cloth simulation is complete. This is required if we want up-to-date
cloth data on the game thread, for example if we want to generate particles at cloth vertices."""

	@property
	def BodySetup(self) -> typing.Any: ...
	"""Used for per poly collision. In 99% of cases you will be better off using a Physics Asset.
This BodySetup is per instance because all modification of vertices is done in place"""

	@property
	def OnConstraintBroken(self) -> typing.Any: ...
	"""Notification when constraint is broken."""

	@property
	def ClothingSimulationFactory(self) -> typing.Any: ...
	"""Class of the object responsible for"""

	@property
	def OnAnimInitialized(self) -> typing.Any: ...
	"""Broadcast when the components anim instance is initialized"""

	def GetCurrentJointAngles(self, InBoneName: str) -> typing.Tuple[float, float, float]: ...
	"""Gets the current Angular state for a named bone constraint
@param InBoneName  Name of bone to get constraint ranges for
@param Swing1Angle current angular state of the constraint
@param TwistAngle  current angular state of the constraint
@param Swing2Angle current angular state of the constraint"""

	def SetAngularLimits(self, InBoneName: str, Swing1LimitAngle: float, TwistLimitAngle: float, Swing2LimitAngle: float): ...
	"""Sets the Angular Motion Ranges for a named bone
@param InBoneName  Name of bone to adjust constraint ranges for
@param Swing1LimitAngle       Size of limit in degrees, 0 means locked, 180 means free
@param TwistLimitAngle        Size of limit in degrees, 0 means locked, 180 means free
@param Swing2LimitAngle       Size of limit in degrees, 0 means locked, 180 means free"""

	def BreakConstraint(self, Impulse: Vector, HitLocation: Vector, InBoneName: str): ...
	"""Break a constraint off a Gore mesh.

@param       Impulse vector of impulse
@param       HitLocation     location of the hit
@param       InBoneName      Name of bone to break constraint for"""

	def FindConstraintBoneName(self, ConstraintIndex: int) -> str: ...
	"""Find Constraint Name from index

@param       ConstraintIndex Index of constraint to look for
@return      Constraint Joint Name"""

	def SetConstraintProfileForAll(self, ProfileName: str, bDefaultIfNotFound: bool = ...): ...
	"""Sets the constraint profile properties (limits, motors, etc...) to match the constraint profile as defined in the physics asset for all constraints. If profile name is not found the joint is set to use the default constraint profile."""

	def SetConstraintProfile(self, JointName: str, ProfileName: str, bDefaultIfNotFound: bool = ...): ...
	"""Sets the constraint profile properties (limits, motors, etc...) to match the constraint profile as defined in the physics asset. If profile name is not found the joint is set to use the default constraint profile."""

	def SetAllMotorsAngularDriveParams(self, InSpring: float, InDamping: float, InForceLimit: float, bSkipCustomPhysicsType: bool = ...): ...
	"""Set Angular Drive motors params for all constraint instances"""

	def SetAllMotorsAngularVelocityDrive(self, bEnableSwingDrive: bool, bEnableTwistDrive: bool, bSkipCustomPhysicsType: bool = ...): ...
	"""Enable or Disable AngularVelocityDrive. If motor is in SLERP mode it will be turned on if either EnableSwingDrive OR EnableTwistDrive are enabled. In Twist and Swing mode the twist and the swing can be controlled individually."""

	def SetAllMotorsAngularPositionDrive(self, bEnableSwingDrive: bool, bEnableTwistDrive: bool, bSkipCustomPhysicsType: bool = ...): ...
	"""Enable or Disable AngularPositionDrive. If motor is in SLERP mode it will be turned on if either EnableSwingDrive OR EnableTwistDrive are enabled. In Twist and Swing mode the twist and the swing can be controlled individually."""

	def AccumulateAllBodiesBelowPhysicsBlendWeight(self, InBoneName: str, AddPhysicsBlendWeight: float, bSkipCustomPhysicsType: bool = ...): ...
	"""Accumulate AddPhysicsBlendWeight to physics blendweight for all of the bones below passed in bone to be simulated"""

	def SetAllBodiesBelowPhysicsBlendWeight(self, InBoneName: str, PhysicsBlendWeight: float, bSkipCustomPhysicsType: bool = ..., bIncludeSelf: bool = ...): ...
	"""Set all of the bones below passed in bone to be simulated"""

	def SetAllBodiesPhysicsBlendWeight(self, PhysicsBlendWeight: float, bSkipCustomPhysicsType: bool = ...): ...
	"""Set All Bodies Physics Blend Weight"""

	def ResetAllBodiesSimulatePhysics(self): ...
	"""Allows you to reset bodies Simulate state based on where bUsePhysics is set to true in the BodySetup."""

	def SetAllBodiesBelowSimulatePhysics(self, InBoneName: str, bNewSimulate: bool, bIncludeSelf: bool = ...): ...
	"""Set all of the bones below passed in bone to be simulated"""

	def SetEnablePhysicsBlending(self, bNewBlendPhysics: bool): ...
	"""Disable physics blending of bones *"""

	def SetPhysicsBlendWeight(self, PhysicsBlendWeight: float): ...
	"""This is global set up for setting physics blend weight
This does multiple things automatically
If PhysicsBlendWeight == 1.f, it will enable Simulation, and if PhysicsBlendWeight == 0.f, it will disable Simulation.
Also it will respect each body's setup, so if the body is fixed, it won't simulate. Vice versa
So if you'd like all bodies to change manually, do not use this function, but SetAllBodiesPhysicsBlendWeight"""

	def SetAllBodiesSimulatePhysics(self, bNewSimulate: bool): ...
	"""Set bSimulatePhysics to true for all bone bodies. Does not change the component bSimulatePhysics flag."""

	def TermBodiesBelow(self, ParentBoneName: str): ...
	"""Terminate physics on all bodies below the named bone, effectively disabling collision forever. If you terminate, you won't be able to re-init later."""

	def AddImpulseToAllBodiesBelow(self, Impulse: Vector, BoneName: str = ..., bVelChange: bool = ..., bIncludeSelf: bool = ...): ...
	"""Add impulse to all single rigid bodies below. Good for one time instant burst.

@param  Impulse         Magnitude and direction of impulse to apply.
@param  BoneName        If a SkeletalMeshComponent, name of body to apply impulse to. 'None' indicates root body.
@param  bVelChange      If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no effect).
@param bIncludeSelf If false, Force is only applied to bodies below but not given bone name."""

	def AddForceToAllBodiesBelow(self, Force: Vector, BoneName: str = ..., bAccelChange: bool = ..., bIncludeSelf: bool = ...): ...
	"""Add a force to all rigid bodies below.
This is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.

@param  Force            Force vector to apply. Magnitude indicates strength of force.
@param  BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body.
@param  bAccelChange If true, Force is taken as a change in acceleration instead of a physical force (i.e. mass will have no effect).
@param  bIncludeSelf If false, Force is only applied to bodies below but not given bone name."""

	def GetSkeletalCenterOfMass(self) -> Vector: ...
	"""Returns the center of mass of the skeletal mesh, instead of the root body's location"""

	def GetBoneMass(self, BoneName: str = ..., bScaleMass: bool = ...) -> float: ...
	"""Returns the mass (in kg) of the given bone

@param BoneName         Name of the body to return. 'None' indicates root body.
@param bScaleMass       If true, the mass is scaled by the bone's MassScale."""

	def GetClosestPointOnPhysicsAsset(self, WorldPosition: Vector) -> typing.Tuple[bool, Vector, Vector, str, float]: ...
	"""Given a world position, find the closest point on the physics asset. Note that this is independent of collision and welding. This is based purely on animation position
@param      WorldPosition                           The point we want the closest point to (i.e. for all bodies in the physics asset, find the one that has a point closest to WorldPosition)
@param      ClosestPointOnPhysicsAsset      The data associated with the closest point (position, normal, etc...)
@return     true if we found a closest point"""

	def SetEnableGravityOnAllBodiesBelow(self, bEnableGravity: bool, BoneName: str, bIncludeSelf: bool = ...): ...
	"""Enables or disables gravity to all bodies below the given bone.
NAME_None indicates all bodies will be edited.
In that case, consider using UPrimitiveComponent::EnableGravity.

@param bEnableGravity   Whether gravity should be enabled or disabled.
@param BoneName                 The name of the top most bone.
@param bIncludeSelf             Whether the bone specified should be edited."""

	def IsBodyGravityEnabled(self, BoneName: str) -> bool: ...
	"""Checks whether or not gravity is enabled on the given bone.
NAME_None indicates the root body should be queried.
If the bone name given is otherwise invalid, false is returned.

@param BoneName The name of the bone to check.
@return True if gravity is enabled on the bone."""

	def SetEnableBodyGravity(self, bEnableGravity: bool, BoneName: str): ...
	"""Enables or disables gravity for the given bone.
NAME_None indicates the root body will be edited.
If the bone name given is otherwise invalid, nothing happens.

@param bEnableGravity   Whether gravity should be enabled or disabled.
@param BoneName                 The name of the bone to modify."""

	def SetNotifyRigidBodyCollisionBelow(self, bNewNotifyRigidBodyCollision: bool, BoneName: str = ..., bIncludeSelf: bool = ...): ...
	"""Changes the value of bNotifyRigidBodyCollision on all bodies below a given bone
@param bNewNotifyRigidBodyCollision   The value to assign to bNotifyRigidBodyCollision
@param BoneName                                               Name of the body to turn hit notifies on (and below)
@param bIncludeSelf                                   Whether to modify the given body (useful for roots with multiple children)"""

	def SetBodyNotifyRigidBodyCollision(self, bNewNotifyRigidBodyCollision: bool, BoneName: str = ...): ...
	"""Changes the value of bNotifyRigidBodyCollision for a given body
@param bNewNotifyRigidBodyCollision   The value to assign to bNotifyRigidBodyCollision
@param BoneName                                               Name of the body to turn hit notifies on/off. None implies root body"""

	def GetClothingSimulationInteractor(self) -> typing.Any: ...
	"""Get the current interactor for a clothing simulation, if the current simulation supports runtime interaction."""

	def SetTeleportDistanceThreshold(self, Threshold: float): ...
	"""Sets the teleportation distance threshold.

@param threshold Threshold value."""

	def GetTeleportDistanceThreshold(self) -> float: ...
	"""Gets the teleportation distance threshold.

@return Threshold value."""

	def SetTeleportRotationThreshold(self, Threshold: float): ...
	"""Sets the teleportation rotation threshold.

@param threshold Threshold in degrees."""

	def GetTeleportRotationThreshold(self) -> float: ...
	"""Gets the teleportation rotation threshold.

@return Threshold in degrees."""

	def SetAllowedAnimCurvesEvaluation(self, List: typing.List[str], bAllow: bool): ...
	"""resets, and then only allow the following list to be allowed/disallowed"""

	def ResetAllowedAnimCurveEvaluation(self): ...
	"""By reset, it will allow all the curves to be evaluated"""

	def AllowAnimCurveEvaluation(self, NameOfCurve: str, bAllow: bool): ...
	"""Allow Anim Curve Evaluation"""

	def GetAllowedAnimCurveEvaluate(self) -> bool: ...
	"""Get Allowed Anim Curve Evaluate"""

	def SetAllowAnimCurveEvaluation(self, bInAllow: bool): ...
	"""Set Allow Anim Curve Evaluation"""

	def GetDisableAnimCurves(self) -> bool: ...
	"""Get Disable Anim Curves"""

	def SetDisableAnimCurves(self, bInDisableAnimCurves: bool): ...
	"""Set Disable Anim Curves"""

	def SetUpdateClothInEditor(self, NewUpdateState: bool): ...
	"""Sets whether or not to animate cloth in the editor. Requires Update Animation In Editor to also be true.
This is supported only in the editor"""

	def SetUpdateAnimationInEditor(self, NewUpdateState: bool): ...
	"""Sets whether or not to force tick component in order to update animation and refresh transform for this component
This is supported only in the editor"""

	def GetAllowRigidBodyAnimNode(self) -> bool: ...
	"""Get Allow Rigid Body Anim Node"""

	def SetAllowRigidBodyAnimNode(self, bInAllow: bool, bReinitAnim: bool = ...): ...
	"""Sets whether or not to allow rigid body animation nodes for this component"""

	def UnbindClothFromMasterPoseComponent(self, bRestoreSimulationSpace: bool = ...): ...
	"""If this component has a valid MasterPoseComponent and has previously had its cloth bound to the
MCP, this function will unbind the cloth and resume simulation.
@param bRestoreSimulationSpace if true and the master pose cloth was originally simulating in world
space, we will restore this setting. This will cause the master component to reset which may be
undesirable."""

	def BindClothToMasterPoseComponent(self): ...
	"""If this component has a valid MasterPoseComponent then this function makes cloth items on the slave component
take the transforms of the cloth items on the master component instead of simulating separately.
@Note This will FORCE any cloth actor on the master component to simulate in local space. Also
The meshes used in the components must be identical for the cloth to bind correctly"""

	def ResetClothTeleportMode(self): ...
	"""Reset the teleport mode of a next update to 'Continuous'"""

	def IsClothingSimulationSuspended(self) -> bool: ...
	"""Gets whether or not the clothing simulation is currently suspended"""

	def ResumeClothingSimulation(self): ...
	"""Resumes a previously suspended clothing simulation, teleporting the clothing on the next tick"""

	def SuspendClothingSimulation(self): ...
	"""Stops simulating clothing, but does not show clothing ref pose. Keeps the last known simulation state"""

	def ForceClothNextUpdateTeleportAndReset(self): ...
	"""Used to indicate we should force 'teleport and reset' during the next call to UpdateClothState.
This can be used to reset it from a bad state or by a teleport where the old state is not important anymore."""

	def ForceClothNextUpdateTeleport(self): ...
	"""Used to indicate we should force 'teleport' during the next call to UpdateClothState,
This will transform positions and velocities and thus keep the simulation state, just translate it to a new pose."""

	def SetClothMaxDistanceScale(self, Scale: float): ...
	"""Set Cloth Max Distance Scale"""

	def GetClothMaxDistanceScale(self) -> float: ...
	"""Get/Set the max distance scale of clothing mesh vertices"""

	def SnapshotPose(self, Snapshot: PoseSnapshot): ...
	"""Takes a snapshot of this skeletal mesh component's pose and saves it to the specified snapshot.
The snapshot is taken at the current LOD, so if for example you took the snapshot at LOD1
and then used it at LOD0 any bones not in LOD1 will use the reference pose"""

	def GetMorphTarget(self, MorphTargetName: str) -> float: ...
	"""Get Morph target with given name"""

	def ClearMorphTargets(self): ...
	"""Clear all Morph Target that are set to this mesh"""

	def SetMorphTarget(self, MorphTargetName: str, Value: float, bRemoveZeroWeight: bool = ...): ...
	"""Set Morph Target with Name and Value(0-1)

@param bRemoveZeroWeight : Used by editor code when it should stay in the active list with zero weight"""

	def OverrideAnimationData(self, InAnimToPlay: AnimationAsset, bIsLooping: bool = ..., bIsPlaying: bool = ..., Position: float = ..., PlayRate: float = ...): ...
	"""This overrides current AnimationData parameter in the SkeletalMeshComponent. This will serialize when the component serialize
so it can be used during construction script. However note that this will override current existing data
This can be useful if you'd like to make a blueprint with custom default animation per component
This sets single player mode, which means you can't use AnimBlueprint with it"""

	def GetPlayRate(self) -> float: ...
	"""Animation play functions
      *
      * These changes status of animation instance, which is transient data, which means it won't serialize with this component
      * Because of that reason, it is not safe to be used during construction script
      * Please use OverrideAnimationDatat for construction script. That will override AnimationData to be serialized"""

	def SetPlayRate(self, Rate: float): ...
	"""Animation play functions
      *
      * These changes status of animation instance, which is transient data, which means it won't serialize with this component
      * Because of that reason, it is not safe to be used during construction script
      * Please use OverrideAnimationDatat for construction script. That will override AnimationData to be serialized"""

	def GetPosition(self) -> float: ...
	"""Animation play functions
      *
      * These changes status of animation instance, which is transient data, which means it won't serialize with this component
      * Because of that reason, it is not safe to be used during construction script
      * Please use OverrideAnimationDatat for construction script. That will override AnimationData to be serialized"""

	def SetPosition(self, InPos: float, bFireNotifies: bool = ...): ...
	"""Animation play functions
      *
      * These changes status of animation instance, which is transient data, which means it won't serialize with this component
      * Because of that reason, it is not safe to be used during construction script
      * Please use OverrideAnimationDatat for construction script. That will override AnimationData to be serialized"""

	def IsPlaying(self) -> bool: ...
	"""Animation play functions
      *
      * These changes status of animation instance, which is transient data, which means it won't serialize with this component
      * Because of that reason, it is not safe to be used during construction script
      * Please use OverrideAnimationDatat for construction script. That will override AnimationData to be serialized"""

	def Stop(self): ...
	"""Animation play functions
      *
      * These changes status of animation instance, which is transient data, which means it won't serialize with this component
      * Because of that reason, it is not safe to be used during construction script
      * Please use OverrideAnimationDatat for construction script. That will override AnimationData to be serialized"""

	def Play(self, bLooping: bool): ...
	"""Animation play functions
      *
      * These changes status of animation instance, which is transient data, which means it won't serialize with this component
      * Because of that reason, it is not safe to be used during construction script
      * Please use OverrideAnimationDatat for construction script. That will override AnimationData to be serialized"""

	def SetAnimation(self, NewAnimToPlay: AnimationAsset): ...
	"""Animation play functions
      *
      * These changes status of animation instance, which is transient data, which means it won't serialize with this component
      * Because of that reason, it is not safe to be used during construction script
      * Please use OverrideAnimationDatat for construction script. That will override AnimationData to be serialized"""

	def PlayAnimation(self, NewAnimToPlay: AnimationAsset, bLooping: bool): ...
	"""Animation play functions
       *
       * These changes status of animation instance, which is transient data, which means it won't serialize with this component
       * Because of that reason, it is not safe to be used during construction script
       * Please use OverrideAnimationDatat for construction script. That will override AnimationData to be serialized"""

	def GetAnimationMode(self) -> int: ...
	"""Get Animation Mode"""

	def SetAnimationMode(self, InAnimationMode: int): ...
	"""Below are the interface to control animation when animation mode, not blueprint mode *"""

	def ResetAnimInstanceDynamics(self, InTeleportType: int = ...): ...
	"""Informs any active anim instances (main instance, linked instances, post instance) that a dynamics reset is required
for example if a teleport occurs."""

	def HasValidAnimationInstance(self) -> bool: ...
	"""Returns whether there are any valid instances to run, currently this means whether we have
have an animation instance or a post process instance available to process."""

	def GetLinkedAnimLayerInstanceByClass(self, InClass: AnimInstance) -> AnimInstance: ...
	"""Gets the first layer linked instance corresponding to the specified class"""

	def GetLinkedAnimLayerInstanceByGroup(self, InGroup: str) -> AnimInstance: ...
	"""Gets the layer linked instance corresponding to the specified group"""

	def UnlinkAnimClassLayers(self, InClass: AnimInstance): ...
	"""Runs through all layer nodes, attempting to find layer nodes that are currently running the specified class, then resets each to its default value.
State sharing rules are as with SetLayerOverlay.
If InClass is null, does nothing."""

	def LinkAnimClassLayers(self, InClass: AnimInstance): ...
	"""Runs through all layer nodes, attempting to find layer nodes that are implemented by the specified class, then sets up a linked instance of the class for each.
Allocates one linked instance to run each of the groups specified in the class, so state is shared. If a layer is not grouped (ie. NAME_None), then state is not shared
and a separate linked instance is allocated for each layer node.
If InClass is null, then all layers are reset to their defaults."""

	def LinkAnimGraphByTag(self, InTag: str, InClass: AnimInstance): ...
	"""Runs through all nodes, attempting to find linked instance by name/tag, then sets the class of each node if the tag matches"""

	def GetLinkedAnimGraphInstancesByTag(self, InTag: str) -> typing.List[AnimInstance]: ...
	"""Returns all tagged linked instance nodes that match the tag."""

	def GetLinkedAnimGraphInstanceByTag(self, InTag: str) -> AnimInstance: ...
	"""Returns the a tagged linked instance node. If no linked instances are found or none are tagged with the
supplied name, this will return NULL."""

	def GetPostProcessInstance(self) -> AnimInstance: ...
	"""Returns the active post process instance is one is available. This is set on the mesh that this
component is using, and is evaluated immediately after the main instance."""

	def GetAnimInstance(self) -> AnimInstance: ...
	"""Returns the animation instance that is driving the class (if available). This is typically an instance of
the class set as AnimBlueprintGeneratedClass (generated by an animation blueprint)
Since this instance is transient, it is not safe to be used during construction script"""

	def GetAnimClass(self) -> Object: ...
	"""Get the anim instance class via getter callable by sequencer."""

	def SetAnimClass(self, NewClass: Object): ...
	"""Set the anim instance class. Clears and re-initializes the anim instance with the new class and sets animation mode to 'AnimationBlueprint'"""

	def GetStringAttribute(self, BoneName: str, AttributeName: str, DefaultValue: str, LookupType: int = ...) -> typing.Tuple[bool, str]: ...
	"""Get string type custom attribute value.

@param BoneName Name of the bone to retrieve try and retrieve the attribute from
@param AttributeName Name of the attribute to retrieve
@param DefaultValue In case the attribute could not be found
@param OutValue Retrieved attribute value if found, otherwise is set to DefaultValue
@param LookupType Determines how the attribute is retrieved from the specified BoneName (see ECustomBoneAttributeLookup)
@return Whether or not the atttribute was successfully retrieved"""

	def GetIntegerAttribute(self, BoneName: str, AttributeName: str, DefaultValue: int, LookupType: int = ...) -> typing.Tuple[bool, int]: ...
	"""Get integer type custom attribute value.

@param BoneName Name of the bone to retrieve try and retrieve the attribute from
@param AttributeName Name of the attribute to retrieve
@param DefaultValue In case the attribute could not be found
@param OutValue Retrieved attribute value if found, otherwise is set to DefaultValue
@param LookupType Determines how the attribute is retrieved from the specified BoneName (see ECustomBoneAttributeLookup)
@return Whether or not the atttribute was successfully retrieved"""

	def GetFloatAttribute(self, BoneName: str, AttributeName: str, DefaultValue: float, LookupType: int = ...) -> typing.Tuple[bool, float]: ...
	"""Get float type custom attribute value.

@param BoneName Name of the bone to retrieve try and retrieve the attribute from
@param AttributeName Name of the attribute to retrieve
@param DefaultValue In case the attribute could not be found
@param OutValue Retrieved attribute value if found, otherwise is set to DefaultValue
@param LookupType Determines how the attribute is retrieved from the specified BoneName (see ECustomBoneAttributeLookup)
@return Whether or not the atttribute was successfully retrieved"""

	def GetStringAttribute_Ref(self, BoneName: str, AttributeName: str, OutValue: str, LookupType: int = ...) -> bool: ...
	"""Get string type custom attribute value.

@param BoneName Name of the bone to retrieve try and retrieve the attribute from
@param AttributeName Name of the attribute to retrieve
@param DefaultValue In case the attribute could not be found
@param OutValue (reference) Retrieved attribute value if found, otherwise is set to DefaultValue
@param LookupType Determines how the attribute is retrieved from the specified BoneName (see ECustomBoneAttributeLookup)
@return Whether or not the atttribute was successfully retrieved"""

	def GetIntegerAttribute_Ref(self, BoneName: str, AttributeName: str, OutValue: int, LookupType: int = ...) -> bool: ...
	"""Get integer type custom attribute value.

@param BoneName Name of the bone to retrieve try and retrieve the attribute from
@param AttributeName Name of the attribute to retrieve
@param DefaultValue In case the attribute could not be found
@param OutValue (reference) Retrieved attribute value if found, otherwise is set to DefaultValue
@param LookupType Determines how the attribute is retrieved from the specified BoneName (see ECustomBoneAttributeLookup)
@return Whether or not the atttribute was successfully retrieved"""

	def GetFloatAttribute_Ref(self, BoneName: str, AttributeName: str, OutValue: float, LookupType: int = ...) -> bool: ...
	"""Get float type custom attribute value.

@param BoneName Name of the bone to retrieve try and retrieve the attribute from
@param AttributeName Name of the attribute to retrieve
@param DefaultValue In case the attribute could not be found
@param OutValue (reference) Retrieved attribute value if found, otherwise is set to DefaultValue
@param LookupType Determines how the attribute is retrieved from the specified BoneName (see ECustomBoneAttributeLookup)
@return Whether or not the atttribute was successfully retrieved"""

	def SetDisablePostProcessBlueprint(self, bInDisablePostProcess: bool): ...
	"""Sets whether the post process blueprint is currently running for this component.
If it is not currently running, and is set to run, the instance will be reinitialized"""

	def GetDisablePostProcessBlueprint(self) -> bool: ...
	"""Gets whether the post process blueprint is currently disabled for this component"""

	def ToggleDisablePostProcessBlueprint(self): ...
	"""Toggles whether the post process blueprint will run for this component"""

	pass

class SkyAtmosphereComponent(SceneComponent):
	"""A component that represents a planet atmosphere material and simulates sky and light scattering within it.
See: https://docs.unrealengine.com/en-US/Engine/Actors/FogEffects/SkyAtmosphere/index.html"""

	@property
	def TransformMode(self) -> int: ...
	"""The ground albedo that will tint the astmophere when the sun light will bounce on it. Only taken into account when MultiScattering>0.0."""

	@property
	def BottomRadius(self) -> float: ...
	"""The planet radius. (kilometers from the center to the ground level)."""

	@property
	def GroundAlbedo(self) -> Color: ...
	"""The ground albedo that will tint the astmophere when the sun light will bounce on it. Only taken into account when MultiScattering>0.0."""

	@property
	def AtmosphereHeight(self) -> float: ...
	"""The planet radius. (kilometers from the center to the ground level)."""

	@property
	def MultiScatteringFactor(self) -> float: ...
	"""Render multi scattering as if sun light would bounce around in the atmosphere. This is achieved using a dual scattering approach."""

	@property
	def TraceSampleCountScale(self) -> float: ...
	"""Scale the atmosphere tracing sample count. Quality level scalability
The sample count is still clamped according to scalability setting to 'r.SkyAtmosphere.SampleCountMax' when 'r.SkyAtmosphere.FastSkyLUT' is 0.
The sample count is still clamped according to scalability setting to 'r.SkyAtmosphere.FastSkyLUT.SampleCountMax' when 'r.SkyAtmosphere.FastSkyLUT' is 1.
The sample count is still clamped for aerial perspective according to  'r.SkyAtmosphere.AerialPerspectiveLUT.SampleCountMaxPerSlice'."""

	@property
	def RayleighScatteringScale(self) -> float: ...
	"""Rayleigh scattering coefficient scale."""

	@property
	def RayleighScattering(self) -> LinearColor: ...
	"""The Rayleigh scattering coefficients resulting from molecules in the air at an altitude of 0 kilometer."""

	@property
	def RayleighExponentialDistribution(self) -> float: ...
	"""The altitude in kilometer at which Rayleigh scattering effect is reduced to 40%."""

	@property
	def MieScatteringScale(self) -> float: ...
	"""Mie scattering coefficient scale."""

	@property
	def MieScattering(self) -> LinearColor: ...
	"""The Mie scattering coefficients resulting from particles in the air at an altitude of 0 kilometer. As it becomes higher, light will be scattered more."""

	@property
	def MieAbsorptionScale(self) -> float: ...
	"""Mie absorption coefficient scale."""

	@property
	def MieAbsorption(self) -> LinearColor: ...
	"""The Mie absorption coefficients resulting from particles in the air at an altitude of 0 kilometer. As it becomes higher, light will be absorbed more."""

	@property
	def MieAnisotropy(self) -> float: ...
	"""A value of 0 mean light is uniformly scattered. A value closer to 1 means lights will scatter more forward, resulting in halos around light sources."""

	@property
	def MieExponentialDistribution(self) -> float: ...
	"""The altitude in kilometer at which Mie effects are reduced to 40%."""

	@property
	def OtherAbsorptionScale(self) -> float: ...
	"""Absorption coefficients for another atmosphere layer. Density increase from 0 to 1 between 10 to 25km and decreases from 1 to 0 between 25 to 40km. This approximates ozone molecules distribution in the Earth atmosphere."""

	@property
	def OtherAbsorption(self) -> LinearColor: ...
	"""Absorption coefficients for another atmosphere layer. Density increase from 0 to 1 between 10 to 25km and decreases from 1 to 0 between 25 to 40km. The default values represents ozone molecules absorption in the Earth atmosphere."""

	@property
	def OtherTentDistribution(self) -> TentDistribution: ...
	"""Represents the altitude based tent distribution of absorption particles in the atmosphere."""

	@property
	def SkyLuminanceFactor(self) -> LinearColor: ...
	"""Scales the luminance of pixels representing the sky, i.e. not belonging to any surface."""

	@property
	def AerialPespectiveViewDistanceScale(self) -> float: ...
	"""Makes the aerial perspective look thicker by scaling distances from view to surfaces (opaque and translucent)."""

	@property
	def HeightFogContribution(self) -> float: ...
	"""Scale the sky and atmosphere lights contribution to the height fog when SupportSkyAtmosphereAffectsHeightFog project setting is true."""

	@property
	def TransmittanceMinLightElevationAngle(self) -> float: ...
	"""The minimum elevation angle in degree that should be used to evaluate the sun transmittance to the ground. Useful to maintain a visible sun light and shadow on meshes even when the sun has started going below the horizon. This does not affect the aerial perspective."""

	@property
	def AerialPerspectiveStartDepth(self) -> float: ...
	"""The distance (kiloneters) at which we start evaluating the aerial pespective.
      Keeping this value a little away from the camera can help with performance: pixels not affected by the aerial perspective will have their computation skipped using early depth test."""

	def SetHeightFogContribution(self, NewValue: float): ...
	"""Set Height Fog Contribution"""

	def SetAerialPespectiveViewDistanceScale(self, NewValue: float): ...
	"""Set Aerial Pespective View Distance Scale"""

	def SetSkyLuminanceFactor(self, NewValue: LinearColor): ...
	"""Set Sky Luminance Factor"""

	def SetOtherAbsorption(self, NewValue: LinearColor): ...
	"""Set Other Absorption"""

	def SetOtherAbsorptionScale(self, NewValue: float): ...
	"""Set Other Absorption Scale"""

	def SetMieExponentialDistribution(self, NewValue: float): ...
	"""Set Mie Exponential Distribution"""

	def SetMieAnisotropy(self, NewValue: float): ...
	"""Set Mie Anisotropy"""

	def SetMieAbsorption(self, NewValue: LinearColor): ...
	"""Set Mie Absorption"""

	def SetMieAbsorptionScale(self, NewValue: float): ...
	"""Set Mie Absorption Scale"""

	def SetMieScattering(self, NewValue: LinearColor): ...
	"""Set Mie Scattering"""

	def SetMieScatteringScale(self, NewValue: float): ...
	"""Set Mie Scattering Scale"""

	def SetRayleighExponentialDistribution(self, NewValue: float): ...
	"""Set Rayleigh Exponential Distribution"""

	def SetRayleighScattering(self, NewValue: LinearColor): ...
	"""Set Rayleigh Scattering"""

	def SetRayleighScatteringScale(self, NewValue: float): ...
	"""Set Rayleigh Scattering Scale"""

	def OverrideAtmosphereLightDirection(self, AtmosphereLightIndex: int, LightDirection: Vector): ...
	"""Override Atmosphere Light Direction"""

	pass

class SkyAtmosphere(Info):
	"""A placeable actor that represents a planet atmosphere material and simulates sky and light scattering within it.
See: https://docs.unrealengine.com/en-US/Engine/Actors/FogEffects/SkyAtmosphere/index.html"""

	pass

class SkyLightComponent(LightComponentBase):
	"""Sky Light Component"""

	@property
	def bRealTimeCapture(self) -> bool: ...
	"""When enabled, the sky will be captured and convolved to achieve dynamic diffuse and specular environment lighting.
SkyAtmosphere, VolumetricCloud Components as well as sky domes with Sky materials are taken into account."""

	@property
	def SourceType(self) -> int: ...
	"""Indicates where to get the light contribution from."""

	@property
	def Cubemap(self) -> TextureCube: ...
	"""Cubemap to use for sky lighting if SourceType is set to SLS_SpecifiedCubemap."""

	@property
	def SourceCubemapAngle(self) -> float: ...
	"""Angle to rotate the source cubemap when SourceType is set to SLS_SpecifiedCubemap."""

	@property
	def CubemapResolution(self) -> int: ...
	"""Maximum resolution for the very top processed cubemap mip. Must be a power of 2."""

	@property
	def SkyDistanceThreshold(self) -> float: ...
	"""Distance from the sky light at which any geometry should be treated as part of the sky.
This is also used by reflection captures, so update reflection captures to see the impact."""

	@property
	def bCaptureEmissiveOnly(self) -> bool: ...
	"""Only capture emissive materials. Skips all lighting making the capture cheaper. Recomended when using CaptureEveryFrame"""

	@property
	def bLowerHemisphereIsBlack(self) -> bool: ...
	"""Whether all distant lighting from the lower hemisphere should be set to LowerHemisphereColor.
Enabling this is accurate when lighting a scene on a planet where the ground blocks the sky,
However disabling it can be useful to approximate skylight bounce lighting (eg Movable light)."""

	@property
	def LowerHemisphereColor(self) -> LinearColor: ...
	"""Lower Hemisphere Color"""

	@property
	def OcclusionMaxDistance(self) -> float: ...
	"""Max distance that the occlusion of one point will affect another.
Higher values increase the cost of Distance Field AO exponentially."""

	@property
	def Contrast(self) -> float: ...
	"""Contrast S-curve applied to the computed AO.  A value of 0 means no contrast increase, 1 is a significant contrast increase."""

	@property
	def OcclusionExponent(self) -> float: ...
	"""Exponent applied to the computed AO.  Values lower than 1 brighten occlusion overall without losing contact shadows."""

	@property
	def MinOcclusion(self) -> float: ...
	"""Controls the darkest that a fully occluded area can get.  This tends to destroy contact shadows, use Contrast or OcclusionExponent instead."""

	@property
	def OcclusionTint(self) -> Color: ...
	"""Tint color on occluded areas, artistic control."""

	@property
	def bCloudAmbientOcclusion(self) -> bool: ...
	"""Whether the cloud should occlude sky contribution within the atmosphere (progressively fading multiple scattering out) or not."""

	@property
	def CloudAmbientOcclusionStrength(self) -> float: ...
	"""The strength of the ambient occlusion, higher value will block more light."""

	@property
	def CloudAmbientOcclusionExtent(self) -> float: ...
	"""The world space radius of the cloud ambient occlusion map around the camera in kilometers."""

	@property
	def CloudAmbientOcclusionMapResolutionScale(self) -> float: ...
	"""Scale the cloud ambient occlusion map resolution, base resolution is 512. The resolution is still clamped to 'r.VolumetricCloud.SkyAO.MaxResolution'."""

	@property
	def CloudAmbientOcclusionApertureScale(self) -> float: ...
	"""Controls the cone aperture angle over which the sky occlusion due to volumetric clouds is evaluated. A value of 1 means `take into account the entire hemisphere` resulting in blurry occlusion, while a value of 0 means `take into account a single up occlusion direction up` resulting in sharp occlusion."""

	@property
	def OcclusionCombineMode(self) -> int: ...
	"""Controls how occlusion from Distance Field Ambient Occlusion is combined with Screen Space Ambient Occlusion."""

	def RecaptureSky(self): ...
	"""Recaptures the scene for the skylight.
This is useful for making sure the sky light is up to date after changing something in the world that it would capture.
Warning: this is very costly and will definitely cause a hitch."""

	def SetMinOcclusion(self, InMinOcclusion: float): ...
	"""Set Min Occlusion"""

	def SetOcclusionExponent(self, InOcclusionExponent: float): ...
	"""Set Occlusion Exponent"""

	def SetOcclusionContrast(self, InOcclusionContrast: float): ...
	"""Set Occlusion Contrast"""

	def SetOcclusionTint(self, InTint: Color): ...
	"""Set Occlusion Tint"""

	def SetLowerHemisphereColor(self, InLowerHemisphereColor: LinearColor): ...
	"""Set Lower Hemisphere Color"""

	def SetCubemapBlend(self, SourceCubemap: TextureCube, DestinationCubemap: TextureCube, InBlendFraction: float): ...
	"""Creates sky lighting from a blend between two cubemaps, which is only valid when SourceType is set to SpecifiedCubemap.
This can be used to seamlessly transition sky lighting between different times of day.
The caller should continue to update the blend until BlendFraction is 0 or 1 to reduce rendering cost.
The caller is responsible for avoiding pops due to changing the source or destination."""

	def SetCubemap(self, NewCubemap: TextureCube): ...
	"""Sets the cubemap used when SourceType is set to SpecifiedCubemap, and causes a skylight update on the next tick."""

	def SetLightColor(self, NewLightColor: LinearColor): ...
	"""Set color of the light"""

	def SetVolumetricScatteringIntensity(self, NewIntensity: float): ...
	"""Set Volumetric Scattering Intensity"""

	def SetIndirectLightingIntensity(self, NewIntensity: float): ...
	"""Set Indirect Lighting Intensity"""

	def SetIntensity(self, NewIntensity: float): ...
	"""Set Intensity"""

	pass

class SphereReflectionCaptureComponent(ReflectionCaptureComponent):
	"""-> will be exported to EngineDecalClasses.h"""

	@property
	def InfluenceRadius(self) -> float: ...
	"""Radius of the area that can receive reflections from this capture."""

	@property
	def CaptureDistanceScale(self) -> float: ...
	"""Not needed anymore, not yet removed in case the artist setup values are needed in the future"""

	@property
	def PreviewInfluenceRadius(self) -> DrawSphereComponent: ...
	"""Preview Influence Radius"""

	pass

class SplineComponent(PrimitiveComponent):
	"""A spline component is a spline shape which can be used for other purposes (e.g. animating objects). It contains debug rendering capabilities.
See: https://docs.unrealengine.com/latest/INT/Resources/ContentExamples/Blueprint_Splines"""

	@property
	def SplineCurves(self) -> typing.Any: ...
	"""Spline Curves"""

	@property
	def ReparamStepsPerSegment(self) -> int: ...
	"""Number of steps per spline segment to place in the reparameterization table"""

	@property
	def Duration(self) -> float: ...
	"""Specifies the duration of the spline in seconds"""

	@property
	def bStationaryEndpoints(self) -> bool: ...
	"""Whether the endpoints of the spline are considered stationary when traversing the spline at non-constant velocity.  Essentially this sets the endpoints' tangents to zero vectors."""

	@property
	def bSplineHasBeenEdited(self) -> bool: ...
	"""Whether the spline has been edited from its default by the spline component visualizer"""

	@property
	def bModifiedByConstructionScript(self) -> bool: ...
	"""Whether the UCS has made changes to the spline points"""

	@property
	def bInputSplinePointsToConstructionScript(self) -> bool: ...
	"""Whether the spline points should be passed to the User Construction Script so they can be further manipulated by it.
If false, they will not be visible to it, and it will not be able to influence the per-instance positions set in the editor."""

	@property
	def bDrawDebug(self) -> bool: ...
	"""If true, the spline will be rendered if the Splines showflag is set."""

	@property
	def DefaultUpVector(self) -> Vector: ...
	"""Default up vector in local space to be used when calculating transforms along the spline"""

	def FindTransformClosestToWorldLocation(self, WorldLocation: Vector, CoordinateSpace: int, bUseScale: bool = ...) -> Transform: ...
	"""Given a location, in world space, return an FTransform closest to that location."""

	def FindScaleClosestToWorldLocation(self, WorldLocation: Vector) -> Vector: ...
	"""Given a location, in world space, return the spline's scale closest to the location."""

	def FindRollClosestToWorldLocation(self, WorldLocation: Vector, CoordinateSpace: int) -> float: ...
	"""Given a location, in world space, return the spline's roll closest to the location, in degrees."""

	def FindRightVectorClosestToWorldLocation(self, WorldLocation: Vector, CoordinateSpace: int) -> Vector: ...
	"""Given a location, in world space, return a unit direction vector corresponding to the spline's right vector closest to the location."""

	def FindUpVectorClosestToWorldLocation(self, WorldLocation: Vector, CoordinateSpace: int) -> Vector: ...
	"""Given a location, in world space, return a unit direction vector corresponding to the spline's up vector closest to the location."""

	def FindRotationClosestToWorldLocation(self, WorldLocation: Vector, CoordinateSpace: int) -> Rotator: ...
	"""Given a location, in world space, return rotation corresponding to the spline's rotation closest to the location."""

	def FindTangentClosestToWorldLocation(self, WorldLocation: Vector, CoordinateSpace: int) -> Vector: ...
	"""Given a location, in world space, return the tangent vector of the spline closest to the location."""

	def FindDirectionClosestToWorldLocation(self, WorldLocation: Vector, CoordinateSpace: int) -> Vector: ...
	"""Given a location, in world space, return a unit direction vector of the spline tangent closest to the location."""

	def FindLocationClosestToWorldLocation(self, WorldLocation: Vector, CoordinateSpace: int) -> Vector: ...
	"""Given a location, in world space, return the point on the curve that is closest to the location."""

	def FindInputKeyClosestToWorldLocation(self, WorldLocation: Vector) -> float: ...
	"""Given a location, in world space, return the input key closest to that location."""

	def GetScaleAtTime(self, Time: float, bUseConstantVelocity: bool = ...) -> Vector: ...
	"""Given a time from 0 to the spline duration, return the spline's scale there."""

	def GetRollAtTime(self, Time: float, CoordinateSpace: int, bUseConstantVelocity: bool = ...) -> float: ...
	"""Given a time from 0 to the spline duration, return the spline's roll there, in degrees."""

	def GetTransformAtTime(self, Time: float, CoordinateSpace: int, bUseConstantVelocity: bool = ..., bUseScale: bool = ...) -> Transform: ...
	"""Given a time from 0 to the spline duration, return the spline's transform at the corresponding position."""

	def GetRightVectorAtTime(self, Time: float, CoordinateSpace: int, bUseConstantVelocity: bool = ...) -> Vector: ...
	"""Given a time from 0 to the spline duration, return the spline's right vector there."""

	def GetUpVectorAtTime(self, Time: float, CoordinateSpace: int, bUseConstantVelocity: bool = ...) -> Vector: ...
	"""Given a time from 0 to the spline duration, return the spline's up vector there."""

	def GetRotationAtTime(self, Time: float, CoordinateSpace: int, bUseConstantVelocity: bool = ...) -> Rotator: ...
	"""Given a time from 0 to the spline duration, return a rotation corresponding to the spline's position and direction there."""

	def GetTangentAtTime(self, Time: float, CoordinateSpace: int, bUseConstantVelocity: bool = ...) -> Vector: ...
	"""Given a time from 0 to the spline duration, return the spline's tangent there."""

	def GetDirectionAtTime(self, Time: float, CoordinateSpace: int, bUseConstantVelocity: bool = ...) -> Vector: ...
	"""Given a time from 0 to the spline duration, return a unit direction vector of the spline tangent there."""

	def GetLocationAtTime(self, Time: float, CoordinateSpace: int, bUseConstantVelocity: bool = ...) -> Vector: ...
	"""Given a time from 0 to the spline duration, return the point in space where this puts you"""

	def GetTransformAtDistanceAlongSpline(self, Distance: float, CoordinateSpace: int, bUseScale: bool = ...) -> Transform: ...
	"""Given a distance along the length of this spline, return an FTransform corresponding to that point on the spline."""

	def GetScaleAtDistanceAlongSpline(self, Distance: float) -> Vector: ...
	"""Given a distance along the length of this spline, return the spline's scale there."""

	def GetRollAtDistanceAlongSpline(self, Distance: float, CoordinateSpace: int) -> float: ...
	"""Given a distance along the length of this spline, return the spline's roll there, in degrees."""

	def GetRightVectorAtDistanceAlongSpline(self, Distance: float, CoordinateSpace: int) -> Vector: ...
	"""Given a distance along the length of this spline, return a unit direction vector corresponding to the spline's right vector there."""

	def GetUpVectorAtDistanceAlongSpline(self, Distance: float, CoordinateSpace: int) -> Vector: ...
	"""Given a distance along the length of this spline, return a unit direction vector corresponding to the spline's up vector there."""

	def GetRotationAtDistanceAlongSpline(self, Distance: float, CoordinateSpace: int) -> Rotator: ...
	"""Given a distance along the length of this spline, return a rotation corresponding to the spline's rotation there."""

	def GetTangentAtDistanceAlongSpline(self, Distance: float, CoordinateSpace: int) -> Vector: ...
	"""Given a distance along the length of this spline, return the tangent vector of the spline there."""

	def GetDirectionAtDistanceAlongSpline(self, Distance: float, CoordinateSpace: int) -> Vector: ...
	"""Given a distance along the length of this spline, return a unit direction vector of the spline tangent there."""

	def GetLocationAtDistanceAlongSpline(self, Distance: float, CoordinateSpace: int) -> Vector: ...
	"""Given a distance along the length of this spline, return the point in space where this puts you"""

	def GetInputKeyAtDistanceAlongSpline(self, Distance: float) -> float: ...
	"""Given a distance along the length of this spline, return the corresponding input key at that point"""

	def GetDefaultUpVector(self, CoordinateSpace: int) -> Vector: ...
	"""Gets the default up vector used by this spline"""

	def SetDefaultUpVector(self, UpVector: Vector, CoordinateSpace: int): ...
	"""Sets the default up vector used by this spline"""

	def GetSplineLength(self) -> float: ...
	"""Returns total length along this spline"""

	def GetVectorPropertyAtSplinePoint(self, Index: int, PropertyName: str) -> Vector: ...
	"""Get a metadata property vector value along the spline at spline point"""

	def GetFloatPropertyAtSplinePoint(self, Index: int, PropertyName: str) -> float: ...
	"""Get a metadata property float value along the spline at spline point"""

	def GetDistanceAlongSplineAtSplinePoint(self, PointIndex: int) -> float: ...
	"""Get the distance along the spline at the spline point"""

	def GetLocationAndTangentAtSplinePoint(self, PointIndex: int, CoordinateSpace: int) -> typing.Tuple[Vector, Vector]: ...
	"""Get location and tangent at a spline point"""

	def GetTransformAtSplinePoint(self, PointIndex: int, CoordinateSpace: int, bUseScale: bool = ...) -> Transform: ...
	"""Get the transform at spline point"""

	def GetScaleAtSplinePoint(self, PointIndex: int) -> Vector: ...
	"""Get the scale at spline point"""

	def GetRollAtSplinePoint(self, PointIndex: int, CoordinateSpace: int) -> float: ...
	"""Get the amount of roll at spline point, in degrees"""

	def GetRightVectorAtSplinePoint(self, PointIndex: int, CoordinateSpace: int) -> Vector: ...
	"""Get the right vector at spline point"""

	def GetUpVectorAtSplinePoint(self, PointIndex: int, CoordinateSpace: int) -> Vector: ...
	"""Get the up vector at spline point"""

	def GetRotationAtSplinePoint(self, PointIndex: int, CoordinateSpace: int) -> Rotator: ...
	"""Get the rotation at spline point as a rotator"""

	def GetLeaveTangentAtSplinePoint(self, PointIndex: int, CoordinateSpace: int) -> Vector: ...
	"""Get the leave tangent at spline point"""

	def GetArriveTangentAtSplinePoint(self, PointIndex: int, CoordinateSpace: int) -> Vector: ...
	"""Get the arrive tangent at spline point"""

	def GetTangentAtSplinePoint(self, PointIndex: int, CoordinateSpace: int) -> Vector: ...
	"""Get the tangent at spline point. This fetches the Leave tangent of the point."""

	def GetDirectionAtSplinePoint(self, PointIndex: int, CoordinateSpace: int) -> Vector: ...
	"""Get the direction at spline point"""

	def GetLocationAtSplinePoint(self, PointIndex: int, CoordinateSpace: int) -> Vector: ...
	"""Get the location at spline point"""

	def GetNumberOfSplineSegments(self) -> int: ...
	"""Get the number of segments that make up this spline"""

	def GetNumberOfSplinePoints(self) -> int: ...
	"""Get the number of points that make up this spline"""

	def SetSplinePointType(self, PointIndex: int, Type: int, bUpdateSpline: bool = ...): ...
	"""Specify the type of a spline point"""

	def GetSplinePointType(self, PointIndex: int) -> int: ...
	"""Get the type of a spline point"""

	def SetScaleAtSplinePoint(self, PointIndex: int, InScaleVector: Vector, bUpdateSpline: bool = ...): ...
	"""Set the scale at a given spline point"""

	def SetRotationAtSplinePoint(self, PointIndex: int, InRotation: Rotator, CoordinateSpace: int, bUpdateSpline: bool = ...): ...
	"""Set the rotation of an existing spline point"""

	def SetUpVectorAtSplinePoint(self, PointIndex: int, InUpVector: Vector, CoordinateSpace: int, bUpdateSpline: bool = ...): ...
	"""Specify the up vector at a given spline point"""

	def SetTangentsAtSplinePoint(self, PointIndex: int, InArriveTangent: Vector, InLeaveTangent: Vector, CoordinateSpace: int, bUpdateSpline: bool = ...): ...
	"""Specify the tangents at a given spline point"""

	def SetTangentAtSplinePoint(self, PointIndex: int, InTangent: Vector, CoordinateSpace: int, bUpdateSpline: bool = ...): ...
	"""Specify the tangent at a given spline point"""

	def SetLocationAtSplinePoint(self, PointIndex: int, InLocation: Vector, CoordinateSpace: int, bUpdateSpline: bool = ...): ...
	"""Move an existing point to a new location"""

	def SetSplinePoints(self, Points: typing.List[Vector], CoordinateSpace: int, bUpdateSpline: bool = ...): ...
	"""Sets the spline to an array of points"""

	def RemoveSplinePoint(self, Index: int, bUpdateSpline: bool = ...): ...
	"""Removes point at specified index from the spline"""

	def AddSplinePointAtIndex(self, Position: Vector, Index: int, CoordinateSpace: int, bUpdateSpline: bool = ...): ...
	"""Adds a point to the spline at the specified index"""

	def AddSplinePoint(self, Position: Vector, CoordinateSpace: int, bUpdateSpline: bool = ...): ...
	"""Adds a point to the spline"""

	def AddPoints(self, Points: typing.List[SplinePoint], bUpdateSpline: bool = ...): ...
	"""Adds an array of FSplinePoints to the spline."""

	def AddPoint(self, Point: SplinePoint, bUpdateSpline: bool = ...): ...
	"""Adds an FSplinePoint to the spline. This contains its input key, position, tangent, rotation and scale."""

	def ClearSplinePoints(self, bUpdateSpline: bool = ...): ...
	"""Clears all the points in the spline"""

	def IsClosedLoop(self) -> bool: ...
	"""Check whether the spline is a closed loop or not"""

	def SetClosedLoopAtPosition(self, bInClosedLoop: bool, Key: float, bUpdateSpline: bool = ...): ...
	"""Specify whether the spline is a closed loop or not, and if so, the input key corresponding to the loop point"""

	def SetClosedLoop(self, bInClosedLoop: bool, bUpdateSpline: bool = ...): ...
	"""Specify whether the spline is a closed loop or not. The loop position will be at 1.0 after the last point's input key"""

	def SetDrawDebug(self, bShow: bool): ...
	"""Specify whether this spline should be rendered when the Editor/Game spline show flag is set"""

	def SetTangentColor(self, TangentColor: LinearColor): ...
	"""Specify selected spline component segment color in the editor"""

	def SetSelectedSplineSegmentColor(self, SegmentColor: LinearColor): ...
	"""Specify selected spline component segment color in the editor"""

	def SetUnselectedSplineSegmentColor(self, SegmentColor: LinearColor): ...
	"""Specify unselected spline component segment color in the editor"""

	def GetVectorPropertyAtSplineInputKey(self, InKey: float, PropertyName: str) -> Vector: ...
	"""Get a metadata property vector value along the spline at spline input key"""

	def GetFloatPropertyAtSplineInputKey(self, InKey: float, PropertyName: str) -> float: ...
	"""Get a metadata property float value along the spline at spline input key"""

	def GetDistanceAlongSplineAtSplineInputKey(self, InKey: float) -> float: ...
	"""Get distance along the spline at the provided input key value"""

	def GetScaleAtSplineInputKey(self, InKey: float) -> Vector: ...
	"""Get scale at the provided input key value"""

	def GetRollAtSplineInputKey(self, InKey: float, CoordinateSpace: int) -> float: ...
	"""Get roll in degrees at the provided input key value"""

	def GetTransformAtSplineInputKey(self, InKey: float, CoordinateSpace: int, bUseScale: bool = ...) -> Transform: ...
	"""Get transform at the provided input key value"""

	def GetRightVectorAtSplineInputKey(self, InKey: float, CoordinateSpace: int) -> Vector: ...
	"""Get right vector at the provided input key value"""

	def GetUpVectorAtSplineInputKey(self, InKey: float, CoordinateSpace: int) -> Vector: ...
	"""Get up vector at the provided input key value"""

	def GetRotationAtSplineInputKey(self, InKey: float, CoordinateSpace: int) -> Rotator: ...
	"""Get rotator corresponding to rotation along spline at the provided input key value"""

	def GetDirectionAtSplineInputKey(self, InKey: float, CoordinateSpace: int) -> Vector: ...
	"""Get unit direction along spline at the provided input key value"""

	def GetTangentAtSplineInputKey(self, InKey: float, CoordinateSpace: int) -> Vector: ...
	"""Get tangent along spline at the provided input key value"""

	def GetLocationAtSplineInputKey(self, InKey: float, CoordinateSpace: int) -> Vector: ...
	"""Get location along spline at the provided input key value"""

	def UpdateSpline(self): ...
	"""Update the spline tangents and SplineReparamTable"""

	pass

class SplineMeshComponent(StaticMeshComponent):
	"""A Spline Mesh Component is a derivation of a Static Mesh Component which can be deformed using a spline. Only a start and end position (and tangent) can be specified.
See: https://docs.unrealengine.com/latest/INT/Resources/ContentExamples/Blueprint_Splines"""

	@property
	def SplineParams(self) -> typing.Any: ...
	"""Spline that is used to deform mesh"""

	@property
	def SplineUpDir(self) -> Vector: ...
	"""Axis (in component space) that is used to determine X axis for co-ordinates along spline"""

	@property
	def SplineBoundaryMin(self) -> float: ...
	"""Minimum coordinate along the spline forward axis which corresponds to start of spline. If set to 0.0, will use bounding box to determine bounds"""

	@property
	def CachedMeshBodySetupGuid(self) -> Guid: ...
	"""Used to automatically trigger rebuild of collision data"""

	@property
	def BodySetup(self) -> typing.Any: ...
	"""Physics data."""

	@property
	def SplineBoundaryMax(self) -> float: ...
	"""Maximum coordinate along the spline forward axis which corresponds to end of spline. If set to 0.0, will use bounding box to determine bounds"""

	@property
	def bAllowSplineEditingPerInstance(self) -> bool: ...
	"""If true, spline keys may be edited per instance in the level viewport. Otherwise, the spline should be initialized in the construction script."""

	@property
	def bSmoothInterpRollScale(self) -> bool: ...
	"""If true, will use smooth interpolation (ease in/out) for Scale, Roll, and Offset along this section of spline. If false, uses linear"""

	@property
	def bMeshDirty(self) -> bool: ...
	"""Indicates that the mesh needs updating"""

	@property
	def ForwardAxis(self) -> int: ...
	"""Chooses the forward axis for the spline mesh orientation"""

	@property
	def VirtualTextureMainPassMaxDrawDistance(self) -> float: ...
	"""The max draw distance to use in the main pass when also rendering to a runtime virtual texture.
This is only exposed to the user through the same setting on ULandscapeSplineSegment."""

	def SetBoundaryMax(self, InBoundaryMax: float, bUpdateMesh: bool = ...): ...
	"""Set the boundary max"""

	def GetBoundaryMax(self) -> float: ...
	"""Get the boundary max"""

	def SetBoundaryMin(self, InBoundaryMin: float, bUpdateMesh: bool = ...): ...
	"""Set the boundary min"""

	def GetBoundaryMin(self) -> float: ...
	"""Get the boundary min"""

	def SetSplineUpDir(self, InSplineUpDir: Vector, bUpdateMesh: bool = ...): ...
	"""Set the spline up direction"""

	def GetSplineUpDir(self) -> Vector: ...
	"""Get the spline up direction"""

	def SetForwardAxis(self, InForwardAxis: int, bUpdateMesh: bool = ...): ...
	"""Set the forward axis"""

	def GetForwardAxis(self) -> int: ...
	"""Get the forward axis"""

	def SetEndOffset(self, EndOffset: Vector2D, bUpdateMesh: bool = ...): ...
	"""Set the end offset"""

	def GetEndOffset(self) -> Vector2D: ...
	"""Get the end offset"""

	def SetEndRoll(self, EndRoll: float, bUpdateMesh: bool = ...): ...
	"""Set the end roll"""

	def GetEndRoll(self) -> float: ...
	"""Get the end roll"""

	def SetEndScale(self, EndScale: Vector2D = ..., bUpdateMesh: bool = ...): ...
	"""Set the end scaling"""

	def GetEndScale(self) -> Vector2D: ...
	"""Get the end scaling"""

	def SetStartOffset(self, StartOffset: Vector2D, bUpdateMesh: bool = ...): ...
	"""Set the start offset"""

	def GetStartOffset(self) -> Vector2D: ...
	"""Get the start offset"""

	def SetStartRoll(self, StartRoll: float, bUpdateMesh: bool = ...): ...
	"""Set the start roll"""

	def GetStartRoll(self) -> float: ...
	"""Get the start roll"""

	def SetStartScale(self, StartScale: Vector2D = ..., bUpdateMesh: bool = ...): ...
	"""Set the start scaling"""

	def GetStartScale(self) -> Vector2D: ...
	"""Get the start scaling"""

	def SetStartAndEnd(self, StartPos: Vector, StartTangent: Vector, EndPos: Vector, EndTangent: Vector, bUpdateMesh: bool = ...): ...
	"""Set the start and end, position and tangent, all in local space"""

	def SetEndTangent(self, EndTangent: Vector, bUpdateMesh: bool = ...): ...
	"""Set the end tangent vector of spline in local space"""

	def GetEndTangent(self) -> Vector: ...
	"""Get the end tangent vector of spline in local space"""

	def SetEndPosition(self, EndPos: Vector, bUpdateMesh: bool = ...): ...
	"""Set the end position of spline in local space"""

	def GetEndPosition(self) -> Vector: ...
	"""Get the end position of spline in local space"""

	def SetStartTangent(self, StartTangent: Vector, bUpdateMesh: bool = ...): ...
	"""Set the start tangent vector of spline in local space"""

	def GetStartTangent(self) -> Vector: ...
	"""Get the start tangent vector of spline in local space"""

	def SetStartPosition(self, StartPos: Vector, bUpdateMesh: bool = ...): ...
	"""Set the start position of spline in local space"""

	def GetStartPosition(self) -> Vector: ...
	"""Get the start position of spline in local space"""

	def UpdateMesh(self): ...
	"""Update the collision and render state on the spline mesh following changes to its geometry"""

	pass

class SpotLightComponent(PointLightComponent):
	"""A spot light component emits a directional cone shaped light (Eg a Torch)."""

	@property
	def InnerConeAngle(self) -> float: ...
	"""Degrees."""

	@property
	def OuterConeAngle(self) -> float: ...
	"""Degrees."""

	def SetOuterConeAngle(self, NewOuterConeAngle: float): ...
	"""Set Outer Cone Angle"""

	def SetInnerConeAngle(self, NewInnerConeAngle: float): ...
	"""Set Inner Cone Angle"""

	pass

class StereoLayerShape(Object):
	"""Stereo Layer Shape"""

	pass

class StereoLayerShapeQuad(StereoLayerShape):
	"""Stereo Layer Shape Quad"""

	pass

class StereoLayerShapeCylinder(StereoLayerShape):
	"""Stereo Layer Shape Cylinder"""

	@property
	def Radius(self) -> float: ...
	"""Radial size of the rendered stereo layer cylinder *"""

	@property
	def OverlayArc(self) -> float: ...
	"""Arc angle for the stereo layer cylinder *"""

	@property
	def Height(self) -> int: ...
	"""Height of the stereo layer cylinder *"""

	def SetHeight(self, InHeight: int): ...
	"""Set Height"""

	def SetOverlayArc(self, InOverlayArc: float): ...
	"""Set Overlay Arc"""

	def SetRadius(self, InRadius: float): ...
	"""Set Radius"""

	pass

class StereoLayerShapeCubemap(StereoLayerShape):
	"""Stereo Layer Shape Cubemap"""

	pass

class StereoLayerShapeEquirect(StereoLayerShape):
	"""Stereo Layer Shape Equirect"""

	@property
	def LeftUVRect(self) -> Box2D: ...
	"""Left source texture UVRect, specifying portion of input texture corresponding to left eye."""

	@property
	def RightUVRect(self) -> Box2D: ...
	"""Right source texture UVRect, specifying portion of input texture corresponding to right eye."""

	@property
	def LeftScale(self) -> Vector2D: ...
	"""Left eye's texture coordinate scale after mapping to 2D."""

	@property
	def RightScale(self) -> Vector2D: ...
	"""Right eye's texture coordinate scale after mapping to 2D."""

	@property
	def LeftBias(self) -> Vector2D: ...
	"""Left eye's texture coordinate bias after mapping to 2D."""

	@property
	def RightBias(self) -> Vector2D: ...
	"""Right eye's texture coordinate bias after mapping to 2D."""

	def SetEquirectProps(self, InScaleBiases: EquirectProps): ...
	"""Set Equirect layer properties: UVRect, Scale, and Bias
@param       LeftScale: Scale for left eye
@param       LeftBias: Bias for left eye
@param       RightScale: Scale for right eye
@param       RightBias: Bias for right eye"""

	pass

class StereoLayerComponent(SceneComponent):
	"""A geometry layer within the stereo rendered viewport."""

	@property
	def bLiveTexture(self) -> bool: ...
	"""True if the stereo layer texture needs to update itself every frame(scene capture, video, etc.)"""

	@property
	def bSupportsDepth(self) -> bool: ...
	"""True if the stereo layer needs to support depth intersections with the scene geometry, if available on the platform"""

	@property
	def bNoAlphaChannel(self) -> bool: ...
	"""True if the texture should not use its own alpha channel (1.0 will be substituted)"""

	@property
	def bQuadPreserveTextureRatio(self) -> bool: ...
	"""True if the quad should internally set it's Y value based on the set texture's dimensions"""

	def MarkTextureForUpdate(self): ...
	"""Manually mark the stereo layer texture for updating"""

	def GetPriority(self) -> int: ...
	"""@return the render priority"""

	def SetPriority(self, InPriority: int): ...
	"""Change the layer's render priority, higher priorities render on top of lower priorities
@param       InPriority: Priority value"""

	def GetUVRect(self) -> Box2D: ...
	"""@return the UV coordinates mapped to the quad face"""

	def SetUVRect(self, InUVRect: Box2D): ...
	"""Change the UV coordinates mapped to the quad face
@param       InUVRect: Min and Max UV coordinates"""

	def GetQuadSize(self) -> Vector2D: ...
	"""@return the height and width of the rendered quad"""

	def SetQuadSize(self, InQuadSize: Vector2D): ...
	"""Change the quad size. This is the unscaled height and width, before component scale is applied.
@param       InQuadSize: new quad size."""

	def GetLeftTexture(self) -> Texture: ...
	"""@return the texture mapped to the stereo layer for left eye, if stereoscopic layer textures are supported on the platform."""

	def GetTexture(self) -> Texture: ...
	"""@return the texture mapped to the stereo layer."""

	def SetLeftTexture(self, InTexture: Texture): ...
	"""Change the texture displayed on the stereo layer for left eye, if stereoscopic layer textures are supported on the platform.
@param       InTexture: new Texture2D"""

	def SetTexture(self, InTexture: Texture): ...
	"""Change the texture displayed on the stereo layer.

If stereoscopic layer textures are supported on the platform and LeftTexture is set, this property controls the texture for the right eye.
@param       InTexture: new Texture2D"""

	pass

class TextRenderComponent(PrimitiveComponent):
	"""Renders text in the world with given font. Contains usual font related attributes such as Scale, Alignment, Color etc."""

	@property
	def Text(self) -> str: ...
	"""Text content, can be multi line using <br> as line separator"""

	@property
	def TextMaterial(self) -> MaterialInterface: ...
	"""Text material"""

	@property
	def Font(self) -> Font: ...
	"""Text font"""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""Horizontal text alignment"""

	@property
	def VerticalAlignment(self) -> int: ...
	"""Vertical text alignment"""

	@property
	def TextRenderColor(self) -> Color: ...
	"""Color of the text, can be accessed as vertex color"""

	@property
	def XScale(self) -> float: ...
	"""Horizontal scale, default is 1.0"""

	@property
	def YScale(self) -> float: ...
	"""Vertical scale, default is 1.0"""

	@property
	def WorldSize(self) -> float: ...
	"""Vertical size of the fonts largest character in world units. Transform, XScale and YScale will affect final size."""

	@property
	def InvDefaultSize(self) -> float: ...
	"""The inverse of the Font's character height."""

	@property
	def HorizSpacingAdjust(self) -> float: ...
	"""Horizontal adjustment per character, default is 0.0"""

	@property
	def VertSpacingAdjust(self) -> float: ...
	"""Vertical adjustment per character, default is 0.0"""

	@property
	def bAlwaysRenderAsText(self) -> bool: ...
	"""Allows text to draw unmodified when using debug visualization modes. *"""

	def GetTextWorldSize(self) -> Vector: ...
	"""Get world space size of text"""

	def GetTextLocalSize(self) -> Vector: ...
	"""Get local size of text"""

	def SetWorldSize(self, Value: float): ...
	"""Change the world size of the text and signal the primitives to be rebuilt"""

	def SetVertSpacingAdjust(self, Value: float): ...
	"""Change the text vertical spacing adjustment and signal the primitives to be rebuilt"""

	def SetHorizSpacingAdjust(self, Value: float): ...
	"""Change the text horizontal spacing adjustment and signal the primitives to be rebuilt"""

	def SetYScale(self, Value: float): ...
	"""Change the text Y scale and signal the primitives to be rebuilt"""

	def SetXScale(self, Value: float): ...
	"""Change the text X scale and signal the primitives to be rebuilt"""

	def SetTextRenderColor(self, Value: Color): ...
	"""Change the text render color and signal the primitives to be rebuilt"""

	def SetVerticalAlignment(self, Value: int): ...
	"""Change the vertical alignment and signal the primitives to be rebuilt"""

	def SetHorizontalAlignment(self, Value: int): ...
	"""Change the horizontal alignment and signal the primitives to be rebuilt"""

	def SetFont(self, Value: Font): ...
	"""Change the font and signal the primitives to be rebuilt"""

	def SetTextMaterial(self, Material: MaterialInterface): ...
	"""Change the text material and signal the primitives to be rebuilt"""

	def SetText(self, Value: str): ...
	"""Change the text value and signal the primitives to be rebuilt"""

	pass

class TimelineComponent(ActorComponent):
	"""TimelineComponent holds a series of events, floats, vectors or colors with associated keyframes.
Events can be triggered at keyframes along the timeline.
Floats, vectors, and colors are interpolated between keyframes along the timeline."""

	def SetLinearColorCurve(self, NewLinearColorCurve: CurveLinearColor, LinearColorTrackName: str): ...
	"""Update a certain linear color track's curve"""

	def SetVectorCurve(self, NewVectorCurve: CurveVector, VectorTrackName: str): ...
	"""Update a certain vector track's curve"""

	def SetFloatCurve(self, NewFloatCurve: CurveFloat, FloatTrackName: str): ...
	"""Update a certain float track's curve"""

	def GetIgnoreTimeDilation(self) -> bool: ...
	"""Get whether to ignore time dilation."""

	def SetIgnoreTimeDilation(self, bNewIgnoreTimeDilation: bool): ...
	"""Set whether to ignore time dilation."""

	def SetTimelineLengthMode(self, NewLengthMode: int): ...
	"""Sets the length mode of the timeline"""

	def SetTimelineLength(self, NewLength: float): ...
	"""Set length of the timeline"""

	def GetTimelineLength(self) -> float: ...
	"""Get length of the timeline"""

	def SetNewTime(self, NewTime: float): ...
	"""Set the new playback position time to use"""

	def GetPlayRate(self) -> float: ...
	"""Get the current play rate for this timeline"""

	def SetPlayRate(self, NewRate: float): ...
	"""Sets the new play rate for this timeline"""

	def IsLooping(self) -> bool: ...
	"""Get whether we are looping or not"""

	def SetLooping(self, bNewLooping: bool): ...
	"""true means we would loop, false means we should not."""

	def GetPlaybackPosition(self) -> float: ...
	"""Get the current playback position of the Timeline"""

	def SetPlaybackPosition(self, NewPosition: float, bFireEvents: bool, bFireUpdate: bool = ...): ...
	"""Jump to a position in the timeline.
@param bFireEvents If true, event functions that are between current position and new playback position will fire.
@param bFireUpdate If true, the update output exec will fire after setting the new playback position."""

	def IsReversing(self) -> bool: ...
	"""Get whether we are reversing or not"""

	def IsPlaying(self) -> bool: ...
	"""Get whether this timeline is playing or not."""

	def Stop(self): ...
	"""Stop playback of timeline"""

	def ReverseFromEnd(self): ...
	"""Start playback of timeline in reverse from the end"""

	def Reverse(self): ...
	"""Start playback of timeline in reverse"""

	def PlayFromStart(self): ...
	"""Start playback of timeline from the start"""

	def Play(self): ...
	"""Start playback of timeline"""

	pass

class VectorFieldComponent(PrimitiveComponent):
	"""A Component referencing a vector field."""

	@property
	def VectorField(self) -> typing.Any: ...
	"""The vector field asset."""

	@property
	def Intensity(self) -> float: ...
	"""The intensity at which the vector field is applied."""

	@property
	def Tightness(self) -> float: ...
	"""How tightly particles follow the vector field."""

	@property
	def bPreviewVectorField(self) -> bool: ...
	"""If true, the vector field is only used for preview visualizations."""

	def SetIntensity(self, NewIntensity: float): ...
	"""Set the intensity of the vector field.
@param NewIntensity - The new intensity of the vector field."""

	pass

class VolumetricCloudComponent(SceneComponent):
	"""A component that represents a participating media material around a planet, e.g. clouds."""

	@property
	def LayerBottomAltitude(self) -> float: ...
	"""The altitude at which the cloud layer starts. (kilometers above the ground)"""

	@property
	def LayerHeight(self) -> float: ...
	"""The altitude at which the cloud layer ends. (kilometers above the ground)"""

	@property
	def TracingStartMaxDistance(self) -> float: ...
	"""The maximum distance of the volumetric surface before which we will accept to start tracing. (kilometers)"""

	@property
	def TracingMaxDistance(self) -> float: ...
	"""The maximum distance that will be traced inside the cloud layer. (kilometers)"""

	@property
	def PlanetRadius(self) -> float: ...
	"""The planet radius used when there is not SkyAtmosphere component present in the scene."""

	@property
	def GroundAlbedo(self) -> Color: ...
	"""The ground albedo used to light the cloud from below with respect to the sun light and sky atmosphere.
This is only used by the cloud material when the 'Volumetric Advanced' node have GroundContribution enabled."""

	@property
	def Material(self) -> MaterialInterface: ...
	"""The material describing the cloud volume. It must be a Volume domain material."""

	@property
	def bUsePerSampleAtmosphericLightTransmittance(self) -> bool: ...
	"""Whether to apply atmosphere transmittance per sample, instead of using the light global transmittance."""

	@property
	def SkyLightCloudBottomOcclusion(self) -> float: ...
	"""Occlude the sky light contribution at the bottom of the cloud layer. This is a fast approximation to sky lighting being occluded by cloud without having to trace rays or sample AO texture. Ignored if the cloud material explicitely sets the ambient occlusion value."""

	@property
	def ViewSampleCountScale(self) -> float: ...
	"""Scale the tracing sample count in primary views. Quality level scalability CVARs affect the maximum range.
The sample count resolution is still clamped according to scalability setting to 'r.VolumetricCloud.ViewRaySampleCountMax'."""

	@property
	def ReflectionSampleCountScale(self) -> float: ...
	"""Scale the tracing sample count in reflection views. Quality level scalability CVARs affect the maximum range.
The sample count resolution is still clamped according to scalability setting to 'r.VolumetricCloud.ReflectionRaySampleMaxCount'."""

	@property
	def ShadowViewSampleCountScale(self) -> float: ...
	"""Scale the shadow tracing sample count in primary views, only used with Advanced Output ray marched shadows. Quality level scalability CVARs affect the maximum range.
The sample count resolution is still clamped according to scalability setting to 'r.VolumetricCloud.Shadow.ViewRaySampleMaxCount'."""

	@property
	def ShadowReflectionSampleCountScale(self) -> float: ...
	"""Scale the shadow tracing sample count in reflection views, only used with Advanced Output ray marched shadows. Quality level scalability CVARs affect the maximum range.
The sample count resolution is still clamped according to scalability setting to 'r.VolumetricCloud.Shadow.ReflectionRaySampleMaxCount'."""

	@property
	def ShadowTracingDistance(self) -> float: ...
	"""The shadow tracing distance in kilometers, only used with Advanced Output ray marched shadows."""

	def SetMaterial(self, NewValue: MaterialInterface): ...
	"""Set Material"""

	def SetShadowTracingDistance(self, NewValue: float): ...
	"""Set Shadow Tracing Distance"""

	def SetShadowReflectionSampleCountScale(self, NewValue: float): ...
	"""Set Shadow Reflection Sample Count Scale"""

	def SetShadowViewSampleCountScale(self, NewValue: float): ...
	"""Set Shadow View Sample Count Scale"""

	def SetReflectionSampleCountScale(self, NewValue: float): ...
	"""Set Reflection Sample Count Scale"""

	def SetViewSampleCountScale(self, NewValue: float): ...
	"""Set View Sample Count Scale"""

	def SetSkyLightCloudBottomOcclusion(self, NewValue: float): ...
	"""Set Sky Light Cloud Bottom Occlusion"""

	def SetbUsePerSampleAtmosphericLightTransmittance(self, NewValue: bool): ...
	"""Setb Use Per Sample Atmospheric Light Transmittance"""

	def SetGroundAlbedo(self, NewValue: Color): ...
	"""Set Ground Albedo"""

	def SetPlanetRadius(self, NewValue: float): ...
	"""Set Planet Radius"""

	def SetTracingMaxDistance(self, NewValue: float): ...
	"""Set Tracing Max Distance"""

	def SetTracingStartMaxDistance(self, NewValue: float): ...
	"""Set Tracing Start Max Distance"""

	def SetLayerHeight(self, NewValue: float): ...
	"""Set Layer Height"""

	def SetLayerBottomAltitude(self, NewValue: float): ...
	"""Set Layer Bottom Altitude"""

	pass

class VolumetricCloud(Info):
	"""A placeable actor that represents a participating media material around a planet, e.g. clouds.
See: TODO address to the documentation."""

	pass

class WindDirectionalSourceComponent(SceneComponent):
	"""Component that provides a directional wind source. Only affects SpeedTree assets."""

	@property
	def Strength(self) -> float: ...
	"""Strength"""

	@property
	def Speed(self) -> float: ...
	"""Speed"""

	@property
	def MinGustAmount(self) -> float: ...
	"""Min Gust Amount"""

	@property
	def MaxGustAmount(self) -> float: ...
	"""Max Gust Amount"""

	@property
	def Radius(self) -> float: ...
	"""Radius"""

	@property
	def bPointWind(self) -> bool: ...
	"""Point Wind"""

	def SetWindType(self, InNewType: int): ...
	"""Set the type of wind generator to use"""

	def SetRadius(self, InNewRadius: float): ...
	"""Set the effect radius for point wind"""

	def SetMaximumGustAmount(self, InNewMaxGust: float): ...
	"""Set maximum deviation for wind gusts"""

	def SetMinimumGustAmount(self, InNewMinGust: float): ...
	"""Set minimum deviation for wind gusts"""

	def SetSpeed(self, InNewSpeed: float): ...
	"""Sets the windspeed of the generated wind"""

	def SetStrength(self, InNewStrength: float): ...
	"""Sets the strength of the generated wind"""

	pass

class CurveBase(Object):
	"""Defines a curve of interpolated points to evaluate over a given range"""

	def GetValueRange(self) -> typing.Tuple[float, float]: ...
	"""Get the value range across all curves"""

	def GetTimeRange(self) -> typing.Tuple[float, float]: ...
	"""Get the time range across all curves"""

	pass

class CurveFloat(CurveBase):
	"""Curve Float"""

	@property
	def FloatCurve(self) -> typing.Any: ...
	"""Keyframe data"""

	@property
	def bIsEventCurve(self) -> bool: ...
	"""Flag to represent event curve"""

	def GetFloatValue(self, InTime: float) -> float: ...
	"""Evaluate this float curve at the specified time"""

	pass

class CurveLinearColor(CurveBase):
	"""Curve Linear Color"""

	@property
	def FloatCurves(self) -> typing.List[unsupported]: ...
	"""Keyframe data, one curve for red, green, blue, and alpha"""

	@property
	def AdjustHue(self) -> float: ...
	"""Properties for adjusting the color of the gradient"""

	@property
	def AdjustSaturation(self) -> float: ...
	"""Adjust Saturation"""

	@property
	def AdjustBrightness(self) -> float: ...
	"""Adjust Brightness"""

	@property
	def AdjustBrightnessCurve(self) -> float: ...
	"""Adjust Brightness Curve"""

	@property
	def AdjustVibrance(self) -> float: ...
	"""Adjust Vibrance"""

	@property
	def AdjustMinAlpha(self) -> float: ...
	"""Adjust Min Alpha"""

	@property
	def AdjustMaxAlpha(self) -> float: ...
	"""Adjust Max Alpha"""

	def GetClampedLinearColorValue(self, InTime: float) -> LinearColor: ...
	"""Get Clamped Linear Color Value"""

	def GetLinearColorValue(self, InTime: float) -> LinearColor: ...
	"""Get Linear Color Value"""

	pass

class StreamableRenderAsset(Object):
	"""Streamable Render Asset"""

	@property
	def NumCinematicMipLevels(self) -> int: ...
	"""Number of mip-levels to use for cinematic quality."""

	@property
	def NeverStream(self) -> bool: ...
	"""Never Stream"""

	@property
	def bGlobalForceMipLevelsToBeResident(self) -> bool: ...
	"""Global and serialized version of ForceMiplevelsToBeResident."""

	@property
	def bHasStreamingUpdatePending(self) -> bool: ...
	"""Whether some mips might be streamed soon. If false, the texture is not planned resolution will be stable."""

	@property
	def bForceMiplevelsToBeResident(self) -> bool: ...
	"""Override whether to fully stream even if texture hasn't been rendered."""

	@property
	def bIgnoreStreamingMipBias(self) -> bool: ...
	"""When forced fully resident, ignores the streaming mip bias used to accommodate memory constraints."""

	pass

class Texture(StreamableRenderAsset):
	"""Texture"""

	@property
	def LODBias(self) -> int: ...
	"""A bias to the index of the top mip level to use."""

	@property
	def CompressionSettings(self) -> int: ...
	"""Compression settings to use when building the texture."""

	@property
	def Filter(self) -> int: ...
	"""The texture filtering mode to use when sampling this texture."""

	@property
	def MipLoadOptions(self) -> int: ...
	"""The texture mip load options."""

	@property
	def LODGroup(self) -> int: ...
	"""Texture group this texture belongs to"""

	@property
	def Downscale(self) -> typing.Any: ...
	"""Downscale source texture, applied only to textures without mips
0.0 - use scale value from texture group
1.0 - do not scale texture
> 1.0 - scale texure"""

	@property
	def DownscaleOptions(self) -> int: ...
	"""Texture downscaling options"""

	@property
	def SRGB(self) -> bool: ...
	"""This should be unchecked if using alpha channels individually as masks."""

	@property
	def bNoTiling(self) -> bool: ...
	"""If true, the RHI texture will be created using TexCreate_NoTiling"""

	@property
	def VirtualTextureStreaming(self) -> bool: ...
	"""Is this texture streamed in using VT"""

	@property
	def CompressionYCoCg(self) -> bool: ...
	"""If true the texture stores YCoCg. Blue channel will be filled with a precision scale during compression."""

	@property
	def bNotOfflineProcessed(self) -> bool: ...
	"""If true, the RHI texture will be created without TexCreate_OfflineProcessed."""

	pass

class Texture2D(Texture):
	"""Texture 2D"""

	@property
	def LevelIndex(self) -> int: ...
	"""* Level scope index of this texture. It is used to reduce the amount of lookup to map a texture to its level index.
* Useful when building texture streaming data, as well as when filling the texture streamer with precomputed data.
* It relates to FStreamingTextureBuildInfo::TextureLevelIndex and also the index in ULevel::StreamingTextureGuids.
* Default value of -1, indicates that the texture has an unknown index (not yet processed). At level load time,
* -2 is also used to indicate that the texture has been processed but no entry were found in the level table.
* After any of these processes, the LevelIndex is reset to INDEX_NONE. Making it ready for the next level task."""

	@property
	def FirstResourceMemMip(self) -> int: ...
	"""keep track of first mip level used for ResourceMem creation"""

	@property
	def AddressX(self) -> int: ...
	"""The addressing mode to use for the X axis."""

	@property
	def AddressY(self) -> int: ...
	"""The addressing mode to use for the Y axis."""

	pass

class CurveLinearColorAtlas(Texture2D):
	"""Manages gradient LUT textures for registered actors and assigns them to the corresponding materials on the actor"""

	@property
	def TextureSize(self) -> int: ...
	"""Texture Size"""

	@property
	def GradientCurves(self) -> typing.List[CurveLinearColor]: ...
	"""Size of the lookup textures"""

	def GetCurvePosition(self, InCurve: CurveLinearColor) -> typing.Tuple[bool, float]: ...
	"""Get Curve Position"""

	pass

class CurveVector(CurveBase):
	"""Curve Vector"""

	@property
	def FloatCurves(self) -> typing.List[unsupported]: ...
	"""Keyframe data, one curve for X, Y and Z"""

	def GetVectorValue(self, InTime: float) -> Vector: ...
	"""Evaluate this float curve at the specified time"""

	pass

class AssetImportData(Object):
	"""todo: Make this class better suited to multiple import paths - maybe have FAssetImportInfo use a map rather than array?"""

	pass

class Brush(Actor):
	"""Brush"""

	@property
	def BrushType(self) -> int: ...
	"""Type of brush"""

	@property
	def BrushColor(self) -> Color: ...
	"""Information."""

	@property
	def PolyFlags(self) -> int: ...
	"""Poly Flags"""

	@property
	def bColored(self) -> bool: ...
	"""Colored"""

	@property
	def bSolidWhenSelected(self) -> bool: ...
	"""Solid when Selected"""

	@property
	def bPlaceableFromClassBrowser(self) -> bool: ...
	"""If true, this brush class can be placed using the class browser like other simple class types"""

	@property
	def bNotForClientOrServer(self) -> bool: ...
	"""If true, this brush is a builder or otherwise does not need to be loaded into the game"""

	@property
	def Brush(self) -> typing.Any: ...
	"""Brush"""

	@property
	def bInManipulation(self) -> bool: ...
	"""Flag set when we are in a manipulation (scaling, translation, brush builder param change etc.)"""

	@property
	def SavedSelections(self) -> typing.List[unsupported]: ...
	"""Stores selection information from geometry mode.  This is the only information that we can't
regenerate by looking at the source brushes following an undo operation."""

	pass

class Volume(Brush):
	"""An editable 3D volume placed in a level. Different types of volumes perform different functions
See: https://docs.unrealengine.com/latest/INT/Engine/Actors/Volumes"""

	pass

class BlockingVolume(Volume):
	"""An invisible volume used to block other actors."""

	pass

class ReflectionCapture(Actor):
	"""Reflection Capture"""

	pass

class BoxReflectionCapture(ReflectionCapture):
	"""Actor used to capture the scene for reflection in a box shape
See: https://docs.unrealengine.com/latest/INT/Resources/ContentExamples/Reflections/1_3/index.html"""

	pass

class BrushShape(Brush):
	"""A brush that acts as a template for geometry mode modifiers like 'Lathe'."""

	pass

class Canvas(Object):
	"""A drawing canvas."""

	@property
	def OrgX(self) -> float: ...
	"""Modifiable properties."""

	@property
	def OrgY(self) -> float: ...
	"""Origin for drawing in X."""

	@property
	def ClipX(self) -> float: ...
	"""Origin for drawing in Y."""

	@property
	def ClipY(self) -> float: ...
	"""Bottom right clipping region."""

	@property
	def DrawColor(self) -> Color: ...
	"""Bottom right clipping region."""

	@property
	def bCenterX(self) -> bool: ...
	"""Color for drawing."""

	@property
	def bCenterY(self) -> bool: ...
	"""Whether to center the text horizontally (about CurX)"""

	@property
	def bNoSmooth(self) -> bool: ...
	"""Whether to center the text vertically (about CurY)"""

	@property
	def SizeX(self) -> int: ...
	"""Don't bilinear filter."""

	@property
	def SizeY(self) -> int: ...
	"""Zero-based actual dimensions X."""

	@property
	def ColorModulate(self) -> Plane: ...
	"""Internal."""

	@property
	def DefaultTexture(self) -> Texture2D: ...
	"""Default Texture"""

	@property
	def GradientTexture0(self) -> Texture2D: ...
	"""Default texture to use"""

	@property
	def ReporterGraph(self) -> typing.Any: ...
	"""Helper class to render 2d graphs on canvas"""

	def ClippedTextSize(self, RenderFont: Font, RenderText: str, Scale: Vector2D = ...) -> Vector2D: ...
	"""Returns the clipped text size in screen space coordinates.

@param RenderFont                            Font to use when determining the size of the text. If this is null, then a default engine font is used.
@param RenderText                            Text to determine the size of.
@param Scale                                         Scale of the font to use when determining the size of the text.
@return                                                      Returns the screen space size of the text."""

	def WrappedTextSize(self, RenderFont: Font, RenderText: str) -> Vector2D: ...
	"""Returns the wrapped text size in screen space coordinates.

@param RenderFont                            Font to use when determining the size of the text. If this is null, then a default engine font is used.
@param RenderText                            Text to determine the size of.
@return                                                      Returns the screen space size of the text."""

	def Deproject(self, ScreenPosition: Vector2D) -> typing.Tuple[Vector, Vector]: ...
	"""Performs a deprojection of a screen space coordinate using the projection matrix set up for the Canvas.

@param ScreenPosition                        Screen space position to deproject to the World.
@param WorldOrigin                           Vector which is the world position of the screen space position.
@param WorldDirection                        Vector which can be used in a trace to determine what is 'behind' the screen space position. Useful for object picking."""

	def Project(self, WorldLocation: Vector) -> Vector: ...
	"""Performs a projection of a world space coordinates using the projection matrix set up for the Canvas.

@param WorldLocation                         World space location to project onto the Canvas rendering plane.
@return                                                      Returns a vector where X, Y defines a screen space position representing the world space location."""

	def DrawPolygon(self, RenderTexture: Texture, ScreenPosition: Vector2D, Radius: Vector2D = ..., NumberOfSides: int = ..., RenderColor: LinearColor = ...): ...
	"""Draws a polygon on the Canvas.

@param RenderTexture                         Texture to use when rendering the triangles. If no texture is set, then the default white texture is used.
@param ScreenPosition                        Screen space position to render the text.
@param Radius                                        How large in pixels this polygon should be.
@param NumberOfSides                         How many sides this polygon should have. This should be above or equal to three.
@param RenderColor                           Color to tint the polygon."""

	def DrawMaterialTriangles(self, RenderMaterial: MaterialInterface, Triangles: typing.List[CanvasUVTri]): ...
	"""Draws a set of triangles on the Canvas.

@param RenderMaterial                        Material to use when rendering. Remember that only the emissive channel is able to be rendered as no lighting is performed when rendering to the Canvas.
@param Triangles                                     Triangles to render."""

	def DrawTriangles(self, RenderTexture: Texture, Triangles: typing.List[CanvasUVTri]): ...
	"""Draws a set of triangles on the Canvas.

@param RenderTexture                         Texture to use when rendering the triangles. If no texture is set, then the default white texture is used.
@param Triangles                                     Triangles to render."""

	def DrawBox(self, ScreenPosition: Vector2D, ScreenSize: Vector2D, Thickness: float = ..., RenderColor: LinearColor = ...): ...
	"""Draws an unfilled box on the Canvas.

@param ScreenPosition                        Screen space position to render the text.
@param ScreenSize                            Screen space size to render the texture.
@param Thickness                                     How many pixels thick the box lines should be."""

	def DrawBorder(self, BorderTexture: Texture, BackgroundTexture: Texture, LeftBorderTexture: Texture, RightBorderTexture: Texture, TopBorderTexture: Texture, BottomBorderTexture: Texture, ScreenPosition: Vector2D, ScreenSize: Vector2D, CoordinatePosition: Vector2D, CoordinateSize: Vector2D = ..., RenderColor: LinearColor = ..., BorderScale: Vector2D = ..., BackgroundScale: Vector2D = ..., Rotation: float = ..., PivotPoint: Vector2D = ..., CornerSize: Vector2D = ...): ...
	"""Draws a 3x3 grid border with tiled frame and tiled interior on the Canvas.

@param BorderTexture                         Texture to use for border.
@param BackgroundTexture                     Texture to use for border background.
@param LeftBorderTexture                     Texture to use for the tiling left border.
@param RightBorderTexture            Texture to use for the tiling right border.
@param TopBorderTexture                      Texture to use for the tiling top border.
@param BottomBorderTexture           Texture to use for the tiling bottom border.
@param ScreenPosition                        Screen space position to render the texture.
@param ScreenSize                            Screen space size to render the texture.
@param CoordinatePosition            Normalized UV starting coordinate to use when rendering the border texture.
@param CoordinateSize                        Normalized UV size coordinate to use when rendering the border texture.
@param RenderColor                           Color to tint the border.
@param BorderScale                           Scale of the border.
@param BackgroundScale                       Scale of the background.
@param Rotation                                      Rotation, in degrees, to render the texture.
@param PivotPoint                            Normalized pivot point to use when rotating the texture.
@param CornerSize                            Frame corner size in percent of frame texture (should be < 0.5f)."""

	def DrawText(self, RenderFont: Font, RenderText: str, ScreenPosition: Vector2D, Scale: Vector2D = ..., RenderColor: LinearColor = ..., Kerning: float = ..., ShadowColor: LinearColor = ..., ShadowOffset: Vector2D = ..., bCentreX: bool = ..., bCentreY: bool = ..., bOutlined: bool = ..., OutlineColor: LinearColor = ...): ...
	"""Draws text on the Canvas.

@param RenderFont                            Font to use when rendering the text. If this is null, then a default engine font is used.
@param RenderText                            Text to render on the Canvas.
@param ScreenPosition                        Screen space position to render the text.
@param RenderColor                           Color to render the text.
@param Kerning                                       Horizontal spacing adjustment to modify the spacing between each letter.
@param ShadowColor                           Color to render the shadow of the text.
@param ShadowOffset                          Pixel offset relative to the screen space position to render the shadow of the text.
@param bCentreX                                      If true, then interpret the screen space position X coordinate as the center of the rendered text.
@param bCentreY                                      If true, then interpret the screen space position Y coordinate as the center of the rendered text.
@param bOutlined                                     If true, then the text should be rendered with an outline.
@param OutlineColor                          Color to render the outline for the text."""

	def DrawMaterial(self, RenderMaterial: MaterialInterface, ScreenPosition: Vector2D, ScreenSize: Vector2D, CoordinatePosition: Vector2D, CoordinateSize: Vector2D = ..., Rotation: float = ..., PivotPoint: Vector2D = ...): ...
	"""Draws a material on the Canvas.

@param RenderMaterial                        Material to use when rendering. Remember that only the emissive channel is able to be rendered as no lighting is performed when rendering to the Canvas.
@param ScreenPosition                        Screen space position to render the texture.
@param ScreenSize                            Screen space size to render the texture.
@param CoordinatePosition            Normalized UV starting coordinate to use when rendering the texture.
@param CoordinateSize                        Normalized UV size coordinate to use when rendering the texture.
@param Rotation                                      Rotation, in degrees, to render the texture.
@param PivotPoint                            Normalized pivot point to use when rotating the texture."""

	def DrawTexture(self, RenderTexture: Texture, ScreenPosition: Vector2D, ScreenSize: Vector2D, CoordinatePosition: Vector2D, CoordinateSize: Vector2D = ..., RenderColor: LinearColor = ..., BlendMode: int = ..., Rotation: float = ..., PivotPoint: Vector2D = ...): ...
	"""Draws a texture on the Canvas.

@param RenderTexture                         Texture to use when rendering. If no texture is set then this will use the default white texture.
@param ScreenPosition                        Screen space position to render the texture.
@param ScreenSize                            Screen space size to render the texture.
@param CoordinatePosition            Normalized UV starting coordinate to use when rendering the texture.
@param CoordinateSize                        Normalized UV size coordinate to use when rendering the texture.
@param RenderColor                           Color to use when rendering the texture.
@param BlendMode                                     Blending mode to use when rendering the texture.
@param Rotation                                      Rotation, in degrees, to render the texture.
@param PivotPoint                            Normalized pivot point to use when rotating the texture."""

	def DrawLine(self, ScreenPositionA: Vector2D = ..., ScreenPositionB: Vector2D = ..., Thickness: float = ..., RenderColor: LinearColor = ...): ...
	"""Draws a line on the Canvas.

@param ScreenPositionA               Starting position of the line in screen space.
@param ScreenPositionB               Ending position of the line in screen space.
@param Thickness                             How many pixels thick this line should be.
@param RenderColor                   Color to render the line."""

	pass

class TextureRenderTarget(Texture):
	"""Texture Render Target"""

	@property
	def TargetGamma(self) -> float: ...
	"""Will override FTextureRenderTarget2DResource::GetDisplayGamma if > 0."""

	pass

class TextureRenderTarget2D(TextureRenderTarget):
	"""TextureRenderTarget2D

2D render target texture resource. This can be used as a target
for rendering as well as rendered as a regular 2D texture resource."""

	@property
	def SizeX(self) -> int: ...
	"""The width of the texture."""

	@property
	def SizeY(self) -> int: ...
	"""The height of the texture."""

	@property
	def ClearColor(self) -> LinearColor: ...
	"""the color the texture is cleared to"""

	@property
	def AddressX(self) -> int: ...
	"""The addressing mode to use for the X axis."""

	@property
	def AddressY(self) -> int: ...
	"""The addressing mode to use for the Y axis."""

	@property
	def bForceLinearGamma(self) -> bool: ...
	"""True to force linear gamma space for this render target"""

	@property
	def bGPUSharedFlag(self) -> bool: ...
	"""Whether to support GPU sharing of the underlying native texture resource."""

	@property
	def RenderTargetFormat(self) -> int: ...
	"""Format of the texture render target.
Data written to the render target will be quantized to this format, which can limit the range and precision.
The largest format (RTF_RGBA32f) uses 16x more memory and bandwidth than the smallest (RTF_R8) and can greatly affect performance.
Use the smallest format that has enough precision and range for what you are doing."""

	@property
	def bAutoGenerateMips(self) -> bool: ...
	"""Whether to support Mip maps for this render target texture"""

	@property
	def MipsSamplerFilter(self) -> int: ...
	"""Sampler filter type for AutoGenerateMips. Defaults to match texture filter."""

	@property
	def MipsAddressU(self) -> int: ...
	"""AutoGenerateMips sampler address mode for U channel. Defaults to clamp."""

	@property
	def MipsAddressV(self) -> int: ...
	"""AutoGenerateMips sampler address mode for V channel. Defaults to clamp."""

	@property
	def OverrideFormat(self) -> int: ...
	"""Normally the format is derived from RenderTargetFormat, this allows code to set the format explicitly."""

	pass

class CanvasRenderTarget2D(TextureRenderTarget2D):
	"""CanvasRenderTarget2D is 2D render target which exposes a Canvas interface to allow you to draw elements onto
it directly.  Use CreateCanvasRenderTarget2D() to create a render target texture by unique name, then
bind a function to the OnCanvasRenderTargetUpdate delegate which will be called when the render target is
updated.  If you need to repaint your canvas every single frame, simply call UpdateResource() on it from a Tick
function.  Also, remember to hold onto your new canvas render target with a reference so that it doesn't get
garbage collected."""

	@property
	def OnCanvasRenderTargetUpdate(self) -> typing.Any: ...
	"""Called when this Canvas Render Target is asked to update its texture resource."""

	def GetSize(self) -> typing.Tuple[int, int]: ...
	"""Gets a specific render target's size from the global map of canvas render targets.

@param       Width   Output variable for the render target's width
@param       Height  Output variable for the render target's height"""

	@staticmethod
	def CreateCanvasRenderTarget2D(WorldContextObject: Object, CanvasRenderTarget2DClass: CanvasRenderTarget2D, Width: int = ..., Height: int = ...) -> CanvasRenderTarget2D: ...
	"""Creates a new canvas render target and initializes it to the specified dimensions

@param       WorldContextObject      The world where this render target will be rendered for
@param       CanvasRenderTarget2DClass       Class of the render target.  Unless you want to use a special sub-class, you can simply pass UCanvasRenderTarget2D::StaticClass() here.
@param       Width                           Width of the render target.
@param       Height                          Height of the render target.

@return                                              Returns the instanced render target."""

	def UpdateResource(self): ...
	"""Updates the the canvas render target texture's resource. This is where the render target will create or
find a canvas object to use.  It also calls UpdateResourceImmediate() to clear the render target texture
from the deferred rendering list, to stop the texture from being cleared the next frame. From there it
will ask the rendering thread to set up the RHI viewport. The canvas is then set up for rendering and
then the user's update delegate is called.  The canvas is then flushed and the RHI resolves the
texture to make it available for rendering."""

	pass

class CurveTable(Object):
	"""Imported spreadsheet table as curves."""

	pass

class CompositeCurveTable(CurveTable):
	"""Curve table composed of a stack of other curve tables."""

	pass

class DataTable(Object):
	"""Imported spreadsheet table."""

	@property
	def RowStruct(self) -> typing.Any: ...
	"""Structure to use for each row of the table, must inherit from FTableRowBase"""

	@property
	def bStripFromClientBuilds(self) -> bool: ...
	"""Set to true to not cook this data table into client builds. Useful for sensitive tables that only servers should know about."""

	@property
	def bIgnoreExtraFields(self) -> bool: ...
	"""Set to true to ignore extra fields in the import data, if false it will warn about them"""

	@property
	def bIgnoreMissingFields(self) -> bool: ...
	"""Set to true to ignore any fields that are expected but missing, if false it will warn about them"""

	@property
	def ImportKeyField(self) -> str: ...
	"""Explicit field in import data to use as key. If this is empty it uses Name for JSON and the first field found for CSV"""

	pass

class CompositeDataTable(DataTable):
	"""Data table composed of a stack of other data tables."""

	pass

class CullDistanceVolume(Volume):
	"""Cull Distance Volume"""

	@property
	def CullDistances(self) -> typing.List[CullDistanceSizePair]: ...
	"""Array of size and cull distance pairs. The code will calculate the sphere diameter of a primitive's BB and look for a best
fit in this array to determine which cull distance to use."""

	@property
	def bEnabled(self) -> bool: ...
	"""Whether the volume is currently enabled or not."""

	pass

class DataAsset(Object):
	"""Base class for a simple asset containing data. The editor will list this in the content browser if you inherit from this class"""

	pass

class PrimaryDataAsset(DataAsset):
	"""A DataAsset that implements GetPrimaryAssetId and has asset bundle support, which makes it something that can be manually loaded/unloaded from the AssetManager
Making blueprint subclasses of this is useful because you can make blueprint-only primary asset types
Blueprint subclasses will end up with a PrimaryAssetType equal to the name of the first native class found going up the hierarchy, or the top level blueprint class that directly subclasses this
IE, if you have PrimaryDataAsset -> ParentNativeClass -> ChildNativeClass -> BlueprintAsset the type will be ChildNativeClass
Whereas if you have PrimaryDataAsset -> ParentBlueprintClass -> ChildBlueprintClass the type will be ParentBlueprintClass
To override this behavior, override GetPrimaryAssetId in your native class"""

	pass

class Controller(Actor):
	"""Controllers are non-physical actors that can possess a Pawn to control
its actions.  PlayerControllers are used by human players to control pawns, while
AIControllers implement the artificial intelligence for the pawns they control.
Controllers take control of a pawn using their Possess() method, and relinquish
control of the pawn by calling UnPossess().

Controllers receive notifications for many of the events occurring for the Pawn they
are controlling.  This gives the controller the opportunity to implement the behavior
in response to this event, intercepting the event and superseding the Pawn's default
behavior.

ControlRotation (accessed via GetControlRotation()), determines the viewing/aiming
direction of the controlled Pawn and is affected by input such as from a mouse or gamepad.

See: https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Controller/"""

	@property
	def PlayerState(self) -> PlayerState: ...
	"""PlayerState containing replicated information about the player using this controller (only exists for players, not NPCs)."""

	@property
	def OnInstigatedAnyDamage(self) -> typing.Any: ...
	"""Called when the controller has instigated damage in any way"""

	@property
	def StateName(self) -> str: ...
	"""Current gameplay state this controller is in"""

	def ResetIgnoreInputFlags(self): ...
	"""Reset move and look input ignore flags."""

	def IsLookInputIgnored(self) -> bool: ...
	"""Returns true if look input is ignored."""

	def ResetIgnoreLookInput(self): ...
	"""Stops ignoring look input by resetting the ignore look input state."""

	def SetIgnoreLookInput(self, bNewLookInput: bool): ...
	"""Locks or unlocks look input, consecutive calls stack up and require the same amount of calls to undo, or can all be undone using ResetIgnoreLookInput.
@param bNewLookInput  If true, look input is ignored. If false, input is not ignored."""

	def IsMoveInputIgnored(self) -> bool: ...
	"""Returns true if movement input is ignored."""

	def ResetIgnoreMoveInput(self): ...
	"""Stops ignoring move input by resetting the ignore move input state."""

	def SetIgnoreMoveInput(self, bNewMoveInput: bool): ...
	"""Locks or unlocks movement input, consecutive calls stack up and require the same amount of calls to undo, or can all be undone using ResetIgnoreMoveInput.
@param bNewMoveInput If true, move input is ignored. If false, input is not ignored."""

	def StopMovement(self): ...
	"""Aborts the move the controller is currently performing"""

	def UnPossess(self): ...
	"""Called to unpossess our pawn for any reason that is not the pawn being destroyed (destruction handled by PawnDestroyed())."""

	def Possess(self, InPawn: Pawn): ...
	"""Handles attaching this controller to the specified pawn.
Only runs on the network authority (where HasAuthority() returns true).
Derived native classes can override OnPossess to filter the specified pawn.
When possessed pawn changed, blueprint class gets notified by ReceivePossess
and OnNewPawn delegate is broadcasted.
@param InPawn The Pawn to be possessed.
@see HasAuthority, OnPossess, ReceivePossess"""

	def IsLocalController(self) -> bool: ...
	"""Returns whether this Controller is a local controller."""

	def IsLocalPlayerController(self) -> bool: ...
	"""Returns whether this Controller is a locally controlled PlayerController."""

	def IsPlayerController(self) -> bool: ...
	"""Returns whether this Controller is a PlayerController."""

	def GetDesiredRotation(self) -> Rotator: ...
	"""Get the desired pawn target rotation"""

	def GetViewTarget(self) -> Actor: ...
	"""Get the actor the controller is looking at"""

	def GetControlledPawn(self) -> Pawn: ...
	"""Return the Pawn that is currently 'controlled' by this PlayerController"""

	def ClientSetRotation(self, NewRotation: Rotator, bResetCamera: bool): ...
	"""Replicated function to set the pawn rotation, allowing the server to force."""

	def ClientSetLocation(self, NewLocation: Vector, NewRotation: Rotator): ...
	"""Replicated function to set the pawn location and rotation, allowing server to force (ex. teleports)."""

	def OnRep_PlayerState(self): ...
	"""On Rep Player State"""

	def OnRep_Pawn(self): ...
	"""Replication Notification Callbacks"""

	def LineOfSightTo(self, Other: Actor, ViewPoint: Vector = ..., bAlternateChecks: bool = ...) -> bool: ...
	"""Checks line to center and top of other actor
@param Other is the actor whose visibility is being checked.
@param ViewPoint is eye position visibility is being checked from.  If vect(0,0,0) passed in, uses current viewtarget's eye position.
@param bAlternateChecks used only in AIController implementation
@return true if controller's pawn can see Other actor."""

	def SetInitialLocationAndRotation(self, NewLocation: Vector, NewRotation: Rotator): ...
	"""Set the initial location and rotation of the controller, as well as the control rotation. Typically used when the controller is first created."""

	def SetControlRotation(self, NewRotation: Rotator): ...
	"""Set the control rotation."""

	def GetControlRotation(self) -> Rotator: ...
	"""Get the control rotation. This is the full aim rotation, which may be different than a camera orientation (for example in a third person view),
and may differ from the rotation of the controlled Pawn (which may choose not to visually pitch or roll, for example)."""

	pass

class PlayerController(Controller):
	"""PlayerControllers are used by human players to control Pawns.

ControlRotation (accessed via GetControlRotation()), determines the aiming
orientation of the controlled Pawn.

In networked games, PlayerControllers exist on the server for every player-controlled pawn,
and also on the controlling client's machine. They do NOT exist on a client's
machine for pawns controlled by remote players elsewhere on the network.

See: https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Controller/PlayerController/"""

	@property
	def Player(self) -> typing.Any: ...
	"""UPlayer associated with this PlayerController.  Could be a local player or a net connection."""

	@property
	def AcknowledgedPawn(self) -> Pawn: ...
	"""Used in net games so client can acknowledge it possessed a specific pawn."""

	@property
	def ControllingDirTrackInst(self) -> typing.Any: ...
	"""Director track that's currently possessing this player controller, or none if not possessed."""

	@property
	def MyHUD(self) -> HUD: ...
	"""Heads up display associated with this PlayerController."""

	@property
	def PlayerCameraManager(self) -> PlayerCameraManager: ...
	"""Camera manager associated with this Player Controller."""

	@property
	def PlayerCameraManagerClass(self) -> PlayerCameraManager: ...
	"""PlayerCamera class should be set for each game, otherwise Engine.PlayerCameraManager is used"""

	@property
	def bAutoManageActiveCameraTarget(self) -> bool: ...
	"""True to allow this player controller to manage the camera target for you,
typically by using the possessed pawn as the camera target. Set to false
if you want to manually control the camera target."""

	@property
	def TargetViewRotation(self) -> Rotator: ...
	"""Used to replicate the view rotation of targets not owned/possessed by this PlayerController."""

	@property
	def SmoothTargetViewRotationSpeed(self) -> float: ...
	"""Interp speed for blending remote view rotation for smoother client updates"""

	@property
	def HiddenActors(self) -> typing.List[Actor]: ...
	"""The actors which the camera shouldn't see - e.g. used to hide actors which the camera penetrates"""

	@property
	def HiddenPrimitiveComponents(self) -> typing.List[PrimitiveComponent]: ...
	"""Explicit components the camera shouldn't see (helpful for external systems to hide a component from a single player)"""

	@property
	def LastSpectatorStateSynchTime(self) -> float: ...
	"""Used to make sure the client is kept synchronized when in a spectator state"""

	@property
	def LastSpectatorSyncLocation(self) -> Vector: ...
	"""Last location synced on the server for a spectator."""

	@property
	def LastSpectatorSyncRotation(self) -> Rotator: ...
	"""Last rotation synced on the server for a spectator."""

	@property
	def ClientCap(self) -> int: ...
	"""Cap set by server on bandwidth from client to server in bytes/sec (only has impact if >=2600)"""

	@property
	def CheatManager(self) -> CheatManager: ...
	"""Object that manages 'cheat' commands.

By default:
  - Debug and Development builds will force it to be instantiated (See: APlayerController::EnableCheats).
  - Test and Shipping builds will only instantiate it if the authoritative game mode allows cheats (See: AGameModeBase::AllowCheats).

This behavior can be changed either by overriding APlayerController::EnableCheats or AGameModeBase::AllowCheats."""

	@property
	def CheatClass(self) -> CheatManager: ...
	"""Class of my CheatManager.
See: CheatManager for more information about when it will be instantiated."""

	@property
	def PlayerInput(self) -> typing.Any: ...
	"""Object that manages player input."""

	@property
	def ActiveForceFeedbackEffects(self) -> typing.List[unsupported]: ...
	"""Active Force Feedback Effects"""

	@property
	def bPlayerIsWaiting(self) -> bool: ...
	"""True if PlayerController is currently waiting for the match to start or to respawn. Only valid in Spectating state."""

	@property
	def NetPlayerIndex(self) -> int: ...
	"""Index identifying players using the same base connection (splitscreen clients)
Used by netcode to match replicated PlayerControllers to the correct splitscreen viewport and child connection
replicated via special internal code, not through normal variable replication"""

	@property
	def PendingSwapConnection(self) -> typing.Any: ...
	"""This is set on the OLD PlayerController when performing a swap over a network connection
so we know what connection we're waiting on acknowledgment from to finish destroying this PC
(or when the connection is closed)
See: GameModeBase::SwapPlayerControllers()"""

	@property
	def NetConnection(self) -> typing.Any: ...
	"""The net connection this controller is communicating on, nullptr for local players on server"""

	@property
	def InputYawScale(self) -> float: ...
	"""Yaw input speed scaling"""

	@property
	def InputPitchScale(self) -> float: ...
	"""Pitch input speed scaling"""

	@property
	def InputRollScale(self) -> float: ...
	"""Roll input speed scaling"""

	@property
	def bShowMouseCursor(self) -> bool: ...
	"""Whether the mouse cursor should be displayed."""

	@property
	def bEnableClickEvents(self) -> bool: ...
	"""Whether actor/component click events should be generated."""

	@property
	def bEnableTouchEvents(self) -> bool: ...
	"""Whether actor/component touch events should be generated."""

	@property
	def bEnableMouseOverEvents(self) -> bool: ...
	"""Whether actor/component mouse over events should be generated."""

	@property
	def bEnableTouchOverEvents(self) -> bool: ...
	"""Whether actor/component touch over events should be generated."""

	@property
	def bForceFeedbackEnabled(self) -> bool: ...
	"""Force Feedback Enabled"""

	@property
	def ForceFeedbackScale(self) -> float: ...
	"""Scale applied to force feedback values"""

	@property
	def ClickEventKeys(self) -> typing.List[Key]: ...
	"""List of keys that will cause click events to be forwarded, default to left click"""

	@property
	def DefaultMouseCursor(self) -> int: ...
	"""Type of mouse cursor to show by default"""

	@property
	def CurrentMouseCursor(self) -> int: ...
	"""Currently visible mouse cursor"""

	@property
	def DefaultClickTraceChannel(self) -> int: ...
	"""Default trace channel used for determining what world object was clicked on."""

	@property
	def CurrentClickTraceChannel(self) -> int: ...
	"""Trace channel currently being used for determining what world object was clicked on."""

	@property
	def HitResultTraceDistance(self) -> float: ...
	"""Distance to trace when computing click events"""

	@property
	def SeamlessTravelCount(self) -> int: ...
	"""Counter for this players seamless travels (used along with the below value, to restrict ServerNotifyLoadedWorld)"""

	@property
	def LastCompletedSeamlessTravelCount(self) -> int: ...
	"""The value of SeamlessTravelCount, upon the last call to GameModeBase::HandleSeamlessTravelPlayer; used to detect seamless travel"""

	def GetFocalLocation(self) -> Vector: ...
	"""Returns the location the PlayerController is focused on.
 If there is a possessed Pawn, returns the Pawn's location.
 If there is a spectator Pawn, returns that Pawn's location.
 Otherwise, returns the PlayerController's spawn location (usually the last known Pawn location after it has died)."""

	def GetSpectatorPawn(self) -> SpectatorPawn: ...
	"""Get the Pawn used when spectating. nullptr when not spectating."""

	def OnServerStartedVisualLogger(self, bIsLogging: bool): ...
	"""Notify from server that Visual Logger is recording, to show that information on client about possible performance issues"""

	def SetCinematicMode(self, bInCinematicMode: bool, bHidePlayer: bool, bAffectsHUD: bool, bAffectsMovement: bool, bAffectsTurning: bool): ...
	"""Server/SP only function for changing whether the player is in cinematic mode.  Updates values of various state variables, then replicates the call to the client
to sync the current cinematic mode.
@param       bInCinematicMode        specify true if the player is entering cinematic mode; false if the player is leaving cinematic mode.
@param       bHidePlayer                     specify true to hide the player's pawn (only relevant if bInCinematicMode is true)
@param       bAffectsHUD                     specify true if we should show/hide the HUD to match the value of bCinematicMode
@param       bAffectsMovement        specify true to disable movement in cinematic mode, enable it when leaving
@param       bAffectsTurning         specify true to disable turning in cinematic mode or enable it when leaving"""

	def CanRestartPlayer(self) -> bool: ...
	"""Returns true if this controller thinks it's able to restart. Called from GameModeBase::PlayerCanRestart"""

	def ClearAudioListenerAttenuationOverride(self): ...
	"""Clear Audio Listener Attenuation Override"""

	def SetAudioListenerAttenuationOverride(self, AttachToComponent: SceneComponent, AttenuationLocationOVerride: Vector): ...
	"""Set Audio Listener Attenuation Override"""

	def ClearAudioListenerOverride(self): ...
	"""Clear any overrides that have been applied to audio listener"""

	def SetAudioListenerOverride(self, AttachToComponent: SceneComponent, Location: Vector, Rotation: Rotator): ...
	"""Used to override the default positioning of the audio listener

@param AttachToComponent Optional component to attach the audio listener to
@param Location Depending on whether Component is attached this is either an offset from its location or an absolute position
@param Rotation Depending on whether Component is attached this is either an offset from its rotation or an absolute rotation"""

	def SetViewTargetWithBlend(self, NewViewTarget: Actor, BlendTime: float = ..., BlendFunc: int = ..., BlendExp: float = ..., bLockOutgoing: bool = ...): ...
	"""Set the view target blending with variable control
@param NewViewTarget - new actor to set as view target
@param BlendTime - time taken to blend
@param BlendFunc - Cubic, Linear etc functions for blending
@param BlendExp -  Exponent, used by certain blend functions to control the shape of the curve.
@param bLockOutgoing - If true, lock outgoing viewtarget to last frame's camera position for the remainder of the blend."""

	def Camera(self, NewMode: str): ...
	"""Change Camera mode
@param       New camera mode to set"""

	def SetVirtualJoystickVisibility(self, bVisible: bool): ...
	"""Set the virtual joystick visibility."""

	def ActivateTouchInterface(self, NewTouchInterface: TouchInterface): ...
	"""Activates a new touch interface for this player controller"""

	def GetInputAnalogStickState(self, WhichStick: int) -> typing.Tuple[float, float]: ...
	"""Retrieves the X and Y displacement of the given analog stick."""

	def GetInputMouseDelta(self) -> typing.Tuple[float, float]: ...
	"""Retrieves how far the mouse moved this frame."""

	def GetInputKeyTimeDown(self, Key: Key) -> float: ...
	"""Returns how long the given key/button has been down.  Returns 0 if it's up or it just went down this frame."""

	def GetMousePosition(self) -> typing.Tuple[bool, float, float]: ...
	"""Retrieves the X and Y screen coordinates of the mouse cursor. Returns false if there is no associated mouse device"""

	def GetInputMotionState(self) -> typing.Tuple[Vector, Vector, Vector, Vector]: ...
	"""Retrieves the current motion state of the player's input device"""

	def GetInputTouchState(self, FingerIndex: int) -> typing.Tuple[float, float, bool]: ...
	"""Retrieves the X and Y screen coordinates of the specified touch key. Returns false if the touch index is not down"""

	def GetInputVectorKeyState(self, Key: Key) -> Vector: ...
	"""Returns the vector value for the given key/button."""

	def GetInputAnalogKeyState(self, Key: Key) -> float: ...
	"""Returns the analog value for the given key/button.  If analog isn't supported, returns 1 for down and 0 for up."""

	def WasInputKeyJustReleased(self, Key: Key) -> bool: ...
	"""Returns true if the given key/button was down last frame and up this frame."""

	def WasInputKeyJustPressed(self, Key: Key) -> bool: ...
	"""Returns true if the given key/button was up last frame and down this frame."""

	def IsInputKeyDown(self, Key: Key) -> bool: ...
	"""Returns true if the given key/button is pressed on the input of the controller (if present)"""

	def AddRollInput(self, Val: float): ...
	"""Add Roll input. This value is multiplied by InputRollScale.
@param Val Amount to add to Roll. This value is multiplied by InputRollScale."""

	def AddYawInput(self, Val: float): ...
	"""Add Yaw (turn) input. This value is multiplied by InputYawScale.
@param Val Amount to add to Yaw. This value is multiplied by InputYawScale."""

	def AddPitchInput(self, Val: float): ...
	"""Add Pitch (look up) input. This value is multiplied by InputPitchScale.
@param Val Amount to add to Pitch. This value is multiplied by InputPitchScale."""

	def ClientTeamMessage(self, SenderPlayerState: PlayerState, S: str, Type: str, MsgLifeTime: float): ...
	"""@todo document"""

	def ClientReceiveLocalizedMessage(self, Message, Switch: int, RelatedPlayerState_1: PlayerState, RelatedPlayerState_2: PlayerState, OptionalObject: Object): ...
	"""send client localized message id"""

	def ClientRetryClientRestart(self, NewPawn: Pawn): ...
	"""Assign Pawn to player, but avoid calling ClientRestart if we have already accepted this pawn"""

	def ClientEndOnlineSession(self): ...
	"""Notify client that the session is about to start"""

	def ClientStartOnlineSession(self): ...
	"""Notify client that the session is starting"""

	def ClientWasKicked(self, KickReason: str): ...
	"""Notify client they were kicked from the server"""

	def ClientUpdateMultipleLevelsStreamingStatus(self, LevelStatuses: typing.List[unsupported]): ...
	"""Replicated Update streaming status.  This version allows for the streaming state of many levels to be sent in a single RPC.
@param LevelStatuses The list of levels the client should have either streamed in or not, depending on state."""

	def ClientUpdateLevelStreamingStatus(self, PackageName: str, bNewShouldBeLoaded: bool, bNewShouldBeVisible: bool, bNewShouldBlockOnLoad: bool, LODIndex: int): ...
	"""Replicated Update streaming status
@param PackageName - Name of the level package name used for loading.
@param bNewShouldBeLoaded - Whether the level should be loaded
@param bNewShouldBeVisible - Whether the level should be visible if it is loaded
@param bNewShouldBlockOnLoad - Whether we want to force a blocking load
@param LODIndex                              - Current LOD index for a streaming level"""

	def ClientTravelInternal(self, URL: str, TravelType: int, bSeamless: bool, MapPackageGuid: Guid): ...
	"""Internal clientside implementation of ClientTravel - use ClientTravel to call this

@param URL                           A string containing the mapname (or IP address) to travel to, along with option key/value pairs
@param TravelType            specifies whether the client should append URL options used in previous travels; if true is specified
                                                     for the bSeamlesss parameter, this value must be TRAVEL_Relative.
@param bSeamless                     Indicates whether to use seamless travel (requires TravelType of TRAVEL_Relative)
@param MapPackageGuid        The GUID of the map package to travel to - this is used to find the file when it has been autodownloaded,
                                                     so it is only needed for clients"""

	def ClientTravel(self, URL: str, TravelType: int, bSeamless: bool, MapPackageGuid: Guid): ...
	"""Travel to a different map or IP address. Calls the PreClientTravel event before doing anything.
NOTE: This is implemented as a locally executed wrapper for ClientTravelInternal, to avoid API compatability breakage

@param URL                           A string containing the mapname (or IP address) to travel to, along with option key/value pairs
@param TravelType            specifies whether the client should append URL options used in previous travels; if true is specified
                                                     for the bSeamlesss parameter, this value must be TRAVEL_Relative.
@param bSeamless                     Indicates whether to use seamless travel (requires TravelType of TRAVEL_Relative)
@param MapPackageGuid        The GUID of the map package to travel to - this is used to find the file when it has been autodownloaded,
                                                     so it is only needed for clients"""

	def ResetControllerLightColor(self): ...
	"""Resets the light color of the player's controller to default"""

	def SetControllerLightColor(self, Color: Color): ...
	"""Sets the light color of the player's controller
@param       Color                                   The color for the light to be"""

	def SetDisableHaptics(self, bNewDisabled: bool): ...
	"""Allows the player controller to disable all haptic requests from being fired, e.g. in the case of a level loading

@param       bNewDisabled    If TRUE, the haptics will stop and prevented from being enabled again until set to FALSE"""

	def SetHapticsByValue(self, Frequency: float, Amplitude: float, Hand: int): ...
	"""Sets the value of the haptics for the specified hand directly, using frequency and amplitude.  NOTE:  If a curve is already
playing for this hand, it will be cancelled in favour of the specified values.

@param       Frequency                               The normalized frequency [0.0, 1.0] to play through the haptics system
@param       Amplitude                               The normalized amplitude [0.0, 1.0] to set the haptic feedback to
@param       Hand                                    Which hand to play the effect on"""

	def StopHapticEffect(self, Hand: int): ...
	"""Stops a playing haptic feedback curve
@param       HapticEffect                    The haptic effect to stop
@param       Hand                                    Which hand to stop the effect for"""

	def PlayHapticEffect(self, HapticEffect: HapticFeedbackEffect_Base, Hand: int, Scale: float = ..., bLoop: bool = ...): ...
	"""Play a haptic feedback curve on the player's controller
@param       HapticEffect                    The haptic effect to play
@param       Hand                                    Which hand to play the effect on
@param       Scale                                   Scale between 0.0 and 1.0 on the intensity of playback"""

	def ClientStopForceFeedback(self, ForceFeedbackEffect: ForceFeedbackEffect, Tag: str): ...
	"""Stops a playing force feedback pattern
@param       ForceFeedbackEffect             If set only patterns from that effect will be stopped
@param       Tag                                             If not none only the pattern with this tag will be stopped"""

	def K2_ClientPlayForceFeedback(self, ForceFeedbackEffect: ForceFeedbackEffect, Tag: str, bLooping: bool, bIgnoreTimeDilation: bool, bPlayWhilePaused: bool): ...
	"""Play a force feedback pattern on the player's controller
@param       ForceFeedbackEffect             The force feedback pattern to play
@param       bLooping                                Whether the pattern should be played repeatedly or be a single one shot
@param       bIgnoreTimeDilation             Whether the pattern should ignore time dilation
@param       bPlayWhilePaused                Whether the pattern should continue to play while the game is paused
@param       Tag                                             A tag that allows stopping of an effect.  If another effect with this Tag is playing, it will be stopped and replaced"""

	def ClientStopCameraShakesFromSource(self, SourceComponent: CameraShakeSourceComponent, bImmediately: bool = ...): ...
	"""Stop camera shake on client."""

	def ClientStopCameraShake(self, Shake: CameraShakeBase, bImmediately: bool = ...): ...
	"""Stop camera shake on client."""

	def ClientStopCameraAnim(self, AnimToStop: CameraAnim): ...
	"""Stop camera animation on client."""

	def ClientClearCameraLensEffects(self): ...
	"""Removes all Camera Lens Effects."""

	def ClientSpawnCameraLensEffect(self, LensEffectEmitterClass: EmitterCameraLensEffectBase): ...
	"""Spawn a camera lens effect (e.g. blood)."""

	def ClientSetViewTarget(self, A: Actor, TransitionParams: ViewTargetTransitionParams): ...
	"""Set the view target
@param A - new actor to set as view target
@param TransitionParams - parameters to use for controlling the transition"""

	def SetMouseCursorWidget(self, Cursor: int, CursorWidget: UserWidget): ...
	"""Sets the Widget for the Mouse Cursor to display
@param Cursor - the cursor to set the widget for
@param CursorWidget - the widget to set the cursor to"""

	def GetHUD(self) -> HUD: ...
	"""Gets the HUD currently being used by this player controller"""

	def GetViewportSize(self) -> typing.Tuple[int, int]: ...
	"""Helper to get the size of the HUD canvas for this player controller.  Returns 0 if there is no HUD"""

	def ClientSetHUD(self, NewHUDClass: HUD): ...
	"""Set the client's class of HUD and spawns a new instance of it. If there was already a HUD active, it is destroyed."""

	def ClientSetForceMipLevelsToBeResident(self, Material: MaterialInterface, ForceDuration: float, CinematicTextureGroups: int): ...
	"""Forces the streaming system to disregard the normal logic for the specified duration and
instead always load all mip-levels for all textures used by the specified material.

@param Material              - The material whose textures should be forced into memory.
@param ForceDuration - Number of seconds to keep all mip-levels in memory, disregarding the normal priority logic.
@param CinematicTextureGroups        - Bitfield indicating which texture groups that use extra high-resolution mips"""

	def ClientSetCinematicMode(self, bInCinematicMode: bool, bAffectsMovement: bool, bAffectsTurning: bool, bAffectsHUD: bool): ...
	"""Called by the server to synchronize cinematic transitions with the client"""

	def ClientSetCameraMode(self, NewCamMode: str): ...
	"""Replicated function to set camera style on client
@param       NewCamMode, name defining the new camera mode"""

	def ClientSetCameraFade(self, bEnableFading: bool, FadeColor: Color, FadeAlpha: Vector2D, FadeTime: float, bFadeAudio: bool, bHoldWhenFinished: bool): ...
	"""Tell client to fade camera
@Param bEnableFading - true if we should apply FadeColor/FadeAmount to the screen
@Param FadeColor - Color to fade to
@Param FadeAlpha - Contains the start fade (X) and end fade (Y) values to apply. A start fade of less than 0 will use the screen's current fade value
@Param FadeTime - length of time for fade to occur over
@Param bFadeAudio - true to apply fading of audio alongside the video
@param bHoldWhenFinished - True for fade to hold at the ToAlpha until fade is disabled"""

	def ClientSetBlockOnAsyncLoading(self): ...
	"""Tells the client to block until all pending level streaming actions are complete.
Happens at the end of the tick primarily used to force update the client ASAP at join time."""

	def ClientRestart(self, NewPawn: Pawn): ...
	"""Tell client to restart the level"""

	def ClientReset(self): ...
	"""Tell client to reset the PlayerController"""

	def ClientPrestreamTextures(self, ForcedActor: Actor, ForceDuration: float, bEnableStreaming: bool, CinematicTextureGroups: int): ...
	"""Forces the streaming system to disregard the normal logic for the specified duration and
instead always load all mip-levels for all textures used by the specified actor.
@param ForcedActor           - The actor whose textures should be forced into memory.
@param ForceDuration         - Number of seconds to keep all mip-levels in memory, disregarding the normal priority logic.
@param bEnableStreaming      - Whether to start (true) or stop (false) streaming
@param CinematicTextureGroups        - Bitfield indicating which texture groups that use extra high-resolution mips"""

	def ClientPrepareMapChange(self, LevelName: str, bFirst: bool, bLast: bool): ...
	"""Asynchronously loads the given level in preparation for a streaming map transition.
the server sends one function per level name since dynamic arrays can't be replicated
@param LevelNames - the names of the level packages to load. LevelNames[0] will be the new persistent (primary) level
@param bFirst - whether this is the first item in the list (so clear the list first)
@param bLast - whether this is the last item in the list (so start preparing the change after receiving it)"""

	def ClientPlaySoundAtLocation(self, Sound: SoundBase, Location: Vector, VolumeMultiplier: float, PitchMultiplier: float): ...
	"""Play sound client-side at the specified location
@param Sound - Sound to play
@param Location - Location to play the sound at
@param VolumeMultiplier - Volume multiplier to apply to the sound
@param PitchMultiplier - Pitch multiplier to apply to the sound"""

	def ClientPlaySound(self, Sound: SoundBase, VolumeMultiplier: float, PitchMultiplier: float): ...
	"""Play sound client-side (so only the client will hear it)
@param Sound - Sound to play
@param VolumeMultiplier - Volume multiplier to apply to the sound
@param PitchMultiplier - Pitch multiplier to apply to the sound"""

	def ClientStartCameraShakeFromSource(self, Shake: CameraShakeBase, SourceComponent: CameraShakeSourceComponent): ...
	"""Play Camera Shake localized to a given source
@param Shake - Camera shake animation to play
@param SourceComponent - The source from which the camera shakes originates"""

	def ClientStartCameraShake(self, Shake: CameraShakeBase, Scale: float = ..., PlaySpace: int = ..., UserPlaySpaceRot: Rotator = ...): ...
	"""Play Camera Shake
@param Shake - Camera shake animation to play
@param Scale - Scalar defining how 'intense' to play the anim
@param PlaySpace - Which coordinate system to play the shake in (used for CameraAnims within the shake).
@param UserPlaySpaceRot - Matrix used when PlaySpace = CAPS_UserDefined"""

	def ClientPlayCameraAnim(self, AnimToPlay: CameraAnim, Scale: float = ..., Rate: float = ..., BlendInTime: float = ..., BlendOutTime: float = ..., bLoop: bool = ..., bRandomStartTime: bool = ..., Space: int = ..., CustomPlaySpace: Rotator = ...): ...
	"""Play the indicated CameraAnim on this camera.
@param AnimToPlay - Camera animation to play
@param Scale - 'Intensity' scalar.  This is the scale at which the anim was first played.
@param Rate -  Multiplier for playback rate.  1.0 = normal.
@param BlendInTime - Time to interpolate in from zero, for smooth starts
@param BlendOutTime - Time to interpolate out to zero, for smooth finishes
@param bLoop - True if the animation should loop, false otherwise
@param bRandomStartTime - Whether or not to choose a random time to start playing.  Only really makes sense for bLoop = true
@param Space - Animation play area
@param CustomPlaySpace - Matrix used when Space = CAPS_UserDefined"""

	def ClientMessage(self, S: str, Type: str, MsgLifeTime: float): ...
	"""Outputs a message to HUD
@param S - message to display
@param Type - @todo document
@param MsgLifeTime - Optional length of time to display 0 = default time"""

	def ClientIgnoreMoveInput(self, bIgnore: bool): ...
	"""Calls IgnoreMoveInput on client"""

	def ClientIgnoreLookInput(self, bIgnore: bool): ...
	"""Calls IgnoreLookInput on client"""

	def ClientGotoState(self, NewState: str): ...
	"""Server uses this to force client into NewState .
@Note ALL STATE NAMES NEED TO BE DEFINED IN name table in UnrealNames.h to be correctly replicated (so they are mapped to the same thing on client and server)."""

	def ClientGameEnded(self, EndGameFocus: Actor, bIsWinner: bool): ...
	"""Replicated function called by GameHasEnded().
@param       EndGameFocus - actor to view with camera
@param       bIsWinner - true if this controller is on winning team"""

	def ClientForceGarbageCollection(self): ...
	"""Forces GC at the end of the tick on the client"""

	def ClientFlushLevelStreaming(self): ...
	"""Tells the client to block until all pending level streaming actions are complete
happens at the end of the tick
primarily used to force update the client ASAP at join time"""

	def ClientCommitMapChange(self): ...
	"""Actually performs the level transition prepared by PrepareMapChange()."""

	def ClientCapBandwidth(self, Cap: int): ...
	"""Set CurrentNetSpeed to the lower of its current value and Cap."""

	def ClientCancelPendingMapChange(self): ...
	"""Tells client to cancel any pending map change."""

	def ClientAddTextureStreamingLoc(self, InLoc: Vector, Duration: float, bOverrideLocation: bool): ...
	"""Adds a location to the texture streaming system for the specified duration."""

	def SendToConsole(self, Command: str): ...
	"""Sends a command to the console to execute if not shipping version"""

	def ConsoleKey(self, Key: Key): ...
	"""Console control commands, useful when remote debugging so you can't touch the console the normal way"""

	def ClientUnmutePlayer(self, PlayerId: UniqueNetIdRepl): ...
	"""Tell the client to unmute a player for this controller
@param PlayerId player id to unmute"""

	def ClientMutePlayer(self, PlayerId: UniqueNetIdRepl): ...
	"""Tell the client to mute a player for this controller
@param PlayerId player id to mute"""

	def ClientVoiceHandshakeComplete(self): ...
	"""Tells the client that the server has all the information it needs and that it
is ok to start sending voice packets. The server will already send voice packets
when this function is called, since it is set server side and then forwarded

NOTE: This is done as an RPC instead of variable replication because ordering matters"""

	def ToggleSpeaking(self, bInSpeaking: bool): ...
	"""Toggle voice chat on and off
@param bSpeaking enable or disable voice chat"""

	def ClientEnableNetworkVoice(self, bEnable: bool): ...
	"""Tell the client to enable or disable voice chat (not muting)
@param bEnable enable or disable voice chat"""

	def StartFire(self, FireModeNum: int = ...): ...
	"""Fire the player's currently selected weapon with the optional firemode."""

	def SetMouseLocation(self, X: int, Y: int): ...
	"""Positions the mouse cursor in screen space, in pixels."""

	def ProjectWorldLocationToScreen(self, WorldLocation: Vector, bPlayerViewportRelative: bool = ...) -> typing.Tuple[bool, Vector2D]: ...
	"""Convert a World Space 3D position into a 2D Screen Space position.
@return true if the world coordinate was successfully projected to the screen."""

	def DeprojectScreenPositionToWorld(self, ScreenX: float, ScreenY: float) -> typing.Tuple[bool, Vector, Vector]: ...
	"""Convert 2D screen position to World Space 3D position and direction. Returns false if unable to determine value. *"""

	def DeprojectMousePositionToWorld(self) -> typing.Tuple[bool, Vector, Vector]: ...
	"""Convert current mouse 2D position to World Space 3D position and direction. Returns false if unable to determine value. *"""

	def GetHitResultUnderFingerForObjects(self, FingerIndex: int, ObjectTypes: typing.List[int], bTraceComplex: bool) -> typing.Tuple[bool, HitResult]: ...
	"""Performs a collision query under the finger, looking for object types"""

	def GetHitResultUnderFingerByChannel(self, FingerIndex: int, TraceChannel: int, bTraceComplex: bool) -> typing.Tuple[bool, HitResult]: ...
	"""Performs a collision query under the finger, looking on a trace channel"""

	def GetHitResultUnderCursorForObjects(self, ObjectTypes: typing.List[int], bTraceComplex: bool) -> typing.Tuple[bool, HitResult]: ...
	"""Performs a collision query under the mouse cursor, looking for object types"""

	def GetHitResultUnderCursorByChannel(self, TraceChannel: int, bTraceComplex: bool) -> typing.Tuple[bool, HitResult]: ...
	"""Performs a collision query under the mouse cursor, looking on a trace channel"""

	def SwitchLevel(self, URL: str): ...
	"""SwitchLevel to the given MapURL."""

	def SetName(self, S: str): ...
	"""Tries to set the player's name to the given name."""

	def Pause(self): ...
	"""Command to try to pause the game."""

	def ClientRepObjRef(self, Object: Object): ...
	"""Development RPC for testing object reference replication"""

	def ClientReturnToMainMenuWithTextReason(self, ReturnReason: str): ...
	"""Return the client to the main menu gracefully"""

	def ClientReturnToMainMenu(self, ReturnReason: str): ...
	"""Client Return to Main Menu"""

	def ServerExec(self, Msg: str): ...
	"""Executes command on server (non shipping builds only)"""

	def LocalTravel(self, URL: str): ...
	"""Causes the client to travel to the given URL"""

	def RestartLevel(self): ...
	"""Restarts the current level"""

	def FOV(self, NewFOV: float): ...
	"""Set the field of view to NewFOV"""

	def EnableCheats(self): ...
	"""Enables cheats within the game"""

	def ClientSetSpectatorWaiting(self, bWaiting: bool): ...
	"""Indicate that the Spectator is waiting to join/respawn."""

	pass

class DebugCameraController(PlayerController):
	"""Camera controller that allows you to fly around a level mostly unrestricted by normal movement rules.

To turn it on, please press Alt+C or both (left and right) analogs on XBox pad,
or use the 'ToggleDebugCamera' console command. Check the debug camera bindings
in DefaultPawn.cpp for the camera controls."""

	@property
	def bShowSelectedInfo(self) -> bool: ...
	"""Whether to show information about the selected actor on the debug camera HUD."""

	@property
	def bIsFrozenRendering(self) -> bool: ...
	"""Saves whether the FreezeRendering console command is active"""

	@property
	def bIsOrbitingSelectedActor(self) -> bool: ...
	"""Whether to orbit selected actor."""

	@property
	def bOrbitPivotUseCenter(self) -> bool: ...
	"""When orbiting, true if using actor center as pivot, false if using last selected hitpoint"""

	@property
	def bEnableBufferVisualization(self) -> bool: ...
	"""Whether set view mode to display GBuffer visualization overview"""

	@property
	def bEnableBufferVisualizationFullMode(self) -> bool: ...
	"""Whether set view mode to display GBuffer visualization full"""

	@property
	def bIsBufferVisualizationInputSetup(self) -> bool: ...
	"""Whether GBuffer visualization overview inputs are set up"""

	@property
	def bLastDisplayEnabled(self) -> bool: ...
	"""Last display enabled setting before toggling buffer visualization overview"""

	@property
	def DrawFrustum(self) -> DrawFrustumComponent: ...
	"""Visualizes the frustum of the camera"""

	@property
	def SelectedActor(self) -> Actor: ...
	"""Currently selected actor, may be invalid"""

	@property
	def SelectedComponent(self) -> PrimitiveComponent: ...
	"""Currently selected component, may be invalid"""

	@property
	def SelectedHitPoint(self) -> HitResult: ...
	"""Selected hit point"""

	@property
	def OriginalControllerRef(self) -> PlayerController: ...
	"""Controller that was active before this was spawned"""

	@property
	def OriginalPlayer(self) -> typing.Any: ...
	"""Player object that was active before this was spawned"""

	@property
	def SpeedScale(self) -> float: ...
	"""Allows control over the speed of the spectator pawn. This scales the speed based on the InitialMaxSpeed. Use Set Pawn Movement Speed Scale during runtime"""

	@property
	def InitialMaxSpeed(self) -> float: ...
	"""Initial max speed of the spectator pawn when we start possession."""

	@property
	def InitialAccel(self) -> float: ...
	"""Initial acceleration of the spectator pawn when we start possession."""

	@property
	def InitialDecel(self) -> float: ...
	"""Initial deceleration of the spectator pawn when we start possession."""

	def SetPawnMovementSpeedScale(self, NewSpeedScale: float): ...
	"""Sets the pawn movement speed scale."""

	def GetSelectedActor(self) -> Actor: ...
	"""Returns the currently selected actor, or null if it is invalid or not set"""

	def ToggleDisplay(self): ...
	"""Toggles the display of debug info and input commands for the Debug Camera."""

	def ShowDebugSelectedInfo(self): ...
	"""Sets whether to show information about the selected actor on the debug camera HUD.t"""

	pass

class HUD(Actor):
	"""Base class of the heads-up display. This has a canvas and a debug canvas on which primitives can be drawn.
It also contains a list of simple hit boxes that can be used for simple item click detection.
A method of rendering debug text is also included.
Provides some simple methods for rendering text, textures, rectangles and materials which can also be accessed from blueprints.
See: UCanvas
See: FHUDHitBox
See: FDebugTextInfo"""

	@property
	def PlayerOwner(self) -> PlayerController: ...
	"""PlayerController which owns this HUD."""

	@property
	def bLostFocusPaused(self) -> bool: ...
	"""Tells whether the game was paused due to lost focus"""

	@property
	def bShowHUD(self) -> bool: ...
	"""Whether or not the HUD should be drawn."""

	@property
	def bShowDebugInfo(self) -> bool: ...
	"""If true, current ViewTarget shows debug information using its DisplayDebug()."""

	@property
	def CurrentTargetIndex(self) -> int: ...
	"""Current target in our considered Targets list for 'showdebug'"""

	@property
	def bShowHitBoxDebugInfo(self) -> bool: ...
	"""If true, show hitbox debugging info."""

	@property
	def bShowOverlays(self) -> bool: ...
	"""If true, render actor overlays."""

	@property
	def bEnableDebugTextShadow(self) -> bool: ...
	"""Put shadow on debug strings"""

	@property
	def PostRenderedActors(self) -> typing.List[Actor]: ...
	"""Holds a list of Actors that need PostRender() calls."""

	@property
	def DebugDisplay(self) -> typing.List[str]: ...
	"""Array of names specifying what debug info to display for viewtarget actor."""

	@property
	def ToggledDebugCategories(self) -> typing.List[str]: ...
	"""Array of names specifying what subsets of debug info to display for viewtarget actor."""

	def PreviousDebugTarget(self): ...
	"""Cycle to previous target in our considered targets list for 'showdebug'"""

	def NextDebugTarget(self): ...
	"""Cycle to next target in our considered targets list for 'showdebug'"""

	def GetOwningPawn(self) -> Pawn: ...
	"""Returns the Pawn for this HUD's player."""

	def GetOwningPlayerController(self) -> PlayerController: ...
	"""Returns the PlayerController for this HUD's player."""

	def AddHitBox(self, Position: Vector2D, Size: Vector2D, InName: str, bConsumesInput: bool, Priority: int = ...): ...
	"""Add a hitbox to the hud
@param Position                      Coordinates of the top left of the hit box.
@param Size                          Size of the hit box.
@param Name                          Name of the hit box.
@param bConsumesInput        Whether click processing should continue if this hit box is clicked.
@param Priority                      The priority of the box used for layering. Larger values are considered first.  Equal values are considered in the order they were added."""

	def GetActorsInSelectionRectangle(self, ClassFilter: Actor, FirstPoint: Vector2D, SecondPoint: Vector2D, bIncludeNonCollidingComponents: bool = ..., bActorMustBeFullyEnclosed: bool = ...) -> typing.List[Actor]: ...
	"""Returns the array of actors inside a selection rectangle, with a class filter.

Sample usage:

      TArray<AStaticMeshActor*> ActorsInSelectionRect;
             Canvas->GetActorsInSelectionRectangle<AStaticMeshActor>(FirstPoint,SecondPoint,ActorsInSelectionRect);


@param FirstPoint                                    The first point, or anchor of the marquee box. Where the dragging of the marquee started in screen space.
@param SecondPoint                                   The second point, where the mouse cursor currently is / the other point of the box selection, in screen space.
@return OutActors                                    The actors that are within the selection box according to selection rule
@param bIncludeNonCollidingComponents        Whether to include even non-colliding components of the actor when determining its bounds
@param bActorMustBeFullyEnclosed     The Selection rule: whether the selection box can partially intersect Actor, or must fully enclose the Actor."""

	def Deproject(self, ScreenX: float, ScreenY: float) -> typing.Tuple[Vector, Vector]: ...
	"""Transforms a 2D screen location into a 3D location and direction"""

	def Project(self, Location: Vector) -> Vector: ...
	"""Transforms a 3D world-space vector into 2D screen coordinates"""

	def DrawMaterialTriangle(self, Material: MaterialInterface, V0_Pos: Vector2D, V1_Pos: Vector2D, V2_Pos: Vector2D, V0_UV: Vector2D, V1_UV: Vector2D, V2_UV: Vector2D, V0_Color: LinearColor = ..., V1_Color: LinearColor = ..., V2_Color: LinearColor = ...): ...
	"""Draw Material Triangle"""

	def DrawMaterialSimple(self, Material: MaterialInterface, ScreenX: float, ScreenY: float, ScreenW: float, ScreenH: float, Scale: float = ..., bScalePosition: bool = ...): ...
	"""Draws a material-textured quad on the HUD.  Assumes UVs such that the entire material is shown.
@param Material                      Material to use
@param ScreenX                       Screen-space X coordinate of upper left corner of the quad.
@param ScreenY                       Screen-space Y coordinate of upper left corner of the quad.
@param ScreenW                       Screen-space width of the quad (in pixels).
@param ScreenH                       Screen-space height of the quad (in pixels).
@param Scale                         Amount to scale the entire texture (horizontally and vertically)
@param bScalePosition        Whether the 'Scale' parameter should also scale the position of this draw call."""

	def DrawMaterial(self, Material: MaterialInterface, ScreenX: float, ScreenY: float, ScreenW: float, ScreenH: float, MaterialU: float, MaterialV: float, MaterialUWidth: float, MaterialVHeight: float, Scale: float = ..., bScalePosition: bool = ..., Rotation: float = ..., RotPivot: Vector2D = ...): ...
	"""Draws a material-textured quad on the HUD.
@param Material                      Material to use
@param ScreenX                       Screen-space X coordinate of upper left corner of the quad.
@param ScreenY                       Screen-space Y coordinate of upper left corner of the quad.
@param ScreenW                       Screen-space width of the quad (in pixels).
@param ScreenH                       Screen-space height of the quad (in pixels).
@param MaterialU                     Texture-space U coordinate of upper left corner of the quad
@param MaterialV                     Texture-space V coordinate of upper left corner of the quad.
@param MaterialUWidth        Texture-space width of the quad (in normalized UV distance).
@param MaterialVHeight       Texture-space height of the quad (in normalized UV distance).
@param Scale                         Amount to scale the entire texture (horizontally and vertically)
@param bScalePosition        Whether the 'Scale' parameter should also scale the position of this draw call.
@param Rotation                      Amount to rotate this quad
@param RotPivot                      Location (as proportion of quad, 0-1) to rotate about"""

	def DrawTextureSimple(self, Texture: Texture, ScreenX: float, ScreenY: float, Scale: float = ..., bScalePosition: bool = ...): ...
	"""Draws a textured quad on the HUD. Assumes 1:1 texel density.
@param Texture                       Texture to draw.
@param ScreenX                       Screen-space X coordinate of upper left corner of the quad.
@param ScreenY                       Screen-space Y coordinate of upper left corner of the quad.
@param Scale                         Scale multiplier to control size of the text.
@param bScalePosition        Whether the 'Scale' parameter should also scale the position of this draw call."""

	def DrawTexture(self, Texture: Texture, ScreenX: float, ScreenY: float, ScreenW: float, ScreenH: float, TextureU: float, TextureV: float, TextureUWidth: float, TextureVHeight: float, TintColor: LinearColor = ..., BlendMode: int = ..., Scale: float = ..., bScalePosition: bool = ..., Rotation: float = ..., RotPivot: Vector2D = ...): ...
	"""Draws a textured quad on the HUD.
@param Texture                       Texture to draw.
@param ScreenX                       Screen-space X coordinate of upper left corner of the quad.
@param ScreenY                       Screen-space Y coordinate of upper left corner of the quad.
@param ScreenW                       Screen-space width of the quad (in pixels).
@param ScreenH                       Screen-space height of the quad (in pixels).
@param TextureU                      Texture-space U coordinate of upper left corner of the quad
@param TextureV                      Texture-space V coordinate of upper left corner of the quad.
@param TextureUWidth         Texture-space width of the quad (in normalized UV distance).
@param TextureVHeight        Texture-space height of the quad (in normalized UV distance).
@param TintColor                     Vertex color for the quad.
@param BlendMode                     Controls how to blend this quad with the scene. Translucent by default.
@param Scale                         Amount to scale the entire texture (horizontally and vertically)
@param bScalePosition        Whether the 'Scale' parameter should also scale the position of this draw call.
@param Rotation                      Amount to rotate this quad
@param RotPivot                      Location (as proportion of quad, 0-1) to rotate about"""

	def DrawRect(self, RectColor: LinearColor, ScreenX: float, ScreenY: float, ScreenW: float, ScreenH: float): ...
	"""Draws a colored untextured quad on the HUD.
@param RectColor                     Color of the rect. Can be translucent.
@param ScreenX                       Screen-space X coordinate of upper left corner of the quad.
@param ScreenY                       Screen-space Y coordinate of upper left corner of the quad.
@param ScreenW                       Screen-space width of the quad (in pixels).
@param ScreenH                       Screen-space height of the quad (in pixels)."""

	def DrawLine(self, StartScreenX: float, StartScreenY: float, EndScreenX: float, EndScreenY: float, LineColor: LinearColor, LineThickness: float = ...): ...
	"""Draws a 2D line on the HUD.
@param StartScreenX          Screen-space X coordinate of start of the line.
@param StartScreenY          Screen-space Y coordinate of start of the line.
@param EndScreenX            Screen-space X coordinate of end of the line.
@param EndScreenY            Screen-space Y coordinate of end of the line.
@param LineColor                     Color to draw line
@param LineThickness         Thickness of the line to draw"""

	def DrawText(self, Text: str, TextColor: LinearColor, ScreenX: float, ScreenY: float, Font: Font = ..., Scale: float = ..., bScalePosition: bool = ...): ...
	"""Draws a string on the HUD.
@param Text                          String to draw
@param TextColor                     Color to draw string
@param ScreenX                       Screen-space X coordinate of upper left corner of the string.
@param ScreenY                       Screen-space Y coordinate of upper left corner of the string.
@param Font                          Font to draw text.  If NULL, default font is chosen.
@param Scale                         Scale multiplier to control size of the text.
@param bScalePosition        Whether the 'Scale' parameter should also scale the position of this draw call."""

	def GetTextSize(self, Text: str, Font: Font = ..., Scale: float = ...) -> typing.Tuple[float, float]: ...
	"""Returns the width and height of a string.
@param Text                          String to draw
@param OutWidth                      Returns the width in pixels of the string.
@param OutHeight                     Returns the height in pixels of the string.
@param Font                          Font to draw text.  If NULL, default font is chosen.
@param Scale                         Scale multiplier to control size of the text."""

	def RemoveDebugText(self, SrcActor: Actor, bLeaveDurationText: bool): ...
	"""Remove debug strings for the given actor

@param       SrcActor                        Actor whose string you wish to remove
@param       bLeaveDurationText      when true text that has a finite duration will be removed, otherwise all will be removed for given actor"""

	def RemoveAllDebugStrings(self): ...
	"""Remove all debug strings added via AddDebugText"""

	def AddDebugText(self, DebugText: str, SrcActor: Actor, Duration: float, Offset: Vector, DesiredOffset: Vector, TextColor: Color, bSkipOverwriteCheck: bool, bAbsoluteLocation: bool, bKeepAttachedToActor: bool, InFont: Font, FontScale: float, bDrawShadow: bool): ...
	"""Add debug text for a specific actor to be displayed via DrawDebugTextList().  If the debug text is invalid then it will
attempt to remove any previous entries via RemoveDebugText().

@param DebugText                             Text to draw
@param SrcActor                              Actor to which this relates
@param Duration                              Duration to display the string
@param Offset                                Initial offset to render text
@param DesiredOffset                 Desired offset to render text - the text will move to this location over the given duration
@param TextColor                     Color of text to render
@param bSkipOverwriteCheck   skips the check to see if there is already debug text for the given actor
@param bAbsoluteLocation     use an absolute world location
@param bKeepAttachedToActor  if this is true the text will follow the actor, otherwise it will be drawn at the location when the call was made
@param InFont                                font to use
@param FontScale                     scale
@param bDrawShadow                   Draw shadow on this string"""

	def ShowDebugForReticleTargetToggle(self, DesiredClass: Actor): ...
	"""Toggles 'ShowDebug' from showing debug info between reticle target actor (of subclass <DesiredClass>) and camera view target"""

	def ShowDebugToggleSubCategory(self, Category: str): ...
	"""Toggles sub categories of show debug to customize display"""

	def ShowDebug(self, DebugType: str = ...): ...
	"""Toggles displaying properties of player's current ViewTarget
DebugType input values supported by base engine include 'AI', 'physics', 'net', 'camera', and 'collision'"""

	def ShowHUD(self): ...
	"""hides or shows HUD"""

	pass

class DebugCameraHUD(HUD):
	"""HUD that displays info for the DebugCameraController view."""

	pass

class DecalActor(Actor):
	"""DecalActor contains a DecalComponent which can be used to render material modifications on top of existing geometry.

See: https://docs.unrealengine.com/latest/INT/Engine/Actors/DecalActor
See: UDecalComponent"""

	pass

class Light(Actor):
	"""Light"""

	@property
	def bEnabled(self) -> bool: ...
	"""replicated copy of LightComponent's bEnabled property"""

	def OnRep_bEnabled(self): ...
	"""Replication Notification Callbacks"""

	pass

class DirectionalLight(Light):
	"""Implements a directional light actor."""

	pass

class DocumentationActor(Actor):
	"""Documentation Actor"""

	pass

class ExponentialHeightFog(Info):
	"""Implements an Actor for exponential height fog."""

	@property
	def bEnabled(self) -> bool: ...
	"""replicated copy of ExponentialHeightFogComponent's bEnabled property"""

	def OnRep_bEnabled(self): ...
	"""Replication Notification Callbacks"""

	pass

class Font(Object):
	"""A font object, for use by Slate, UMG, and Canvas.

A font can either be:
  * Runtime cached - The font contains a series of TTF files that combine to form a composite font. The glyphs are cached on demand when required at runtime.
  * Offline cached - The font contains a series of textures containing pre-baked cached glyphs and their associated texture coordinates."""

	@property
	def FontCacheType(self) -> int: ...
	"""What kind of font caching should we use? This controls which options we see"""

	@property
	def Characters(self) -> typing.List[unsupported]: ...
	"""List of characters in the font.  For a MultiFont, this will include all characters in all sub-fonts!  Thus,
              the number of characters in this array isn't necessary the number of characters available in the font"""

	@property
	def Textures(self) -> typing.List[Texture2D]: ...
	"""Textures that store this font's glyph image data //NOTE: Do not expose this to the editor as it has nasty crash potential"""

	@property
	def IsRemapped(self) -> int: ...
	"""True if font is 'remapped'.  That is, the character array is not a direct mapping to unicode values.  Instead,
              all characters are indexed indirectly through the CharRemap array"""

	@property
	def EmScale(self) -> float: ...
	"""Font metrics."""

	@property
	def Ascent(self) -> float: ...
	"""@todo document"""

	@property
	def Descent(self) -> float: ...
	"""@todo document"""

	@property
	def Leading(self) -> float: ...
	"""@todo document"""

	@property
	def Kerning(self) -> int: ...
	"""Default horizontal spacing between characters when rendering text with this font"""

	@property
	def ImportOptions(self) -> typing.Any: ...
	"""Options used when importing this font"""

	@property
	def NumCharacters(self) -> int: ...
	"""Number of characters in the font, not including multiple instances of the same character (for multi-fonts).
              This is cached at load-time or creation time, and is never serialized."""

	@property
	def MaxCharHeight(self) -> typing.List[int]: ...
	"""The maximum height of a character in this font.  For multi-fonts, this array will contain a maximum
              character height for each multi-font, otherwise the array will contain only a single element.  This is
              cached at load-time or creation time, and is never serialized."""

	@property
	def ScalingFactor(self) -> float: ...
	"""Scale to apply to the font."""

	@property
	def LegacyFontSize(self) -> int: ...
	"""The default size of the font used for legacy Canvas APIs that don't specify a font size"""

	@property
	def LegacyFontName(self) -> str: ...
	"""The default font name to use for legacy Canvas APIs that don't specify a font name"""

	@property
	def CompositeFont(self) -> typing.Any: ...
	"""Embedded composite font data"""

	pass

class FontFace(Object):
	"""A font face asset contains the raw payload data for a source TTF/OTF file as used by FreeType.
During cook this asset type generates a '.ufont' file containing the raw payload data (unless loaded 'Inline')."""

	@property
	def SourceFilename(self) -> str: ...
	"""The filename of the font face we were created from. This may not always exist on disk, as we may have previously loaded and cached the font data inside this asset."""

	@property
	def Hinting(self) -> int: ...
	"""The hinting algorithm to use with the font face."""

	@property
	def LoadingPolicy(self) -> int: ...
	"""Enum controlling how this font face should be loaded at runtime. See the enum for more explanations of the options."""

	@property
	def LayoutMethod(self) -> int: ...
	"""Which method should we use when laying out the font? Try changing this if you notice clipping or height issues with your font."""

	pass

class GameInstance(Object):
	"""GameInstance: high-level manager object for an instance of the running game.
Spawned at game creation and not destroyed until game instance is shut down.
Running as a standalone game, there will be one of these.
Running in PIE (play-in-editor) will generate one of these per PIE instance."""

	def DebugRemovePlayer(self, ControllerId: int): ...
	"""Debug console command to remove the player with a given controller ID.
@param ControllerId - The controller ID to search for."""

	def DebugCreatePlayer(self, ControllerId: int): ...
	"""Debug console command to create a player.
@param ControllerId - The controller ID the player should accept input from."""

	def GetPyProxy(self) -> object: ...

	def GetWorld(self) -> World: ...

	pass

class SpotLight(Light):
	"""Spot Light"""

	@property
	def SpotLightComponent(self) -> SpotLightComponent: ...
	"""Spot Light Component"""

	pass

class GeneratedMeshAreaLight(SpotLight):
	"""Implements a light that is created after a lighting build with Lightmass and handles mesh area light influence on dynamic objects."""

	pass

class LevelBounds(Actor):
	"""Defines level bounds
Updates bounding box automatically based on actors transformation changes or holds fixed user defined bounding box
Uses only actors where AActor::IsLevelBoundsRelevant() == true"""

	@property
	def BoxComponent(self) -> BoxComponent: ...
	"""Bounding box for the level bounds."""

	@property
	def bAutoUpdateBounds(self) -> bool: ...
	"""Whether to automatically update actor bounds based on all relevant actors bounds belonging to the same level"""

	pass

class LevelScriptActor(Actor):
	"""ALevelScriptActor is the base class for classes generated by
ULevelScriptBlueprints. ALevelScriptActor instances are hidden actors that
exist within a level, and can execute level-wide logic (operating on specific
actor instances within the level). The level-script's functionality is defined
inside the ULevelScriptBlueprint itself (using the blueprint's node-based
interface).

See: AActor
See: https://docs.unrealengine.com/latest/INT/Engine/Blueprints/UserGuide/Types/LevelBlueprint/index.html
See: ULevelScriptBlueprint
See: https://docs.unrealengine.com/latest/INT/Engine/Blueprints/index.html
See: UBlueprint"""

	def SetCinematicMode(self, bCinematicMode: bool, bHidePlayer: bool = ..., bAffectsHUD: bool = ..., bAffectsMovement: bool = ..., bAffectsTurning: bool = ...): ...
	"""Sets the cinematic mode on all PlayerControllers

@param       bInCinematicMode        specify true if the player is entering cinematic mode; false if the player is leaving cinematic mode.
@param       bHidePlayer                     specify true to hide the player's pawn (only relevant if bInCinematicMode is true)
@param       bAffectsHUD                     specify true if we should show/hide the HUD to match the value of bCinematicMode
@param       bAffectsMovement        specify true to disable movement in cinematic mode, enable it when leaving
@param       bAffectsTurning         specify true to disable turning in cinematic mode or enable it when leaving"""

	def RemoteEvent(self, EventName: str) -> bool: ...
	"""Tries to find an event named 'EventName' on all other levels, and calls it"""

	pass

class LevelStreaming(Object):
	"""Abstract base class of container object encapsulating data required for streaming and providing
interface for when a level should be streamed in and out of memory."""

	@property
	def PackageNameToLoad(self) -> str: ...
	"""If this isn't Name_None, then we load from this package on disk to the new package named PackageName"""

	@property
	def LODPackageNames(self) -> typing.List[str]: ...
	"""LOD versions of this level"""

	@property
	def LevelTransform(self) -> Transform: ...
	"""Transform applied to actors after loading."""

	@property
	def bLocked(self) -> bool: ...
	"""Whether this level is locked; that is, its actors are read-only."""

	@property
	def bIsStatic(self) -> bool: ...
	"""Whether this level only contains static actors that aren't affected by gameplay or replication.
If true, the engine can make certain optimizations and will add this level to the StaticLevels collection."""

	@property
	def bShouldBlockOnLoad(self) -> bool: ...
	"""Whether we want to force a blocking load"""

	@property
	def bShouldBlockOnUnload(self) -> bool: ...
	"""Whether we want to force a blocking unload"""

	@property
	def bDisableDistanceStreaming(self) -> bool: ...
	"""Whether this level streaming object should be ignored by world composition distance streaming,
so streaming state can be controlled by other systems (ex: in blueprints)"""

	@property
	def bDrawOnLevelStatusMap(self) -> bool: ...
	"""If true, will be drawn on the 'level streaming status' map (STAT LEVELMAP console command)"""

	@property
	def LevelColor(self) -> LinearColor: ...
	"""The level color used for visualization. (Show -> Advanced -> Level Coloration)"""

	@property
	def EditorStreamingVolumes(self) -> typing.List[LevelStreamingVolume]: ...
	"""The level streaming volumes bound to this level."""

	@property
	def MinTimeBetweenVolumeUnloadRequests(self) -> float: ...
	"""Cooldown time in seconds between volume-based unload requests.  Used in preventing spurious unload requests."""

	@property
	def OnLevelLoaded(self) -> typing.Any: ...
	"""Called when level is streamed in"""

	@property
	def OnLevelUnloaded(self) -> typing.Any: ...
	"""Called when level is streamed out"""

	@property
	def OnLevelShown(self) -> typing.Any: ...
	"""Called when level is added to the world"""

	@property
	def OnLevelHidden(self) -> typing.Any: ...
	"""Called when level is removed from the world"""

	def GetLevelScriptActor(self) -> LevelScriptActor: ...
	"""Returns the Level Script Actor of the level if the level is loaded and valid"""

	def CreateInstance(self, UniqueInstanceName: str) -> LevelStreaming: ...
	"""Creates a new instance of this streaming level with a provided unique instance name"""

	def IsStreamingStatePending(self) -> bool: ...
	"""Returns whether level has streaming state change pending"""

	def IsLevelLoaded(self) -> bool: ...
	"""Returns whether streaming level is loaded"""

	def IsLevelVisible(self) -> bool: ...
	"""Returns whether streaming level is visible"""

	def GetLoadedLevel(self) -> typing.Any: ...
	"""Gets a pointer to the LoadedLevel value"""

	def ShouldBeLoaded(self) -> bool: ...
	"""Return whether this level should be present in memory which in turn tells the
streaming code to stream it in. Please note that a change in value from false
to true only tells the streaming code that it needs to START streaming it in
so the code needs to return true an appropriate amount of time before it is
needed.

@return true if level should be loaded/ streamed in, false otherwise"""

	def GetWorldAssetPackageFName(self) -> str: ...
	"""Gets the package name for the world asset referred to by this level streaming as an FName"""

	def SetIsRequestingUnloadAndRemoval(self, bInIsRequestingUnloadAndRemoval: bool): ...
	"""Sets if the streaming level should be unloaded and removed."""

	def GetIsRequestingUnloadAndRemoval(self) -> bool: ...
	"""Returns if the streaming level has requested to be unloaded and removed."""

	def SetPriority(self, NewPriority: int): ...
	"""Sets the relative priority of considering the streaming level. Changing the priority will not interrupt the currently considered level, but will affect the next time a level is being selected for evaluation."""

	def SetLevelLODIndex(self, LODIndex: int): ...
	"""Sets the world composition level LOD index and marks the streaming level as requiring consideration."""

	def SetShouldBeLoaded(self, bInShouldBeLoaded: bool): ...
	"""Virtual that can be overriden to change whether a streaming level should be loaded.
Doesn't do anything at the base level as should be loaded defaults to true"""

	def SetShouldBeVisible(self, bInShouldBeVisible: bool): ...
	"""Sets the should be visible flag and marks the streaming level as requiring consideration."""

	pass

class LevelStreamingAlwaysLoaded(LevelStreaming):
	"""Level Streaming Always Loaded"""

	pass

class LevelStreamingDynamic(LevelStreaming):
	"""Level Streaming Dynamic"""

	@property
	def bInitiallyLoaded(self) -> bool: ...
	"""Whether the level should be loaded at startup"""

	@property
	def bInitiallyVisible(self) -> bool: ...
	"""Whether the level should be visible at startup if it is loaded"""

	@staticmethod
	def LoadLevelInstanceBySoftObjectPtr(WorldContextObject: Object, Level, Location: Vector, Rotation: Rotator, OptionalLevelNameOverride: str = ...) -> typing.Tuple[LevelStreamingDynamic, bool]: ...
	"""Load Level Instance by Soft Object Ptr"""

	@staticmethod
	def LoadLevelInstance(WorldContextObject: Object, LevelName: str, Location: Vector, Rotation: Rotator, OptionalLevelNameOverride: str = ...) -> typing.Tuple[LevelStreamingDynamic, bool]: ...
	"""Stream in a level with a specific location and rotation. You can create multiple instances of the same level!

The level to be loaded does not have to be in the persistent map's Levels list, however to ensure that the .umap does get
packaged, please be sure to include the .umap in your Packaging Settings:

  Project Settings -> Packaging -> List of Maps to Include in a Packaged Build (you may have to show advanced or type in filter)

@param LevelName - Level package name to load, ex: /Game/Maps/MyMapName, specifying short name like MyMapName will force very slow search on disk
@param Location - World space location where the level should be spawned
@param Rotation - World space rotation for rotating the entire level
@param bOutSuccess - Whether operation was successful (map was found and added to the sub-levels list)
@param OptionalLevelNameOverride - If set, the loaded level package have this name, which is used by other functions like UnloadStreamLevel. Note this is necessary for server and client networking because the level must have the same name on both.
@return Streaming level object for a level instance"""

	pass

class LevelStreamingVolume(Volume):
	"""Level Streaming Volume"""

	@property
	def StreamingLevelNames(self) -> typing.List[str]: ...
	"""Levels names affected by this level streaming volume."""

	@property
	def bEditorPreVisOnly(self) -> bool: ...
	"""If true, this streaming volume should only be used for editor streaming level previs."""

	@property
	def bDisabled(self) -> bool: ...
	"""If true, this streaming volume is ignored by the streaming volume code.  Used to either
disable a level streaming volume without disassociating it from the level, or to toggle
the control of a level's streaming between Kismet and volume streaming."""

	@property
	def StreamingUsage(self) -> int: ...
	"""Determines what this volume is used for, e.g. whether to control loading, loading and visibility or just visibilty (blocking on load)"""

	pass

class LightMapTexture2D(Texture2D):
	"""Light Map Texture 2D"""

	pass

class LODActor(Actor):
	"""LODActor is an instance of an autogenerated StaticMesh Actors by Hierarchical LOD System
This is essentially just StaticMeshActor that you can't move or edit, but it contains multiple actors reference

See: https://docs.unrealengine.com/latest/INT/Engine/Actors/LODActor/
See: UStaticMesh"""

	@property
	def LODLevel(self) -> int: ...
	"""The hierarchy level of this actor; the first tier of HLOD is level 1, the second tier is level 2 and so on."""

	@property
	def SubActors(self) -> typing.List[Actor]: ...
	"""Sub Actors"""

	@property
	def CachedNumHLODLevels(self) -> int: ...
	"""Cached Num HLODLevels"""

	pass

class MeshMergeCullingVolume(Volume):
	"""A volume that can be added a level in order to remove triangles from source meshes before generating HLOD or merged meshes"""

	pass

class NavigationObjectBase(Actor):
	"""Navigation Object Base"""

	@property
	def bIsPIEPlayerStart(self) -> bool: ...
	"""True if this nav point was spawned to be a PIE player start."""

	pass

class Note(Actor):
	"""Note"""

	pass

class SceneCapture(Actor):
	"""Scene Capture"""

	pass

class PlaneReflectionCapture(ReflectionCapture):
	"""Plane Reflection Capture"""

	pass

class PlayerStart(NavigationObjectBase):
	"""This class indicates a location where a player can spawn when the game begins

See: https://docs.unrealengine.com/latest/INT/Engine/Actors/PlayerStart/"""

	@property
	def PlayerStartTag(self) -> str: ...
	"""Used when searching for which playerstart to use."""

	pass

class PlayerStartPIE(PlayerStart):
	"""Player Start PIE"""

	pass

class PointLight(Light):
	"""Point Light"""

	@property
	def PointLightComponent(self) -> PointLightComponent: ...
	"""Point Light Component"""

	pass

class PostProcessVolume(Volume):
	"""for FPostprocessSettings"""

	@property
	def Settings(self) -> PostProcessSettings: ...
	"""Post process settings to use for this volume."""

	@property
	def Priority(self) -> float: ...
	"""Priority of this volume. In the case of overlapping volumes the one with the highest priority
overrides the lower priority ones. The order is undefined if two or more overlapping volumes have the same priority."""

	@property
	def BlendRadius(self) -> float: ...
	"""World space radius around the volume that is used for blending (only if not unbound)."""

	@property
	def BlendWeight(self) -> float: ...
	"""0:no effect, 1:full effect"""

	@property
	def bEnabled(self) -> bool: ...
	"""Whether this volume is enabled or not."""

	@property
	def bUnbound(self) -> bool: ...
	"""Whether this volume covers the whole world, or just the area inside its bounds."""

	def AddOrUpdateBlendable(self, InBlendableObject, InWeight: float = ...): ...
	"""Adds an Blendable (implements IBlendableInterface) to the array of Blendables (if it doesn't exist) and update the weight"""

	pass

class PreviewMeshCollection(DataAsset):
	"""A simple collection of skeletal meshes used for in-editor preview"""

	@property
	def Skeleton(self) -> typing.Any: ...
	"""Skeleton"""

	@property
	def SkeletalMeshes(self) -> typing.List[unsupported]: ...
	"""The skeletal meshes that this collection contains"""

	pass

class PrimaryAssetLabel(PrimaryDataAsset):
	"""A seed file that is created to mark referenced assets as part of this primary asset"""

	@property
	def Rules(self) -> typing.Any: ...
	"""Management rules for this specific asset, if set it will override the type rules"""

	@property
	def bLabelAssetsInMyDirectory(self) -> bool: ...
	"""True to Label everything in this directory and sub directories"""

	@property
	def bIsRuntimeLabel(self) -> bool: ...
	"""Set to true if the label asset itself should be cooked and available at runtime. This does not affect the assets that are labeled, they are set with cook rule"""

	@property
	def ExplicitAssets(self) -> typing.List[unsupported]: ...
	"""List of manually specified assets to label"""

	@property
	def ExplicitBlueprints(self) -> typing.List[unsupported]: ...
	"""List of manually specified blueprint assets to label"""

	@property
	def AssetCollection(self) -> CollectionReference: ...
	"""Collection to load asset references out of"""

	pass

class RectLight(Light):
	"""Rect Light"""

	@property
	def RectLightComponent(self) -> RectLightComponent: ...
	"""Rect Light Component"""

	pass

class RuntimeOptionsBase(Object):
	"""URuntimeOptionsBase: Base class designed to be subclassed in your game.

Supports checking at runtime whether features are enabled/disabled, and changing
configuration parameters via console cheats or startup commands.

Add new config properties to your subclasses which default to the desired normal state
This can be adjusted via the development-only tools (command line or cvar) or via an
override in the config hierarchy to adjust it as needed (e.g., via a hotfix).

In non-Shipping builds, each property will be exposed both as a console variable and as a
command-line argument for easy testing during development.

Debug console syntax (disabled in Shipping configurations):
  prefix.PropertyName Value
Command line syntax (disabled in Shipping configurations):
  -prefix.PropertyName=Value
DefaultRuntimeOptions.ini syntax (note that there is no prefix for these):
  [/Script/YourModule.YourRuntimeOptionsSubclass]
  PropertyName=Value

Where the prefix is set by the value of OptionCommandPrefix (defaults to 'ro' but can be overridden)

You can also change the name of the ini file that settings are gathered from in your derived
UCLASS() declaration"""

	pass

class SceneCaptureCube(SceneCapture):
	"""Scene Capture Cube"""

	def OnInterpToggle(self, bEnable: bool): ...
	"""On Interp Toggle"""

	pass

class ServerStatReplicator(Info):
	"""Class used to replicate server 'stat net' data over. For server only values, the client data is
is overwritten when bUpdateStatNet == true. For data that both the client and server set, the server
data will only overwrite if bUpdateStatNet == true && bOverwriteClientStats == true."""

	@property
	def bUpdateStatNet(self) -> bool: ...
	"""Whether to update stat net with data from the server or not"""

	@property
	def bOverwriteClientStats(self) -> bool: ...
	"""Whether to overwrite client data stat net with data from the server or not"""

	@property
	def Channels(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def InRate(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def OutRate(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def MaxPacketOverhead(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def InRateClientMax(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def InRateClientMin(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def InRateClientAvg(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def InPacketsClientMax(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def InPacketsClientMin(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def InPacketsClientAvg(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def OutRateClientMax(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def OutRateClientMin(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def OutRateClientAvg(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def OutPacketsClientMax(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def OutPacketsClientMin(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def OutPacketsClientAvg(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NetNumClients(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def InPackets(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def OutPackets(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def InBunches(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def OutBunches(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def OutLoss(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def InLoss(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def VoiceBytesSent(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def VoiceBytesRecv(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def VoicePacketsSent(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def VoicePacketsRecv(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def PercentInVoice(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def PercentOutVoice(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumActorChannels(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumConsideredActors(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def PrioritizedActors(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumRelevantActors(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumRelevantDeletedActors(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumReplicatedActorAttempts(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumReplicatedActors(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumActors(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumNetActors(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumDormantActors(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumInitiallyDormantActors(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumNetGUIDsAckd(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumNetGUIDsPending(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NumNetGUIDsUnAckd(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def ObjPathBytes(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NetGUIDOutRate(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NetGUIDInRate(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	@property
	def NetSaturated(self) -> int: ...
	"""See: Network stats counters in EngineStats.h"""

	pass

class ShadowMapTexture2D(Texture2D):
	"""Shadow Map Texture 2D"""

	@property
	def ShadowmapFlags(self) -> int: ...
	"""Bit-field with shadowmap flags."""

	pass

class SkeletalMesh(StreamableRenderAsset):
	"""SkeletalMesh is geometry bound to a hierarchical skeleton of bones which can be animated for the purpose of deforming the mesh.
Skeletal Meshes are built up of two parts; a set of polygons composed to make up the surface of the mesh, and a hierarchical skeleton which can be used to animate the polygons.
The 3D models, rigging, and animations are created in an external modeling and animation application (3DSMax, Maya, Softimage, etc).

See: https://docs.unrealengine.com/latest/INT/Engine/Content/Types/SkeletalMeshes/"""

	@property
	def Skeleton(self) -> typing.Any: ...
	"""Skeleton of this skeletal mesh *"""

	@property
	def Materials(self) -> typing.List[SkeletalMaterial]: ...
	"""List of materials applied to this mesh."""

	@property
	def SkelMirrorTable(self) -> typing.List[unsupported]: ...
	"""List of bones that should be mirrored."""

	@property
	def MinLod(self) -> typing.Any: ...
	"""Minimum LOD to render. Can be overridden per component as well as set here for all mesh instances here"""

	@property
	def DisableBelowMinLodStripping(self) -> typing.Any: ...
	"""when true all lods below minlod will still be cooked"""

	@property
	def SkelMirrorAxis(self) -> int: ...
	"""Skel Mirror Axis"""

	@property
	def SkelMirrorFlipAxis(self) -> int: ...
	"""Skel Mirror Flip Axis"""

	@property
	def bHasBeenSimplified(self) -> bool: ...
	"""true if this mesh has ever been simplified with Simplygon."""

	@property
	def bHasVertexColors(self) -> bool: ...
	"""Whether or not the mesh has vertex colors"""

	@property
	def bEnablePerPolyCollision(self) -> bool: ...
	"""Uses skinned data for collision data. Per poly collision cannot be used for simulation, in most cases you are better off using the physics asset"""

	@property
	def BodySetup(self) -> typing.Any: ...
	"""Physics data for the per poly collision case. In 99% of cases you will not need this and are better off using simple ragdoll collision (physics asset)"""

	@property
	def PhysicsAsset(self) -> PhysicsAsset: ...
	"""Physics and collision information used for this USkeletalMesh, set up in Physics Asset Editor.
This is used for per-bone hit detection, accurate bounding box calculation and ragdoll physics for example."""

	@property
	def ShadowPhysicsAsset(self) -> PhysicsAsset: ...
	"""Physics asset whose shapes will be used for shadowing when components have bCastCharacterCapsuleDirectShadow or bCastCharacterCapsuleIndirectShadow enabled.
Only spheres and sphyl shapes in the physics asset can be supported.  The more shapes used, the higher the cost of the capsule shadows will be."""

	@property
	def NodeMappingData(self) -> typing.List[NodeMappingContainer]: ...
	"""Mapping data that is saved"""

	@property
	def MorphTargets(self) -> typing.List[unsupported]: ...
	"""Morph Targets"""

	@property
	def PostProcessAnimBlueprint(self) -> AnimInstance: ...
	"""Animation Blueprint class to run as a post process for this mesh.
This blueprint will be ran before physics, but after the main
anim instance for any skeletal mesh component using this mesh."""

	@property
	def MeshClothingAssets(self) -> typing.List[unsupported]: ...
	"""Clothing assets imported to this mesh. May or may not be in use currently on the mesh.
Ordering not guaranteed, use the provided getters to access elements in this array
whenever possible"""

	def IsSectionUsingCloth(self, InSectionIndex: int, bCheckCorrespondingSections: bool = ...) -> bool: ...
	"""Checks whether the provided section is using APEX cloth. if bCheckCorrespondingSections is true
disabled sections will defer to correspond sections to see if they use cloth (non-cloth sections
are disabled and another section added when cloth is enabled, using this flag allows for a check
on the original section to succeed)
@param InSectionIndex Index to check
@param bCheckCorrespondingSections Whether to check corresponding sections for disabled sections"""

	def GetSocketByIndex(self, Index: int) -> SkeletalMeshSocket: ...
	"""Returns a socket by index. Max index is NumSockets(). The meshes sockets are accessed first, then the skeletons."""

	def NumSockets(self) -> int: ...
	"""Returns the number of sockets available. Both on this mesh and it's skeleton."""

	def FindSocketInfo(self, InSocketName: str) -> typing.Tuple[SkeletalMeshSocket, Transform, int, int]: ...
	"""Find a socket object and asscociated info in this SkeletalMesh by name.
Entering NAME_None will return NULL. If there are multiple sockets with the same name, will return the first one.
Also returns the index for the socket allowing for future fast access via GetSocketByIndex()
Also rteturns the socket loca transform and the bone index (if any)"""

	def FindSocketAndIndex(self, InSocketName: str) -> typing.Tuple[SkeletalMeshSocket, int]: ...
	"""Find a socket object in this SkeletalMesh by name.
Entering NAME_None will return NULL. If there are multiple sockets with the same name, will return the first one.
Also returns the index for the socket allowing for future fast access via GetSocketByIndex()"""

	def FindSocket(self, InSocketName: str) -> SkeletalMeshSocket: ...
	"""Find a socket object in this SkeletalMesh by name.
Entering NAME_None will return NULL. If there are multiple sockets with the same name, will return the first one."""

	def GetAllMorphTargetNames(self) -> typing.List[str]: ...
	"""Returns the list of all morph targets of this skeletal mesh
@return     The list of morph targets"""

	def GetNodeMappingContainer(self, SourceAsset: Blueprint) -> NodeMappingContainer: ...
	"""Get Node Mapping Container"""

	def GetDefaultAnimatingRig(self) -> typing.Any: ...
	"""Get Default Animating Rig"""

	def SetDefaultAnimatingRig(self, InAnimatingRig): ...
	"""Set Default Animating Rig"""

	def SetLODSettings(self, InLODSettings: SkeletalMeshLODSettings): ...
	"""Set LODSettings"""

	def GetImportedBounds(self) -> BoxSphereBounds: ...
	"""Get the original imported bounds of the skel mesh"""

	def GetBounds(self) -> BoxSphereBounds: ...
	"""Get the extended bounds of this mesh (imported bounds plus bounds extension)"""

	pass

class SkeletalMeshLODSettings(DataAsset):
	"""Skeletal Mesh LODSettings"""

	pass

class SkeletalMeshSocket(Object):
	"""Skeletal Mesh Socket"""

	@property
	def SocketName(self) -> str: ...
	"""Defines a named attachment location on the USkeletalMesh.
These are set up in editor and used as a shortcut instead of specifying
everything explicitly to AttachComponent in the SkeletalMeshComponent.
The Outer of a SkeletalMeshSocket should always be the USkeletalMesh."""

	@property
	def BoneName(self) -> str: ...
	"""Bone Name"""

	@property
	def RelativeLocation(self) -> Vector: ...
	"""Relative Location"""

	@property
	def RelativeRotation(self) -> Rotator: ...
	"""Relative Rotation"""

	@property
	def RelativeScale(self) -> Vector: ...
	"""Relative Scale"""

	@property
	def bForceAlwaysAnimated(self) -> bool: ...
	"""If true then the hierarchy of bones this socket is attached to will always be
          evaluated, even if it had previously been removed due to the current lod setting"""

	def InitializeSocketFromLocation(self, SkelComp: SkeletalMeshComponent, WorldLocation: Vector, WorldNormal: Vector): ...
	"""Sets BoneName, RelativeLocation and RelativeRotation based on closest bone to WorldLocation and WorldNormal"""

	def GetSocketLocation(self, SkelComp: SkeletalMeshComponent) -> Vector: ...
	"""Get Socket Location"""

	pass

class SkyLight(Info):
	"""Sky Light"""

	@property
	def bEnabled(self) -> bool: ...
	"""replicated copy of LightComponent's bEnabled property"""

	def OnRep_bEnabled(self): ...
	"""Replication Notification Callbacks"""

	pass

class SphereReflectionCapture(ReflectionCapture):
	"""Actor used to capture the scene for reflection in a sphere shape.
See: https://docs.unrealengine.com/latest/INT/Resources/ContentExamples/Reflections/1_4"""

	pass

class SplineMeshActor(Actor):
	"""SplineMeshActor is an actor with a SplineMeshComponent.

See: USplineMeshComponent"""

	pass

class StaticMesh(StreamableRenderAsset):
	"""A StaticMesh is a piece of geometry that consists of a static set of polygons.
Static Meshes can be translated, rotated, and scaled, but they cannot have their vertices animated in any way. As such, they are more efficient
to render than other types of geometry such as USkeletalMesh, and they are often the basic building block of levels created in the engine.

See: https://docs.unrealengine.com/latest/INT/Engine/Content/Types/StaticMeshes/
See: AStaticMeshActor, UStaticMeshComponent"""

	@property
	def MinLOD(self) -> typing.Any: ...
	"""Minimum LOD to use for rendering.  This is the default setting for the mesh and can be overridden by component settings."""

	@property
	def LpvBiasMultiplier(self) -> float: ...
	"""Bias multiplier for Light Propagation Volume lighting"""

	@property
	def StaticMaterials(self) -> typing.List[StaticMaterial]: ...
	"""Static Materials"""

	@property
	def LightmapUVDensity(self) -> float: ...
	"""Lightmap UVDensity"""

	@property
	def LightMapResolution(self) -> int: ...
	"""The light map resolution"""

	@property
	def LightMapCoordinateIndex(self) -> int: ...
	"""The light map coordinate index"""

	@property
	def DistanceFieldSelfShadowBias(self) -> float: ...
	"""Useful for reducing self shadowing from distance field methods when using world position offset to animate the mesh's vertices."""

	@property
	def BodySetup(self) -> typing.Any: ...
	"""Physics data."""

	@property
	def LODForCollision(self) -> int: ...
	"""Specifies which mesh LOD to use for complex (per-poly) collision.
Sometimes it can be desirable to use a lower poly representation for collision to reduce memory usage, improve performance and behaviour.
Collision representation does not change based on distance to camera."""

	@property
	def bGenerateMeshDistanceField(self) -> bool: ...
	"""Whether to generate a distance field for this mesh, which can be used by DistanceField Indirect Shadows.
This is ignored if the project's 'Generate Mesh Distance Fields' setting is enabled."""

	@property
	def bHasNavigationData(self) -> bool: ...
	"""If true, mesh will have NavCollision property with additional data for navmesh generation and usage.
          Set to false for distant meshes (always outside navigation bounds) to save memory on collision data."""

	@property
	def bSupportUniformlyDistributedSampling(self) -> bool: ...
	"""Mesh supports uniformly distributed sampling in constant time.
Memory cost is 8 bytes per triangle.
Example usage is uniform spawning of particles."""

	@property
	def bSupportPhysicalMaterialMasks(self) -> bool: ...
	"""If true, complex collision data will store UVs and face remap table for use when performing
PhysicalMaterialMask lookups in cooked builds. Note the increased memory cost for this
functionality."""

	@property
	def bIsBuiltAtRuntime(self) -> bool: ...
	"""If true, StaticMesh has been built at runtime"""

	@property
	def bAllowCPUAccess(self) -> bool: ...
	"""If true, will keep geometry data CPU-accessible in cooked builds, rather than uploading to GPU memory and releasing it from CPU memory.
This is required if you wish to access StaticMesh geometry data on the CPU at runtime in cooked builds (e.g. to convert StaticMesh to ProceduralMeshComponent)"""

	@property
	def bSupportGpuUniformlyDistributedSampling(self) -> bool: ...
	"""If true, a GPU buffer containing required data for uniform mesh surface sampling will be created at load time.
It is created from the cpu data so bSupportUniformlyDistributedSampling is also required to be true."""

	@property
	def Sockets(self) -> typing.List[StaticMeshSocket]: ...
	"""Array of named socket locations, set up in editor and used as a shortcut instead of specifying
everything explicitly to AttachComponent in the StaticMeshComponent."""

	@property
	def PositiveBoundsExtension(self) -> Vector: ...
	"""Bound extension values in the positive direction of XYZ, positive value increases bound size"""

	@property
	def NegativeBoundsExtension(self) -> Vector: ...
	"""Bound extension values in the negative direction of XYZ, positive value increases bound size"""

	@property
	def ExtendedBounds(self) -> BoxSphereBounds: ...
	"""Original mesh bounds extended with Positive/NegativeBoundsExtension"""

	@property
	def EditableMesh(self) -> Object: ...
	"""The editable mesh representation of this static mesh // @todo: Maybe we don't want this visible in the details panel in the end; for now, this might aid debugging."""

	@property
	def NavCollision(self) -> typing.Any: ...
	"""Pre-build navigation collision"""

	def RemoveSocket(self, Socket: StaticMeshSocket): ...
	"""Remove a socket object in this StaticMesh by providing it's pointer. Use FindSocket() if needed."""

	def FindSocket(self, InSocketName: str) -> StaticMeshSocket: ...
	"""Find a socket object in this StaticMesh by name.
Entering NAME_None will return NULL. If there are multiple sockets with the same name, will return the first one."""

	def AddSocket(self, Socket: StaticMeshSocket): ...
	"""Add a socket object in this StaticMesh."""

	def GetMaterialIndex(self, MaterialSlotName: str) -> int: ...
	"""Gets a Material index given a slot name

@return Requested material"""

	def AddMaterial(self, Material: MaterialInterface) -> str: ...
	"""Adds a new material and return its slot name"""

	def GetMaterial(self, MaterialIndex: int) -> MaterialInterface: ...
	"""Gets a Material given a Material Index and an LOD number

@return Requested material"""

	def GetNumSections(self, InLOD: int) -> int: ...
	"""Returns number of Sections that this StaticMesh has, in the supplied LOD (LOD 0 is the highest)"""

	def GetBoundingBox(self) -> Box: ...
	"""Returns the bounding box, in local space including bounds extension(s), of the StaticMesh asset"""

	def GetBounds(self) -> BoxSphereBounds: ...
	"""Returns the number of bounds of the mesh.

@return      The bounding box represented as box origin with extents and also a sphere that encapsulates that box"""

	def GetNumLods(self) -> int: ...
	"""Returns the number of LODs used by the mesh."""

	def BuildFromStaticMeshDescriptions(self, StaticMeshDescriptions: typing.List[unsupported], bBuildSimpleCollision: bool = ...): ...
	"""Builds static mesh LODs from the array of StaticMeshDescriptions passed in"""

	@staticmethod
	def CreateStaticMeshDescription(Outer: Object = ...) -> typing.Any: ...
	"""Create an empty StaticMeshDescription object, to describe a static mesh at runtime"""

	def GetMinimumLODForPlatform(self, PlatformName: str) -> int: ...
	"""Get Minimum LODFor Platform"""

	def GetMinimumLODForPlatforms(self) -> typing.Dict[str, str]: ...
	"""Get Minimum LODFor Platforms"""

	pass

class StaticMeshActor(Actor):
	"""StaticMeshActor is an instance of a UStaticMesh in the world.
Static meshes are geometry that do not animate or otherwise deform, and are more efficient to render than other types of geometry.
Static meshes dragged into the level from the Content Browser are automatically converted to StaticMeshActors.

See: https://docs.unrealengine.com/latest/INT/Engine/Actors/StaticMeshActor/
See: UStaticMesh"""

	@property
	def bStaticMeshReplicateMovement(self) -> bool: ...
	"""This static mesh should replicate movement. Automatically sets the RemoteRole and bReplicateMovement flags. Meant to be edited on placed actors (those other two properties are not)"""

	@property
	def NavigationGeometryGatheringMode(self) -> int: ...
	"""Navigation Geometry Gathering Mode"""

	def SetMobility(self, InMobility: int): ...
	"""Function to change mobility type"""

	pass

class StaticMeshSocket(Object):
	"""Static Mesh Socket"""

	@property
	def SocketName(self) -> str: ...
	"""Defines a named attachment location on the UStaticMesh.
These are set up in editor and used as a shortcut instead of specifying
everything explicitly to AttachComponent in the StaticMeshComponent.
The Outer of a StaticMeshSocket should always be the UStaticMesh."""

	@property
	def RelativeLocation(self) -> Vector: ...
	"""Relative Location"""

	@property
	def RelativeRotation(self) -> Rotator: ...
	"""Relative Rotation"""

	@property
	def RelativeScale(self) -> Vector: ...
	"""Relative Scale"""

	@property
	def Tag(self) -> str: ...
	"""Tag"""

	pass

class TimecodeProvider(Object):
	"""A class responsible of fetching a timecode from a source.
Note, FApp::GetTimecode and FApp::GetTimecodeFramerate should be used to retrieve
the current system Timecode and Framerate."""

	@property
	def FrameDelay(self) -> float: ...
	"""Number of frames to subtract from the qualified frame time when GetDelayedQualifiedFrameTime or GetDelayedTimecode is called.
See: GetDelayedQualifiedFrameTime, GetDelayedTimecode"""

	def GetSynchronizationState(self) -> int: ...
	"""The state of the TimecodeProvider and if it's currently synchronized and the Timecode and FrameRate getters are valid."""

	def GetFrameRate(self) -> FrameRate: ...
	"""Return the frame rate of the frame time."""

	def GetDelayedTimecode(self) -> Timecode: ...
	"""Return the delayed frame time converted into a timecode value."""

	def GetTimecode(self) -> Timecode: ...
	"""Return the frame time converted into a timecode value."""

	def GetDelayedQualifiedFrameTime(self) -> QualifiedFrameTime: ...
	"""Return current frame time with FrameDelay applied.
Only assume valid when GetSynchronizationState() returns Synchronized."""

	def GetQualifiedFrameTime(self) -> QualifiedFrameTime: ...
	"""Return current frame time.
Since it may be called several times per frame, it is suggested to return a cached value."""

	def FetchAndUpdate(self): ...
	"""Update the state of the provider. Call it to ensure timecode and state are updated.
It is suggested to fetch timecode from its source and cache it for the getters."""

	def FetchTimecode(self) -> typing.Tuple[bool, QualifiedFrameTime]: ...
	"""Fetch current timecode from its source. e.g. From hardware/network/file/etc.
It is recommended to cache the fetched timecode."""

	pass

class SystemTimeTimecodeProvider(TimecodeProvider):
	"""Converts the current system time to timecode, relative to a provided frame rate."""

	@property
	def FrameRate(self) -> FrameRate: ...
	"""The frame rate at which the timecode value will be generated."""

	@property
	def bGenerateFullFrame(self) -> bool: ...
	"""When generating frame time, should we generate full frame without subframe value."""

	@property
	def bUseHighPerformanceClock(self) -> bool: ...
	"""Use the high performance clock instead of the system time to generate the timecode value.
Using the high performance clock is faster but will make the value drift over time."""

	pass

class TargetPoint(Actor):
	"""Target Point"""

	pass

class TextRenderActor(Actor):
	"""Text Render Actor"""

	pass

class Texture2DArray(Texture):
	"""Texture 2DArray"""

	@property
	def AddressX(self) -> int: ...
	"""The addressing mode to use for the X axis."""

	@property
	def AddressY(self) -> int: ...
	"""The addressing mode to use for the Y axis."""

	@property
	def AddressZ(self) -> int: ...
	"""The addressing mode to use for the Z axis."""

	pass

class Texture2DDynamic(Texture):
	"""Texture 2DDynamic"""

	@property
	def Format(self) -> int: ...
	"""The format of the texture."""

	pass

class TextureCube(Texture):
	"""Texture Cube"""

	pass

class TextureLightProfile(Texture2D):
	"""Texture Light Profile"""

	@property
	def Brightness(self) -> float: ...
	"""Light brightness in Candelas, imported from IES profile, <= 0 if the profile is used for masking only. Use with InverseSquareFalloff."""

	@property
	def TextureMultiplier(self) -> float: ...
	"""Multiplier to map texture value to result to integrate over the sphere to 1.0f"""

	pass

class TextureRenderTarget2DArray(TextureRenderTarget):
	"""TextureRenderTarget2DArray

2D Array render target texture resource. This can be used as a target
for rendering as well as rendered as a regular 2DArray texture resource."""

	@property
	def SizeX(self) -> int: ...
	"""The width of the texture."""

	@property
	def SizeY(self) -> int: ...
	"""The height of the texture."""

	@property
	def Slices(self) -> int: ...
	"""The slices of the texture."""

	@property
	def ClearColor(self) -> LinearColor: ...
	"""the color the texture is cleared to"""

	@property
	def OverrideFormat(self) -> int: ...
	"""Normally the format is derived from bHDR, this allows code to set the format explicitly."""

	@property
	def bHDR(self) -> bool: ...
	"""Whether to support storing HDR values, which requires more memory."""

	@property
	def bForceLinearGamma(self) -> bool: ...
	"""True to force linear gamma space for this render target"""

	pass

class TextureRenderTargetCube(TextureRenderTarget):
	"""TextureRenderTargetCube

Cube render target texture resource. This can be used as a target
for rendering as well as rendered as a regular cube texture resource."""

	@property
	def SizeX(self) -> int: ...
	"""The width of the texture."""

	@property
	def ClearColor(self) -> LinearColor: ...
	"""the color the texture is cleared to"""

	@property
	def OverrideFormat(self) -> int: ...
	"""Normally the format is derived from bHDR, this allows code to set the format explicitly."""

	@property
	def bHDR(self) -> bool: ...
	"""Whether to support storing HDR values, which requires more memory."""

	@property
	def bForceLinearGamma(self) -> bool: ...
	"""True to force linear gamma space for this render target"""

	pass

class TextureRenderTargetVolume(TextureRenderTarget):
	"""TextureRenderTargetVolume

Volume render target texture resource. This can be used as a target
for rendering as well as rendered as a regular Volume texture resource."""

	@property
	def SizeX(self) -> int: ...
	"""The width of the texture."""

	@property
	def SizeY(self) -> int: ...
	"""The height of the texture."""

	@property
	def SizeZ(self) -> int: ...
	"""The depth of the texture."""

	@property
	def ClearColor(self) -> LinearColor: ...
	"""the color the texture is cleared to"""

	@property
	def OverrideFormat(self) -> int: ...
	"""Normally the format is derived from bHDR, this allows code to set the format explicitly."""

	@property
	def bHDR(self) -> bool: ...
	"""Whether to support storing HDR values, which requires more memory."""

	@property
	def bForceLinearGamma(self) -> bool: ...
	"""True to force linear gamma space for this render target"""

	pass

class TimelineTemplate(Object):
	"""Timeline Template"""

	@property
	def TimelineLength(self) -> float: ...
	"""Length of this timeline"""

	@property
	def LengthMode(self) -> int: ...
	"""How we want the timeline to determine its own length (e.g. specified length, last keyframe)"""

	@property
	def bAutoPlay(self) -> bool: ...
	"""If we want the timeline to auto-play"""

	@property
	def bLoop(self) -> bool: ...
	"""If we want the timeline to loop"""

	@property
	def bReplicated(self) -> bool: ...
	"""If we want the timeline to loop"""

	@property
	def bIgnoreTimeDilation(self) -> bool: ...
	"""If we want the timeline to ignore global time dilation"""

	@property
	def EventTracks(self) -> typing.List[unsupported]: ...
	"""Set of event tracks"""

	@property
	def FloatTracks(self) -> typing.List[unsupported]: ...
	"""Set of float interpolation tracks"""

	@property
	def VectorTracks(self) -> typing.List[unsupported]: ...
	"""Set of vector interpolation tracks"""

	@property
	def LinearColorTracks(self) -> typing.List[unsupported]: ...
	"""Set of linear color interpolation tracks"""

	@property
	def MetaDataArray(self) -> typing.List[unsupported]: ...
	"""Metadata information for this timeline"""

	@property
	def TimelineGuid(self) -> Guid: ...
	"""Timeline Guid"""

	pass

class TriggerBase(Actor):
	"""An actor used to generate collision events (begin/end overlap) in the level."""

	pass

class TriggerBox(TriggerBase):
	"""A box shaped trigger, used to generate overlap events in the level"""

	pass

class TriggerCapsule(TriggerBase):
	"""A capsule shaped trigger, used to generate overlap events in the level"""

	pass

class TriggerSphere(TriggerBase):
	"""A sphere shaped trigger, used to generate overlap events in the level"""

	pass

class TriggerVolume(Volume):
	"""Trigger Volume"""

	pass

class Subsystem(Object):
	"""Subsystems are auto instanced classes that share the lifetime of certain engine constructs

   Currently supported Subsystem lifetimes are:
           Engine           -> inherit UEngineSubsystem
           Editor           -> inherit UEditorSubsystem
           GameInstance -> inherit UGameInstanceSubsystem
           World            -> inherit UWorldSubsystem
           LocalPlayer      -> inherit ULocalPlayerSubsystem"""

	pass

class WorldSubsystem(Subsystem):
	"""UWorldSubsystem
Base class for auto instanced and initialized systems that share the lifetime of a UWorld"""

	pass

class ViewportStatsSubsystem(WorldSubsystem):
	"""The Viewport Stats Subsystem offers the ability to add messages to the current
viewport such as 'LIGHTING NEEDS TO BE REBUILT' and 'BLUEPRINT COMPILE ERROR'.

Example usage:

     if (UViewportStatsSubsystem* ViewportSubsystem = GetWorld()->GetSubsystem<UViewportStatsSubsystem>())
     {
             // Bind a member function delegate to the subsystem...
             FViewportDisplayCallback Callback;
             Callback.BindDynamic(this, &UCustomClass::DisplayViewportMessage);
             ViewportSubsystem->AddDisplayDelegate(Callback);

             // ... or use inline lambda functions
             ViewportSubsystem->AddDisplayDelegate([](FText& OutText, FLinearColor& OutColor)
             {
                     // Some kind of state management
                     OutText = NSLOCTEXT('FooNamespace', 'Blarg', 'Display message here');
                     OutColor = FLinearColor::Red;
                     return bShouldDisplay;"""

	def RemoveDisplayDelegate(self, IndexToRemove: int): ...
	"""Remove a callback function from the display subsystem

@param IndexToRemove  The index in the DisplayDelegates array to remove.
                                              This is the value returned from AddDisplayDelegate."""

	def AddDisplayDelegate(self, Delegate) -> int: ...
	"""Add a dynamic delegate to the display subsystem.

@param Callback       The callback the subsystem will use to determine if a message should be displayed or not
                                      Signature of callbacks should be: bool(FText& OutTest, FLinearColor& OutColor)"""

	def AddTimedDisplay(self, Text: str, Color: LinearColor = ..., Duration: float = ...): ...
	"""Add a message to be displayed on the viewport of this world

@param Text           The text to be displayed
@param Color          Color of the text to be displayed
@param Duration       How long the text will be on screen, if 0 then it will stay indefinitely"""

	pass

class VolumeTexture(Texture):
	"""Volume Texture"""

	pass

class WindDirectionalSource(Info):
	"""Actor that provides a directional wind source. Only affects SpeedTree assets."""

	pass

class World(Object):
	"""The World is the top level object representing a map or a sandbox in which Actors and Components will exist and be rendered.

A World can be a single Persistent Level with an optional list of streaming levels that are loaded and unloaded via volumes and blueprint functions
or it can be a collection of levels organized with a World Composition.

In a standalone game, generally only a single World exists except during seamless area transitions when both a destination and current world exists.
In the editor many Worlds exist: The level being edited, each PIE instance, each editor tool which has an interactive rendered viewport, and many more."""

	@property
	def PersistentLevel(self) -> typing.Any: ...
	"""Persistent level containing the world info, default brush and actors spawned during gameplay among other things"""

	@property
	def NetDriver(self) -> typing.Any: ...
	"""The NAME_GameNetDriver game connection(s) for client/server communication"""

	@property
	def LineBatcher(self) -> LineBatchComponent: ...
	"""Line Batchers. All lines to be drawn in the world."""

	@property
	def PersistentLineBatcher(self) -> LineBatchComponent: ...
	"""Persistent Line Batchers. They don't get flushed every frame."""

	@property
	def ForegroundLineBatcher(self) -> LineBatchComponent: ...
	"""Foreground Line Batchers. This can't be Persistent."""

	@property
	def NetworkManager(self) -> GameNetworkManager: ...
	"""Instance of this world's game-specific networking management"""

	@property
	def PhysicsCollisionHandler(self) -> PhysicsCollisionHandler: ...
	"""Instance of this world's game-specific physics collision handler"""

	@property
	def ExtraReferencedObjects(self) -> typing.List[Object]: ...
	"""Array of any additional objects that need to be referenced by this world, to make sure they aren't GC'd"""

	@property
	def PerModuleDataObjects(self) -> typing.List[Object]: ...
	"""External modules can have additional data associated with this UWorld.
This is a list of per module world data objects. These aren't
loaded/saved by default."""

	@property
	def StreamingLevelsPrefix(self) -> str: ...
	"""Prefix we used to rename streaming levels, non empty in PIE and standalone preview"""

	@property
	def DemoNetDriver(self) -> typing.Any: ...
	"""Demo Net Driver"""

	@property
	def MyParticleEventManager(self) -> typing.Any: ...
	"""Particle event manager *"""

	@property
	def bAreConstraintsDirty(self) -> bool: ...
	"""Keeps track whether actors moved via PostEditMove and therefore constraint syncup should be performed."""

	@property
	def WorldComposition(self) -> typing.Any: ...
	"""All levels information from which our world is composed"""

	def GetWorldSettings(self) -> WorldSettings: ...
	"""Returns the AWorldSettings actor associated with this world.

@return AWorldSettings actor associated with this world"""

	def HandleTimelineScrubbed(self): ...
	"""Called from DemoNetDriver when playing back a replay and the timeline is successfully scrubbed"""

	def GetAllObjects(self) -> typing.List[Object]: ...

	def GetAllActors(self) -> typing.List[Actor]: ...

	def FindObject(self, Name: str) -> Object: ...

	def GetLevels(self) -> typing.List[Level]: ...

	def GetCurrentLevel(self) -> Level: ...

	def DestroyActor(self, ThisActor: Actor, bNetForce: bool = ..., bShouldModifyLevel: bool = ...) -> bool: ...

	def RemoveActor(self, ThisActor: Actor, bShouldModifyLevel: bool) -> None: ...

	def SpawnActor(self, ActorClass: Class, Location: Vector = ..., Rotation: Rotator = ..., SpawnCollisionHandlingOverride: ESpawnActorCollisionHandlingMethod = ...) -> Actor: ...

	def SpawnActorAbsolute(self, ActorClass: Class, AbsoluteTransform: Transform, SpawnCollisionHandlingOverride: ESpawnActorCollisionHandlingMethod = ...) -> Actor: ...

	def GetPlayerController(self) -> PlayerController: ...

	def GetWorldType(self) -> int: ...

	def GetCurrentLevelScriptActor(self) -> LevelScriptActor: ...

	pass

class Exporter(Object):
	"""Exporter"""

	@property
	def SupportedClass(self) -> Object: ...
	"""Supported class of this exporter"""

	@property
	def ExportRootScope(self) -> Object: ...
	"""The root scope of objects to be exported, only used if PPF_ExportsNotFullyQualfied is set
Objects being exported that are contained within ExportRootScope will use just their name instead of a full path"""

	@property
	def FormatExtension(self) -> typing.List[str]: ...
	"""File extension to use for this exporter"""

	@property
	def FormatDescription(self) -> typing.List[str]: ...
	"""Descriptiong of the export format"""

	@property
	def PreferredFormatIndex(self) -> int: ...
	"""Index into FormatExtension/FormatDescription of the preferred export format."""

	@property
	def TextIndent(self) -> int: ...
	"""Current indentation of spaces of the exported text"""

	@property
	def bText(self) -> bool: ...
	"""If true, this will export the data as text"""

	@property
	def bSelectedOnly(self) -> bool: ...
	"""If true, this will export only the selected objects"""

	@property
	def bForceFileOperations(self) -> bool: ...
	"""If true, this will force the exporter code to create a file-based Ar (this can keep large output files from taking too much memory)"""

	@property
	def ExportTask(self) -> AssetExportTask: ...
	"""Export Task"""

	@staticmethod
	def RunAssetExportTasks(ExportTasks: typing.List[AssetExportTask]) -> bool: ...
	"""Export the given objects to files.  Child classes do not override this, but they do provide an Export() function
to do the resource-specific export work.

@param       ExportTasks             The array of tasks to export.

@return      true if all tasks ran without error"""

	@staticmethod
	def RunAssetExportTask(Task: AssetExportTask) -> bool: ...
	"""Export the given object to file.  Child classes do not override this, but they do provide an Export() function
to do the resource-specific export work.

@param        Task            The task to export.

@return       true if the the object was successfully exported"""

	pass

class BlueprintAsyncActionBase(Object):
	"""Blueprint Async Action Base"""

	def Activate(self): ...
	"""Called to trigger the action once the delegates have been bound"""

	pass

class AsyncActionHandleSaveGame(BlueprintAsyncActionBase):
	"""Async action to handle async load/save of a USaveGame. This can be subclassed by a specific game"""

	@property
	def Completed(self) -> typing.Any: ...
	"""Delegate called when the save/load completes"""

	@staticmethod
	def AsyncLoadGameFromSlot(WorldContextObject: Object, SlotName: str, UserIndex: int) -> AsyncActionHandleSaveGame: ...
	"""Schedule an async load of a specific slot. UGameplayStatics::AsyncLoadGameFromSlot is the native version of this.
When the load has succeeded or failed, the completed pin is activated with success/failure and the newly loaded save game object if valid.
Keep in mind that some platforms may not support trying to load and save at the same time.

@param SlotName                      Name of the save game slot to load from.
@param UserIndex                     For some platforms, master user index to identify the user doing the loading."""

	@staticmethod
	def AsyncSaveGameToSlot(WorldContextObject: Object, SaveGameObject: SaveGame, SlotName: str, UserIndex: int) -> AsyncActionHandleSaveGame: ...
	"""Schedule an async save to a specific slot. UGameplayStatics::AsyncSaveGameToSlot is the native version of this.
When the save has succeeded or failed, the completed pin is activated with success/failure and the save game object.
Keep in mind that some platforms may not support trying to load and save at the same time.

@param SaveGameObject        Object that contains data about the save game that we want to write out.
@param SlotName                      Name of the save game slot to load from.
@param UserIndex                     For some platforms, master user index to identify the user doing the loading."""

	pass

class CameraBlockingVolume(Volume):
	"""A volume which blocks the Camera channel by default."""

	pass

class Pawn(Actor):
	"""Pawn is the base class of all actors that can be possessed by players or AI.
They are the physical representations of players and creatures in a level.

See: https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Pawn/"""

	@property
	def bUseControllerRotationPitch(self) -> bool: ...
	"""If true, this Pawn's pitch will be updated to match the Controller's ControlRotation pitch, if controlled by a PlayerController."""

	@property
	def bUseControllerRotationYaw(self) -> bool: ...
	"""If true, this Pawn's yaw will be updated to match the Controller's ControlRotation yaw, if controlled by a PlayerController."""

	@property
	def bUseControllerRotationRoll(self) -> bool: ...
	"""If true, this Pawn's roll will be updated to match the Controller's ControlRotation roll, if controlled by a PlayerController."""

	@property
	def bCanAffectNavigationGeneration(self) -> bool: ...
	"""If set to false (default) given pawn instance will never affect navigation generation.
    Setting it to true will result in using regular AActor's navigation relevancy
    calculation to check if this pawn instance should affect navigation generation
    Use SetCanAffectNavigationGeneration to change this value at runtime.
    Note that modifying this value at runtime will result in any navigation change only if runtime navigation generation is enabled."""

	@property
	def BaseEyeHeight(self) -> float: ...
	"""Base eye height above collision center."""

	@property
	def AutoPossessPlayer(self) -> int: ...
	"""Determines which PlayerController, if any, should automatically possess the pawn when the level starts or when the pawn is spawned.
See: AutoPossessAI"""

	@property
	def AutoPossessAI(self) -> int: ...
	"""Determines when the Pawn creates and is possessed by an AI Controller (on level start, when spawned, etc).
Only possible if AIControllerClassRef is set, and ignored if AutoPossessPlayer is enabled.
See: AutoPossessPlayer"""

	@property
	def RemoteViewPitch(self) -> int: ...
	"""Replicated so we can see where remote clients are looking."""

	@property
	def AIControllerClass(self) -> Controller: ...
	"""Default class to use when pawn is controlled by AI."""

	@property
	def LastHitBy(self) -> Controller: ...
	"""Controller of the last Actor that caused us damage."""

	@property
	def Controller(self) -> Controller: ...
	"""Controller currently possessing this Actor"""

	def IsMoveInputIgnored(self) -> bool: ...
	"""Helper to see if move input is ignored. If our controller is a PlayerController, checks Controller->IsMoveInputIgnored()."""

	def AddControllerRollInput(self, Val: float): ...
	"""Add input (affecting Roll) to the Controller's ControlRotation, if it is a local PlayerController.
This value is multiplied by the PlayerController's InputRollScale value.
@param Val Amount to add to Roll. This value is multiplied by the PlayerController's InputRollScale value.
@see PlayerController::InputRollScale"""

	def AddControllerYawInput(self, Val: float): ...
	"""Add input (affecting Yaw) to the Controller's ControlRotation, if it is a local PlayerController.
This value is multiplied by the PlayerController's InputYawScale value.
@param Val Amount to add to Yaw. This value is multiplied by the PlayerController's InputYawScale value.
@see PlayerController::InputYawScale"""

	def AddControllerPitchInput(self, Val: float): ...
	"""Add input (affecting Pitch) to the Controller's ControlRotation, if it is a local PlayerController.
This value is multiplied by the PlayerController's InputPitchScale value.
@param Val Amount to add to Pitch. This value is multiplied by the PlayerController's InputPitchScale value.
@see PlayerController::InputPitchScale"""

	def ConsumeMovementInputVector(self) -> Vector: ...
	"""Returns the pending input vector and resets it to zero.
This should be used during a movement update (by the Pawn or PawnMovementComponent) to prevent accumulation of control input between frames.
Copies the pending input vector to the saved input vector (GetLastMovementInputVector()).
@return The pending input vector."""

	def GetLastMovementInputVector(self) -> Vector: ...
	"""Return the last input vector in world space that was processed by ConsumeMovementInputVector(), which is usually done by the Pawn or PawnMovementComponent.
Any user that needs to know about the input that last affected movement should use this function.
For example an animation update would want to use this, since by default the order of updates in a frame is:
PlayerController (device input) -> MovementComponent -> Pawn -> Mesh (animations)

@return The last input vector in world space that was processed by ConsumeMovementInputVector().
@see AddMovementInput(), GetPendingMovementInputVector(), ConsumeMovementInputVector()"""

	def GetPendingMovementInputVector(self) -> Vector: ...
	"""Return the pending input vector in world space. This is the most up-to-date value of the input vector, pending ConsumeMovementInputVector() which clears it,
Usually only a PawnMovementComponent will want to read this value, or the Pawn itself if it is responsible for movement.

@return The pending input vector in world space.
@see AddMovementInput(), GetLastMovementInputVector(), ConsumeMovementInputVector()"""

	def AddMovementInput(self, WorldDirection: Vector, ScaleValue: float = ..., bForce: bool = ...): ...
	"""Add movement input along the given world direction vector (usually normalized) scaled by 'ScaleValue'. If ScaleValue < 0, movement will be in the opposite direction.
Base Pawn classes won't automatically apply movement, it's up to the user to do so in a Tick event. Subclasses such as Character and DefaultPawn automatically handle this input and move.

@param WorldDirection        Direction in world space to apply input
@param ScaleValue            Scale to apply to input. This can be used for analog input, ie a value of 0.5 applies half the normal value, while -1.0 would reverse the direction.
@param bForce                        If true always add the input, ignoring the result of IsMoveInputIgnored().
@see GetPendingMovementInputVector(), GetLastMovementInputVector(), ConsumeMovementInputVector()"""

	def SpawnDefaultController(self): ...
	"""Spawn default controller for this Pawn, and get possessed by it."""

	def DetachFromControllerPendingDestroy(self): ...
	"""Call this function to detach safely pawn from its controller, knowing that we will be destroyed soon."""

	def GetBaseAimRotation(self) -> Rotator: ...
	"""Return the aim rotation for the Pawn.
If we have a controller, by default we aim at the player's 'eyes' direction
that is by default the Pawn rotation for AI, and camera (crosshair) rotation for human players."""

	def IsBotControlled(self) -> bool: ...
	"""Returns true if controlled by a bot."""

	def IsPlayerControlled(self) -> bool: ...
	"""Returns true if controlled by a human player (possessed by a PlayerController)."""

	def IsLocallyControlled(self) -> bool: ...
	"""Returns true if controlled by a local (not network) Controller."""

	def GetNavAgentLocation(self) -> Vector: ...
	"""Basically retrieved pawn's location on navmesh"""

	def SetCanAffectNavigationGeneration(self, bNewValue: bool, bForceUpdate: bool = ...): ...
	"""Use SetCanAffectNavigationGeneration to change this value at runtime.
Note that calling this function at runtime will result in any navigation change only if runtime navigation generation is enabled."""

	def OnRep_PlayerState(self): ...
	"""PlayerState Replication Notification Callback"""

	def OnRep_Controller(self): ...
	"""Called when Controller is replicated"""

	def GetControlRotation(self) -> Rotator: ...
	"""Get the rotation of the Controller, often the 'view' rotation of this Pawn."""

	def GetController(self) -> Controller: ...
	"""Returns controller for this actor."""

	def IsPawnControlled(self) -> bool: ...
	"""Check if this actor is currently being controlled at all (the actor has a valid Controller)"""

	def IsControlled(self) -> bool: ...
	"""Is Controlled"""

	@staticmethod
	def GetMovementBaseActor(Pawn: Pawn) -> Actor: ...
	"""Gets the owning actor of the Movement Base Component on which the pawn is standing."""

	def PawnMakeNoise(self, Loudness: float, NoiseLocation: Vector, bUseNoiseMakerLocation: bool = ..., NoiseMaker: Actor = ...): ...
	"""Inform AIControllers that you've made a noise they might hear (they are sent a HearNoise message if they have bHearNoises==true)
The instigator of this sound is the pawn which is used to call MakeNoise.

@param Loudness - is the relative loudness of this noise (range 0.0 to 1.0).  Directly affects the hearing range specified by the AI's HearingThreshold.
@param NoiseLocation - Position of noise source.  If zero vector, use the actor's location.
@param bUseNoiseMakerLocation - If true, use the location of the NoiseMaker rather than NoiseLocation.  If false, use NoiseLocation.
@param NoiseMaker - Which actor is the source of the noise.  Not to be confused with the Noise Instigator, which is responsible for the noise (and is the pawn on which this function is called).  If not specified, the pawn instigating the noise will be used as the NoiseMaker"""

	def GetMovementComponent(self) -> PawnMovementComponent: ...
	"""Return our PawnMovementComponent, if we have one."""

	pass

class Character(Pawn):
	"""Characters are Pawns that have a mesh, collision, and built-in movement logic.
They are responsible for all physical interaction between the player or AI and the world, and also implement basic networking and input models.
They are designed for a vertically-oriented player representation that can walk, jump, fly, and swim through the world using CharacterMovementComponent.

See: APawn, UCharacterMovementComponent
See: https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Pawn/Character/"""

	@property
	def CrouchedEyeHeight(self) -> float: ...
	"""Default crouched eye height"""

	@property
	def bIsCrouched(self) -> bool: ...
	"""Set by character movement to specify that this Character is currently crouched."""

	@property
	def bProxyIsJumpForceApplied(self) -> bool: ...
	"""Set to indicate that this Character is currently under the force of a jump (if JumpMaxHoldTime is non-zero). IsJumpProvidingForce() handles this as well."""

	@property
	def bPressedJump(self) -> bool: ...
	"""When true, player wants to jump"""

	@property
	def bClientUpdating(self) -> bool: ...
	"""When true, applying updates to network client (replaying saved moves for a locally controlled character)"""

	@property
	def bClientWasFalling(self) -> bool: ...
	"""True if Pawn was initially falling when started to replay network moves."""

	@property
	def bClientResimulateRootMotion(self) -> bool: ...
	"""If server disagrees with root motion track position, client has to resimulate root motion from last AckedMove."""

	@property
	def bClientResimulateRootMotionSources(self) -> bool: ...
	"""If server disagrees with root motion state, client has to resimulate root motion from last AckedMove."""

	@property
	def bSimGravityDisabled(self) -> bool: ...
	"""Disable simulated gravity (set when character encroaches geometry on client, to keep him from falling through floors)"""

	@property
	def bClientCheckEncroachmentOnNetUpdate(self) -> bool: ...
	"""Client Check Encroachment on Net Update"""

	@property
	def bServerMoveIgnoreRootMotion(self) -> bool: ...
	"""Disable root motion on the server. When receiving a DualServerMove, where the first move is not root motion and the second is."""

	@property
	def bWasJumping(self) -> bool: ...
	"""Tracks whether or not the character was already jumping last frame."""

	@property
	def JumpKeyHoldTime(self) -> float: ...
	"""Jump key Held Time.
This is the time that the player has held the jump key, in seconds."""

	@property
	def JumpForceTimeRemaining(self) -> float: ...
	"""Amount of jump force time remaining, if JumpMaxHoldTime > 0."""

	@property
	def ProxyJumpForceStartedTime(self) -> float: ...
	"""Track last time a jump force started for a proxy."""

	@property
	def JumpMaxHoldTime(self) -> float: ...
	"""The max time the jump key can be held.
Note that if StopJumping() is not called before the max jump hold time is reached,
then the character will carry on receiving vertical velocity. Therefore it is usually
best to call StopJumping() when jump input has ceased (such as a button up event)."""

	@property
	def JumpMaxCount(self) -> int: ...
	"""The max number of jumps the character can perform.
Note that if JumpMaxHoldTime is non zero and StopJumping is not called, the player
may be able to perform and unlimited number of jumps. Therefore it is usually
best to call StopJumping() when jump input has ceased (such as a button up event)."""

	@property
	def JumpCurrentCount(self) -> int: ...
	"""Tracks the current number of jumps performed.
This is incremented in CheckJumpInput, used in CanJump_Implementation, and reset in OnMovementModeChanged.
When providing overrides for these methods, it's recommended to either manually
increment / reset this value, or call the Super:: method."""

	@property
	def JumpCurrentCountPreJump(self) -> int: ...
	"""Represents the current number of jumps performed before CheckJumpInput modifies JumpCurrentCount.
This is set in CheckJumpInput and is used in SetMoveFor and PrepMoveFor instead of JumpCurrentCount
since CheckJumpInput can modify JumpCurrentCount.
When providing overrides for these methods, it's recommended to either manually
set this value, or call the Super:: method."""

	@property
	def OnReachedJumpApex(self) -> typing.Any: ...
	"""Broadcast when Character's jump reaches its apex. Needs CharacterMovement->bNotifyApex = true"""

	@property
	def MovementModeChangedDelegate(self) -> typing.Any: ...
	"""Multicast delegate for MovementMode changing."""

	@property
	def OnCharacterMovementUpdated(self) -> typing.Any: ...
	"""Event triggered at the end of a CharacterMovementComponent movement update.
This is the preferred event to use rather than the Tick event when performing custom updates to CharacterMovement properties based on the current state.
This is mainly due to the nature of network updates, where client corrections in position from the server can cause multiple iterations of a movement update,
which allows this event to update as well, while a Tick event would not.

@param       DeltaSeconds            Delta time in seconds for this update
@param       InitialLocation         Location at the start of the update. May be different than the current location if movement occurred.
@param       InitialVelocity         Velocity at the start of the update. May be different than the current velocity."""

	@property
	def SavedRootMotion(self) -> typing.Any: ...
	"""For LocallyControlled Autonomous clients.
During a PerformMovement() after root motion is prepared, we save it off into this and
then record it into our SavedMoves.
During SavedMove playback we use it as our 'Previous Move' SavedRootMotion which includes
last received root motion from the Server"""

	@property
	def ClientRootMotionParams(self) -> typing.Any: ...
	"""For LocallyControlled Autonomous clients. Saved root motion data to be used by SavedMoves."""

	@property
	def RootMotionRepMoves(self) -> typing.List[unsupported]: ...
	"""Array of previously received root motion moves from the server."""

	@property
	def RepRootMotion(self) -> typing.Any: ...
	"""Replicated Root Motion montage"""

	def GetAnimRootMotionTranslationScale(self) -> float: ...
	"""Returns current value of AnimRootMotionScale"""

	def IsPlayingNetworkedRootMotionMontage(self) -> bool: ...
	"""True if we are playing Root Motion right now, through a Montage with RootMotionMode == ERootMotionMode::RootMotionFromMontagesOnly.
This means code path for networked root motion is enabled."""

	def HasAnyRootMotion(self) -> bool: ...
	"""True if we are playing root motion from any source right now (anim root motion, root motion source)"""

	def IsPlayingRootMotion(self) -> bool: ...
	"""True if we are playing Anim root motion right now"""

	def OnRep_RootMotion(self): ...
	"""Handles replicated root motion properties on simulated proxies and position correction."""

	def RootMotionDebugClientPrintOnScreen(self, InString: str): ...
	"""Root Motion Debug Client Print on Screen"""

	def ClientCheatGhost(self): ...
	"""Client Cheat Ghost"""

	def ClientCheatFly(self): ...
	"""Client Cheat Fly"""

	def ClientCheatWalk(self): ...
	"""Client Cheat Walk"""

	def CanCrouch(self) -> bool: ...
	"""@return true if this character is currently able to crouch (and is not currently crouched)"""

	def UnCrouch(self, bClientSimulation: bool = ...): ...
	"""Request the character to stop crouching. The request is processed on the next update of the CharacterMovementComponent.
@see OnEndCrouch
@see IsCrouched
@see CharacterMovement->WantsToCrouch"""

	def Crouch(self, bClientSimulation: bool = ...): ...
	"""Request the character to start crouching. The request is processed on the next update of the CharacterMovementComponent.
@see OnStartCrouch
@see IsCrouched
@see CharacterMovement->WantsToCrouch"""

	def OnWalkingOffLedge(self, PreviousFloorImpactNormal: Vector, PreviousFloorContactNormal: Vector, PreviousLocation: Vector, TimeDelta: float): ...
	"""Event fired when the Character is walking off a surface and is about to fall because CharacterMovement->CurrentFloor became unwalkable.
If CharacterMovement->MovementMode does not change during this event then the character will automatically start falling afterwards.
@note Z velocity is zero during walking movement, and will be here as well. Another velocity can be computed here if desired and will be used when starting to fall.

@param  PreviousFloorImpactNormal Normal of the previous walkable floor.
@param  PreviousFloorContactNormal Normal of the contact with the previous walkable floor.
@param  PreviousLocation     Previous character location before movement off the ledge.
@param  TimeTick     Time delta of movement update resulting in moving off the ledge."""

	def OnJumped(self): ...
	"""Event fired when the character has just started jumping"""

	def LaunchCharacter(self, LaunchVelocity: Vector, bXYOverride: bool, bZOverride: bool): ...
	"""Set a pending launch velocity on the Character. This velocity will be processed on the next CharacterMovementComponent tick,
and will set it to the 'falling' state. Triggers the OnLaunched event.
@PARAM LaunchVelocity is the velocity to impart to the Character
@PARAM bXYOverride if true replace the XY part of the Character's velocity instead of adding to it.
@PARAM bZOverride if true replace the Z component of the Character's velocity instead of adding to it."""

	def GetCurrentMontage(self) -> AnimMontage: ...
	"""Return current playing Montage *"""

	def StopAnimMontage(self, AnimMontage: AnimMontage = ...): ...
	"""Stop Animation Montage. If nullptr, it will stop what's currently active. The Blend Out Time is taken from the montage asset that is being stopped. *"""

	def PlayAnimMontage(self, AnimMontage: AnimMontage, InPlayRate: float = ..., StartSectionName: str = ...) -> float: ...
	"""Play Animation Montage on the character mesh. Returns the length of the animation montage in seconds, or 0.f if failed to play. *"""

	def IsJumpProvidingForce(self) -> bool: ...
	"""True if jump is actively providing a force, such as when the jump key is held and the time it has been held is less than JumpMaxHoldTime.
@see CharacterMovement->IsFalling"""

	def CanJump(self) -> bool: ...
	"""Check if the character can jump in the current state.

The default implementation may be overridden or extended by implementing the custom CanJump event in Blueprints.

@Return Whether the character can jump in the current state."""

	def StopJumping(self): ...
	"""Stop the character from jumping on the next update.
Call this from an input event (such as a button 'up' event) to cease applying
jump Z-velocity. If this is not called, then jump z-velocity will be applied
until JumpMaxHoldTime is reached."""

	def Jump(self): ...
	"""Make the character jump on the next update.
If you want your character to jump according to the time that the jump key is held,
then you can set JumpKeyHoldTime to some non-zero value. Make sure in this case to
call StopJumping() when you want the jump's z-velocity to stop being applied (such
as on a button up event), otherwise the character will carry on receiving the
velocity until JumpKeyHoldTime is reached."""

	def OnRep_IsCrouched(self): ...
	"""Handle Crouching replicated from server"""

	def GetBaseRotationOffset(self) -> Rotator: ...
	"""Get the saved rotation offset of mesh. This is how much extra rotation is applied from the capsule rotation."""

	def GetBaseTranslationOffset(self) -> Vector: ...
	"""Get the saved translation offset of mesh. This is how much extra offset is applied from the center of the capsule."""

	def OnRep_ReplayLastTransformUpdateTimeStamp(self): ...
	"""On Rep Replay Last Transform Update Time Stamp"""

	def OnRep_ReplicatedBasedMovement(self): ...
	"""Rep notify for ReplicatedBasedMovement"""

	def CacheInitialMeshOffset(self, MeshRelativeLocation: Vector, MeshRelativeRotation: Rotator): ...
	"""Cache mesh offset from capsule. This is used as the target for network smoothing interpolation, when the mesh is offset with lagged smoothing.
This is automatically called during initialization; call this at runtime if you intend to change the default mesh offset from the capsule.
@see GetBaseTranslationOffset(), GetBaseRotationOffset()"""

	def ClientAdjustRootMotionSourcePosition(self, TimeStamp: float, ServerRootMotion, bHasAnimRootMotion: bool, ServerMontageTrackPosition: float, ServerLoc: Vector, ServerRotation: Vector_NetQuantizeNormal, ServerVelZ: float, ServerBase: PrimitiveComponent, ServerBoneName: str, bHasBase: bool, bBaseRelativePosition: bool, ServerMovementMode: int): ...
	"""Client Adjust Root Motion Source Position"""

	def ClientAdjustRootMotionPosition(self, TimeStamp: float, ServerMontageTrackPosition: float, ServerLoc: Vector, ServerRotation: Vector_NetQuantizeNormal, ServerVelZ: float, ServerBase: PrimitiveComponent, ServerBoneName: str, bHasBase: bool, bBaseRelativePosition: bool, ServerMovementMode: int): ...
	"""Client Adjust Root Motion Position"""

	def ClientVeryShortAdjustPosition(self, TimeStamp: float, NewLoc: Vector, NewBase: PrimitiveComponent, NewBaseBoneName: str, bHasBase: bool, bBaseRelativePosition: bool, ServerMovementMode: int): ...
	"""Bandwidth saving version, when velocity is zeroed"""

	def ClientAdjustPosition(self, TimeStamp: float, NewLoc: Vector, NewVel: Vector, NewBase: PrimitiveComponent, NewBaseBoneName: str, bHasBase: bool, bBaseRelativePosition: bool, ServerMovementMode: int): ...
	"""Client Adjust Position"""

	def ClientAckGoodMove(self, TimeStamp: float): ...
	"""Client Ack Good Move"""

	def ClientMoveResponsePacked(self, PackedBits): ...
	"""Client RPC that passes through to CharacterMovement (avoids RPC overhead for components)."""

	def GetPyProxy(self) -> object: ...

	pass

class NavMovementComponent(MovementComponent):
	"""NavMovementComponent defines base functionality for MovementComponents that move any 'agent' that may be involved in AI pathfinding."""

	@property
	def NavAgentProps(self) -> NavAgentProperties: ...
	"""Properties that define how the component can move."""

	@property
	def MovementState(self) -> MovementProperties: ...
	"""Expresses runtime state of character's movement. Put all temporal changes to movement properties here"""

	def IsFlying(self) -> bool: ...
	"""Returns true if currently flying (moving through a non-fluid volume without resting on the ground)"""

	def IsSwimming(self) -> bool: ...
	"""Returns true if currently swimming (moving through a fluid volume)"""

	def IsMovingOnGround(self) -> bool: ...
	"""Returns true if currently moving on the ground (e.g. walking or driving)"""

	def IsFalling(self) -> bool: ...
	"""Returns true if currently falling (not flying, in a non-fluid volume, and not on the ground)"""

	def IsCrouching(self) -> bool: ...
	"""Returns true if currently crouching"""

	def StopMovementKeepPathing(self): ...
	"""Stops movement immediately (reset velocity) but keeps following current path"""

	def StopActiveMovement(self): ...
	"""Stops applying further movement (usually zeros acceleration)."""

	pass

class PawnMovementComponent(NavMovementComponent):
	"""PawnMovementComponent can be used to update movement for an associated Pawn.
It also provides ways to accumulate and read directional input in a generic way (with AddInputVector(), ConsumeInputVector(), etc).
See: APawn"""

	def GetPawnOwner(self) -> Pawn: ...
	"""Return the Pawn that owns UpdatedComponent."""

	def IsMoveInputIgnored(self) -> bool: ...
	"""Helper to see if move input is ignored. If there is no Pawn or UpdatedComponent, returns true, otherwise defers to the Pawn's implementation of IsMoveInputIgnored()."""

	def ConsumeInputVector(self) -> Vector: ...
	"""Returns the pending input vector and resets it to zero.
       * This should be used during a movement update (by the Pawn or PawnMovementComponent) to prevent accumulation of control input between frames.
       * Copies the pending input vector to the saved input vector (GetLastMovementInputVector()).
       * @return The pending input vector."""

	def GetLastInputVector(self) -> Vector: ...
	"""Return the last input vector in world space that was processed by ConsumeInputVector(), which is usually done by the Pawn or PawnMovementComponent.
Any user that needs to know about the input that last affected movement should use this function.
@return The last input vector in world space that was processed by ConsumeInputVector().
@see AddInputVector(), ConsumeInputVector(), GetPendingInputVector()"""

	def GetPendingInputVector(self) -> Vector: ...
	"""Return the pending input vector in world space. This is the most up-to-date value of the input vector, pending ConsumeMovementInputVector() which clears it.
PawnMovementComponents implementing movement usually want to use either this or ConsumeInputVector() as these functions represent the most recent state of input.
@return The pending input vector in world space.
@see AddInputVector(), ConsumeInputVector(), GetLastInputVector()"""

	def AddInputVector(self, WorldVector: Vector, bForce: bool = ...): ...
	"""Adds the given vector to the accumulated input in world space. Input vectors are usually between 0 and 1 in magnitude.
They are accumulated during a frame then applied as acceleration during the movement update.

@param WorldDirection        Direction in world space to apply input
@param ScaleValue            Scale to apply to input. This can be used for analog input, ie a value of 0.5 applies half the normal value.
@param bForce                        If true always add the input, ignoring the result of IsMoveInputIgnored().
@see APawn::AddMovementInput()"""

	pass

class CharacterMovementComponent(PawnMovementComponent):
	"""CharacterMovementComponent handles movement logic for the associated Character owner.
It supports various movement modes including: walking, falling, swimming, flying, custom.

Movement is affected primarily by current Velocity and Acceleration. Acceleration is updated each frame
based on the input vector accumulated thus far (see UPawnMovementComponent::GetPendingInputVector()).

Networking is fully implemented, with server-client correction and prediction included.

See: ACharacter, UPawnMovementComponent
See: https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Pawn/Character/"""

	@property
	def GravityScale(self) -> float: ...
	"""Custom gravity scale. Gravity is multiplied by this amount for the character."""

	@property
	def MaxStepHeight(self) -> float: ...
	"""Maximum height character can step up"""

	@property
	def JumpZVelocity(self) -> float: ...
	"""Initial velocity (instantaneous vertical acceleration) when jumping."""

	@property
	def JumpOffJumpZFactor(self) -> float: ...
	"""Fraction of JumpZVelocity to use when automatically 'jumping off' of a base actor that's not allowed to be a base for a character. (For example, if you're not allowed to stand on other players.)"""

	@property
	def MovementMode(self) -> int: ...
	"""Actor's current movement mode (walking, falling, etc).
   - walking:  Walking on a surface, under the effects of friction, and able to 'step up' barriers. Vertical velocity is zero.
   - falling:  Falling under the effects of gravity, after jumping or walking off the edge of a surface.
   - flying:   Flying, ignoring the effects of gravity.
   - swimming: Swimming through a fluid volume, under the effects of gravity and buoyancy.
   - custom:   User-defined custom movement mode, including many possible sub-modes.
This is automatically replicated through the Character owner and for client-server movement functions.
See: SetMovementMode(), CustomMovementMode"""

	@property
	def CustomMovementMode(self) -> int: ...
	"""Current custom sub-mode if MovementMode is set to Custom.
This is automatically replicated through the Character owner and for client-server movement functions.
See: SetMovementMode()"""

	@property
	def NetworkSmoothingMode(self) -> int: ...
	"""Smoothing mode for simulated proxies in network game."""

	@property
	def GroundFriction(self) -> float: ...
	"""Setting that affects movement control. Higher values allow faster changes in direction.
If bUseSeparateBrakingFriction is false, also affects the ability to stop more quickly when braking (whenever Acceleration is zero), where it is multiplied by BrakingFrictionFactor.
When braking, this property allows you to control how much friction is applied when moving across the ground, applying an opposing force that scales with current velocity.
This can be used to simulate slippery surfaces such as ice or oil by changing the value (possibly based on the material pawn is standing on).
See: BrakingDecelerationWalking, BrakingFriction, bUseSeparateBrakingFriction, BrakingFrictionFactor"""

	@property
	def MaxWalkSpeed(self) -> float: ...
	"""The maximum ground speed when walking. Also determines maximum lateral speed when falling."""

	@property
	def MaxWalkSpeedCrouched(self) -> float: ...
	"""The maximum ground speed when walking and crouched."""

	@property
	def MaxSwimSpeed(self) -> float: ...
	"""The maximum swimming speed."""

	@property
	def MaxFlySpeed(self) -> float: ...
	"""The maximum flying speed."""

	@property
	def MaxCustomMovementSpeed(self) -> float: ...
	"""The maximum speed when using Custom movement mode."""

	@property
	def MaxAcceleration(self) -> float: ...
	"""Max Acceleration (rate of change of velocity)"""

	@property
	def MinAnalogWalkSpeed(self) -> float: ...
	"""The ground speed that we should accelerate up to when walking at minimum analog stick tilt"""

	@property
	def BrakingFrictionFactor(self) -> float: ...
	"""Factor used to multiply actual value of friction used when braking.
This applies to any friction value that is currently used, which may depend on bUseSeparateBrakingFriction.
@note This is 2 by default for historical reasons, a value of 1 gives the true drag equation.
See: bUseSeparateBrakingFriction, GroundFriction, BrakingFriction"""

	@property
	def BrakingFriction(self) -> float: ...
	"""Friction (drag) coefficient applied when braking (whenever Acceleration = 0, or if character is exceeding max speed); actual value used is this multiplied by BrakingFrictionFactor.
When braking, this property allows you to control how much friction is applied when moving across the ground, applying an opposing force that scales with current velocity.
Braking is composed of friction (velocity-dependent drag) and constant deceleration.
This is the current value, used in all movement modes; if this is not desired, override it or bUseSeparateBrakingFriction when movement mode changes.
@note Only used if bUseSeparateBrakingFriction setting is true, otherwise current friction such as GroundFriction is used.
See: bUseSeparateBrakingFriction, BrakingFrictionFactor, GroundFriction, BrakingDecelerationWalking"""

	@property
	def BrakingSubStepTime(self) -> float: ...
	"""Time substepping when applying braking friction. Smaller time steps increase accuracy at the slight cost of performance, especially if there are large frame times."""

	@property
	def BrakingDecelerationWalking(self) -> float: ...
	"""Deceleration when walking and not applying acceleration. This is a constant opposing force that directly lowers velocity by a constant value.
See: GroundFriction, MaxAcceleration"""

	@property
	def BrakingDecelerationFalling(self) -> float: ...
	"""Lateral deceleration when falling and not applying acceleration.
See: MaxAcceleration"""

	@property
	def BrakingDecelerationSwimming(self) -> float: ...
	"""Deceleration when swimming and not applying acceleration.
See: MaxAcceleration"""

	@property
	def BrakingDecelerationFlying(self) -> float: ...
	"""Deceleration when flying and not applying acceleration.
See: MaxAcceleration"""

	@property
	def AirControl(self) -> float: ...
	"""When falling, amount of lateral movement control available to the character.
0 = no control, 1 = full control at max speed of MaxWalkSpeed."""

	@property
	def AirControlBoostMultiplier(self) -> float: ...
	"""When falling, multiplier applied to AirControl when lateral velocity is less than AirControlBoostVelocityThreshold.
Setting this to zero will disable air control boosting. Final result is clamped at 1."""

	@property
	def AirControlBoostVelocityThreshold(self) -> float: ...
	"""When falling, if lateral velocity magnitude is less than this value, AirControl is multiplied by AirControlBoostMultiplier.
Setting this to zero will disable air control boosting."""

	@property
	def FallingLateralFriction(self) -> float: ...
	"""Friction to apply to lateral air movement when falling.
If bUseSeparateBrakingFriction is false, also affects the ability to stop more quickly when braking (whenever Acceleration is zero).
See: BrakingFriction, bUseSeparateBrakingFriction"""

	@property
	def CrouchedHalfHeight(self) -> float: ...
	"""Collision half-height when crouching (component scale is applied separately)"""

	@property
	def Buoyancy(self) -> float: ...
	"""Water buoyancy. A ratio (1.0 = neutral buoyancy, 0.0 = no buoyancy)"""

	@property
	def PerchRadiusThreshold(self) -> float: ...
	"""Don't allow the character to perch on the edge of a surface if the contact is this close to the edge of the capsule.
Note that characters will not fall off if they are within MaxStepHeight of a walkable surface below."""

	@property
	def PerchAdditionalHeight(self) -> float: ...
	"""When perching on a ledge, add this additional distance to MaxStepHeight when determining how high above a walkable floor we can perch.
Note that we still enforce MaxStepHeight to start the step up; this just allows the character to hang off the edge or step slightly higher off the floor.
(See: PerchRadiusThreshold)"""

	@property
	def RotationRate(self) -> Rotator: ...
	"""Change in rotation per second, used when UseControllerDesiredRotation or OrientRotationToMovement are true. Set a negative value for infinite rotation rate and instant turns."""

	@property
	def bUseSeparateBrakingFriction(self) -> bool: ...
	"""If true, BrakingFriction will be used to slow the character to a stop (when there is no Acceleration).
If false, braking uses the same friction passed to CalcVelocity() (ie GroundFriction when walking), multiplied by BrakingFrictionFactor.
This setting applies to all movement modes; if only desired in certain modes, consider toggling it when movement modes change.
See: BrakingFriction"""

	@property
	def bApplyGravityWhileJumping(self) -> bool: ...
	"""Apply gravity while the character is actively jumping (e.g. holding the jump key).
Helps remove frame-rate dependent jump height, but may alter base jump height."""

	@property
	def bUseControllerDesiredRotation(self) -> bool: ...
	"""If true, smoothly rotate the Character toward the Controller's desired rotation (typically Controller->ControlRotation), using RotationRate as the rate of rotation change. Overridden by OrientRotationToMovement.
Normally you will want to make sure that other settings are cleared, such as bUseControllerRotationYaw on the Character."""

	@property
	def bOrientRotationToMovement(self) -> bool: ...
	"""If true, rotate the Character toward the direction of acceleration, using RotationRate as the rate of rotation change. Overrides UseControllerDesiredRotation.
Normally you will want to make sure that other settings are cleared, such as bUseControllerRotationYaw on the Character."""

	@property
	def bSweepWhileNavWalking(self) -> bool: ...
	"""Whether or not the character should sweep for collision geometry while walking.
See: USceneComponent::MoveComponent."""

	@property
	def bEnableScopedMovementUpdates(self) -> bool: ...
	"""If true, high-level movement updates will be wrapped in a movement scope that accumulates updates and defers a bulk of the work until the end.
When enabled, touch and hit events will not be triggered until the end of multiple moves within an update, which can improve performance.

See: FScopedMovementUpdate"""

	@property
	def bEnableServerDualMoveScopedMovementUpdates(self) -> bool: ...
	"""Optional scoped movement update to combine moves for cheaper performance on the server when the client sends two moves in one packet.
Be warned that since this wraps a larger scope than is normally done with bEnableScopedMovementUpdates, this can result in subtle changes in behavior
in regards to when overlap events are handled, when attached components are moved, etc.

See: bEnableScopedMovementUpdates"""

	@property
	def bForceMaxAccel(self) -> bool: ...
	"""Ignores size of acceleration component, and forces max acceleration to drive character at full velocity."""

	@property
	def bRunPhysicsWithNoController(self) -> bool: ...
	"""If true, movement will be performed even if there is no Controller for the Character owner.
Normally without a Controller, movement will be aborted and velocity and acceleration are zeroed if the character is walking.
Characters that are spawned without a Controller but with this flag enabled will initialize the movement mode to DefaultLandMovementMode or DefaultWaterMovementMode appropriately.
See: DefaultLandMovementMode, DefaultWaterMovementMode"""

	@property
	def bForceNextFloorCheck(self) -> bool: ...
	"""Force the Character in MOVE_Walking to do a check for a valid floor even if he hasn't moved. Cleared after next floor check.
Normally if bAlwaysCheckFloor is false we try to avoid the floor check unless some conditions are met, but this can be used to force the next check to always run."""

	@property
	def bShrinkProxyCapsule(self) -> bool: ...
	"""If true, the capsule needs to be shrunk on this simulated proxy, to avoid replication rounding putting us in geometry.
Whenever this is set to true, this will cause the capsule to be shrunk again on the next update, and then set to false."""

	@property
	def bCanWalkOffLedges(self) -> bool: ...
	"""If true, Character can walk off a ledge."""

	@property
	def bCanWalkOffLedgesWhenCrouching(self) -> bool: ...
	"""If true, Character can walk off a ledge when crouching."""

	@property
	def bNetworkSkipProxyPredictionOnNetUpdate(self) -> bool: ...
	"""Whether we skip prediction on frames where a proxy receives a network update. This can avoid expensive prediction on those frames,
with the side-effect of predicting with a frame of additional latency."""

	@property
	def bNetworkAlwaysReplicateTransformUpdateTimestamp(self) -> bool: ...
	"""Flag used on the server to determine whether to always replicate ReplicatedServerLastTransformUpdateTimeStamp to clients.
Normally this is only sent when the network smoothing mode on character movement is set to Linear smoothing (on the server), to save bandwidth.
Setting this to true will force the timestamp to replicate regardless, in case the server doesn't know about the smoothing mode, or if the timestamp is used for another purpose."""

	@property
	def bDeferUpdateMoveComponent(self) -> bool: ...
	"""true to update CharacterOwner and UpdatedComponent after movement ends"""

	@property
	def bEnablePhysicsInteraction(self) -> bool: ...
	"""If enabled, the player will interact with physics objects when walking into them."""

	@property
	def bTouchForceScaledToMass(self) -> bool: ...
	"""If enabled, the TouchForceFactor is applied per kg mass of the affected object."""

	@property
	def bPushForceScaledToMass(self) -> bool: ...
	"""If enabled, the PushForceFactor is applied per kg mass of the affected object."""

	@property
	def bPushForceUsingZOffset(self) -> bool: ...
	"""If enabled, the PushForce location is moved using PushForcePointZOffsetFactor. Otherwise simply use the impact point."""

	@property
	def bScalePushForceToVelocity(self) -> bool: ...
	"""If enabled, the applied push force will try to get the physics object to the same velocity than the player, not faster. This will only
              scale the force down, it will never apply more force than defined by PushForceFactor."""

	@property
	def DeferredUpdatedMoveComponent(self) -> SceneComponent: ...
	"""What to update CharacterOwner and UpdatedComponent after movement ends"""

	@property
	def MaxOutOfWaterStepHeight(self) -> float: ...
	"""Maximum step height for getting out of water"""

	@property
	def OutofWaterZ(self) -> float: ...
	"""Z velocity applied when pawn tries to get out of water"""

	@property
	def Mass(self) -> float: ...
	"""Mass of pawn (for when momentum is imparted to it)."""

	@property
	def StandingDownwardForceScale(self) -> float: ...
	"""Force applied to objects we stand on (due to Mass and Gravity) is scaled by this amount."""

	@property
	def InitialPushForceFactor(self) -> float: ...
	"""Initial impulse force to apply when the player bounces into a blocking physics object."""

	@property
	def PushForceFactor(self) -> float: ...
	"""Force to apply when the player collides with a blocking physics object."""

	@property
	def PushForcePointZOffsetFactor(self) -> float: ...
	"""Z-Offset for the position the force is applied to. 0.0f is the center of the physics object, 1.0f is the top and -1.0f is the bottom of the object."""

	@property
	def TouchForceFactor(self) -> float: ...
	"""Force to apply to physics objects that are touched by the player."""

	@property
	def MinTouchForce(self) -> float: ...
	"""Minimum Force applied to touched physics objects. If < 0.0f, there is no minimum."""

	@property
	def MaxTouchForce(self) -> float: ...
	"""Maximum force applied to touched physics objects. If < 0.0f, there is no maximum."""

	@property
	def RepulsionForce(self) -> float: ...
	"""Force per kg applied constantly to all overlapping components."""

	@property
	def MaxSimulationTimeStep(self) -> float: ...
	"""Max time delta for each discrete simulation step.
Used primarily in the the more advanced movement modes that break up larger time steps (usually those applying gravity such as falling and walking).
Lowering this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.

WARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.
See: MaxSimulationIterations"""

	@property
	def MaxSimulationIterations(self) -> int: ...
	"""Max number of iterations used for each discrete simulation step.
Used primarily in the the more advanced movement modes that break up larger time steps (usually those applying gravity such as falling and walking).
Increasing this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.

WARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.
See: MaxSimulationTimeStep"""

	@property
	def MaxJumpApexAttemptsPerSimulation(self) -> int: ...
	"""Max number of attempts per simulation to attempt to exactly reach the jump apex when falling movement reaches the top of the arc.
Limiting this prevents deep recursion when special cases cause collision or other conditions which reactivate the apex condition."""

	@property
	def MaxDepenetrationWithGeometry(self) -> float: ...
	"""Max distance we allow simulated proxies to depenetrate when moving out of anything but Pawns.
This is generally more tolerant than with Pawns, because other geometry is either not moving, or is moving predictably with a bit of delay compared to on the server.
See: MaxDepenetrationWithGeometryAsProxy, MaxDepenetrationWithPawn, MaxDepenetrationWithPawnAsProxy"""

	@property
	def MaxDepenetrationWithGeometryAsProxy(self) -> float: ...
	"""Max distance we allow simulated proxies to depenetrate when moving out of anything but Pawns.
This is generally more tolerant than with Pawns, because other geometry is either not moving, or is moving predictably with a bit of delay compared to on the server.
See: MaxDepenetrationWithGeometry, MaxDepenetrationWithPawn, MaxDepenetrationWithPawnAsProxy"""

	@property
	def MaxDepenetrationWithPawn(self) -> float: ...
	"""Max distance we are allowed to depenetrate when moving out of other Pawns.
See: MaxDepenetrationWithGeometry, MaxDepenetrationWithGeometryAsProxy, MaxDepenetrationWithPawnAsProxy"""

	@property
	def MaxDepenetrationWithPawnAsProxy(self) -> float: ...
	"""Max distance we allow simulated proxies to depenetrate when moving out of other Pawns.
Typically we don't want a large value, because we receive a server authoritative position that we should not then ignore by pushing them out of the local player.
See: MaxDepenetrationWithGeometry, MaxDepenetrationWithGeometryAsProxy, MaxDepenetrationWithPawn"""

	@property
	def NetworkSimulatedSmoothLocationTime(self) -> float: ...
	"""How long to take to smoothly interpolate from the old pawn position on the client to the corrected one sent by the server. Not used by Linear smoothing."""

	@property
	def NetworkSimulatedSmoothRotationTime(self) -> float: ...
	"""How long to take to smoothly interpolate from the old pawn rotation on the client to the corrected one sent by the server. Not used by Linear smoothing."""

	@property
	def ListenServerNetworkSimulatedSmoothLocationTime(self) -> float: ...
	"""Similar setting as NetworkSimulatedSmoothLocationTime but only used on Listen servers."""

	@property
	def ListenServerNetworkSimulatedSmoothRotationTime(self) -> float: ...
	"""Similar setting as NetworkSimulatedSmoothRotationTime but only used on Listen servers."""

	@property
	def NetProxyShrinkRadius(self) -> float: ...
	"""Shrink simulated proxy capsule radius by this amount, to account for network rounding that may cause encroachment. Changing during gameplay is not supported.
See: AdjustProxyCapsuleSize()"""

	@property
	def NetProxyShrinkHalfHeight(self) -> float: ...
	"""Shrink simulated proxy capsule half height by this amount, to account for network rounding that may cause encroachment. Changing during gameplay is not supported.
See: AdjustProxyCapsuleSize()"""

	@property
	def NetworkMaxSmoothUpdateDistance(self) -> float: ...
	"""Maximum distance character is allowed to lag behind server location when interpolating between updates."""

	@property
	def NetworkNoSmoothUpdateDistance(self) -> float: ...
	"""Maximum distance beyond which character is teleported to the new server location without any smoothing."""

	@property
	def NetworkMinTimeBetweenClientAckGoodMoves(self) -> float: ...
	"""Minimum time on the server between acknowledging good client moves. This can save on bandwidth. Set to 0 to disable throttling."""

	@property
	def NetworkMinTimeBetweenClientAdjustments(self) -> float: ...
	"""Minimum time on the server between sending client adjustments when client has exceeded allowable position error.
Should be >= NetworkMinTimeBetweenClientAdjustmentsLargeCorrection (the larger value is used regardless).
This can save on bandwidth. Set to 0 to disable throttling.
See: ServerLastClientAdjustmentTime"""

	@property
	def NetworkMinTimeBetweenClientAdjustmentsLargeCorrection(self) -> float: ...
	"""Minimum time on the server between sending client adjustments when client has exceeded allowable position error by a large amount (NetworkLargeClientCorrectionDistance).
Should be <= NetworkMinTimeBetweenClientAdjustments (the smaller value is used regardless).
See: NetworkMinTimeBetweenClientAdjustments"""

	@property
	def NetworkLargeClientCorrectionDistance(self) -> float: ...
	"""If client error is larger than this, sets bNetworkLargeClientCorrection to reduce delay between client adjustments.
See: NetworkMinTimeBetweenClientAdjustments, NetworkMinTimeBetweenClientAdjustmentsLargeCorrection"""

	@property
	def LedgeCheckThreshold(self) -> float: ...
	"""Used in determining if pawn is going off ledge.  If the ledge is 'shorter' than this value then the pawn will be able to walk off it. *"""

	@property
	def JumpOutOfWaterPitch(self) -> float: ...
	"""When exiting water, jump if control pitch angle is this high or above."""

	@property
	def CurrentFloor(self) -> FindFloorResult: ...
	"""Information about the floor the Character is standing on (updated only during walking movement)."""

	@property
	def DefaultLandMovementMode(self) -> int: ...
	"""Default movement mode when not in water. Used at player startup or when teleported.
See: DefaultWaterMovementMode
See: bRunPhysicsWithNoController"""

	@property
	def DefaultWaterMovementMode(self) -> int: ...
	"""Default movement mode when in water. Used at player startup or when teleported.
See: DefaultLandMovementMode
See: bRunPhysicsWithNoController"""

	@property
	def bMaintainHorizontalGroundVelocity(self) -> bool: ...
	"""If true, walking movement always maintains horizontal velocity when moving up ramps, which causes movement up ramps to be faster parallel to the ramp surface.
If false, then walking movement maintains velocity magnitude parallel to the ramp surface."""

	@property
	def bImpartBaseVelocityX(self) -> bool: ...
	"""If true, impart the base actor's X velocity when falling off it (which includes jumping)"""

	@property
	def bImpartBaseVelocityY(self) -> bool: ...
	"""If true, impart the base actor's Y velocity when falling off it (which includes jumping)"""

	@property
	def bImpartBaseVelocityZ(self) -> bool: ...
	"""If true, impart the base actor's Z velocity when falling off it (which includes jumping)"""

	@property
	def bImpartBaseAngularVelocity(self) -> bool: ...
	"""If true, impart the base component's tangential components of angular velocity when jumping or falling off it.
Only those components of the velocity allowed by the separate component settings (bImpartBaseVelocityX etc) will be applied.
See: bImpartBaseVelocityX, bImpartBaseVelocityY, bImpartBaseVelocityZ"""

	@property
	def bJustTeleported(self) -> bool: ...
	"""Used by movement code to determine if a change in position is based on normal movement or a teleport. If not a teleport, velocity can be recomputed based on the change in position."""

	@property
	def bNetworkUpdateReceived(self) -> bool: ...
	"""True when a network replication update is received for simulated proxies."""

	@property
	def bNetworkMovementModeChanged(self) -> bool: ...
	"""True when the networked movement mode has been replicated."""

	@property
	def bIgnoreClientMovementErrorChecksAndCorrection(self) -> bool: ...
	"""If true, we should ignore server location difference checks for client error on this movement component.
This can be useful when character is moving at extreme speeds for a duration and you need it to look
smooth on clients without the server correcting the client. Make sure to disable when done, as this would
break this character's server-client movement correction.
See: bServerAcceptClientAuthoritativePosition, ServerCheckClientError()"""

	@property
	def bServerAcceptClientAuthoritativePosition(self) -> bool: ...
	"""If true, and server does not detect client position error, server will copy the client movement location/velocity/etc after simulating the move.
This can be useful for short bursts of movement that are difficult to sync over the network.
Note that if bIgnoreClientMovementErrorChecksAndCorrection is used, this means the server will not detect an error.
Also see GameNetworkManager->ClientAuthorativePosition which permanently enables this behavior.
See: bIgnoreClientMovementErrorChecksAndCorrection, ServerShouldUseAuthoritativePosition()"""

	@property
	def bNotifyApex(self) -> bool: ...
	"""If true, event NotifyJumpApex() to CharacterOwner's controller when at apex of jump. Is cleared when event is triggered.
By default this is off, and if you want the event to fire you typically set it to true when movement mode changes to 'Falling' from another mode (see OnMovementModeChanged)."""

	@property
	def bCheatFlying(self) -> bool: ...
	"""Instantly stop when in flying mode and no acceleration is being applied."""

	@property
	def bWantsToCrouch(self) -> bool: ...
	"""If true, try to crouch (or keep crouching) on next update. If false, try to stop crouching on next update."""

	@property
	def bCrouchMaintainsBaseLocation(self) -> bool: ...
	"""If true, crouching should keep the base of the capsule in place by lowering the center of the shrunken capsule. If false, the base of the capsule moves up and the center stays in place.
The same behavior applies when the character uncrouches: if true, the base is kept in the same location and the center moves up. If false, the capsule grows and only moves up if the base impacts something.
By default this variable is set when the movement mode changes: set to true when walking and false otherwise. Feel free to override the behavior when the movement mode changes."""

	@property
	def bIgnoreBaseRotation(self) -> bool: ...
	"""Whether the character ignores changes in rotation of the base it is standing on.
If true, the character maintains current world rotation.
If false, the character rotates with the moving base."""

	@property
	def bFastAttachedMove(self) -> bool: ...
	"""Set this to true if riding on a moving base that you know is clear from non-moving world obstructions.
Optimization to avoid sweeps during based movement, use with care."""

	@property
	def bAlwaysCheckFloor(self) -> bool: ...
	"""Whether we always force floor checks for stationary Characters while walking.
Normally floor checks are avoided if possible when not moving, but this can be used to force them if there are use-cases where they are being skipped erroneously
(such as objects moving up into the character from below)."""

	@property
	def bUseFlatBaseForFloorChecks(self) -> bool: ...
	"""Performs floor checks as if the character is using a shape with a flat base.
This avoids the situation where characters slowly lower off the side of a ledge (as their capsule 'balances' on the edge)."""

	@property
	def bPerformingJumpOff(self) -> bool: ...
	"""Used to prevent reentry of JumpOff()"""

	@property
	def bWantsToLeaveNavWalking(self) -> bool: ...
	"""Used to safely leave NavWalking movement mode"""

	@property
	def bUseRVOAvoidance(self) -> bool: ...
	"""If set, component will use RVO avoidance. This only runs on the server."""

	@property
	def bRequestedMoveUseAcceleration(self) -> bool: ...
	"""Should use acceleration for path following?
If true, acceleration is applied when path following to reach the target velocity.
If false, path following velocity is set directly, disregarding acceleration."""

	@property
	def bWasSimulatingRootMotion(self) -> bool: ...
	"""True when SimulatedProxies are simulating RootMotion"""

	@property
	def bAllowPhysicsRotationDuringAnimRootMotion(self) -> bool: ...
	"""Allow Physics Rotation During Anim Root Motion"""

	@property
	def AvoidanceConsiderationRadius(self) -> float: ...
	"""Avoidance Consideration Radius"""

	@property
	def RequestedVelocity(self) -> Vector: ...
	"""Velocity requested by path following.
See: RequestDirectMove()"""

	@property
	def AvoidanceUID(self) -> int: ...
	"""No default value, for now it's assumed to be valid if GetAvoidanceManager() returns non-NULL."""

	@property
	def AvoidanceGroup(self) -> NavAvoidanceMask: ...
	"""Moving actor's group mask"""

	@property
	def GroupsToAvoid(self) -> NavAvoidanceMask: ...
	"""Will avoid other agents if they are in one of specified groups"""

	@property
	def GroupsToIgnore(self) -> NavAvoidanceMask: ...
	"""Will NOT avoid other agents if they are in one of specified groups, higher priority than GroupsToAvoid"""

	@property
	def AvoidanceWeight(self) -> float: ...
	"""De facto default value 0.5 (due to that being the default in the avoidance registration function), indicates RVO behavior."""

	@property
	def PendingLaunchVelocity(self) -> Vector: ...
	"""Temporarily holds launch velocity when pawn is to be launched so it happens at end of movement."""

	@property
	def NavMeshProjectionInterval(self) -> float: ...
	"""How often we should raycast to project from navmesh to underlying geometry"""

	@property
	def NavMeshProjectionTimer(self) -> float: ...
	"""Nav Mesh Projection Timer"""

	@property
	def NavMeshProjectionInterpSpeed(self) -> float: ...
	"""Speed at which to interpolate agent navmesh offset between traces. 0: Instant (no interp) > 0: Interp speed')"""

	@property
	def NavMeshProjectionHeightScaleUp(self) -> float: ...
	"""Scale of the total capsule height to use for projection from navmesh to underlying geometry in the upward direction.
In other words, start the trace at [CapsuleHeight * NavMeshProjectionHeightScaleUp] above nav mesh."""

	@property
	def NavMeshProjectionHeightScaleDown(self) -> float: ...
	"""Scale of the total capsule height to use for projection from navmesh to underlying geometry in the downward direction.
In other words, trace down to [CapsuleHeight * NavMeshProjectionHeightScaleDown] below nav mesh."""

	@property
	def NavWalkingFloorDistTolerance(self) -> float: ...
	"""Ignore small differences in ground height between server and client data during NavWalking mode"""

	@property
	def PostPhysicsTickFunction(self) -> typing.Any: ...
	"""Post-physics tick function for this character"""

	@property
	def MinTimeBetweenTimeStampResets(self) -> float: ...
	"""Minimum time between client TimeStamp resets.
       !! This has to be large enough so that we don't confuse the server if the client can stall or timeout.
       We do this as we use floats for TimeStamps, and server derives DeltaTime from two TimeStamps.
       As time goes on, accuracy decreases from those floating point numbers.
       So we trigger a TimeStamp reset at regular intervals to maintain a high level of accuracy."""

	@property
	def CurrentRootMotion(self) -> typing.Any: ...
	"""Root Motion Group containing active root motion sources being applied to movement"""

	@property
	def ServerCorrectionRootMotion(self) -> typing.Any: ...
	"""Server Correction Root Motion"""

	@property
	def RootMotionParams(self) -> typing.Any: ...
	"""Root Motion movement params. Holds result of anim montage root motion during PerformMovement(), and is overridden
 during autonomous move playback to force historical root motion for MoveAutonomous() calls"""

	@property
	def AnimRootMotionVelocity(self) -> Vector: ...
	"""Velocity extracted from RootMotionParams when there is anim root motion active. Invalid to use when HasAnimRootMotion() returns false."""

	def ComputeFloorDistance(self, CapsuleLocation: Vector, LineDistance: float, SweepDistance: float, SweepRadius: float) -> FindFloorResult: ...
	"""Compute distance to the floor from bottom sphere of capsule and store the result in FloorResult.
This distance is the swept distance of the capsule to the first point impacted by the lower hemisphere, or distance from the bottom of the capsule in the case of a line trace.
This function does not care if collision is disabled on the capsule (unlike FindFloor).

@param CapsuleLocation                Location where the capsule sweep should originate
@param LineDistance                   If non-zero, max distance to test for a simple line check from the capsule base. Used only if the sweep test fails to find a walkable floor, and only returns a valid result if the impact normal is a walkable normal.
@param SweepDistance                  If non-zero, max distance to use when sweeping a capsule downwards for the test. MUST be greater than or equal to the line distance.
@param SweepRadius                    The radius to use for sweep tests. Should be <= capsule radius.
@param FloorResult                    Result of the floor check"""

	def FindFloor(self, CapsuleLocation: Vector) -> FindFloorResult: ...
	"""Sweeps a vertical trace to find the floor for the capsule at the given location. Will attempt to perch if ShouldComputePerchResult() returns true for the downward sweep result.
No floor will be found if collision is disabled on the capsule!

@param CapsuleLocation                Location where the capsule sweep should originate
@param FloorResult                    Result of the floor check"""

	def SetWalkableFloorZ(self, InWalkableFloorZ: float): ...
	"""Set the Z component of the normal of the steepest walkable surface for the character. Also computes WalkableFloorAngle."""

	def GetWalkableFloorZ(self) -> float: ...
	"""Get the Z component of the normal of the steepest walkable surface for the character. Any lower than this and it is not walkable."""

	def SetWalkableFloorAngle(self, InWalkableFloorAngle: float): ...
	"""Set the max angle in degrees of a walkable surface for the character. Also computes WalkableFloorZ."""

	def GetWalkableFloorAngle(self) -> float: ...
	"""Get the max angle in degrees of a walkable surface for the character."""

	def IsWalkable(self, Hit: HitResult) -> bool: ...
	"""Return true if the hit result should be considered a walkable surface for the character."""

	def GetValidPerchRadius(self) -> float: ...
	"""Returns the radius within which we can stand on the edge of a surface without falling (if this is a walkable surface).
Simply computed as the capsule radius minus the result of GetPerchRadiusThreshold()."""

	def GetPerchRadiusThreshold(self) -> float: ...
	"""Returns The distance from the edge of the capsule within which we don't allow the character to perch on the edge of a surface."""

	def AddForce(self, Force: Vector): ...
	"""Add force to character. Forces are accumulated each tick and applied together
so multiple calls to this function will accumulate.
Forces are scaled depending on timestep, so they can be applied each frame. If you want an
instantaneous force, use AddImpulse.
Adding a force always takes the actor's mass into account.
Note that changing the momentum of characters like this can change the movement mode.

@param       Force                   Force to apply."""

	def AddImpulse(self, Impulse: Vector, bVelocityChange: bool = ...): ...
	"""Add impulse to character. Impulses are accumulated each tick and applied together
so multiple calls to this function will accumulate.
An impulse is an instantaneous force, usually applied once. If you want to continually apply
forces each frame, use AddForce().
Note that changing the momentum of characters like this can change the movement mode.

@param       Impulse                         Impulse to apply.
@param       bVelocityChange         Whether or not the impulse is relative to mass."""

	def ClearAccumulatedForces(self): ...
	"""Clears forces accumulated through AddImpulse() and AddForce(), and also pending launch velocity."""

	def GetAnalogInputModifier(self) -> float: ...
	"""Returns modifier [0..1] based on the magnitude of the last input vector, which is used to modify the acceleration and max speed during movement."""

	def GetCurrentAcceleration(self) -> Vector: ...
	"""Returns current acceleration, computed from input vector each update."""

	def GetMaxBrakingDeceleration(self) -> float: ...
	"""Returns maximum deceleration for the current state when braking (ie when there is no acceleration)."""

	def GetMaxAcceleration(self) -> float: ...
	"""Returns maximum acceleration for the current state."""

	def GetMinAnalogSpeed(self) -> float: ...
	"""Returns maximum acceleration for the current state."""

	def GetMaxJumpHeightWithJumpTime(self) -> float: ...
	"""Compute the max jump height based on the JumpZVelocity velocity and gravity.
This does take into account the CharacterOwner's MaxJumpHoldTime."""

	def GetMaxJumpHeight(self) -> float: ...
	"""Compute the max jump height based on the JumpZVelocity velocity and gravity.
This does not take into account the CharacterOwner's MaxJumpHoldTime."""

	def CalcVelocity(self, DeltaTime: float, Friction: float, bFluid: bool, BrakingDeceleration: float): ...
	"""Updates Velocity and Acceleration based on the current state, applying the effects of friction and acceleration or deceleration. Does not apply gravity.
This is used internally during movement updates. Normally you don't need to call this from outside code, but you might want to use it for custom movement modes.

@param       DeltaTime                                               time elapsed since last frame.
@param       Friction                                                coefficient of friction when not accelerating, or in the direction opposite acceleration.
@param       bFluid                                                  true if moving through a fluid, causing Friction to always be applied regardless of acceleration.
@param       BrakingDeceleration                             deceleration applied when not accelerating, or when exceeding max velocity."""

	def GetImpartedMovementBaseVelocity(self) -> Vector: ...
	"""If we have a movement base, get the velocity that should be imparted by that base, usually when jumping off of it.
Only applies the components of the velocity enabled by bImpartBaseVelocityX, bImpartBaseVelocityY, bImpartBaseVelocityZ."""

	def GetMovementBase(self) -> PrimitiveComponent: ...
	"""Return PrimitiveComponent we are based on (standing and walking on)."""

	def DisableMovement(self): ...
	"""Make movement impossible (sets movement mode to MOVE_None)."""

	def IsWalking(self) -> bool: ...
	"""Returns true if the character is in the 'Walking' movement mode."""

	def SetMovementMode(self, NewMovementMode: int, NewCustomMode: int = ...): ...
	"""Change movement mode.

@param NewMovementMode       The new movement mode
@param NewCustomMode         The new custom sub-mode, only applicable if NewMovementMode is Custom."""

	def GetCharacterOwner(self) -> Character: ...
	"""Get the Character that owns UpdatedComponent."""

	def SetAvoidanceEnabled(self, bEnable: bool): ...
	"""Change avoidance state and registers in RVO manager if needed"""

	def SetGroupsToIgnoreMask(self, GroupMask: NavAvoidanceMask): ...
	"""Set Groups to Ignore Mask"""

	def SetGroupsToAvoidMask(self, GroupMask: NavAvoidanceMask): ...
	"""Set Groups to Avoid Mask"""

	def SetAvoidanceGroupMask(self, GroupMask: NavAvoidanceMask): ...
	"""Set Avoidance Group Mask"""

	def GetLastUpdateVelocity(self) -> Vector: ...
	"""Returns the velocity at the end of the last tick."""

	def GetLastUpdateRotation(self) -> Rotator: ...
	"""Returns the rotation at the end of the last tick."""

	def GetLastUpdateLocation(self) -> Vector: ...
	"""Returns the location at the end of the last tick."""

	pass

class CheatManager(Object):
	"""Cheat Manager is a central blueprint to implement test and debug code and actions that are not to ship with the game.
As the Cheat Manager is not instanced in shipping builds, it is for debugging purposes only"""

	@property
	def DebugCameraControllerRef(self) -> DebugCameraController: ...
	"""Debug camera - used to have independent camera without stopping gameplay"""

	@property
	def DebugCameraControllerClass(self) -> DebugCameraController: ...
	"""Debug camera - used to have independent camera without stopping gameplay"""

	def UpdateSafeArea(self): ...
	"""Update Safe Area"""

	def ToggleServerStatReplicatorUpdateStatNet(self): ...
	"""Toggle Server Stat Replicator Update Stat Net"""

	def ToggleServerStatReplicatorClientOverwrite(self): ...
	"""Toggle Server Stat Replicator Client Overwrite"""

	def DestroyServerStatReplicator(self): ...
	"""Destroy Server Stat Replicator"""

	def SpawnServerStatReplicator(self): ...
	"""Spawn Server Stat Replicator"""

	def CheatScript(self, ScriptName: str): ...
	"""Executes commands listed in CheatScript.ScriptName ini section of DefaultGame.ini"""

	def InvertMouse(self): ...
	"""Backwards compatibility exec function for people used to it instead of using InvertAxisKey"""

	def SetMouseSensitivityToDefault(self): ...
	"""Exec function to return the mouse sensitivity to its default value"""

	def SetWorldOrigin(self): ...
	"""Translate world origin to this player position"""

	def LogLoc(self): ...
	"""Logs the current location in bugit format without taking screenshot and further routing."""

	def FlushLog(self): ...
	"""This will force a flush of the output log to file"""

	def BugItStringCreator(self, ViewLocation: Vector, ViewRotation: Rotator) -> typing.Tuple[str, str]: ...
	"""This will create a BugItGo string for us.  Nice for calling form c++ where you just want the string and no Screenshots *"""

	def BugIt(self, ScreenShotDescription: str = ...): ...
	"""This function is used to print out the BugIt location.  It prints out copy and paste versions for both IMing someone to type in
and also a gameinfo ?options version so that you can append it to your launching url and be taken to the correct place.
Additionally, it will take a screen shot so reporting bugs is a one command action!"""

	def BugItGo(self, X: float, Y: float, Z: float, Pitch: float, Yaw: float, Roll: float): ...
	"""This will move the player and set their rotation to the passed in values.
We have this version of the BugIt family as it is easier to type in just raw numbers in the console."""

	def DumpVoiceMutingState(self): ...
	"""Dump current state of voice chat"""

	def DumpChatState(self): ...
	"""Dump known chat information"""

	def DumpPartyState(self): ...
	"""Dump known party information"""

	def DumpOnlineSessionState(self): ...
	"""Dump online session information"""

	def TestCollisionDistance(self): ...
	"""Test all volumes in the world to the player controller's view location*"""

	def DebugCapsuleSweepClear(self): ...
	"""Clear persistent list for trace capture *"""

	def DebugCapsuleSweepPawn(self): ...
	"""Capture current local PC's pawn's location and add to persistent list *"""

	def DebugCapsuleSweepCapture(self): ...
	"""Capture current trace and add to persistent list *"""

	def DebugCapsuleSweepComplex(self, bTraceComplex: bool): ...
	"""Change Trace Complex setting *"""

	def DebugCapsuleSweepChannel(self, Channel: int): ...
	"""Change Trace Channel *"""

	def DebugCapsuleSweepSize(self, HalfHeight: float, Radius: float): ...
	"""Change Trace capsule size *"""

	def DebugCapsuleSweep(self): ...
	"""Toggle capsule trace debugging. Will trace a capsule from current view point and show where it hits the world"""

	def ToggleAILogging(self): ...
	"""toggles AI logging"""

	def ToggleDebugCamera(self): ...
	"""Toggle between debug camera/player camera without locking gameplay and with locking local player controller input."""

	def StreamLevelOut(self, PackageName: str): ...
	"""Stream out the given level."""

	def OnlyLoadLevel(self, PackageName: str): ...
	"""Load the given level."""

	def StreamLevelIn(self, PackageName: str): ...
	"""Stream in the given level."""

	def ViewClass(self, DesiredClass: Actor): ...
	"""View from the point of view of an AActor of class DesiredClass.  Each subsequent ViewClass cycles through the list of actors of that class."""

	def ViewActor(self, ActorName: str): ...
	"""View from the point of view of AActor with Name ActorName."""

	def ViewPlayer(self, S: str): ...
	"""View from the point of view of player with PlayerName S."""

	def ViewSelf(self): ...
	"""Make controlled pawn the viewtarget again."""

	def PlayersOnly(self): ...
	"""Freeze everything in the level except for players."""

	def Summon(self, ClassName: str): ...
	"""Load Classname and spawn an actor of that class"""

	def DestroyPawns(self, aClass: Pawn): ...
	"""Destroys (by calling destroy directly) all non-player pawns of class aClass in the level"""

	def DestroyAllPawnsExceptTarget(self): ...
	"""Destroy all pawns except for the (pawn) target.  If no (pawn) target is found we don't destroy anything."""

	def DestroyAll(self, aClass: Actor): ...
	"""Destroy all actors of class aClass"""

	def DestroyTarget(self): ...
	"""Destroy the actor you're looking at."""

	def DamageTarget(self, DamageAmount: float): ...
	"""Damage the actor you're looking at (sourced from the player)."""

	def Slomo(self, NewTimeDilation: float): ...
	"""Modify time dilation to change apparent speed of passage of time. e.g. 'Slomo 0.1' makes everything move very slowly, while 'Slomo 10' makes everything move very fast."""

	def God(self): ...
	"""Invulnerability cheat."""

	def Ghost(self): ...
	"""Pawn no longer collides with the world, and can fly"""

	def Walk(self): ...
	"""Return to walking movement mode from Fly or Ghost cheat."""

	def Fly(self): ...
	"""Pawn can fly."""

	def ChangeSize(self, F: float): ...
	"""Scale the player's size to be F * default size."""

	def Teleport(self): ...
	"""Teleport to surface player is looking at."""

	def FreezeFrame(self, Delay: float): ...
	"""Pause the game for Delay seconds."""

	pass

class DamageType(Object):
	"""A DamageType is intended to define and describe a particular form of damage and to provide an avenue
for customizing responses to damage from various sources.

For example, a game could make a DamageType_Fire set it up to ignite the damaged actor.

DamageTypes are never instanced and should be treated as immutable data holders with static code
functionality.  They should never be stateful."""

	@property
	def bCausedByWorld(self) -> bool: ...
	"""True if this damagetype is caused by the world (falling off level, into lava, etc)."""

	@property
	def bScaleMomentumByMass(self) -> bool: ...
	"""True to scale imparted momentum by the receiving pawn's mass for pawns using character movement"""

	@property
	def bRadialDamageVelChange(self) -> bool: ...
	"""When applying radial impulses, whether to treat as impulse or velocity change."""

	@property
	def DamageImpulse(self) -> float: ...
	"""The magnitude of impulse to apply to the Actors damaged by this type."""

	@property
	def DestructibleImpulse(self) -> float: ...
	"""How large the impulse should be applied to destructible meshes"""

	@property
	def DestructibleDamageSpreadScale(self) -> float: ...
	"""How much the damage spreads on a destructible mesh"""

	@property
	def DamageFalloff(self) -> float: ...
	"""Damage fall-off for radius damage (exponent).  Default 1.0=linear, 2.0=square of distance, etc."""

	pass

class DefaultPawn(Pawn):
	"""DefaultPawn implements a simple Pawn with spherical collision and built-in flying movement.
See: UFloatingPawnMovement"""

	@property
	def BaseTurnRate(self) -> float: ...
	"""Base turn rate, in deg/sec. Other scaling may affect final turn rate."""

	@property
	def BaseLookUpRate(self) -> float: ...
	"""Base lookup rate, in deg/sec. Other scaling may affect final lookup rate."""

	@property
	def bAddDefaultMovementBindings(self) -> bool: ...
	"""If true, adds default input bindings for movement and camera look."""

	def LookUpAtRate(self, Rate: float): ...
	"""Called via input to look up at a given rate (or down if Rate is negative).
@param Rate   This is a normalized rate, i.e. 1.0 means 100% of desired turn rate"""

	def TurnAtRate(self, Rate: float): ...
	"""Called via input to turn at a given rate.
@param Rate  This is a normalized rate, i.e. 1.0 means 100% of desired turn rate"""

	def MoveUp_World(self, Val: float): ...
	"""Input callback to move up in world space (or down if Val is negative).
@param Val Amount of movement in the world up direction (or down if negative).
@see APawn::AddMovementInput()"""

	def MoveRight(self, Val: float): ...
	"""Input callback to strafe right in local space (or left if Val is negative).
@param Val Amount of movement in the right direction (or left if negative).
@see APawn::AddMovementInput()"""

	def MoveForward(self, Val: float): ...
	"""Input callback to move forward in local space (or backward if Val is negative).
@param Val Amount of movement in the forward direction (or backward if negative).
@see APawn::AddMovementInput()"""

	pass

class PhysicsVolume(Volume):
	"""PhysicsVolume: A bounding volume which affects actor physics.
Each AActor is affected at any time by one PhysicsVolume."""

	@property
	def TerminalVelocity(self) -> float: ...
	"""Terminal velocity of pawns using CharacterMovement when falling."""

	@property
	def Priority(self) -> int: ...
	"""Determines which PhysicsVolume takes precedence if they overlap (higher number = higher priority)."""

	@property
	def FluidFriction(self) -> float: ...
	"""This property controls the amount of friction applied by the volume as pawns using CharacterMovement move through it. The higher this value, the harder it will feel to move through"""

	@property
	def bWaterVolume(self) -> bool: ...
	"""True if this volume contains a fluid like water"""

	@property
	def bPhysicsOnContact(self) -> bool: ...
	"""By default, the origin of an AActor must be inside a PhysicsVolume for it to affect the actor. However if this flag is true, the other actor only has to touch the volume to be affected by it."""

	pass

class DefaultPhysicsVolume(PhysicsVolume):
	"""DefaultPhysicsVolume determines the physical effects an actor will experience if they are not inside any user specified PhysicsVolume

See: APhysicsVolume"""

	pass

class FloatingPawnMovement(PawnMovementComponent):
	"""FloatingPawnMovement is a movement component that provides simple movement for any Pawn class.
Limits on speed and acceleration are provided, while gravity is not implemented.

Normally the root component of the owning actor is moved, however another component may be selected (see SetUpdatedComponent()).
During swept (non-teleporting) movement only collision of UpdatedComponent is considered, attached components will teleport to the end location ignoring collision."""

	@property
	def MaxSpeed(self) -> float: ...
	"""Maximum velocity magnitude allowed for the controlled Pawn."""

	@property
	def Acceleration(self) -> float: ...
	"""Acceleration applied by input (rate of change of velocity)"""

	@property
	def Deceleration(self) -> float: ...
	"""Deceleration applied when there is no input (rate of change of velocity)"""

	@property
	def TurningBoost(self) -> float: ...
	"""Setting affecting extra force applied when changing direction, making turns have less drift and become more responsive.
Velocity magnitude is not allowed to increase, that only happens due to normal acceleration. It may decrease with large direction changes.
Larger values apply extra force to reach the target direction more quickly, while a zero value disables any extra turn force."""

	pass

class ForceFeedbackAttenuation(Object):
	"""Wrapper class that can be created as an asset for force feedback attenuation properties which allows reuse
of the properties for multiple attenuation components"""

	@property
	def Attenuation(self) -> ForceFeedbackAttenuationSettings: ...
	"""Attenuation"""

	pass

class ForceFeedbackEffect(Object):
	"""A predefined force-feedback effect to be played on a controller"""

	@property
	def ChannelDetails(self) -> typing.List[unsupported]: ...
	"""Channel Details"""

	@property
	def Duration(self) -> float: ...
	"""Duration of force feedback pattern in seconds."""

	pass

class GameModeBase(Info):
	"""The GameModeBase defines the game being played. It governs the game rules, scoring, what actors
are allowed to exist in this game type, and who may enter the game.

It is only instanced on the server and will never exist on the client.

A GameModeBase actor is instantiated when the level is initialized for gameplay in
C++ UGameEngine::LoadMap().

The class of this GameMode actor is determined by (in order) either the URL ?game=xxx,
the GameMode Override value set in the World Settings, or the DefaultGameMode entry set
in the game's Project Settings.

See: https://docs.unrealengine.com/latest/INT/Gameplay/Framework/GameMode/index.html"""

	@property
	def OptionsString(self) -> str: ...
	"""Save options string and parse it when needed"""

	@property
	def GameSessionClass(self) -> GameSession: ...
	"""Class of GameSession, which handles login approval and online game interface"""

	@property
	def GameStateClass(self) -> GameStateBase: ...
	"""Class of GameState associated with this GameMode."""

	@property
	def PlayerControllerClass(self) -> PlayerController: ...
	"""The class of PlayerController to spawn for players logging in."""

	@property
	def PlayerStateClass(self) -> PlayerState: ...
	"""A PlayerState of this class will be associated with every player to replicate relevant player information to all clients."""

	@property
	def HUDClass(self) -> HUD: ...
	"""HUD class this game uses."""

	@property
	def DefaultPawnClass(self) -> Pawn: ...
	"""The default pawn class used by players."""

	@property
	def SpectatorClass(self) -> SpectatorPawn: ...
	"""The pawn class used by the PlayerController for players when spectating."""

	@property
	def ReplaySpectatorPlayerControllerClass(self) -> PlayerController: ...
	"""The PlayerController class used when spectating a network replay."""

	@property
	def ServerStatReplicatorClass(self) -> ServerStatReplicator: ...
	"""Server Stat Replicator Class"""

	@property
	def GameSession(self) -> GameSession: ...
	"""Game Session handles login approval, arbitration, online game interface"""

	@property
	def GameState(self) -> GameStateBase: ...
	"""GameState is used to replicate game state relevant properties to all clients."""

	@property
	def ServerStatReplicator(self) -> ServerStatReplicator: ...
	"""Server Stat Replicator"""

	@property
	def DefaultPlayerName(self) -> str: ...
	"""The default player name assigned to players that join with no name specified."""

	@property
	def bUseSeamlessTravel(self) -> bool: ...
	"""Whether the game perform map travels using SeamlessTravel() which loads in the background and doesn't disconnect clients"""

	def InitStartSpot(self, StartSpot: Actor, NewPlayer: Controller): ...
	"""Called from RestartPlayerAtPlayerStart, can be used to initialize the start spawn actor"""

	def SpawnDefaultPawnAtTransform(self, NewPlayer: Controller, SpawnTransform: Transform) -> Pawn: ...
	"""Called during RestartPlayer to actually spawn the player's pawn, when using a transform
@param       NewPlayer - Controller for whom this pawn is spawned
@param       StartSpot - Actor at which to spawn pawn
@return      a pawn of the default pawn class"""

	def SpawnDefaultPawnFor(self, NewPlayer: Controller, StartSpot: Actor) -> Pawn: ...
	"""Called during RestartPlayer to actually spawn the player's pawn, when using a start spot
@param       NewPlayer - Controller for whom this pawn is spawned
@param       StartSpot - Actor at which to spawn pawn
@return      a pawn of the default pawn class"""

	def RestartPlayerAtTransform(self, NewPlayer: Controller, SpawnTransform: Transform): ...
	"""Tries to spawn the player's pawn at a specific location"""

	def RestartPlayerAtPlayerStart(self, NewPlayer: Controller, StartSpot: Actor): ...
	"""Tries to spawn the player's pawn at the specified actor's location"""

	def RestartPlayer(self, NewPlayer: Controller): ...
	"""Tries to spawn the player's pawn, at the location returned by FindPlayerStart"""

	def PlayerCanRestart(self, Player: PlayerController) -> bool: ...
	"""Returns true if it's valid to call RestartPlayer. By default will call Player->CanRestartPlayer"""

	def K2_FindPlayerStart(self, Player: Controller, IncomingName: str = ...) -> Actor: ...
	"""Return the specific player start actor that should be used for the next spawn
This will either use a previously saved startactor, or calls ChoosePlayerStart

@param Player The AController for whom we are choosing a Player Start
@param IncomingName Specifies the tag of a Player Start to use
@returns Actor chosen as player start (usually a PlayerStart)"""

	def FindPlayerStart(self, Player: Controller, IncomingName: str) -> Actor: ...
	"""Return the specific player start actor that should be used for the next spawn
This will either use a previously saved startactor, or calls ChoosePlayerStart

@param Player The AController for whom we are choosing a Player Start
@param IncomingName Specifies the tag of a Player Start to use
@returns Actor chosen as player start (usually a PlayerStart)"""

	def ChoosePlayerStart(self, Player: Controller) -> Actor: ...
	"""Return the 'best' player start for this player to spawn from
Default implementation looks for a random unoccupied spot

@param Player is the controller for whom we are choosing a playerstart
@returns AActor chosen as player start (usually a PlayerStart)"""

	def ChangeName(self, Controller: Controller, NewName: str, bNameChange: bool): ...
	"""Sets the name for a controller
@param Controller    The controller of the player to change the name of
@param NewName               The name to set the player to
@param bNameChange   Whether the name is changing or if this is the first time it has been set"""

	def CanSpectate(self, Viewer: PlayerController, ViewTarget: PlayerState) -> bool: ...
	"""Return whether Viewer is allowed to spectate from the point of view of ViewTarget."""

	def MustSpectate(self, NewPlayerController: PlayerController) -> bool: ...
	"""Returns true if NewPlayerController may only join the server as a spectator."""

	def HandleStartingNewPlayer(self, NewPlayer: PlayerController): ...
	"""Signals that a player is ready to enter the game, which may start it up"""

	def ReturnToMainMenuHost(self): ...
	"""Return to main menu, and disconnect any players"""

	def ResetLevel(self): ...
	"""Overridable function called when resetting level. This is used to reset the game state while staying in the same map
Default implementation calls Reset() on all actors except GameMode and Controllers"""

	def ShouldReset(self, ActorToReset: Actor) -> bool: ...
	"""Overridable function to determine whether an Actor should have Reset called when the game has Reset called on it.
Default implementation returns true
@param ActorToReset The actor to make a determination for
@return true if ActorToReset should have Reset() called on it while restarting the game,
                false if the GameMode will manually reset it or if the actor does not need to be reset"""

	def HasMatchEnded(self) -> bool: ...
	"""Returns true if the match can be considered ended"""

	def HasMatchStarted(self) -> bool: ...
	"""Returns true if the match start callbacks have been called"""

	def StartPlay(self): ...
	"""Transitions to calls BeginPlay on actors."""

	def GetNumSpectators(self) -> int: ...
	"""Returns number of human players currently spectating"""

	def GetNumPlayers(self) -> int: ...
	"""Returns number of active human players, excluding spectators"""

	def GetDefaultPawnClassForController(self, InController: Controller) -> Object: ...
	"""Returns default pawn class for given controller"""

	pass

class GameMode(GameModeBase):
	"""GameMode is a subclass of GameModeBase that behaves like a multiplayer match-based game.
It has default behavior for picking spawn points and match state.
If you want a simpler base, inherit from GameModeBase instead."""

	@property
	def bDelayedStart(self) -> bool: ...
	"""Whether the game should immediately start when the first player logs in. Affects the default behavior of ReadyToStartMatch"""

	@property
	def NumSpectators(self) -> int: ...
	"""Current number of spectators."""

	@property
	def NumPlayers(self) -> int: ...
	"""Current number of human players."""

	@property
	def NumBots(self) -> int: ...
	"""number of non-human players (AI controlled but participating as a player)."""

	@property
	def MinRespawnDelay(self) -> float: ...
	"""Minimum time before player can respawn after dying."""

	@property
	def NumTravellingPlayers(self) -> int: ...
	"""Number of players that are still traveling from a previous map"""

	@property
	def EngineMessageClass(self) -> typing.Any: ...
	"""Contains strings describing localized game agnostic messages."""

	@property
	def InactivePlayerArray(self) -> typing.List[PlayerState]: ...
	"""PlayerStates of players who have disconnected from the server (saved in case they reconnect)"""

	def SetBandwidthLimit(self, AsyncIOBandwidthLimit: float): ...
	"""Set Bandwidth Limit"""

	def Say(self, Msg: str): ...
	"""Exec command to broadcast a string to all players"""

	def AbortMatch(self): ...
	"""Report that a match has failed due to unrecoverable error"""

	def RestartGame(self): ...
	"""Restart the game, by default travel to the current map"""

	def EndMatch(self): ...
	"""Transition from InProgress to WaitingPostMatch. You can call this manually, will also get called if ReadyToEndMatch returns true"""

	def StartMatch(self): ...
	"""Transition from WaitingToStart to InProgress. You can call this manually, will also get called if ReadyToStartMatch returns true"""

	def IsMatchInProgress(self) -> bool: ...
	"""Returns true if the match state is InProgress or other gameplay state"""

	def GetMatchState(self) -> str: ...
	"""Returns the current match state, this is an accessor to protect the state machine flow"""

	pass

class GameNetworkManager(Info):
	"""Handles game-specific networking management (cheat detection, bandwidth management, etc.)."""

	@property
	def BadPacketLossThreshold(self) -> float: ...
	"""If packet loss goes over this value, we have bad packet loss. Value is between 0 and 1."""

	@property
	def SeverePacketLossThreshold(self) -> float: ...
	"""If the packet loss goes over this threshold, we have severe packet loss. Value is between 0 and 1"""

	@property
	def BadPingThreshold(self) -> int: ...
	"""If average ping is higher than this threshold in ms, determine the server is either delaying packets or has bad upstream."""

	@property
	def SeverePingThreshold(self) -> int: ...
	"""Similar to BadPingThreshold, but used to track exceptionally bad pings."""

	@property
	def AdjustedNetSpeed(self) -> int: ...
	"""Current adjusted bandwidth per player, based on total and dynamic bandwidth"""

	@property
	def LastNetSpeedUpdateTime(self) -> float: ...
	"""Last time AdjustedNetSpeed was updated for server (by client entering or leaving)"""

	@property
	def TotalNetBandwidth(self) -> int: ...
	"""Total available bandwidth (in bytes/sec) for listen server, split dynamically across net connections"""

	@property
	def MinDynamicBandwidth(self) -> int: ...
	"""Minimum bandwidth set per connection after splitting TotalNetBandwidth"""

	@property
	def MaxDynamicBandwidth(self) -> int: ...
	"""Maximum bandwidth set per connection after splitting TotalNetBandwidth"""

	@property
	def bIsStandbyCheckingEnabled(self) -> bool: ...
	"""Used to determine if checking for standby cheats should occur"""

	@property
	def bHasStandbyCheatTriggered(self) -> bool: ...
	"""Used to determine whether we've already caught a cheat or not"""

	@property
	def StandbyRxCheatTime(self) -> float: ...
	"""The amount of time without packets before triggering the cheat code"""

	@property
	def StandbyTxCheatTime(self) -> float: ...
	"""The amount of time without packets before triggering the cheat code"""

	@property
	def PercentMissingForRxStandby(self) -> float: ...
	"""The percentage of clients missing RX data before triggering the standby code"""

	@property
	def PercentMissingForTxStandby(self) -> float: ...
	"""The percentage of clients missing TX data before triggering the standby code"""

	@property
	def PercentForBadPing(self) -> float: ...
	"""The percentage of clients with bad ping before triggering the standby code"""

	@property
	def JoinInProgressStandbyWaitTime(self) -> float: ...
	"""The amount of time to wait before checking a connection for standby issues"""

	@property
	def MoveRepSize(self) -> float: ...
	"""Average size of replicated move packet (ServerMove() packet size) from player"""

	@property
	def MAXPOSITIONERRORSQUARED(self) -> float: ...
	"""MAXPOSITIONERRORSQUARED is the square of the max position error that is accepted (not corrected) in net play"""

	@property
	def MAXNEARZEROVELOCITYSQUARED(self) -> float: ...
	"""MAXNEARZEROVELOCITYSQUARED is the square of the max velocity that is considered zero (not corrected) in net play"""

	@property
	def CLIENTADJUSTUPDATECOST(self) -> float: ...
	"""CLIENTADJUSTUPDATECOST is the bandwidth cost in bytes of sending a client adjustment update. 180 is greater than the actual cost, but represents a tweaked value reserving enough bandwidth for
      other updates sent to the client.  Increase this value to reduce client adjustment update frequency, or if the amount of data sent in the clientadjustment() call increases"""

	@property
	def MAXCLIENTUPDATEINTERVAL(self) -> float: ...
	"""MAXCLIENTUPDATEINTERVAL is the maximum time between movement updates from the client before the server forces an update."""

	@property
	def MaxClientForcedUpdateDuration(self) -> float: ...
	"""MaxClientForcedUpdateDuration is the maximum time duration over which the server will force updates, after MAXCLIENTUPDATEINTERVAL is initially exceeded."""

	@property
	def ServerForcedUpdateHitchThreshold(self) -> float: ...
	"""Ignore forced client movement updates when server hitches for longer than this duration."""

	@property
	def ServerForcedUpdateHitchCooldown(self) -> float: ...
	"""Ignore forced client movement updates when server hitch was detected within this amount of time in the past."""

	@property
	def MaxMoveDeltaTime(self) -> float: ...
	"""MaxMoveDeltaTime is the default maximum time delta of CharacterMovement ServerMoves. Should be less than or equal to MAXCLIENTUPDATEINTERVAL, otherwise server will interfere by forcing position updates."""

	@property
	def MaxClientSmoothingDeltaTime(self) -> float: ...
	"""MaxClientSmoothingDeltaTime is the maximum delta time between server updates that clients are allowed to smooth between for position interpolation. This was previously (2 * MaxMoveDeltaTime)."""

	@property
	def ClientNetSendMoveDeltaTime(self) -> float: ...
	"""ClientNetSendMoveDeltaTime is the default minimum time delta of CharacterMovement client moves to the server. When updates occur more frequently, they may be combined to save bandwidth.
This value is not used when player count is over ClientNetSendMoveThrottleOverPlayerCount or player net speed is <= ClientNetSendMoveThrottleAtNetSpeed (see ClientNetSendMoveDeltaTimeThrottled)."""

	@property
	def ClientNetSendMoveDeltaTimeThrottled(self) -> float: ...
	"""ClientNetSendMoveDeltaTimeThrottled is used in place of ClientNetSendMoveDeltaTime when player count is high or net speed is low. See ClientNetSendMoveDeltaTime for more info."""

	@property
	def ClientNetSendMoveDeltaTimeStationary(self) -> float: ...
	"""ClientNetSendMoveDeltaTimeStationary is used when players are determined to not be moving or changing their view. See ClientNetSendMoveDeltaTime for more info."""

	@property
	def ClientNetSendMoveThrottleAtNetSpeed(self) -> int: ...
	"""When player net speed (CurrentNetSpeed, based on ConfiguredInternetSpeed or ConfiguredLanSpeed) is less than or equal to this amount, ClientNetSendMoveDeltaTimeThrottled is used instead of ClientNetSendMoveDeltaTime."""

	@property
	def ClientNetSendMoveThrottleOverPlayerCount(self) -> int: ...
	"""When player count is greater than this amount, ClientNetSendMoveDeltaTimeThrottled is used instead of ClientNetSendMoveDeltaTime."""

	@property
	def ClientAuthorativePosition(self) -> bool: ...
	"""If client update is within MAXPOSITIONERRORSQUARED of what the server expects then the client is authoritative on it's final position"""

	@property
	def ClientErrorUpdateRateLimit(self) -> float: ...
	"""Minimum delay between the server sending error corrections to a client, in seconds."""

	@property
	def ClientNetCamUpdateDeltaTime(self) -> float: ...
	"""Minimum delay between calls to ServerUpdateCamera, in seconds."""

	@property
	def ClientNetCamUpdatePositionLimit(self) -> float: ...
	"""Camera position change limit, when exceeded allows an immediate ServerUpdateCamera call."""

	@property
	def bMovementTimeDiscrepancyDetection(self) -> bool: ...
	"""Whether movement time discrepancy (speed hack) detection is enabled."""

	@property
	def bMovementTimeDiscrepancyResolution(self) -> bool: ...
	"""Whether movement time discrepancy resolution is enabled (when detected, make client movement 'pay back' excessive time discrepancies)"""

	@property
	def MovementTimeDiscrepancyMaxTimeMargin(self) -> float: ...
	"""Maximum time client can be ahead before triggering movement time discrepancy detection/resolution (if enabled)."""

	@property
	def MovementTimeDiscrepancyMinTimeMargin(self) -> float: ...
	"""Maximum time client can be behind."""

	@property
	def MovementTimeDiscrepancyResolutionRate(self) -> float: ...
	"""During time discrepancy resolution, we 'pay back' the time discrepancy at this rate for future moves until total error is zero.
1.0 = 100% resolution rate, meaning the next X ServerMoves from the client are fully paying back the time,
0.5 = 50% resolution rate, meaning future ServerMoves will spend 50% of tick continuing to move the character and 50% paying back.
Lowering from 100% could be used to produce less severe/noticeable corrections, although typically we would want to correct
the client as quickly as possible."""

	@property
	def MovementTimeDiscrepancyDriftAllowance(self) -> float: ...
	"""Accepted drift in clocks between client and server as a percent per second allowed.

0.0 is 'no forgiveness' and all logic would run on raw values, no tampering on the server side.
0.02 would be a 2% per second difference 'forgiven' - if the time discrepancy in a given second was less than 2%,
the error handling/detection code effectively ignores it.

Increasing this value above 0% lessens the chance of false positives on time discrepancy (burst packet loss, performance
hitches), but also means anyone tampering with their client time below that percent will not be detected and no resolution
action will be taken, and anyone above that threshold will still gain the advantage of this % of time boost (if running at
10% speed-up and this value is 0.05 or 5% allowance, they would only be resolved down to a 5% speed boost).

Time discrepancy detection code DOES keep track of LifetimeRawTimeDiscrepancy, which is unaffected by this drift allowance,
so cheating below DriftAllowance percent could be tracked and acted on outside of an individual game. For example, if DriftAllowance
was 0.05 (meaning we're not going to actively prevent any cheating below 5% boosts to ensure less false positives for normal players),
we could still post-process analytics of the game showing that Player X regularly runs at 4% speed boost and take action."""

	@property
	def bMovementTimeDiscrepancyForceCorrectionsDuringResolution(self) -> bool: ...
	"""Whether client moves should be force corrected during time discrepancy resolution, useful for projects that have lenient
move error tolerance/ClientAuthorativePosition enabled."""

	@property
	def bUseDistanceBasedRelevancy(self) -> bool: ...
	"""If true, actor network relevancy is constrained by whether they are within their NetCullDistanceSquared from the client's view point."""

	pass

class GameSession(Info):
	"""Acts as a game-specific wrapper around the session interface. The game code makes calls to this when it needs to interact with the session interface.
A game session exists only the server, while running an online game."""

	@property
	def MaxSpectators(self) -> int: ...
	"""Maximum number of spectators allowed by this server."""

	@property
	def MaxPlayers(self) -> int: ...
	"""Maximum number of players allowed by this server."""

	@property
	def MaxPartySize(self) -> int: ...
	"""Restrictions on the largest party that can join together"""

	@property
	def MaxSplitscreensPerConnection(self) -> int: ...
	"""Maximum number of splitscreen players to allow from one connection"""

	@property
	def bRequiresPushToTalk(self) -> bool: ...
	"""Is voice enabled always or via a push to talk keybinding"""

	@property
	def SessionName(self) -> str: ...
	"""SessionName local copy from PlayerState class.  should really be define in this class, but need to address replication issues"""

	pass

class GameStateBase(Info):
	"""GameStateBase is a class that manages the game's global state, and is spawned by GameModeBase.
It exists on both the client and the server and is fully replicated."""

	@property
	def GameModeClass(self) -> GameModeBase: ...
	"""Class of the server's game mode, assigned by GameModeBase."""

	@property
	def AuthorityGameMode(self) -> GameModeBase: ...
	"""Instance of the current game mode, exists only on the server. For non-authority clients, this will be NULL."""

	@property
	def SpectatorClass(self) -> SpectatorPawn: ...
	"""Class used by spectators, assigned by GameModeBase."""

	@property
	def PlayerArray(self) -> typing.List[PlayerState]: ...
	"""Array of all PlayerStates, maintained on both server and clients (PlayerStates are always relevant)"""

	def GetPlayerRespawnDelay(self, Controller: Controller) -> float: ...
	"""Returns how much time needs to be spent before a player can respawn"""

	def GetPlayerStartTime(self, Controller: Controller) -> float: ...
	"""Returns the time that should be used as when a player started"""

	def HasMatchEnded(self) -> bool: ...
	"""Returns true if the match can be considered ended. Defaults to false."""

	def HasMatchStarted(self) -> bool: ...
	"""Returns true if the world has started match (called MatchStarted callbacks)"""

	def HasBegunPlay(self) -> bool: ...
	"""Returns true if the world has started play (called BeginPlay on actors)"""

	def GetServerWorldTimeSeconds(self) -> float: ...
	"""Returns the simulated TimeSeconds on the server, will be synchronized on client and server"""

	pass

class GameState(GameStateBase):
	"""GameState is a subclass of GameStateBase that behaves like a multiplayer match-based game.
It is tied to functionality in GameMode."""

	@property
	def ElapsedTime(self) -> int: ...
	"""Elapsed game time since match has started."""

	def OnRep_ElapsedTime(self): ...
	"""Gives clients the chance to do something when time gets updates"""

	def OnRep_MatchState(self): ...
	"""Match state has changed"""

	pass

class GameUserSettings(Object):
	"""Stores user settings for a game (for example graphics and sound settings), with the ability to save and load to and from a file."""

	@property
	def bUseVSync(self) -> bool: ...
	"""Whether to use VSync or not. (public to allow UI to connect to it)"""

	@property
	def bUseDynamicResolution(self) -> bool: ...
	"""Whether to use dynamic resolution or not. (public to allow UI to connect to it)"""

	def IsHDREnabled(self) -> bool: ...
	"""Is HDREnabled"""

	def GetCurrentHDRDisplayNits(self) -> int: ...
	"""Returns 0 if HDR isn't supported or is turned off"""

	def EnableHDRDisplayOutput(self, bEnable: bool, DisplayNits: int = ...): ...
	"""Enables or disables HDR display output. Can be called again to change the desired nit level"""

	def SupportsHDRDisplayOutput(self) -> bool: ...
	"""Whether the curently running system supports HDR display output"""

	def ApplyHardwareBenchmarkResults(self): ...
	"""Applies the settings stored in ScalabilityQuality and saves settings"""

	def RunHardwareBenchmark(self, WorkScale: int = ..., CPUMultiplier: float = ..., GPUMultiplier: float = ...): ...
	"""Runs the hardware benchmark and populates ScalabilityQuality as well as the last benchmark results config members, but does not apply the settings it determines. Designed to be called in conjunction with ApplyHardwareBenchmarkResults"""

	@staticmethod
	def GetGameUserSettings() -> GameUserSettings: ...
	"""Returns the game local machine settings (resolution, windowing mode, scalability settings, etc...)"""

	@staticmethod
	def GetFramePace() -> int: ...
	"""Gets the current frame pacing frame rate in fps, or 0 if none"""

	@staticmethod
	def GetSyncInterval() -> int: ...
	"""Get Sync Interval"""

	@staticmethod
	def GetDefaultWindowMode() -> int: ...
	"""Returns the default window mode when no mode is set"""

	@staticmethod
	def GetDefaultWindowPosition() -> IntPoint: ...
	"""Returns the default window position when no position is set"""

	@staticmethod
	def GetDefaultResolution() -> IntPoint: ...
	"""Returns the default resolution when no resolution is set"""

	def GetRecommendedResolutionScale(self) -> float: ...
	"""Gets the recommended resolution quality based on LastRecommendedScreenWidth/Height and the current screen resolution"""

	def GetDefaultResolutionScale(self) -> float: ...
	"""Gets the desired resolution quality based on DesiredScreenWidth/Height and the current screen resolution"""

	def SetToDefaults(self): ...
	"""Set to Defaults"""

	def ResetToCurrentSettings(self): ...
	"""This function resets all settings to the current system settings"""

	def SaveSettings(self): ...
	"""Save the user settings to persistent storage (automatically happens as part of ApplySettings)"""

	def LoadSettings(self, bForceReload: bool = ...): ...
	"""Loads the user settings from persistent storage"""

	def ValidateSettings(self): ...
	"""Validates and resets bad user settings to default. Deletes stale user settings file if necessary."""

	def IsDirty(self) -> bool: ...
	"""Checks if any user settings is different from current"""

	def GetShadingQuality(self) -> int: ...
	"""Returns the shading quality (0..4, higher is better)"""

	def SetShadingQuality(self, Value: int): ...
	"""Sets the shading quality (0..4, higher is better)
@param Value 0:low, 1:medium, 2:high, 3:epic, 4:cinematic (gets clamped if needed)"""

	def GetFoliageQuality(self) -> int: ...
	"""Returns the foliage quality (0..4, higher is better)"""

	def SetFoliageQuality(self, Value: int): ...
	"""Sets the foliage quality (0..4, higher is better)
@param Value 0:low, 1:medium, 2:high, 3:epic, 4:cinematic (gets clamped if needed)"""

	def GetPostProcessingQuality(self) -> int: ...
	"""Returns the post-processing quality (0..4, higher is better)"""

	def SetPostProcessingQuality(self, Value: int): ...
	"""Sets the post-processing quality (0..4, higher is better)
@param Value 0:low, 1:medium, 2:high, 3:epic, 4:cinematic (gets clamped if needed)"""

	def GetVisualEffectQuality(self) -> int: ...
	"""Returns the visual effects quality (0..4, higher is better)"""

	def SetVisualEffectQuality(self, Value: int): ...
	"""Sets the visual effects quality (0..4, higher is better)
@param Value 0:low, 1:medium, 2:high, 3:epic, 4:cinematic (gets clamped if needed)"""

	def GetTextureQuality(self) -> int: ...
	"""Returns the texture quality (0..4, higher is better)"""

	def SetTextureQuality(self, Value: int): ...
	"""Sets the texture quality (0..4, higher is better)
@param Value 0:low, 1:medium, 2:high, 3:epic, 4:cinematic  (gets clamped if needed)"""

	def GetAntiAliasingQuality(self) -> int: ...
	"""Returns the anti-aliasing quality (0..4, higher is better)"""

	def SetAntiAliasingQuality(self, Value: int): ...
	"""Sets the anti-aliasing quality (0..4, higher is better)
@param Value 0:low, 1:medium, 2:high, 3:epic, 4:cinematic (gets clamped if needed)"""

	def GetShadowQuality(self) -> int: ...
	"""Returns the shadow quality (0..4, higher is better)"""

	def SetShadowQuality(self, Value: int): ...
	"""Sets the shadow quality (0..4, higher is better)
@param Value 0:low, 1:medium, 2:high, 3:epic, 4:cinematic (gets clamped if needed)"""

	def GetViewDistanceQuality(self) -> int: ...
	"""Returns the view distance quality (0..4, higher is better)"""

	def SetViewDistanceQuality(self, Value: int): ...
	"""Sets the view distance quality (0..4, higher is better)
@param Value 0:low, 1:medium, 2:high, 3:epic, 4:cinematic (gets clamped if needed)"""

	def SetResolutionScaleNormalized(self, NewScaleNormalized: float): ...
	"""Sets the current resolution scale as a normalized 0..1 value between MinScaleValue and MaxScaleValue"""

	def SetResolutionScaleValueEx(self, NewScaleValue: float): ...
	"""Sets the current resolution scale"""

	def GetResolutionScaleNormalized(self) -> float: ...
	"""Gets the current resolution scale as a normalized 0..1 value between MinScaleValue and MaxScaleValue"""

	def GetResolutionScaleInformationEx(self) -> typing.Tuple[float, float, float, float]: ...
	"""Returns the current resolution scale and the range"""

	def GetOverallScalabilityLevel(self) -> int: ...
	"""Returns the overall scalability level (can return -1 if the settings are custom)"""

	def SetOverallScalabilityLevel(self, Value: int): ...
	"""Changes all scalability settings at once based on a single overall quality level
@param Value 0:low, 1:medium, 2:high, 3:epic, 4:cinematic"""

	def GetFrameRateLimit(self) -> float: ...
	"""Gets the user's frame rate limit (0 indiciates the frame rate limit is disabled)"""

	def SetFrameRateLimit(self, NewLimit: float): ...
	"""Sets the user's frame rate limit (0 will disable frame rate limiting)"""

	def GetAudioQualityLevel(self) -> int: ...
	"""Returns the user's audio quality level setting"""

	def SetAudioQualityLevel(self, QualityLevel: int): ...
	"""Sets the user's audio quality level setting"""

	def SetBenchmarkFallbackValues(self): ...
	"""Set scalability settings to sensible fallback values, for use when the benchmark fails or potentially causes a crash"""

	def RevertVideoMode(self): ...
	"""Revert video mode (fullscreenmode/resolution) back to the last user confirmed values"""

	def ConfirmVideoMode(self): ...
	"""Mark current video mode settings (fullscreenmode/resolution) as being confirmed by the user"""

	def IsDynamicResolutionDirty(self) -> bool: ...
	"""Checks if the dynamic resolution user setting is different from current system setting"""

	def IsVSyncDirty(self) -> bool: ...
	"""Checks if the vsync user setting is different from current system setting"""

	def IsFullscreenModeDirty(self) -> bool: ...
	"""Checks if the FullscreenMode user setting is different from current"""

	def IsScreenResolutionDirty(self) -> bool: ...
	"""Checks if the Screen Resolution user setting is different from current"""

	def IsDynamicResolutionEnabled(self) -> bool: ...
	"""Returns the user setting for dynamic resolution."""

	def SetDynamicResolutionEnabled(self, bEnable: bool): ...
	"""Sets the user setting for dynamic resolution. See UGameUserSettings::bUseDynamicResolution."""

	def IsVSyncEnabled(self) -> bool: ...
	"""Returns the user setting for vsync."""

	def SetVSyncEnabled(self, bEnable: bool): ...
	"""Sets the user setting for vsync. See UGameUserSettings::bUseVSync."""

	def GetPreferredFullscreenMode(self) -> int: ...
	"""Returns the user setting for game window fullscreen mode."""

	def SetFullscreenMode(self, InFullscreenMode: int): ...
	"""Sets the user setting for the game window fullscreen mode. See UGameUserSettings::FullscreenMode."""

	def GetLastConfirmedFullscreenMode(self) -> int: ...
	"""Returns the last confirmed user setting for game window fullscreen mode."""

	def GetFullscreenMode(self) -> int: ...
	"""Returns the user setting for game window fullscreen mode."""

	def SetScreenResolution(self, Resolution: IntPoint): ...
	"""Sets the user setting for game screen resolution, in pixels."""

	def GetDesktopResolution(self) -> IntPoint: ...
	"""Returns user's desktop resolution, in pixels."""

	def GetLastConfirmedScreenResolution(self) -> IntPoint: ...
	"""Returns the last confirmed user setting for game screen resolution, in pixels."""

	def GetScreenResolution(self) -> IntPoint: ...
	"""Returns the user setting for game screen resolution, in pixels."""

	def ApplyResolutionSettings(self, bCheckForCommandLineOverrides: bool): ...
	"""Apply Resolution Settings"""

	def ApplyNonResolutionSettings(self): ...
	"""Apply Non Resolution Settings"""

	def ApplySettings(self, bCheckForCommandLineOverrides: bool): ...
	"""Applies all current user settings to the game and saves to permanent storage (e.g. file), optionally checking for command line overrides."""

	pass

class InputSettings(Object):
	"""Project wide settings for input handling

See: https://docs.unrealengine.com/latest/INT/Gameplay/Input/index.html"""

	@property
	def AxisConfig(self) -> typing.List[unsupported]: ...
	"""List of Axis Properties"""

	@property
	def bAltEnterTogglesFullscreen(self) -> bool: ...
	"""Alt Enter Toggles Fullscreen"""

	@property
	def bF11TogglesFullscreen(self) -> bool: ...
	"""F11Toggles Fullscreen"""

	@property
	def bUseMouseForTouch(self) -> bool: ...
	"""Allow mouse to be used for touch"""

	@property
	def bEnableMouseSmoothing(self) -> bool: ...
	"""Mouse smoothing control"""

	@property
	def bEnableFOVScaling(self) -> bool: ...
	"""Scale the mouse based on the player camera manager's field of view"""

	@property
	def bCaptureMouseOnLaunch(self) -> bool: ...
	"""Controls if the viewport will capture the mouse on Launch of the application"""

	@property
	def bAlwaysShowTouchInterface(self) -> bool: ...
	"""Should the touch input interface be shown always, or only when the platform has a touch screen?"""

	@property
	def bShowConsoleOnFourFingerTap(self) -> bool: ...
	"""Whether or not to show the console on 4 finger tap, on mobile platforms"""

	@property
	def bEnableGestureRecognizer(self) -> bool: ...
	"""Whether or not to use the gesture recognition system to convert touches in to gestures that can be bound and queried"""

	@property
	def bUseAutocorrect(self) -> bool: ...
	"""If enabled, virtual keyboards will have autocorrect enabled. Currently only supported on mobile devices."""

	@property
	def ExcludedAutocorrectOS(self) -> typing.List[str]: ...
	"""Disables autocorrect for these operating systems, even if autocorrect is enabled. Use the format '[platform] [osversion]'
(e.g., 'iOS 11.2' or 'Android 6'). More specific versions will disable autocorrect for fewer devices ('iOS 11' will disable
autocorrect for all devices running iOS 11, but 'iOS 11.2.2' will not disable autocorrect for devices running 11.2.1)."""

	@property
	def ExcludedAutocorrectCultures(self) -> typing.List[str]: ...
	"""Disables autocorrect for these cultures, even if autocorrect is turned on. These should be ISO-compliant language and country codes, such as 'en' or 'en-US'."""

	@property
	def ExcludedAutocorrectDeviceModels(self) -> typing.List[str]: ...
	"""Disables autocorrect for these device models, even if autocorrect is turned in. Model IDs listed here will match against the start of the device's
model (e.g., 'SM-' will match all device model IDs that start with 'SM-'). This is currently only supported on Android devices."""

	@property
	def DefaultViewportMouseCaptureMode(self) -> int: ...
	"""The default mouse capture mode for the game viewport"""

	@property
	def DefaultViewportMouseLockMode(self) -> int: ...
	"""The default mouse lock state behavior when the viewport acquires capture"""

	@property
	def FOVScale(self) -> float: ...
	"""The scaling value to multiply the field of view by"""

	@property
	def DoubleClickTime(self) -> float: ...
	"""If a key is pressed twice in this amount of time it is considered a 'double click'"""

	@property
	def DefaultTouchInterface(self) -> SoftObjectPath: ...
	"""The default on-screen touch input interface for the game (can be null to disable the onscreen interface)"""

	@property
	def ConsoleKeys(self) -> typing.List[Key]: ...
	"""The keys which open the console."""

	def ForceRebuildKeymaps(self): ...
	"""When changes are made to the default mappings, push those changes out to PlayerInput key maps"""

	def GetAxisNames(self) -> typing.List[str]: ...
	"""Populate a list of all defined axis names"""

	def GetActionNames(self) -> typing.List[str]: ...
	"""Populate a list of all defined action names"""

	def SaveKeyMappings(self): ...
	"""Flush the current mapping values to the config file"""

	def RemoveAxisMapping(self, KeyMapping: InputAxisKeyMapping, bForceRebuildKeymaps: bool = ...): ...
	"""Programmatically remove an axis mapping to the project defaults"""

	def GetAxisMappingByName(self, InAxisName: str) -> typing.List[InputAxisKeyMapping]: ...
	"""Retrieve all axis mappings by a certain name."""

	def AddAxisMapping(self, KeyMapping: InputAxisKeyMapping, bForceRebuildKeymaps: bool = ...): ...
	"""Programmatically add an axis mapping to the project defaults"""

	def RemoveActionMapping(self, KeyMapping: InputActionKeyMapping, bForceRebuildKeymaps: bool = ...): ...
	"""Programmatically remove an action mapping to the project defaults"""

	def GetActionMappingByName(self, InActionName: str) -> typing.List[InputActionKeyMapping]: ...
	"""Get Action Mapping by Name"""

	def AddActionMapping(self, KeyMapping: InputActionKeyMapping, bForceRebuildKeymaps: bool = ...): ...
	"""Programmatically add an action mapping to the project defaults"""

	@staticmethod
	def GetInputSettings() -> InputSettings: ...
	"""Returns the game local input settings (action mappings, axis mappings, etc...)"""

	pass

class KillZVolume(PhysicsVolume):
	"""KillZVolume is a volume used to determine when actors should be killed. Killing logic is overridden in FellOutOfWorld

See: FellOutOfWorld"""

	pass

class PainCausingVolume(PhysicsVolume):
	"""Volume that causes damage over time to any Actor that overlaps its collision."""

	@property
	def bPainCausing(self) -> bool: ...
	"""Whether volume currently causes damage."""

	@property
	def DamagePerSec(self) -> float: ...
	"""Damage done per second to actors in this volume when bPainCausing=true"""

	@property
	def DamageType(self) -> DamageType: ...
	"""Type of damage done"""

	@property
	def PainInterval(self) -> float: ...
	"""If pain causing, time between damage applications."""

	@property
	def bEntryPain(self) -> bool: ...
	"""if bPainCausing, cause pain when something enters the volume in addition to damage each second"""

	@property
	def BACKUP_bPainCausing(self) -> bool: ...
	"""Checkpointed bPainCausing value"""

	@property
	def DamageInstigator(self) -> Controller: ...
	"""Controller that gets credit for any damage caused by this volume"""

	pass

class PlayerState(Info):
	"""A PlayerState is created for every player on a server (or in a standalone game).
PlayerStates are replicated to all clients, and contain network game relevant information about the player, such as playername, score, etc."""

	@property
	def Score(self) -> float: ...
	"""Score"""

	@property
	def PlayerId(self) -> int: ...
	"""Player Id"""

	@property
	def Ping(self) -> int: ...
	"""Ping"""

	@property
	def bIsSpectator(self) -> bool: ...
	"""Is Spectator"""

	@property
	def bOnlySpectator(self) -> bool: ...
	"""Only Spectator"""

	@property
	def bIsABot(self) -> bool: ...
	"""Is ABot"""

	@property
	def bIsInactive(self) -> bool: ...
	"""Is Inactive"""

	@property
	def bFromPreviousLevel(self) -> bool: ...
	"""From Previous Level"""

	@property
	def StartTime(self) -> int: ...
	"""Start Time"""

	@property
	def EngineMessageClass(self) -> typing.Any: ...
	"""This is used for sending game agnostic messages that can be localized"""

	@property
	def SavedNetworkAddress(self) -> str: ...
	"""Used to match up InactivePlayerState with rejoining playercontroller."""

	@property
	def UniqueId(self) -> UniqueNetIdRepl: ...
	"""Unique Id"""

	def GetPlayerName(self) -> str: ...
	"""returns current player name"""

	def OnRep_UniqueId(self): ...
	"""On Rep Unique Id"""

	def OnRep_PlayerId(self): ...
	"""On Rep Player Id"""

	def OnRep_bIsInactive(self): ...
	"""On Rep B Is Inactive"""

	def OnRep_PlayerName(self): ...
	"""On Rep Player Name"""

	def OnRep_Score(self): ...
	"""Replication Notification Callbacks"""

	pass

class ProjectileMovementComponent(MovementComponent):
	"""ProjectileMovementComponent updates the position of another component during its tick.

Behavior such as bouncing after impacts and homing toward a target are supported.

Normally the root component of the owning actor is moved, however another component may be selected (see SetUpdatedComponent()).
If the updated component is simulating physics, only the initial launch parameters (when initial velocity is non-zero)
will affect the projectile, and the physics sim will take over from there.

See: UMovementComponent"""

	@property
	def InitialSpeed(self) -> float: ...
	"""Initial speed of projectile. If greater than zero, this will override the initial Velocity value and instead treat Velocity as a direction."""

	@property
	def MaxSpeed(self) -> float: ...
	"""Limit on speed of projectile (0 means no limit)."""

	@property
	def bRotationFollowsVelocity(self) -> bool: ...
	"""If true, this projectile will have its rotation updated each frame to match the direction of its velocity."""

	@property
	def bRotationRemainsVertical(self) -> bool: ...
	"""If true, this projectile will have its rotation updated each frame to maintain the rotations Yaw only. (bRotationFollowsVelocity is required to be true)"""

	@property
	def bShouldBounce(self) -> bool: ...
	"""If true, simple bounces will be simulated. Set this to false to stop simulating on contact."""

	@property
	def bInitialVelocityInLocalSpace(self) -> bool: ...
	"""If true, the initial Velocity is interpreted as being in local space upon startup.
See: SetVelocityInLocalSpace()"""

	@property
	def bForceSubStepping(self) -> bool: ...
	"""If true, forces sub-stepping to break up movement into discrete smaller steps to improve accuracy of the trajectory.
Objects that move in a straight line typically do *not* need to set this, as movement always uses continuous collision detection (sweeps) so collision is not missed.
Sub-stepping is automatically enabled when under the effects of gravity or when homing towards a target.
See: MaxSimulationTimeStep, MaxSimulationIterations"""

	@property
	def bSimulationEnabled(self) -> bool: ...
	"""If true, does normal simulation ticking and update. If false, simulation is halted, but component will still tick (allowing interpolation to run)."""

	@property
	def bSweepCollision(self) -> bool: ...
	"""If true, movement uses swept collision checks.
If false, collision effectively teleports to the destination. Note that when this is disabled, movement will never generate blocking collision hits (though overlaps will be updated)."""

	@property
	def bIsHomingProjectile(self) -> bool: ...
	"""If true, we will accelerate toward our homing target. HomingTargetComponent must be set after the projectile is spawned.
See: HomingTargetComponent, HomingAccelerationMagnitude"""

	@property
	def bBounceAngleAffectsFriction(self) -> bool: ...
	"""Controls the effects of friction on velocity parallel to the impact surface when bouncing.
If true, friction will be modified based on the angle of impact, making friction higher for perpendicular impacts and lower for glancing impacts.
If false, a bounce will retain a proportion of tangential velocity equal to (1.0 - Friction), acting as a 'horizontal restitution'."""

	@property
	def bIsSliding(self) -> bool: ...
	"""If true, projectile is sliding / rolling along a surface."""

	@property
	def bInterpMovement(self) -> bool: ...
	"""If true and there is an interpolated component set, location (and optionally rotation) interpolation is enabled which allows the interpolated object to smooth uneven updates
of the UpdatedComponent's location (usually to smooth network updates). This requires using SetInterpolatedComponent() to indicate the visual component that lags behind the collision,
and using MoveInterpolationTarget() when the new target location/rotation is received (usually on a net update).
See: SetInterpolatedComponent(), MoveInterpolationTarget()"""

	@property
	def bInterpRotation(self) -> bool: ...
	"""If true and there is an interpolated component set, rotation interpolation is enabled which allows the interpolated object to smooth uneven updates
of the UpdatedComponent's rotation (usually to smooth network updates).
Rotation interpolation is *only* applied if bInterpMovement is also enabled.
See: SetInterpolatedComponent(), MoveInterpolationTarget()"""

	@property
	def PreviousHitTime(self) -> float: ...
	"""Saved HitResult Time (0 to 1) from previous simulation step. Equal to 1.0 when there was no impact."""

	@property
	def PreviousHitNormal(self) -> Vector: ...
	"""Saved HitResult Normal from previous simulation step that resulted in an impact. If PreviousHitTime is 1.0, then the hit was not in the last step."""

	@property
	def ProjectileGravityScale(self) -> float: ...
	"""Custom gravity scale for this projectile. Set to 0 for no gravity."""

	@property
	def Buoyancy(self) -> float: ...
	"""Buoyancy of UpdatedComponent in fluid. 0.0=sinks as fast as in air, 1.0=neutral buoyancy"""

	@property
	def Bounciness(self) -> float: ...
	"""Percentage of velocity maintained after the bounce in the direction of the normal of impact (coefficient of restitution).
1.0 = no velocity lost, 0.0 = no bounce. Ignored if bShouldBounce is false."""

	@property
	def Friction(self) -> float: ...
	"""Coefficient of friction, affecting the resistance to sliding along a surface.
Normal range is [0,1] : 0.0 = no friction, 1.0+ = very high friction.
Also affects the percentage of velocity maintained after the bounce in the direction tangent to the normal of impact.
Ignored if bShouldBounce is false.
See: bBounceAngleAffectsFriction"""

	@property
	def BounceVelocityStopSimulatingThreshold(self) -> float: ...
	"""If velocity is below this threshold after a bounce, stops simulating and triggers the OnProjectileStop event.
Ignored if bShouldBounce is false, in which case the projectile stops simulating on the first impact.
See: StopSimulating(), OnProjectileStop"""

	@property
	def MinFrictionFraction(self) -> float: ...
	"""When bounce angle affects friction, apply at least this fraction of normal friction.
Helps consistently slow objects sliding or rolling along surfaces or in valleys when the usual friction amount would take a very long time to settle."""

	@property
	def OnProjectileBounce(self) -> typing.Any: ...
	"""Called when projectile impacts something and bounces are enabled."""

	@property
	def OnProjectileStop(self) -> typing.Any: ...
	"""Called when projectile has come to a stop (velocity is below simulation threshold, bounces are disabled, or it is forcibly stopped)."""

	@property
	def HomingAccelerationMagnitude(self) -> float: ...
	"""The magnitude of our acceleration towards the homing target. Overall velocity magnitude will still be limited by MaxSpeed."""

	@property
	def HomingTargetComponent(self) -> SceneComponent: ...
	"""The current target we are homing towards. Can only be set at runtime (when projectile is spawned or updating).
See: bIsHomingProjectile"""

	@property
	def MaxSimulationTimeStep(self) -> float: ...
	"""Max time delta for each discrete simulation step.
Lowering this value can address precision issues with fast-moving objects or complex collision scenarios, at the cost of performance.

WARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.
See: MaxSimulationIterations, bForceSubStepping"""

	@property
	def MaxSimulationIterations(self) -> int: ...
	"""Max number of iterations used for each discrete simulation step.
Increasing this value can address precision issues with fast-moving objects or complex collision scenarios, at the cost of performance.

WARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.
See: MaxSimulationTimeStep, bForceSubStepping"""

	@property
	def BounceAdditionalIterations(self) -> int: ...
	"""On the first few bounces (up to this amount), allow extra iterations over MaxSimulationIterations if necessary."""

	@property
	def InterpLocationTime(self) -> float: ...
	"""'Time' over which most of the location interpolation occurs, when the UpdatedComponent (target) moves ahead of the interpolated component.
Since the implementation uses exponential lagged smoothing, this is a rough time value and experimentation should inform a final result.
A value of zero is effectively instantaneous interpolation."""

	@property
	def InterpRotationTime(self) -> float: ...
	"""'Time' over which most of the rotation interpolation occurs, when the UpdatedComponent (target) moves ahead of the interpolated component.
Since the implementation uses exponential lagged smoothing, this is a rough time value and experimentation should inform a final result.
A value of zero is effectively instantaneous interpolation."""

	@property
	def InterpLocationMaxLagDistance(self) -> float: ...
	"""Max distance behind UpdatedComponent which the interpolated component is allowed to lag."""

	@property
	def InterpLocationSnapToTargetDistance(self) -> float: ...
	"""Max distance behind UpdatedComponent beyond which the interpolated component is snapped to the target location instead.
For instance if the target teleports this far beyond the interpolated component, the interpolation is snapped to match the target."""

	def LimitVelocity(self, NewVelocity: Vector) -> Vector: ...
	"""Don't allow velocity magnitude to exceed MaxSpeed, if MaxSpeed is non-zero."""

	def IsInterpolationComplete(self) -> bool: ...
	"""Returns whether interpolation is complete because the target has been reached. True when interpolation is disabled."""

	def ResetInterpolation(self): ...
	"""Resets interpolation so that interpolated component snaps back to the initial location/rotation without any additional offsets."""

	def MoveInterpolationTarget(self, NewLocation: Vector, NewRotation: Rotator): ...
	"""Moves the UpdatedComponent, which is also the interpolation target for the interpolated component. If there is not interpolated component, this simply moves UpdatedComponent.
Use this typically from PostNetReceiveLocationAndRotation() or similar from an Actor."""

	def SetInterpolatedComponent(self, Component: SceneComponent): ...
	"""Assigns the component that will be used for network interpolation/smoothing. It is expected that this is a component attached somewhere below the UpdatedComponent.
When network updates use MoveInterpolationTarget() to move the UpdatedComponent, the interpolated component's relative offset will be maintained and smoothed over
the course of future component ticks. The current relative location and rotation of the component is saved as the target offset for future interpolation.
@see MoveInterpolationTarget(), bInterpMovement, bInterpRotation"""

	def StopSimulating(self, HitResult: HitResult): ...
	"""Clears the reference to UpdatedComponent, fires stop event (OnProjectileStop), and stops ticking (if bAutoUpdateTickRegistration is true)."""

	def SetVelocityInLocalSpace(self, NewVelocity: Vector): ...
	"""Sets the velocity to the new value, rotated into Actor space."""

	def IsVelocityUnderSimulationThreshold(self) -> bool: ...
	"""Returns true if velocity magnitude is less than BounceVelocityStopSimulatingThreshold."""

	pass

class RotatingMovementComponent(MovementComponent):
	"""Performs continuous rotation of a component at a specific rotation rate.
Rotation can optionally be offset around a pivot point.
Collision testing is not performed during movement."""

	@property
	def RotationRate(self) -> Rotator: ...
	"""How fast to update roll/pitch/yaw of the component we update."""

	@property
	def PivotTranslation(self) -> Vector: ...
	"""Translation of pivot point around which we rotate, relative to current rotation.
For instance, with PivotTranslation set to (X=+100, Y=0, Z=0), rotation will occur
around the point +100 units along the local X axis from the center of the object,
rather than around the object's origin (the default)."""

	@property
	def bRotationInLocalSpace(self) -> bool: ...
	"""Whether rotation is applied in local or world space."""

	pass

class SaveGame(Object):
	"""This class acts as a base class for a save game object that can be used to save state about the game.
When you create your own save game subclass, you would add member variables for the information that you want to save.
Then when you want to save a game, create an instance of this object using CreateSaveGameObject, fill in the data, and use SaveGameToSlot, providing a slot name.
To load the game you then just use LoadGameFromSlot, and read the data from the resulting object.

See: https://docs.unrealengine.com/latest/INT/Gameplay/SaveGame"""

	pass

class SpectatorPawn(DefaultPawn):
	"""Spectator Pawn"""

	pass

class SpectatorPawnMovement(FloatingPawnMovement):
	"""Spectator Pawn Movement"""

	@property
	def bIgnoreTimeDilation(self) -> bool: ...
	"""If true, component moves at full speed no matter the time dilation. Default is false."""

	pass

class SpringArmComponent(SceneComponent):
	"""This component tries to maintain its children at a fixed distance from the parent,
but will retract the children if there is a collision, and spring back when there is no collision.

Example: Use as a 'camera boom' to keep the follow camera for a player from colliding into the world."""

	@property
	def TargetArmLength(self) -> float: ...
	"""Natural length of the spring arm when there are no collisions"""

	@property
	def SocketOffset(self) -> Vector: ...
	"""offset at end of spring arm; use this instead of the relative offset of the attached component to ensure the line trace works as desired"""

	@property
	def TargetOffset(self) -> Vector: ...
	"""Offset at start of spring, applied in world space. Use this if you want a world-space offset from the parent component instead of the usual relative-space offset."""

	@property
	def ProbeSize(self) -> float: ...
	"""How big should the query probe sphere be (in unreal units)"""

	@property
	def ProbeChannel(self) -> int: ...
	"""Collision channel of the query probe (defaults to ECC_Camera)"""

	@property
	def bDoCollisionTest(self) -> bool: ...
	"""If true, do a collision test using ProbeChannel and ProbeSize to prevent camera clipping into level."""

	@property
	def bUsePawnControlRotation(self) -> bool: ...
	"""If this component is placed on a pawn, should it use the view/control rotation of the pawn where possible?
When disabled, the component will revert to using the stored RelativeRotation of the component.
Note that this component itself does not rotate, but instead maintains its relative rotation to its parent as normal,
and just repositions and rotates its children as desired by the inherited rotation settings. Use GetTargetRotation()
if you want the rotation target based on all the settings (UsePawnControlRotation, InheritPitch, etc).

See: GetTargetRotation(), APawn::GetViewRotation()"""

	@property
	def bInheritPitch(self) -> bool: ...
	"""Should we inherit pitch from parent component. Does nothing if using Absolute Rotation."""

	@property
	def bInheritYaw(self) -> bool: ...
	"""Should we inherit yaw from parent component. Does nothing if using Absolute Rotation."""

	@property
	def bInheritRoll(self) -> bool: ...
	"""Should we inherit roll from parent component. Does nothing if using Absolute Rotation."""

	@property
	def bEnableCameraLag(self) -> bool: ...
	"""If true, camera lags behind target position to smooth its movement.
See: CameraLagSpeed"""

	@property
	def bEnableCameraRotationLag(self) -> bool: ...
	"""If true, camera lags behind target rotation to smooth its movement.
See: CameraRotationLagSpeed"""

	@property
	def bUseCameraLagSubstepping(self) -> bool: ...
	"""If bUseCameraLagSubstepping is true, sub-step camera damping so that it handles fluctuating frame rates well (though this comes at a cost).
See: CameraLagMaxTimeStep"""

	@property
	def bDrawDebugLagMarkers(self) -> bool: ...
	"""If true and camera location lag is enabled, draws markers at the camera target (in green) and the lagged position (in yellow).
A line is drawn between the two locations, in green normally but in red if the distance to the lag target has been clamped (by CameraLagMaxDistance)."""

	@property
	def CameraLagSpeed(self) -> float: ...
	"""If bEnableCameraLag is true, controls how quickly camera reaches target position. Low values are slower (more lag), high values are faster (less lag), while zero is instant (no lag)."""

	@property
	def CameraRotationLagSpeed(self) -> float: ...
	"""If bEnableCameraRotationLag is true, controls how quickly camera reaches target position. Low values are slower (more lag), high values are faster (less lag), while zero is instant (no lag)."""

	@property
	def CameraLagMaxTimeStep(self) -> float: ...
	"""Max time step used when sub-stepping camera lag."""

	@property
	def CameraLagMaxDistance(self) -> float: ...
	"""Max distance the camera target may lag behind the current location. If set to zero, no max distance is enforced."""

	def IsCollisionFixApplied(self) -> bool: ...
	"""Is the Collision Test displacement being applied?"""

	def GetUnfixedCameraPosition(self) -> Vector: ...
	"""Get the position where the camera should be without applying the Collision Test displacement"""

	def GetTargetRotation(self) -> Rotator: ...
	"""Get the target rotation we inherit, used as the base target for the boom rotation.
This is derived from attachment to our parent and considering the UsePawnControlRotation and absolute rotation flags."""

	pass

class TouchInterface(Object):
	"""Defines an interface by which touch input can be controlled using any number of buttons and virtual joysticks"""

	@property
	def Controls(self) -> typing.List[unsupported]: ...
	"""Controls"""

	@property
	def ActiveOpacity(self) -> float: ...
	"""Opacity (0.0 - 1.0) of all controls while any control is active"""

	@property
	def InactiveOpacity(self) -> float: ...
	"""Opacity (0.0 - 1.0) of all controls while no controls are active"""

	@property
	def TimeUntilDeactive(self) -> float: ...
	"""How long after user interaction will all controls fade out to Inactive Opacity"""

	@property
	def TimeUntilReset(self) -> float: ...
	"""How long after going inactive will controls reset/recenter themselves (0.0 will disable this feature)"""

	@property
	def ActivationDelay(self) -> float: ...
	"""How long after joystick enabled for touch (0.0 will disable this feature)"""

	@property
	def bPreventRecenter(self) -> bool: ...
	"""Whether to prevent joystick re-center"""

	@property
	def StartupDelay(self) -> float: ...
	"""Delay at startup before virtual joystick is drawn"""

	pass

class HierarchicalLODSetup(Object):
	"""Hierarchical LODSetup"""

	@property
	def HierarchicalLODSetup(self) -> typing.List[unsupported]: ...
	"""Hierarchical LOD Setup"""

	@property
	def OverrideBaseMaterial(self) -> typing.Any: ...
	"""Override Base Material"""

	pass

class WorldSettings(Info):
	"""Actor containing all script accessible world properties."""

	@property
	def VisibilityCellSize(self) -> int: ...
	"""World space size of precomputed visibility cells in x and y.
Smaller sizes produce more effective occlusion culling at the cost of increased runtime memory usage and lighting build times."""

	@property
	def VisibilityAggressiveness(self) -> int: ...
	"""Determines how aggressive precomputed visibility should be.
More aggressive settings cull more objects but also cause more visibility errors like popping."""

	@property
	def bPrecomputeVisibility(self) -> bool: ...
	"""Whether to place visibility cells inside Precomputed Visibility Volumes and along camera tracks in this level.
Precomputing visibility reduces rendering thread time at the cost of some runtime memory and somewhat increased lighting build times."""

	@property
	def bPlaceCellsOnlyAlongCameraTracks(self) -> bool: ...
	"""Whether to place visibility cells only along camera tracks or only above shadow casting surfaces."""

	@property
	def bEnableWorldBoundsChecks(self) -> bool: ...
	"""If true, enables CheckStillInWorld checks"""

	@property
	def bEnableAISystem(self) -> bool: ...
	"""if set to false AI system will not get created. Use it to disable all AI-related activity on a map"""

	@property
	def bEnableWorldComposition(self) -> bool: ...
	"""Enables tools for composing a tiled world.
Level has to be saved and all sub-levels removed before enabling this option."""

	@property
	def bUseClientSideLevelStreamingVolumes(self) -> bool: ...
	"""Enables client-side streaming volumes instead of server-side.
Expected usage scenario: server has all streaming levels always loaded, clients independently stream levels in/out based on streaming volumes."""

	@property
	def bEnableWorldOriginRebasing(self) -> bool: ...
	"""World origin will shift to a camera position when camera goes far away from current origin"""

	@property
	def bWorldGravitySet(self) -> bool: ...
	"""if set to true, when we call GetGravityZ we assume WorldGravityZ has already been initialized and skip the lookup of DefaultGravityZ and GlobalGravityZ"""

	@property
	def bGlobalGravitySet(self) -> bool: ...
	"""If set to true we will use GlobalGravityZ instead of project setting DefaultGravityZ"""

	@property
	def bMinimizeBSPSections(self) -> bool: ...
	"""Causes the BSP build to generate as few sections as possible.
This is useful when you need to reduce draw calls but can reduce texture streaming efficiency and effective lightmap resolution.
Note - changes require a rebuild to propagate.  Also, be sure to select all surfaces and make sure they all have the same flags to minimize section count."""

	@property
	def bForceNoPrecomputedLighting(self) -> bool: ...
	"""Whether to force lightmaps and other precomputed lighting to not be created even when the engine thinks they are needed.
This is useful for improving iteration in levels with fully dynamic lighting and shadowing.
Note that any lighting and shadowing interactions that are usually precomputed will be lost if this is enabled."""

	@property
	def bHighPriorityLoading(self) -> bool: ...
	"""when this flag is set, more time is allocated to background loading (replicated)"""

	@property
	def bHighPriorityLoadingLocal(self) -> bool: ...
	"""copy of bHighPriorityLoading that is not replicated, for clientside-only loading operations"""

	@property
	def bOverrideDefaultBroadphaseSettings(self) -> bool: ...
	"""Override Default Broadphase Settings"""

	@property
	def WorldToMeters(self) -> float: ...
	"""scale of 1uu to 1m in real world measurements, for HMD and other physically tracked devices (e.g. 1uu = 1cm would be 100.0)"""

	@property
	def KillZ(self) -> float: ...
	"""any actor falling below this level gets destroyed"""

	@property
	def KillZDamageType(self) -> DamageType: ...
	"""The type of damage inflicted when a actor falls below KillZ"""

	@property
	def WorldGravityZ(self) -> float: ...
	"""current gravity actually being used"""

	@property
	def GlobalGravityZ(self) -> float: ...
	"""optional level specific gravity override set by level designer"""

	@property
	def DefaultPhysicsVolumeClass(self) -> DefaultPhysicsVolume: ...
	"""level specific default physics volume"""

	@property
	def PhysicsCollisionHandlerClass(self) -> PhysicsCollisionHandler: ...
	"""optional level specific collision handler"""

	@property
	def DefaultGameMode(self) -> GameModeBase: ...
	"""The default GameMode to use when starting this map in the game. If this value is NULL, the INI setting for default game type is used."""

	@property
	def GameNetworkManagerClass(self) -> GameNetworkManager: ...
	"""Class of GameNetworkManager to spawn for network games"""

	@property
	def PackedLightAndShadowMapTextureSize(self) -> int: ...
	"""Maximum size of textures for packed light and shadow maps"""

	@property
	def DefaultColorScale(self) -> Vector: ...
	"""Default color scale for the level"""

	@property
	def DefaultMaxDistanceFieldOcclusionDistance(self) -> float: ...
	"""Max occlusion distance used by mesh distance fields, overridden if there is a movable skylight."""

	@property
	def GlobalDistanceFieldViewDistance(self) -> float: ...
	"""Distance from the camera that the global distance field should cover."""

	@property
	def DynamicIndirectShadowsSelfShadowingIntensity(self) -> float: ...
	"""Controls the intensity of self-shadowing from capsule indirect shadows.
These types of shadows use approximate occluder representations, so reducing self-shadowing intensity can hide those artifacts."""

	@property
	def DefaultReverbSettings(self) -> ReverbSettings: ...
	"""Default reverb settings used by audio volumes."""

	@property
	def DefaultAmbientZoneSettings(self) -> typing.Any: ...
	"""Default interior settings used by audio volumes."""

	@property
	def MonoCullingDistance(self) -> float: ...
	"""Distance from the player after which content will be rendered in mono if monoscopic far field rendering is activated"""

	@property
	def DefaultBaseSoundMix(self) -> SoundMix: ...
	"""Default Base SoundMix."""

	@property
	def TimeDilation(self) -> float: ...
	"""Normally 1 - scales real time passage.
Warning - most use cases should use GetEffectiveTimeDilation() instead of reading from this directly"""

	@property
	def MatineeTimeDilation(self) -> float: ...
	"""Additional time dilation used by Matinee (or Sequencer) slomo track.  Transient because this is often
temporarily modified by the editor when previewing slow motion effects, yet we don't want it saved or loaded from level packages."""

	@property
	def DemoPlayTimeDilation(self) -> float: ...
	"""Additional TimeDilation used to control demo playback speed"""

	@property
	def MinGlobalTimeDilation(self) -> float: ...
	"""Lowest acceptable global time dilation."""

	@property
	def MaxGlobalTimeDilation(self) -> float: ...
	"""Highest acceptable global time dilation."""

	@property
	def MinUndilatedFrameTime(self) -> float: ...
	"""Smallest possible frametime, not considering dilation. Equiv to 1/FastestFPS."""

	@property
	def MaxUndilatedFrameTime(self) -> float: ...
	"""Largest possible frametime, not considering dilation. Equiv to 1/SlowestFPS."""

	@property
	def BroadphaseSettings(self) -> typing.Any: ...
	"""Broadphase Settings"""

	@property
	def Pauser(self) -> PlayerState: ...
	"""Pauser"""

	@property
	def ReplicationViewers(self) -> typing.List[unsupported]: ...
	"""valid only during replication - information about the player(s) being replicated to
(there could be more than one in the case of a splitscreen client)"""

	def OnRep_WorldGravityZ(self): ...
	"""On Rep World Gravity Z"""

	pass

class HapticFeedbackEffect_Base(Object):
	"""Haptic Feedback Effect Base"""

	pass

class HapticFeedbackEffect_Buffer(HapticFeedbackEffect_Base):
	"""Haptic Feedback Effect Buffer"""

	@property
	def Amplitudes(self) -> typing.List[int]: ...
	"""Amplitudes"""

	@property
	def SampleRate(self) -> int: ...
	"""Sample Rate"""

	pass

class HapticFeedbackEffect_Curve(HapticFeedbackEffect_Base):
	"""Haptic Feedback Effect Curve"""

	@property
	def HapticDetails(self) -> typing.Any: ...
	"""Haptic Details"""

	pass

class HapticFeedbackEffect_SoundWave(HapticFeedbackEffect_Base):
	"""Haptic Feedback Effect Sound Wave"""

	@property
	def SoundWave(self) -> SoundWave: ...
	"""Sound Wave"""

	pass

class BlueprintFunctionLibrary(Object):
	"""This class is a base class for any function libraries exposed to blueprints.
Methods in subclasses are expected to be static, and no methods should be added to this base class."""

	pass

class BlueprintPathsLibrary(BlueprintFunctionLibrary):
	"""Function library to expose FPaths to Blueprints and Python

Function signatures are preserved for the most part with adjustments made to some
signatures to better match Blueprints / Python workflow"""

	@staticmethod
	def Combine(InPaths: typing.List[str]) -> str: ...
	"""Combine two or more Paths into one single Path"""

	@staticmethod
	def GetRelativePathToRoot() -> str: ...
	"""Gets the relative path to get from BaseDir to RootDirectory"""

	@staticmethod
	def Split(InPath: str) -> typing.Tuple[str, str, str]: ...
	"""Parses a fully qualified or relative filename into its components (filename, path, extension).

@param        Path            [out] receives the value of the path portion of the input string
@param        Filename        [out] receives the value of the filename portion of the input string
@param        Extension       [out] receives the value of the extension portion of the input string"""

	@staticmethod
	def ValidatePath(InPath: str) -> typing.Tuple[bool, str]: ...
	"""Validates that the parts that make up the path contain no invalid characters as dictated by the operating system
Note that this is a different set of restrictions to those imposed by FPackageName

@param InPath - path to validate
@param OutReason - If validation fails, this is filled with the failure reason
@param bDidSucceed - Whether the path could be validated"""

	@staticmethod
	def MakeValidFileName(InString: str, InReplacementChar: str = ...) -> str: ...
	"""Returns a string that is safe to use as a filename because all items in
GetInvalidFileSystemChars() are removed

Optionally specify the character to replace invalid characters with

@param  InString
@param  InReplacementChar"""

	@staticmethod
	def GetInvalidFileSystemChars() -> str: ...
	"""Returns a string containing all invalid characters as dictated by the operating system"""

	@staticmethod
	def CreateTempFilename(Path: str, Prefix: str = ..., Extension: str = ...) -> str: ...
	"""Creates a temporary filename with the specified prefix.

@param Path The file pathname.
@param Prefix The file prefix.
@param Extension File extension ('.' required)."""

	@staticmethod
	def ConvertFromSandboxPath(InPath: str, InSandboxName: str) -> str: ...
	"""Converts a sandbox (in Saved/Sandboxes) path to a normal path.

@param InSandboxName The name of the sandbox."""

	@staticmethod
	def ConvertToSandboxPath(InPath: str, InSandboxName: str) -> str: ...
	"""Converts a normal path to a sandbox path (in Saved/Sandboxes).

@param InSandboxName The name of the sandbox."""

	@staticmethod
	def ConvertRelativePathToFull(InPath: str, InBasePath: str = ...) -> str: ...
	"""Converts a relative path name to a fully qualified name relative to the specified BasePath.
BasePath will be the process BaseDir() if not BasePath is given"""

	@staticmethod
	def MakePathRelativeTo(InPath: str, InRelativeTo: str) -> typing.Tuple[bool, str]: ...
	"""Assuming both paths (or filenames) are relative to the same base dir, converts InPath to be relative to InRelativeTo

@param InPath Path to change to be relative to InRelativeTo
@param InRelativeTo Path to use as the new relative base
@param InPath New path relative to InRelativeTo
@returns true if OutPath was changed to be relative"""

	@staticmethod
	def MakePlatformFilename(InPath: str) -> str: ...
	"""Takes an 'Unreal' pathname and converts it to a platform filename."""

	@staticmethod
	def MakeStandardFilename(InPath: str) -> str: ...
	"""Make fully standard 'Unreal' pathname:
   - Normalizes path separators [NormalizeFilename]
   - Removes extraneous separators  [NormalizeDirectoryName, as well removing adjacent separators]
   - Collapses internal ..'s
   - Makes relative to Engine/Binaries/<Platform> (will ALWAYS start with ../../..)"""

	@staticmethod
	def RemoveDuplicateSlashes(InPath: str) -> str: ...
	"""Removes duplicate slashes in paths.
Assumes all slashes have been converted to TEXT('/').
For example, takes the string:
      BaseDirectory/SomeDirectory//SomeOtherDirectory////Filename.ext
and converts it to:
      BaseDirectory/SomeDirectory/SomeOtherDirectory/Filename.ext"""

	@staticmethod
	def CollapseRelativeDirectories(InPath: str) -> typing.Tuple[bool, str]: ...
	"""Takes a fully pathed string and eliminates relative pathing (eg: annihilates '..' with the adjacent directory).
Assumes all slashes have been converted to TEXT('/').
For example, takes the string:
      BaseDirectory/SomeDirectory/../SomeOtherDirectory/Filename.ext
and converts it to:
      BaseDirectory/SomeOtherDirectory/Filename.ext"""

	@staticmethod
	def NormalizeDirectoryName(InPath: str) -> str: ...
	"""Normalize all / and / to TEXT('/') and remove any trailing TEXT('/') if the character before that is not a TEXT('/') or a colon"""

	@staticmethod
	def IsSamePath(PathA: str, PathB: str) -> bool: ...
	"""Checks if two paths are the same.

@param PathA First path to check.
@param PathB Second path to check.

@returns True if both paths are the same. False otherwise."""

	@staticmethod
	def NormalizeFilename(InPath: str) -> str: ...
	"""Convert all / and / to TEXT('/')"""

	@staticmethod
	def IsRelative(InPath: str) -> bool: ...
	"""Returns true if this path is relative to another path"""

	@staticmethod
	def IsDrive(InPath: str) -> bool: ...
	"""Returns true if this path represents a root drive or volume"""

	@staticmethod
	def DirectoryExists(InPath: str) -> bool: ...
	"""Returns true if this directory was found, false otherwise"""

	@staticmethod
	def FileExists(InPath: str) -> bool: ...
	"""Returns true if this file was found, false otherwise"""

	@staticmethod
	def SetExtension(InPath: str, InNewExtension: str) -> str: ...
	"""Sets the extension of the given filename (like ChangeExtension, but also applies the extension if the file doesn't have one)"""

	@staticmethod
	def ChangeExtension(InPath: str, InNewExtension: str) -> str: ...
	"""Changes the extension of the given filename (does nothing if the file has no extension)"""

	@staticmethod
	def GetPath(InPath: str) -> str: ...
	"""Returns the path in front of the filename"""

	@staticmethod
	def GetBaseFilename(InPath: str, bRemovePath: bool = ...) -> str: ...
	"""Returns the same thing as GetCleanFilename, but without the extension"""

	@staticmethod
	def GetCleanFilename(InPath: str) -> str: ...
	"""Returns the filename (with extension), minus any path information."""

	@staticmethod
	def GetExtension(InPath: str, bIncludeDot: bool = ...) -> str: ...
	"""Gets the extension for this filename.

@param        bIncludeDot             if true, includes the leading dot in the result

@return       the extension of this filename, or an empty string if the filename doesn't have an extension."""

	@staticmethod
	def SetProjectFilePath(NewGameProjectFilePath: str): ...
	"""Sets the path to the project file.

@param NewGameProjectFilePath - The project file path to set."""

	@staticmethod
	def GetProjectFilePath() -> str: ...
	"""Gets the path to the project file.

@return Project file path."""

	@staticmethod
	def IsProjectFilePathSet() -> bool: ...
	"""Checks whether the path to the project file, if any, is set.

@return true if the path is set, false otherwise."""

	@staticmethod
	def FeaturePackDir() -> str: ...
	"""Returns the directory where feature packs are kept"""

	@staticmethod
	def GameSourceDir() -> str: ...
	"""Returns the directory where game source code files are kept"""

	@staticmethod
	def EngineSourceDir() -> str: ...
	"""Returns the directory where engine source code files are kept"""

	@staticmethod
	def GameAgnosticSavedDir() -> str: ...
	"""Returns the saved directory that is not game specific. This is usually the same as
EngineSavedDir().

@return saved directory"""

	@staticmethod
	def IsRestrictedPath(InPath: str) -> bool: ...
	"""Determines if supplied path uses a restricted/internal subdirectory.  Note that slashes are normalized and character case is ignored for the comparison."""

	@staticmethod
	def GetRestrictedFolderNames() -> typing.List[str]: ...
	"""Returns a list of restricted/internal folder names (without any slashes) which may be tested against full paths to determine if a path is restricted or not."""

	@staticmethod
	def GetGameLocalizationPaths() -> typing.List[str]: ...
	"""Returns a list of game-specific localization paths"""

	@staticmethod
	def GetToolTipLocalizationPaths() -> typing.List[str]: ...
	"""Returns a list of tool tip localization paths"""

	@staticmethod
	def GetPropertyNameLocalizationPaths() -> typing.List[str]: ...
	"""Returns a list of property name localization paths"""

	@staticmethod
	def GetEditorLocalizationPaths() -> typing.List[str]: ...
	"""Returns a list of editor-specific localization paths"""

	@staticmethod
	def GetEngineLocalizationPaths() -> typing.List[str]: ...
	"""Returns a list of engine-specific localization paths"""

	@staticmethod
	def DiffDir() -> str: ...
	"""Returns the directory for temp files used for diffing"""

	@staticmethod
	def GameUserDeveloperDir() -> str: ...
	"""Returns the directory that contains developer-specific content for the current user"""

	@staticmethod
	def GameDevelopersDir() -> str: ...
	"""Returns the directory that contains subfolders for developer-specific content"""

	@staticmethod
	def CloudDir() -> str: ...
	"""Returns the directory for local files used in cloud emulation or support"""

	@staticmethod
	def AutomationLogDir() -> str: ...
	"""Returns the directory for automation log files"""

	@staticmethod
	def AutomationTransientDir() -> str: ...
	"""Returns the directory for automation save files that are meant to be deleted every run"""

	@staticmethod
	def AutomationDir() -> str: ...
	"""Returns the directory for automation save files"""

	@staticmethod
	def ProjectLogDir() -> str: ...
	"""Returns the directory the engine uses to output logs. This currently can't
be an .ini setting as the game starts logging before it can read from .ini
files.

@return log directory"""

	@staticmethod
	def VideoCaptureDir() -> str: ...
	"""Returns the directory the engine uses to output user requested video capture files.

@return Video capture directory"""

	@staticmethod
	def BugItDir() -> str: ...
	"""Returns the directory the engine uses to output BugIt files.

@return screenshot directory"""

	@staticmethod
	def ScreenShotDir() -> str: ...
	"""Returns the directory the engine uses to output screenshot files.

@return screenshot directory"""

	@staticmethod
	def ProfilingDir() -> str: ...
	"""Returns the directory the engine uses to output profiling files.

@return log directory"""

	@staticmethod
	def SandboxesDir() -> str: ...
	"""Returns the directory the engine stores sandbox output

@return sandbox directory"""

	@staticmethod
	def GeneratedConfigDir() -> str: ...
	"""Returns the directory the engine saves generated config files.

@return config directory"""

	@staticmethod
	def SourceConfigDir() -> str: ...
	"""Returns the directory the engine uses to look for the source leaf ini files. This
can't be an .ini variable for obvious reasons.

@return source config directory"""

	@staticmethod
	def ProjectPersistentDownloadDir() -> str: ...
	"""* Returns the writable directory for downloaded data that persists across play sessions."""

	@staticmethod
	def HasProjectPersistentDownloadDir() -> bool: ...
	"""* Returns true if a writable directory for downloaded data that persists across play sessions is available"""

	@staticmethod
	def ProjectModsDir() -> str: ...
	"""Returns the mods directory of the current project by looking at FApp::GetProjectName().

@return mods directory"""

	@staticmethod
	def ProjectPluginsDir() -> str: ...
	"""Returns the plugins directory of the current game by looking at FApp::GetProjectName().

@return plugins directory"""

	@staticmethod
	def ShaderWorkingDir() -> str: ...
	"""Returns the Shader Working Directory

@return shader working directory"""

	@staticmethod
	def ProjectIntermediateDir() -> str: ...
	"""Returns the intermediate directory of the current game by looking at FApp::GetProjectName().

@return intermediate directory"""

	@staticmethod
	def ProjectSavedDir() -> str: ...
	"""Returns the saved directory of the current game by looking at FApp::GetProjectName().

@return saved directory"""

	@staticmethod
	def ProjectConfigDir() -> str: ...
	"""Returns the directory the root configuration files are located.

@return root config directory"""

	@staticmethod
	def ProjectContentDir() -> str: ...
	"""Returns the content directory of the current game by looking at FApp::GetProjectName().

@return content directory"""

	@staticmethod
	def ProjectUserDir() -> str: ...
	"""Returns the root directory for user-specific game files.

@return game user directory"""

	@staticmethod
	def ProjectDir() -> str: ...
	"""Returns the base directory of the current project by looking at FApp::GetProjectName().
This is usually a subdirectory of the installation
root directory and can be overridden on the command line to allow self
contained mod support.

@return base directory"""

	@staticmethod
	def RootDir() -> str: ...
	"""Returns the root directory of the engine directory tree

@return Root directory."""

	@staticmethod
	def EnterpriseFeaturePackDir() -> str: ...
	"""Returns the enterprise FeaturePack directory

@return FeaturePack directory."""

	@staticmethod
	def EnterprisePluginsDir() -> str: ...
	"""Returns the enterprise plugins directory

@return Plugins directory."""

	@staticmethod
	def EnterpriseDir() -> str: ...
	"""Returns the base directory enterprise directory.

@return enterprise directory"""

	@staticmethod
	def EnginePluginsDir() -> str: ...
	"""Returns the plugins directory of the engine

@return Plugins directory."""

	@staticmethod
	def EngineSavedDir() -> str: ...
	"""Returns the saved directory of the engine

@return Saved directory."""

	@staticmethod
	def EngineIntermediateDir() -> str: ...
	"""Returns the intermediate directory of the engine

@return content directory"""

	@staticmethod
	def EngineConfigDir() -> str: ...
	"""Returns the directory the root configuration files are located.

@return root config directory"""

	@staticmethod
	def EngineContentDir() -> str: ...
	"""Returns the content directory of the 'core' engine that can be shared across
several games or across games & mods.

@return engine content directory"""

	@staticmethod
	def EngineVersionAgnosticUserDir() -> str: ...
	"""Returns the root directory for user-specific engine files which can be shared between versions. Always writable.

@return root user directory"""

	@staticmethod
	def EngineUserDir() -> str: ...
	"""Returns the root directory for user-specific engine files. Always writable.

@return root user directory"""

	@staticmethod
	def EngineDir() -> str: ...
	"""Returns the base directory of the 'core' engine that can be shared across
several games or across games & mods. Shaders and base localization files
e.g. reside in the engine directory.

@return engine directory"""

	@staticmethod
	def LaunchDir() -> str: ...
	"""Returns the directory the application was launched from (useful for commandline utilities)"""

	@staticmethod
	def ShouldSaveToUserDir() -> bool: ...
	"""Should the 'saved' directory structures be rooted in the user dir or relative to the 'engine/game'"""

	pass

class PlatformGameInstance(GameInstance):
	"""UObject based class for handling mobile events. Having this object as an option gives the app lifetime access to these global delegates. The component UApplicationLifecycleComponent is destroyed at level loads"""

	@property
	def ApplicationWillDeactivateDelegate(self) -> typing.Any: ...
	"""This is called when the application is about to be deactivated (e.g., due to a phone call or SMS or the sleep button).
The game should be paused if possible, etc..."""

	@property
	def ApplicationHasReactivatedDelegate(self) -> typing.Any: ...
	"""Called when the application has been reactivated (reverse any processing done in the Deactivate delegate)"""

	@property
	def ApplicationWillEnterBackgroundDelegate(self) -> typing.Any: ...
	"""This is called when the application is being backgrounded (e.g., due to switching
to another app or closing it via the home button)
The game should release shared resources, save state, etc..., since it can be
terminated from the background state without any further warning."""

	@property
	def ApplicationHasEnteredForegroundDelegate(self) -> typing.Any: ...
	"""Called when the application is returning to the foreground (reverse any processing done in the EnterBackground delegate)"""

	@property
	def ApplicationWillTerminateDelegate(self) -> typing.Any: ...
	"""This *may* be called when the application is getting terminated by the OS.
There is no guarantee that this will ever be called on a mobile device,
save state when ApplicationWillEnterBackgroundDelegate is called instead."""

	@property
	def ApplicationShouldUnloadResourcesDelegate(self) -> typing.Any: ...
	"""Called when the OS is running low on resources and asks the application to free up any cached resources, drop graphics quality etc."""

	@property
	def ApplicationReceivedStartupArgumentsDelegate(self) -> typing.Any: ...
	"""Called with arguments passed to the application on statup, perhaps meta data passed on by another application which launched this one."""

	@property
	def ApplicationRegisteredForRemoteNotificationsDelegate(self) -> typing.Any: ...
	"""called when the user grants permission to register for remote notifications"""

	@property
	def ApplicationRegisteredForUserNotificationsDelegate(self) -> typing.Any: ...
	"""called when the user grants permission to register for notifications"""

	@property
	def ApplicationFailedToRegisterForRemoteNotificationsDelegate(self) -> typing.Any: ...
	"""called when the application fails to register for remote notifications"""

	@property
	def ApplicationReceivedRemoteNotificationDelegate(self) -> typing.Any: ...
	"""called when the application receives a remote notification"""

	@property
	def ApplicationReceivedLocalNotificationDelegate(self) -> typing.Any: ...
	"""called when the application receives a local notification"""

	@property
	def ApplicationReceivedScreenOrientationChangedNotificationDelegate(self) -> typing.Any: ...
	"""called when the application receives a screen orientation change notification"""

	pass

class BlueprintPlatformLibrary(BlueprintFunctionLibrary):
	"""Blueprint Platform Library"""

	@staticmethod
	def GetDeviceOrientation() -> int: ...
	"""@return the current device orientation"""

	@staticmethod
	def GetLaunchNotification() -> typing.Tuple[bool, str, int]: ...
	"""Get the local notification that was used to launch the app
@param NotificationLaunchedApp Return true if a notification was used to launch the app
@param ActivationEvent Returns the name of the ActivationEvent if a notification was used to launch the app
@param FireDate Returns the time the notification was activated"""

	@staticmethod
	def CancelLocalNotificationById(NotificationId: int): ...
	"""Cancel a local notification given the ActivationEvent
@param NotificationId The Id returned from one of the ScheduleLocalNotification* functions"""

	@staticmethod
	def CancelLocalNotification(ActivationEvent: str): ...
	"""Cancel a local notification given the ActivationEvent
@param ActivationEvent The string passed into the Schedule call for the notification to be cancelled"""

	@staticmethod
	def ScheduleLocalNotificationBadgeFromNow(inSecondsFromNow: int, ActivationEvent: str): ...
	"""Schedule a local notification badge to fire inSecondsFromNow from now
@param inSecondsFromNow The seconds until the notification should fire
@param ActivationEvent A string that is passed in the delegate callback when the app is brought into the foreground from the user activating the notification"""

	@staticmethod
	def ScheduleLocalNotificationBadgeAtTime(FireDateTime: DateTime, LocalTime: bool, ActivationEvent: str) -> int: ...
	"""Schedule a local notification badge at a specific time, inLocalTime specifies the current local time or if UTC time should be used
@param FireDateTime The time at which to fire the local notification
@param LocalTime If true the provided time is in the local timezone, if false it is in UTC
@param ActivationEvent A string that is passed in the delegate callback when the app is brought into the foreground from the user activating the notification"""

	@staticmethod
	def ScheduleLocalNotificationFromNow(inSecondsFromNow: int, Title: str, Body: str, Action: str, ActivationEvent: str) -> int: ...
	"""Schedule a local notification to fire inSecondsFromNow from now
@param inSecondsFromNow The seconds until the notification should fire
@param LocalTime If true the provided time is in the local timezone, if false it is in UTC
@param Title The title of the notification
@param Body The more detailed description of the notification
@param Action The text to be displayed on the slider controller
@param ActivationEvent A string that is passed in the delegate callback when the app is brought into the foreground from the user activating the notification"""

	@staticmethod
	def ScheduleLocalNotificationAtTime(FireDateTime: DateTime, LocalTime: bool, Title: str, Body: str, Action: str, ActivationEvent: str) -> int: ...
	"""Schedule a local notification at a specific time, inLocalTime specifies the current local time or if UTC time should be used
@param FireDateTime The time at which to fire the local notification
@param LocalTime If true the provided time is in the local timezone, if false it is in UTC
@param Title The title of the notification
@param Body The more detailed description of the notification
@param Action The text to be displayed on the slider controller
@param ActivationEvent A string that is passed in the delegate callback when the app is brought into the foreground from the user activating the notification"""

	@staticmethod
	def ClearAllLocalNotifications(): ...
	"""Clear all pending local notifications. Typically this will be done before scheduling new notifications when going into the background"""

	pass

class DataTableFunctionLibrary(BlueprintFunctionLibrary):
	"""Data Table Function Library"""

	@staticmethod
	def GetDataTableRowFromName(Table: DataTable, RowName: str) -> typing.Tuple[bool, TableRowBase]: ...
	"""Get a Row from a DataTable given a RowName"""

	@staticmethod
	def GetDataTableColumnAsString(DataTable: DataTable, PropertyName: str) -> typing.List[str]: ...
	"""Export from the DataTable all the row for one column. Export it as string. The row name is not included."""

	@staticmethod
	def GetDataTableRowNames(Table: DataTable) -> typing.List[str]: ...
	"""Get Data Table Row Names"""

	@staticmethod
	def DoesDataTableRowExist(Table: DataTable, RowName: str) -> bool: ...
	"""Returns whether or not Table contains a row named RowName"""

	@staticmethod
	def EvaluateCurveTableRow(CurveTable: CurveTable, RowName: str, InXY: float, ContextString: str) -> typing.Tuple[int, float]: ...
	"""Evaluate Curve Table Row"""

	pass

class GameplayStatics(BlueprintFunctionLibrary):
	"""Static class with useful gameplay utility functions that can be called from both Blueprint and C++"""

	@staticmethod
	def AnnounceAccessibleString(AnnouncementString: str): ...
	"""If accessibility is enabled, have the platform announce a string to the player.
These announcements can be interrupted by system accessibiliity announcements or other accessibility announcement requests.
This should be used judiciously as flooding a player with announcements can be overrwhelming and confusing.
Try to make announcements concise and clear.
NOTE: Currently only supported on Win10, Mac, iOS"""

	@staticmethod
	def HasLaunchOption(OptionToCheck: str) -> bool: ...
	"""Checks the commandline to see if the desired option was specified on the commandline (e.g. -demobuild)
@return                               True if the launch option was specified on the commandline, false otherwise"""

	@staticmethod
	def GetIntOption(Options: str, Key: str, DefaultValue: int) -> int: ...
	"""Find an option in the options string and return it as an integer.
@param Options               The string containing the options.
@param Key                   The key to find the value of in Options.
@return                              The value associated with Key as an integer if Key found in Options string, otherwise DefaultValue."""

	@staticmethod
	def HasOption(Options: str, InKey: str) -> bool: ...
	"""Returns whether a key exists in an options string.
@param Options               The string containing the options.
@param Key                   The key to determine if it exists in Options.
@return                              Whether Key was found in Options."""

	@staticmethod
	def ParseOption(Options: str, Key: str) -> str: ...
	"""Find an option in the options string and return it.
@param Options               The string containing the options.
@param Key                   The key to find the value of in Options.
@return                              The value associated with Key if Key found in Options string."""

	@staticmethod
	def GetKeyValue(Pair: str) -> typing.Tuple[str, str]: ...
	"""Break up a key=value pair into its key and value.
@param Pair                  The string containing a pair to split apart.
@param Key                   (out) Key portion of Pair. If no = in string will be the same as Pair.
@param Value                 (out) Value portion of Pair. If no = in string will be empty."""

	@staticmethod
	def GetViewProjectionMatrix(DesiredView: MinimalViewInfo) -> typing.Tuple[Matrix, Matrix, Matrix]: ...
	"""Returns the View Matrix, Projection Matrix and the View x Projection Matrix for a given view
@param DesiredView                   FMinimalViewInfo struct for a camera.
@param ViewMatrix                    (out) Corresponding View Matrix
@param ProjectionMatrix              (out) Corresponding Projection Matrix
@param ViewProjectionMatrix  (out) Corresponding View x Projection Matrix"""

	@staticmethod
	def ProjectWorldToScreen(Player: PlayerController, WorldPosition: Vector, bPlayerViewportRelative: bool = ...) -> typing.Tuple[bool, Vector2D]: ...
	"""Transforms the given 3D world-space point into a its 2D screen space coordinate.
@param Player                        Project using this player's view.
@param WorldPosition         World position to project.
@param ScreenPosition        (out) Corresponding 2D position in screen space
@param bPlayerViewportRelative       Should this be relative to the player viewport subregion (useful when using player attached widgets in split screen)"""

	@staticmethod
	def DeprojectScreenToWorld(Player: PlayerController, ScreenPosition: Vector2D) -> typing.Tuple[bool, Vector, Vector]: ...
	"""Transforms the given 2D screen space coordinate into a 3D world-space point and direction.
@param Player                        Deproject using this player's view.
@param ScreenPosition        2D screen space to deproject.
@param WorldPosition         (out) Corresponding 3D position in world space.
@param WorldDirection        (out) World space direction vector away from the camera at the given 2d point."""

	@staticmethod
	def GrassOverlappingSphereCount(WorldContextObject: Object, StaticMesh: StaticMesh, CenterPosition: Vector, Radius: float) -> int: ...
	"""Counts how many grass foliage instances overlap a given sphere.

@param        Mesh                    The static mesh we are interested in counting.
@param        CenterPosition  The center position of the sphere.
@param        Radius                  The radius of the sphere.

@return Number of foliage instances with their mesh set to Mesh that overlap the sphere."""

	@staticmethod
	def RebaseZeroOriginOntoLocal(WorldContextObject: Object, WorldLocation: Vector) -> Vector: ...
	"""Returns local location for origin based position."""

	@staticmethod
	def RebaseLocalOriginOntoZero(WorldContextObject: Object, WorldLocation: Vector) -> Vector: ...
	"""Returns origin based position for local world location."""

	@staticmethod
	def SetWorldOriginLocation(WorldContextObject: Object, NewLocation: IntVector): ...
	"""Requests a new location for a world origin."""

	@staticmethod
	def GetWorldOriginLocation(WorldContextObject: Object) -> IntVector: ...
	"""Returns world origin current location."""

	@staticmethod
	def SuggestProjectileVelocity_CustomArc(WorldContextObject: Object, StartPos: Vector, EndPos: Vector, OverrideGravityZ: float = ..., ArcParam: float = ...) -> typing.Tuple[bool, Vector]: ...
	"""Returns the launch velocity needed for a projectile at rest at StartPos to land on EndPos.
Assumes a medium arc (e.g. 45 deg on level ground). Projectile velocity is variable and unconstrained.
Does no tracing.

@param OutLaunchVelocity                      Returns the launch velocity required to reach the EndPos
@param StartPos                                       Start position of the simulation
@param EndPos                                         Desired end location for the simulation
@param OverrideGravityZ                       Optional override of WorldGravityZ
@param ArcParam                                       Change height of arc between 0.0-1.0 where 0.5 is the default medium arc, 0 is up, and 1 is directly toward EndPos."""

	@staticmethod
	def Blueprint_PredictProjectilePath_Advanced(WorldContextObject: Object, PredictParams: PredictProjectilePathParams) -> typing.Tuple[bool, PredictProjectilePathResult]: ...
	"""Predict the arc of a virtual projectile affected by gravity with collision checks along the arc.
Returns true if it hit something.

@param PredictParams                          Input params to the trace (start location, velocity, time to simulate, etc).
@param PredictResult                          Output result of the trace (Hit result, array of location/velocity/times for each trace step, etc).
@return                                                       True if hit something along the path (if tracing with collision)."""

	@staticmethod
	def Blueprint_PredictProjectilePath_ByTraceChannel(WorldContextObject: Object, StartPos: Vector, LaunchVelocity: Vector, bTracePath: bool, ProjectileRadius: float, TraceChannel: int, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, DrawDebugTime: float, SimFrequency: float = ..., MaxSimTime: float = ..., OverrideGravityZ: float = ...) -> typing.Tuple[bool, HitResult, typing.List[Vector], Vector]: ...
	"""Predict the arc of a virtual projectile affected by gravity with collision checks along the arc. Returns a list of positions of the simulated arc and the destination reached by the simulation.
Returns true if it hit something (if tracing with collision).

@param OutPathPositions                       Predicted projectile path. Ordered series of positions from StartPos to the end. Includes location at point of impact if it hit something.
@param OutHit                                         Predicted hit result, if the projectile will hit something
@param OutLastTraceDestination        Goal position of the final trace it did. Will not be in the path if there is a hit.
@param StartPos                                       First start trace location
@param LaunchVelocity                         Velocity the 'virtual projectile' is launched at
@param bTracePath                                     Trace along the entire path to look for blocking hits
@param ProjectileRadius                       Radius of the virtual projectile to sweep against the environment
@param TraceChannel                           TraceChannel to trace against, if bTracePath is true.
@param bTraceComplex                          Use TraceComplex (trace against triangles not primitives)
@param ActorsToIgnore                         Actors to exclude from the traces
@param DrawDebugType                          Debug type (one-frame, duration, persistent)
@param DrawDebugTime                          Duration of debug lines (only relevant for DrawDebugType::Duration)
@param SimFrequency                           Determines size of each sub-step in the simulation (chopping up MaxSimTime)
@param MaxSimTime                                     Maximum simulation time for the virtual projectile.
@param OverrideGravityZ                       Optional override of Gravity (if 0, uses WorldGravityZ)
@return                                                       True if hit something along the path (if tracing with collision)."""

	@staticmethod
	def Blueprint_PredictProjectilePath_ByObjectType(WorldContextObject: Object, StartPos: Vector, LaunchVelocity: Vector, bTracePath: bool, ProjectileRadius: float, ObjectTypes: typing.List[int], bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, DrawDebugTime: float, SimFrequency: float = ..., MaxSimTime: float = ..., OverrideGravityZ: float = ...) -> typing.Tuple[bool, HitResult, typing.List[Vector], Vector]: ...
	"""Predict the arc of a virtual projectile affected by gravity with collision checks along the arc. Returns a list of positions of the simulated arc and the destination reached by the simulation.
Returns true if it hit something.

@param OutPathPositions                       Predicted projectile path. Ordered series of positions from StartPos to the end. Includes location at point of impact if it hit something.
@param OutHit                                         Predicted hit result, if the projectile will hit something
@param OutLastTraceDestination        Goal position of the final trace it did. Will not be in the path if there is a hit.
@param StartPos                                       First start trace location
@param LaunchVelocity                         Velocity the 'virtual projectile' is launched at
@param bTracePath                                     Trace along the entire path to look for blocking hits
@param ProjectileRadius                       Radius of the virtual projectile to sweep against the environment
@param ObjectTypes                            ObjectTypes to trace against, if bTracePath is true.
@param bTraceComplex                          Use TraceComplex (trace against triangles not primitives)
@param ActorsToIgnore                         Actors to exclude from the traces
@param DrawDebugType                          Debug type (one-frame, duration, persistent)
@param DrawDebugTime                          Duration of debug lines (only relevant for DrawDebugType::Duration)
@param SimFrequency                           Determines size of each sub-step in the simulation (chopping up MaxSimTime)
@param MaxSimTime                                     Maximum simulation time for the virtual projectile.
@param OverrideGravityZ                       Optional override of Gravity (if 0, uses WorldGravityZ)
@return                                                       True if hit something along the path if tracing for collision."""

	@staticmethod
	def BlueprintSuggestProjectileVelocity(WorldContextObject: Object, StartLocation: Vector, EndLocation: Vector, LaunchSpeed: float, OverrideGravityZ: float, TraceOption: int, CollisionRadius: float, bFavorHighArc: bool, bDrawDebug: bool) -> typing.Tuple[bool, Vector]: ...
	"""Calculates an launch velocity for a projectile to hit a specified point.
@param TossVelocity          (output) Result launch velocity.
@param StartLocation         Intended launch location
@param EndLocation           Desired landing location
@param LaunchSpeed           Desired launch speed
@param OverrideGravityZ      Optional gravity override.  0 means 'do not override'.
@param TraceOption           Controls whether or not to validate a clear path by tracing along the calculated arc
@param CollisionRadius       Radius of the projectile (assumed spherical), used when tracing
@param bFavorHighArc         If true and there are 2 valid solutions, will return the higher arc.  If false, will favor the lower arc.
@param bDrawDebug            When true, a debug arc is drawn (red for an invalid arc, green for a valid arc)
@return                                      Returns false if there is no valid solution or the valid solutions are blocked.  Returns true otherwise."""

	@staticmethod
	def GetPlatformName() -> str: ...
	"""Returns the string name of the current platform, to perform different behavior based on platform.
(Platform names include Windows, Mac, IOS, Android, PS4, XboxOne, Linux)"""

	@staticmethod
	def EnableLiveStreaming(Enable: bool): ...
	"""Toggle live DVR streaming.
@param Enable                        If true enable streaming, otherwise disable."""

	@staticmethod
	def GetAccurateRealTime(WorldContextObject: Object) -> typing.Tuple[int, float]: ...
	"""Returns time in seconds since the application was started. Unlike the other time functions this is accurate to the exact time this function is called instead of set once per frame."""

	@staticmethod
	def GetAudioTimeSeconds(WorldContextObject: Object) -> float: ...
	"""Returns time in seconds since world was brought up for play, IS stopped when game pauses, NOT dilated/clamped."""

	@staticmethod
	def GetRealTimeSeconds(WorldContextObject: Object) -> float: ...
	"""Returns time in seconds since world was brought up for play, does NOT stop when game pauses, NOT dilated/clamped"""

	@staticmethod
	def GetUnpausedTimeSeconds(WorldContextObject: Object) -> float: ...
	"""Returns time in seconds since world was brought up for play, adjusted by time dilation and IS NOT stopped when game pauses"""

	@staticmethod
	def GetTimeSeconds(WorldContextObject: Object) -> float: ...
	"""Returns time in seconds since world was brought up for play, adjusted by time dilation and IS stopped when game pauses"""

	@staticmethod
	def GetWorldDeltaSeconds(WorldContextObject: Object) -> float: ...
	"""Returns the frame delta time in seconds, adjusted by time dilation."""

	@staticmethod
	def DeleteGameInSlot(SlotName: str, UserIndex: int) -> bool: ...
	"""Delete a save game in a particular slot.
@param SlotName                      Name of save game slot to delete.
@param UserIndex                     For some platforms, master user index to identify the user doing the deletion.
@return                                      True if a file was actually able to be deleted. use DoesSaveGameExist to distinguish between delete failures and failure due to file not existing."""

	@staticmethod
	def LoadGameFromSlot(SlotName: str, UserIndex: int) -> SaveGame: ...
	"""Load the contents from a given slot.
@param SlotName                      Name of the save game slot to load from.
@param UserIndex                     For some platforms, master user index to identify the user doing the loading.
@return                                      Object containing loaded game state (nullptr if load fails)"""

	@staticmethod
	def DoesSaveGameExist(SlotName: str, UserIndex: int) -> bool: ...
	"""See if a save game exists with the specified name.
@param SlotName                      Name of save game slot.
@param UserIndex                     For some platforms, master user index to identify the user doing the saving."""

	@staticmethod
	def SaveGameToSlot(SaveGameObject: SaveGame, SlotName: str, UserIndex: int) -> bool: ...
	"""Save the contents of the SaveGameObject to a platform-specific save slot/file.
@note This will write out all non-transient properties, the SaveGame property flag is not checked

@param SaveGameObject        Object that contains data about the save game that we want to write out
@param SlotName                      Name of save game slot to save to.
@param UserIndex                     For some platforms, master user index to identify the user doing the saving.
@return                                      Whether we successfully saved this information"""

	@staticmethod
	def CreateSaveGameObject(SaveGameClass: SaveGame) -> SaveGame: ...
	"""Create a new, empty SaveGame object to set data on and then pass to SaveGameToSlot.
@param       SaveGameClass   Class of SaveGame to create
@return                                      New SaveGame object to write data to"""

	@staticmethod
	def FindCollisionUV(Hit: HitResult, UVChannel: int) -> typing.Tuple[bool, Vector2D]: ...
	"""Try and find the UV for a collision impact. Note this ONLY works if 'Support UV From Hit Results' is enabled in Physics Settings."""

	@staticmethod
	def GetSurfaceType(Hit: HitResult) -> int: ...
	"""Returns the EPhysicalSurface type of the given Hit.
To edit surface type for your project, use ProjectSettings/Physics/PhysicalSurface section"""

	@staticmethod
	def MakeHitResult(bBlockingHit: bool, bInitialOverlap: bool, Time: float, Distance: float, Location: Vector, ImpactPoint: Vector, Normal: Vector, ImpactNormal: Vector, PhysMat: PhysicalMaterial, HitActor: Actor, HitComponent: PrimitiveComponent, HitBoneName: str, HitItem: int, FaceIndex: int, TraceStart: Vector, TraceEnd: Vector) -> HitResult: ...
	"""Create a HitResult struct
@param Hit                   The source HitResult.
@param bBlockingHit  True if there was a blocking hit, false otherwise.
@param bInitialOverlap True if the hit started in an initial overlap. In this case some other values should be interpreted differently. Time will be 0, ImpactPoint will equal Location, and normals will be equal and indicate a depenetration vector.
@param Time                  'Time' of impact along trace direction ranging from [0.0 to 1.0) if there is a hit, indicating time between start and end. Equals 1.0 if there is no hit.
@param Distance              The distance from the TraceStart to the Location in world space. This value is 0 if there was an initial overlap (trace started inside another colliding object).
@param Location              Location of the hit in world space. If this was a swept shape test, this is the location where we can place the shape in the world where it will not penetrate.
@param Normal                Normal of the hit in world space, for the object that was swept (e.g. for a sphere trace this points towards the sphere's center). Equal to ImpactNormal for line tests.
@param ImpactPoint   Location of the actual contact point of the trace shape with the surface of the hit object. Equal to Location in the case of an initial overlap.
@param ImpactNormal  Normal of the hit in world space, for the object that was hit by the sweep.
@param PhysMat               Physical material that was hit. Must set bReturnPhysicalMaterial to true in the query params for this to be returned.
@param HitActor              Actor hit by the trace.
@param HitComponent  PrimitiveComponent hit by the trace.
@param HitBoneName   Name of the bone hit (valid only if we hit a skeletal mesh).
@param HitItem               Primitive-specific data recording which item in the primitive was hit
@param FaceIndex             If colliding with trimesh or landscape, index of face that was hit."""

	@staticmethod
	def BreakHitResult(Hit: HitResult) -> typing.Tuple[bool, bool, float, float, Vector, Vector, Vector, Vector, PhysicalMaterial, Actor, PrimitiveComponent, str, int, int, Vector, Vector]: ...
	"""Extracts data from a HitResult.
@param Hit                   The source HitResult.
@param bBlockingHit  True if there was a blocking hit, false otherwise.
@param bInitialOverlap True if the hit started in an initial overlap. In this case some other values should be interpreted differently. Time will be 0, ImpactPoint will equal Location, and normals will be equal and indicate a depenetration vector.
@param Time                  'Time' of impact along trace direction ranging from [0.0 to 1.0) if there is a hit, indicating time between start and end. Equals 1.0 if there is no hit.
@param Distance              The distance from the TraceStart to the Location in world space. This value is 0 if there was an initial overlap (trace started inside another colliding object).
@param Location              Location of the hit in world space. If this was a swept shape test, this is the location where we can place the shape in the world where it will not penetrate.
@param Normal                Normal of the hit in world space, for the object that was swept (e.g. for a sphere trace this points towards the sphere's center). Equal to ImpactNormal for line tests.
@param ImpactPoint   Location of the actual contact point of the trace shape with the surface of the hit object. Equal to Location in the case of an initial overlap.
@param ImpactNormal  Normal of the hit in world space, for the object that was hit by the sweep.
@param PhysMat               Physical material that was hit. Must set bReturnPhysicalMaterial to true in the query params for this to be returned.
@param HitActor              Actor hit by the trace.
@param HitComponent  PrimitiveComponent hit by the trace.
@param HitBoneName   Name of the bone hit (valid only if we hit a skeletal mesh).
@param HitItem               Primitive-specific data recording which item in the primitive was hit
@param FaceIndex             If colliding with trimesh or landscape, index of face that was hit."""

	@staticmethod
	def SpawnDecalAttached(DecalMaterial: MaterialInterface, DecalSize: Vector, AttachToComponent: SceneComponent, AttachPointName: str = ..., Location: Vector = ..., Rotation: Rotator = ..., LocationType: int = ..., LifeSpan: float = ...) -> DecalComponent: ...
	"""Spawns a decal attached to and following the specified component. Does not replicate.
@param DecalMaterial - decal's material
@param DecalSize - size of decal
@param AttachComponent - Component to attach to.
@param AttachPointName - Optional named point within the AttachComponent to spawn the emitter at
@param Location - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world position that will be translated to a relative offset
@param Rotation - Depending on the value of LocationType this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a realative offset
@param LocationType - Specifies whether Location is a relative offset or an absolute world position
@param LifeSpan - destroy decal component after time runs out (0 = infinite)"""

	@staticmethod
	def SpawnDecalAtLocation(WorldContextObject: Object, DecalMaterial: MaterialInterface, DecalSize: Vector, Location: Vector, Rotation: Rotator = ..., LifeSpan: float = ...) -> DecalComponent: ...
	"""Spawns a decal at the given location and rotation, fire and forget. Does not replicate.
@param DecalMaterial - decal's material
@param DecalSize - size of decal
@param Location - location to place the decal in world space
@param Rotation - rotation to place the decal in world space
@param LifeSpan - destroy decal component after time runs out (0 = infinite)"""

	@staticmethod
	def GetMaxAudioChannelCount(WorldContextObject: Object) -> int: ...
	"""Retrieves the max voice count currently used by the audio engine."""

	@staticmethod
	def SetMaxAudioChannelsScaled(WorldContextObject: Object, MaxChannelCountScale: float): ...
	"""Sets the max number of voices (also known as 'channels') dynamically by percentage. E.g. if you want to temporarily reduce voice count by 50%, use 0.50. Later, you can return to the original max voice count by using 1.0."""

	@staticmethod
	def GetCurrentReverbEffect(WorldContextObject: Object) -> ReverbEffect: ...
	"""Returns the highest priority reverb settings currently active from any source (volumes or manual setting)."""

	@staticmethod
	def DeactivateReverbEffect(WorldContextObject: Object, TagName: str): ...
	"""Deactivates a Reverb Effect not applied by a volume

@param TagName Tag associated with Reverb Effect to remove"""

	@staticmethod
	def ActivateReverbEffect(WorldContextObject: Object, ReverbEffect: ReverbEffect, TagName: str, Priority: float = ..., Volume: float = ..., FadeTime: float = ...): ...
	"""Activates a Reverb Effect without the need for a volume
@param ReverbEffect Reverb Effect to use
@param TagName Tag to associate with Reverb Effect
@param Priority Priority of the Reverb Effect
@param Volume Volume level of Reverb Effect
@param FadeTime Time before Reverb Effect is fully active"""

	@staticmethod
	def ClearSoundMixModifiers(WorldContextObject: Object): ...
	"""Clear all sound mix modifiers from the audio system *"""

	@staticmethod
	def PopSoundMixModifier(WorldContextObject: Object, InSoundMixModifier: SoundMix): ...
	"""Pop a sound mix modifier from the audio system *"""

	@staticmethod
	def PushSoundMixModifier(WorldContextObject: Object, InSoundMixModifier: SoundMix): ...
	"""Push a sound mix modifier onto the audio system *"""

	@staticmethod
	def ClearSoundMixClassOverride(WorldContextObject: Object, InSoundMixModifier: SoundMix, InSoundClass: SoundClass, FadeOutTime: float = ...): ...
	"""Clears the override of the sound class adjuster in the given sound mix. If the override did not exist in the sound mix, this will do nothing.
@param InSoundMixModifier The sound mix to modify.
@param InSoundClass The sound class to override (or add) in the sound mix.
@param FadeOutTime The interpolation time to use to go from the current sound class adjuster override values to the non-override values."""

	@staticmethod
	def SetSoundMixClassOverride(WorldContextObject: Object, InSoundMixModifier: SoundMix, InSoundClass: SoundClass, Volume: float = ..., Pitch: float = ..., FadeInTime: float = ..., bApplyToChildren: bool = ...): ...
	"""Overrides the sound class adjuster in the given sound mix. If the sound class does not exist in the input sound mix, the sound class adjustment will be added to the sound mix.
@param InSoundMixModifier The sound mix to modify.
@param InSoundClass The sound class to override (or add) in the sound mix.
@param Volume The volume scale to set the sound class adjuster to.
@param Pitch The pitch scale to set the sound class adjuster to.
@param FadeInTime The interpolation time to use to go from the current sound class adjuster values to the new values.
@param bApplyToChildren Whether or not to apply this override to the sound class' children or to just the specified sound class."""

	@staticmethod
	def PrimeSound(InSound: SoundBase): ...
	"""Primes the sound, caching the first chunk of streamed audio. *"""

	@staticmethod
	def SetBaseSoundMix(WorldContextObject: Object, InSoundMix: SoundMix): ...
	"""Set the sound mix of the audio system for special EQing *"""

	@staticmethod
	def AreSubtitlesEnabled() -> bool: ...
	"""Returns whether or not subtitles are currently enabled.
@return true if subtitles are enabled."""

	@staticmethod
	def SetSubtitlesEnabled(bEnabled: bool): ...
	"""Will set subtitles to be enabled or disabled.
@param bEnabled will enable subtitle drawing if true, disable if false."""

	@staticmethod
	def SpawnForceFeedbackAttached(ForceFeedbackEffect: ForceFeedbackEffect, AttachToComponent: SceneComponent, AttachPointName: str = ..., Location: Vector = ..., Rotation: Rotator = ..., LocationType: int = ..., bStopWhenAttachedToDestroyed: bool = ..., bLooping: bool = ..., IntensityMultiplier: float = ..., StartTime: float = ..., AttenuationSettings: ForceFeedbackAttenuation = ..., bAutoDestroy: bool = ...) -> ForceFeedbackComponent: ...
	"""Plays a force feedback effect attached to and following the specified component. This is a fire and forget effect. Replication is also not handled at this point.
@param ForceFeedbackEffect - effect to play
@param AttachComponent - Component to attach to.
@param AttachPointName - Optional named point within the AttachComponent to attach to
@param Location - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world position that will be translated to a relative offset
@param Rotation - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a relative offset
@param LocationType - Specifies whether Location is a relative offset or an absolute world position
@param bStopWhenAttachedToDestroyed - Specifies whether the feedback effect should stop playing when the owner of the attach to component is destroyed.
@param IntensityMultiplier - Intensity multiplier
@param StartTime - How far in to the feedback effect to begin playback at
@param AttenuationSettings - Override attenuation settings package to play effect with
@param bAutoDestroy - Whether the returned force feedback component will be automatically cleaned up when the feedback patern finishes (by completing or stopping) or whether it can be reactivated
@return Force Feedback Component to manipulate the playing feedback effect with"""

	@staticmethod
	def SpawnForceFeedbackAtLocation(WorldContextObject: Object, ForceFeedbackEffect: ForceFeedbackEffect, Location: Vector, Rotation: Rotator = ..., bLooping: bool = ..., IntensityMultiplier: float = ..., StartTime: float = ..., AttenuationSettings: ForceFeedbackAttenuation = ..., bAutoDestroy: bool = ...) -> ForceFeedbackComponent: ...
	"""Plays a force feedback effect at the given location. This is a fire and forget effect and does not travel with any actor. Replication is also not handled at this point.
@param ForceFeedbackEffect - effect to play
@param Location - World position to center the effect at
@param Rotation - World rotation to center the effect at
@param IntensityMultiplier - Intensity multiplier
@param StartTime - How far in to the feedback effect to begin playback at
@param AttenuationSettings - Override attenuation settings package to play effect with
@param bAutoDestroy - Whether the returned force feedback component will be automatically cleaned up when the feedback patern finishes (by completing or stopping) or whether it can be reactivated
@return Force Feedback Component to manipulate the playing feedback effect with"""

	@staticmethod
	def SpawnDialogueAttached(Dialogue: DialogueWave, Context: DialogueContext, AttachToComponent: SceneComponent, AttachPointName: str = ..., Location: Vector = ..., Rotation: Rotator = ..., LocationType: int = ..., bStopWhenAttachedToDestroyed: bool = ..., VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ..., AttenuationSettings: SoundAttenuation = ..., bAutoDestroy: bool = ...) -> AudioComponent: ...
	"""Spawns a dialogue attached to and following the specified component. This is a fire and forget sound. Replication is also not handled at this point.
@param Dialogue - dialogue to play
@param Context - context the dialogue is to play in
@param AttachComponent - Component to attach to.
@param AttachPointName - Optional named point within the AttachComponent to play the sound at
@param Location - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world position that will be translated to a relative offset
@param Rotation - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a relative offset
@param LocationType - Specifies whether Location is a relative offset or an absolute world position
@param bStopWhenAttachedToDestroyed - Specifies whether the sound should stop playing when the owner of the attach to component is destroyed.
@param VolumeMultiplier - Volume multiplier
@param PitchMultiplier - PitchMultiplier
@param StartTime - How far in to the dialogue to begin playback at
@param AttenuationSettings - Override attenuation settings package to play sound with
@param bAutoDestroy - Whether the returned audio component will be automatically cleaned up when the sound finishes (by completing or stopping) or whether it can be reactivated
@return Audio Component to manipulate the playing dialogue with"""

	@staticmethod
	def SpawnDialogueAtLocation(WorldContextObject: Object, Dialogue: DialogueWave, Context: DialogueContext, Location: Vector, Rotation: Rotator = ..., VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ..., AttenuationSettings: SoundAttenuation = ..., bAutoDestroy: bool = ...) -> AudioComponent: ...
	"""Plays a dialogue at the given location. This is a fire and forget sound and does not travel with any actor. Replication is also not handled at this point.
@param Dialogue - dialogue to play
@param Context - context the dialogue is to play in
@param Location - World position to play dialogue at
@param Rotation - World rotation to play dialogue at
@param VolumeMultiplier - Volume multiplier
@param PitchMultiplier - PitchMultiplier
@param StartTime - How far in to the dialogue to begin playback at
@param AttenuationSettings - Override attenuation settings package to play sound with
@param bAutoDestroy - Whether the returned audio component will be automatically cleaned up when the sound finishes (by completing or stopping) or whether it can be reactivated
@return Audio Component to manipulate the playing dialogue with"""

	@staticmethod
	def PlayDialogueAtLocation(WorldContextObject: Object, Dialogue: DialogueWave, Context: DialogueContext, Location: Vector, Rotation: Rotator, VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ..., AttenuationSettings: SoundAttenuation = ...): ...
	"""Plays a dialogue at the given location. This is a fire and forget sound and does not travel with any actor. Replication is also not handled at this point.
@param Dialogue - dialogue to play
@param Context - context the dialogue is to play in
@param Location - World position to play dialogue at
@param Rotation - World rotation to play dialogue at
@param VolumeMultiplier - Volume multiplier
@param PitchMultiplier - Pitch multiplier
@param StartTime - How far in to the dialogue to begin playback at
@param AttenuationSettings - Override attenuation settings package to play sound with"""

	@staticmethod
	def SpawnDialogue2D(WorldContextObject: Object, Dialogue: DialogueWave, Context: DialogueContext, VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ..., bAutoDestroy: bool = ...) -> AudioComponent: ...
	"""Spawns a dialogue with no attenuation, perfect for UI.

* Not Replicated.
@param Dialogue - dialogue to play
@param Context - context the dialogue is to play in
@param VolumeMultiplier - Multiplied with the volume to make the sound louder or softer.
@param PitchMultiplier - Multiplies the pitch.
@param StartTime - How far in to the dialogue to begin playback at
@param bAutoDestroy - Whether the returned audio component will be automatically cleaned up when the sound finishes (by completing or stopping) or whether it can be reactivated
@return An audio component to manipulate the spawned sound"""

	@staticmethod
	def PlayDialogue2D(WorldContextObject: Object, Dialogue: DialogueWave, Context: DialogueContext, VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ...): ...
	"""Plays a dialogue directly with no attenuation, perfect for UI.

* Fire and Forget.
* Not Replicated.
@param Dialogue - dialogue to play
@param Context - context the dialogue is to play in
@param VolumeMultiplier - Multiplied with the volume to make the sound louder or softer.
@param PitchMultiplier - Multiplies the pitch.
@param StartTime - How far in to the dialogue to begin playback at"""

	@staticmethod
	def SpawnSoundAttached(Sound: SoundBase, AttachToComponent: SceneComponent, AttachPointName: str = ..., Location: Vector = ..., Rotation: Rotator = ..., LocationType: int = ..., bStopWhenAttachedToDestroyed: bool = ..., VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ..., AttenuationSettings: SoundAttenuation = ..., ConcurrencySettings: SoundConcurrency = ..., bAutoDestroy: bool = ...) -> AudioComponent: ...
	"""Plays a sound attached to and following the specified component. This is a fire and forget sound. Replication is also not handled at this point.
@param Sound - sound to play
@param AttachComponent - Component to attach to.
@param AttachPointName - Optional named point within the AttachComponent to play the sound at
@param Location - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world position that will be translated to a relative offset
@param Rotation - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a relative offset
@param LocationType - Specifies whether Location is a relative offset or an absolute world position
@param bStopWhenAttachedToDestroyed - Specifies whether the sound should stop playing when the owner of the attach to component is destroyed.
@param VolumeMultiplier - Volume multiplier
@param PitchMultiplier - PitchMultiplier
@param StartTime - How far in to the sound to begin playback at
@param AttenuationSettings - Override attenuation settings package to play sound with
@param ConcurrencySettings - Override concurrency settings package to play sound with
@param bAutoDestroy - Whether the returned audio component will be automatically cleaned up when the sound finishes (by completing or stopping) or whether it can be reactivated
@return An audio component to manipulate the spawned sound"""

	@staticmethod
	def SpawnSoundAtLocation(WorldContextObject: Object, Sound: SoundBase, Location: Vector, Rotation: Rotator = ..., VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ..., AttenuationSettings: SoundAttenuation = ..., ConcurrencySettings: SoundConcurrency = ..., bAutoDestroy: bool = ...) -> AudioComponent: ...
	"""Spawns a sound at the given location. This does not travel with any actor. Replication is also not handled at this point.
@param Sound - sound to play
@param Location - World position to play sound at
@param Rotation - World rotation to play sound at
@param VolumeMultiplier - Volume multiplier
@param PitchMultiplier - PitchMultiplier
@param StartTime - How far in to the sound to begin playback at
@param AttenuationSettings - Override attenuation settings package to play sound with
@param ConcurrencySettings - Override concurrency settings package to play sound with
@param bAutoDestroy - Whether the returned audio component will be automatically cleaned up when the sound finishes (by completing or stopping) or whether it can be reactivated
@return An audio component to manipulate the spawned sound"""

	@staticmethod
	def PlaySoundAtLocation(WorldContextObject: Object, Sound: SoundBase, Location: Vector, Rotation: Rotator, VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ..., AttenuationSettings: SoundAttenuation = ..., ConcurrencySettings: SoundConcurrency = ..., OwningActor: Actor = ...): ...
	"""Plays a sound at the given location. This is a fire and forget sound and does not travel with any actor. Replication is also not handled at this point.
@param Sound - sound to play
@param Location - World position to play sound at
@param Rotation - World rotation to play sound at
@param VolumeMultiplier - Volume multiplier
@param PitchMultiplier - PitchMultiplier
@param StartTime - How far in to the sound to begin playback at
@param AttenuationSettings - Override attenuation settings package to play sound with
@param ConcurrencySettings - Override concurrency settings package to play sound with
@param OwningActor - The actor to use as the 'owner' for concurrency settings purposes. Allows PlaySound calls to do a concurrency limit per owner."""

	@staticmethod
	def CreateSound2D(WorldContextObject: Object, Sound: SoundBase, VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ..., ConcurrencySettings: SoundConcurrency = ..., bPersistAcrossLevelTransition: bool = ..., bAutoDestroy: bool = ...) -> AudioComponent: ...
	"""Creates a sound with no attenuation, perfect for UI sounds. This does NOT play the sound

* Not Replicated.
@param Sound - Sound to create.
@param VolumeMultiplier - Multiplied with the volume to make the sound louder or softer.
@param PitchMultiplier - Multiplies the pitch.
@param StartTime - How far in to the sound to begin playback at
@param ConcurrencySettings - Override concurrency settings package to play sound with
@param PersistAcrossLevelTransition - Whether the sound should continue to play when the map it was played in is unloaded
@param bAutoDestroy - Whether the returned audio component will be automatically cleaned up when the sound finishes (by completing or stopping) or whether it can be reactivated
@return An audio component to manipulate the created sound"""

	@staticmethod
	def SpawnSound2D(WorldContextObject: Object, Sound: SoundBase, VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ..., ConcurrencySettings: SoundConcurrency = ..., bPersistAcrossLevelTransition: bool = ..., bAutoDestroy: bool = ...) -> AudioComponent: ...
	"""Spawns a sound with no attenuation, perfect for UI sounds.

* Not Replicated.
@param Sound - Sound to play.
@param VolumeMultiplier - Multiplied with the volume to make the sound louder or softer.
@param PitchMultiplier - Multiplies the pitch.
@param StartTime - How far in to the sound to begin playback at
@param ConcurrencySettings - Override concurrency settings package to play sound with
@param PersistAcrossLevelTransition - Whether the sound should continue to play when the map it was played in is unloaded
@param bAutoDestroy - Whether the returned audio component will be automatically cleaned up when the sound finishes (by completing or stopping) or whether it can be reactivated
@return An audio component to manipulate the spawned sound"""

	@staticmethod
	def PlaySound2D(WorldContextObject: Object, Sound: SoundBase, VolumeMultiplier: float = ..., PitchMultiplier: float = ..., StartTime: float = ..., ConcurrencySettings: SoundConcurrency = ..., OwningActor: Actor = ..., bIsUISound: bool = ...): ...
	"""Plays a sound directly with no attenuation, perfect for UI sounds.

* Fire and Forget.
* Not Replicated.
@param Sound - Sound to play.
@param VolumeMultiplier - Multiplied with the volume to make the sound louder or softer.
@param PitchMultiplier - Multiplies the pitch.
@param ConcurrencySettings - Override concurrency settings package to play sound with
@param StartTime - How far in to the sound to begin playback at
@param ConcurrencySettings - Override concurrency settings package to play sound with
@param OwningActor - The actor to use as the 'owner' for concurrency settings purposes. Allows PlaySound calls to do a concurrency limit per owner.
@param bIsUISound - True if sound is UI related, else false"""

	@staticmethod
	def SetGlobalListenerFocusParameters(WorldContextObject: Object, FocusAzimuthScale: float = ..., NonFocusAzimuthScale: float = ..., FocusDistanceScale: float = ..., NonFocusDistanceScale: float = ..., FocusVolumeScale: float = ..., NonFocusVolumeScale: float = ..., FocusPriorityScale: float = ..., NonFocusPriorityScale: float = ...): ...
	"""Sets the global listener focus parameters which will scale focus behavior of sounds based on their focus azimuth settings in their attenuation settings.

* Fire and Forget.
* Not Replicated.
@param FocusAzimuthScale - An angle scale value used to scale the azimuth angle that defines where sounds are in-focus.
@param NonFocusAzimuthScale- An angle scale value used to scale the azimuth angle that defines where sounds are out-of-focus.
@param FocusDistanceScale - A distance scale value to use for sounds which are in-focus. Values < 1.0 will reduce perceived distance to sounds, values > 1.0 will increase perceived distance to in-focus sounds.
@param NonFocusDistanceScale - A distance scale value to use for sounds which are out-of-focus. Values < 1.0 will reduce perceived distance to sounds, values > 1.0 will increase perceived distance to in-focus sounds.
@param FocusVolumeScale- A volume attenuation value to use for sounds which are in-focus.
@param NonFocusVolumeScale- A volume attenuation value to use for sounds which are out-of-focus.
@param FocusPriorityScale - A priority scale value (> 0.0) to use for sounds which are in-focus. Values < 1.0 will reduce the priority of in-focus sounds, values > 1.0 will increase the priority of in-focus sounds.
@param NonFocusPriorityScale - A priority scale value (> 0.0) to use for sounds which are out-of-focus. Values < 1.0 will reduce the priority of sounds out-of-focus sounds, values > 1.0 will increase the priority of out-of-focus sounds."""

	@staticmethod
	def SetSoundClassDistanceScale(WorldContextObject: Object, SoundClass: SoundClass, DistanceAttenuationScale: float, TimeSec: float = ...): ...
	"""Sets attenuation distance scale value on the sound class over the given amount of time from it's current attenuation distance override value (1.0f it not overridden).
Attenuation scale allows scaling the attenuation distance used for computing distance attenuation.

* Fire and Forget.
* Not Replicated.
@param SoundClass - Sound class to to use to set the attenuation distance scale on.
@param DistanceAttenuationScale - A distance attenuation scale value.
@param TimeSec - A time value to linearly interpolate from the current distance attenuation scale value to the new value."""

	@staticmethod
	def SetGlobalPitchModulation(WorldContextObject: Object, PitchModulation: float, TimeSec: float): ...
	"""Sets a global pitch modulation scalar that will apply to all non-UI sounds

* Fire and Forget.
* Not Replicated.
@param PitchModulation - A pitch modulation value to globally set.
@param TimeSec - A time value to linearly interpolate the global modulation pitch over from it's current value."""

	@staticmethod
	def GetClosestListenerLocation(WorldContextObject: Object, Location: Vector, MaximumRange: float, bAllowAttenuationOverride: bool) -> typing.Tuple[bool, Vector]: ...
	"""Finds and returns the position of the closest listener to the specified location
@param Location                                              The location from which we'd like to find the closest listener, in world space.
@param MaximumRange                                  The maximum distance away from Location that a listener can be.
@param bAllowAttenuationOverride             True for the adjusted listener position (if attenuation override is set), false for the raw listener position (for panning)
@param ListenerPosition                              [Out] The position of the closest listener in world space, if found.
@return true if we've successfully found a listener within MaximumRange of Location, otherwise false.
@note This will always return false if there is no audio device, or the audio device is disabled."""

	@staticmethod
	def AreAnyListenersWithinRange(WorldContextObject: Object, Location: Vector, MaximumRange: float) -> bool: ...
	"""Determines if any audio listeners are within range of the specified location
@param Location              The location to potentially play a sound at
@param MaximumRange  The maximum distance away from Location that a listener can be
@note This will always return false if there is no audio device, or the audio device is disabled."""

	@staticmethod
	def SpawnEmitterAttached(EmitterTemplate: ParticleSystem, AttachToComponent: SceneComponent, AttachPointName: str = ..., Location: Vector = ..., Rotation: Rotator = ..., Scale: Vector = ..., LocationType: int = ..., bAutoDestroy: bool = ..., PoolingMethod: int = ..., bAutoActivate: bool = ...) -> ParticleSystemComponent: ...
	"""Plays the specified effect attached to and following the specified component. The system will go away when the effect is complete. Does not replicate.
@param EmitterTemplate - particle system to create
@param AttachComponent - Component to attach to.
@param AttachPointName - Optional named point within the AttachComponent to spawn the emitter at
@param Location - Depending on the value of LocationType this is either a relative offset from the attach component/point or an absolute world location that will be translated to a relative offset (if LocationType is KeepWorldPosition).
@param Rotation - Depending on the value of LocationType this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a relative offset (if LocationType is KeepWorldPosition).
@param Scale - Depending on the value of LocationType this is either a relative scale from the attach component or an absolute world scale that will be translated to a relative scale (if LocationType is KeepWorldPosition).
@param LocationType - Specifies whether Location is a relative offset or an absolute world position
@param bAutoDestroy - Whether the component will automatically be destroyed when the particle system completes playing or whether it can be reactivated
@param PoolingMethod - Method used for pooling this component. Defaults to none.
@param bAutoActivate - Whether the component will be automatically activated on creation."""

	@staticmethod
	def SpawnEmitterAtLocation(WorldContextObject: Object, EmitterTemplate: ParticleSystem, Location: Vector, Rotation: Rotator = ..., Scale: Vector = ..., bAutoDestroy: bool = ..., PoolingMethod: int = ..., bAutoActivateSystem: bool = ...) -> ParticleSystemComponent: ...
	"""Plays the specified effect at the given location and rotation, fire and forget. The system will go away when the effect is complete. Does not replicate.
@param WorldContextObject - Object that we can obtain a world context from
@param EmitterTemplate - particle system to create
@param Location - location to place the effect in world space
@param Rotation - rotation to place the effect in world space
@param Scale - scale to create the effect at
@param bAutoDestroy - Whether the component will automatically be destroyed when the particle system completes playing or whether it can be reactivated
@param PoolingMethod - Method used for pooling this component. Defaults to none.
@param bAutoActivate - Whether the component will be automatically activated on creation."""

	@staticmethod
	def PlayWorldCameraShake(WorldContextObject: Object, Shake: CameraShakeBase, Epicenter: Vector, InnerRadius: float, OuterRadius: float, Falloff: float = ..., bOrientShakeTowardsEpicenter: bool = ...): ...
	"""Plays an in-world camera shake that affects all nearby local players, with distance-based attenuation. Does not replicate.
@param WorldContextObject - Object that we can obtain a world context from
@param Shake - Camera shake asset to use
@param Epicenter - location to place the effect in world space
@param InnerRadius - Cameras inside this radius are ignored
@param OuterRadius - Cameras outside of InnerRadius and inside this are effected
@param Falloff - Affects falloff of effect as it nears OuterRadius
@param bOrientShakeTowardsEpicenter - Changes the rotation of shake to point towards epicenter instead of forward"""

	@staticmethod
	def ApplyDamage(DamagedActor: Actor, BaseDamage: float, EventInstigator: Controller, DamageCauser: Actor, DamageTypeClass: DamageType) -> float: ...
	"""Hurts the specified actor with generic damage.
@param DamagedActor - Actor that will be damaged.
@param BaseDamage - The base damage to apply.
@param EventInstigator - Controller that was responsible for causing this damage (e.g. player who shot the weapon)
@param DamageCauser - Actor that actually caused the damage (e.g. the grenade that exploded)
@param DamageTypeClass - Class that describes the damage that was done.
@return Actual damage the ended up being applied to the actor."""

	@staticmethod
	def ApplyPointDamage(DamagedActor: Actor, BaseDamage: float, HitFromDirection: Vector, HitInfo: HitResult, EventInstigator: Controller, DamageCauser: Actor, DamageTypeClass: DamageType) -> float: ...
	"""Hurts the specified actor with the specified impact.
@param DamagedActor - Actor that will be damaged.
@param BaseDamage - The base damage to apply.
@param HitFromDirection - Direction the hit came FROM
@param HitInfo - Collision or trace result that describes the hit
@param EventInstigator - Controller that was responsible for causing this damage (e.g. player who shot the weapon)
@param DamageCauser - Actor that actually caused the damage (e.g. the grenade that exploded)
@param DamageTypeClass - Class that describes the damage that was done.
@return Actual damage the ended up being applied to the actor."""

	@staticmethod
	def ApplyRadialDamageWithFalloff(WorldContextObject: Object, BaseDamage: float, MinimumDamage: float, Origin: Vector, DamageInnerRadius: float, DamageOuterRadius: float, DamageFalloff: float, DamageTypeClass: DamageType, IgnoreActors: typing.List[Actor], DamageCauser: Actor = ..., InstigatedByController: Controller = ..., DamagePreventionChannel: int = ...) -> bool: ...
	"""Hurt locally authoritative actors within the radius. Will only hit components that block the Visibility channel.
@param BaseDamage - The base damage to apply, i.e. the damage at the origin.
@param Origin - Epicenter of the damage area.
@param DamageInnerRadius - Radius of the full damage area, from Origin
@param DamageOuterRadius - Radius of the minimum damage area, from Origin
@param DamageFalloff - Falloff exponent of damage from DamageInnerRadius to DamageOuterRadius
@param DamageTypeClass - Class that describes the damage that was done.
@param IgnoreActors - List of Actors to ignore
@param DamageCauser - Actor that actually caused the damage (e.g. the grenade that exploded)
@param InstigatedByController - Controller that was responsible for causing this damage (e.g. player who threw the grenade)
@param bFullDamage - if true, damage not scaled based on distance from Origin
@param DamagePreventionChannel - Damage will not be applied to victim if there is something between the origin and the victim which blocks traces on this channel
@return true if damage was applied to at least one actor."""

	@staticmethod
	def ApplyRadialDamage(WorldContextObject: Object, BaseDamage: float, Origin: Vector, DamageRadius: float, DamageTypeClass: DamageType, IgnoreActors: typing.List[Actor], DamageCauser: Actor = ..., InstigatedByController: Controller = ..., bDoFullDamage: bool = ..., DamagePreventionChannel: int = ...) -> bool: ...
	"""Hurt locally authoritative actors within the radius. Will only hit components that block the Visibility channel.
@param BaseDamage - The base damage to apply, i.e. the damage at the origin.
@param Origin - Epicenter of the damage area.
@param DamageRadius - Radius of the damage area, from Origin
@param DamageTypeClass - Class that describes the damage that was done.
@param IgnoreActors - List of Actors to ignore
@param DamageCauser - Actor that actually caused the damage (e.g. the grenade that exploded).  This actor will not be damaged and it will not block damage.
@param InstigatedByController - Controller that was responsible for causing this damage (e.g. player who threw the grenade)
@param bFullDamage - if true, damage not scaled based on distance from Origin
@param DamagePreventionChannel - Damage will not be applied to victim if there is something between the origin and the victim which blocks traces on this channel
@return true if damage was applied to at least one actor."""

	@staticmethod
	def SetViewportMouseCaptureMode(WorldContextObject: Object, MouseCaptureMode: int): ...
	"""Sets the current viewport mouse capture mode"""

	@staticmethod
	def GetViewportMouseCaptureMode(WorldContextObject: Object) -> int: ...
	"""Returns the current viewport mouse capture mode"""

	@staticmethod
	def GetEnableWorldRendering(WorldContextObject: Object) -> bool: ...
	"""Returns the world rendering state
@return      Whether the world should be rendered or not"""

	@staticmethod
	def SetEnableWorldRendering(WorldContextObject: Object, bEnable: bool): ...
	"""Enabled rendering of the world
@param       bEnable         Whether the world should be rendered or not"""

	@staticmethod
	def IsSplitscreenForceDisabled(WorldContextObject: Object) -> bool: ...
	"""Returns the split screen state
@return      Whether the game viewport is split screen or not"""

	@staticmethod
	def SetForceDisableSplitscreen(WorldContextObject: Object, bDisable: bool): ...
	"""Enables split screen
@param       bDisable                Whether the viewport should split screen between local players or not"""

	@staticmethod
	def IsGamePaused(WorldContextObject: Object) -> bool: ...
	"""Returns the game's paused state
@return      Whether the game is currently paused or not"""

	@staticmethod
	def SetGamePaused(WorldContextObject: Object, bPaused: bool) -> bool: ...
	"""Sets the game's paused state
@param       bPaused         Whether the game should be paused or not
@return      Whether the game was successfully paused/unpaused"""

	@staticmethod
	def SetGlobalTimeDilation(WorldContextObject: Object, TimeDilation: float): ...
	"""Sets the global time dilation.
@param       TimeDilation    value to set the global time dilation to"""

	@staticmethod
	def GetGlobalTimeDilation(WorldContextObject: Object) -> float: ...
	"""Gets the current global time dilation.
@return Current time dilation."""

	@staticmethod
	def GetObjectClass(Object: Object) -> Object: ...
	"""Returns the class of a passed in Object, will always be valid if Object is not NULL"""

	@staticmethod
	def GetGameState(WorldContextObject: Object) -> GameStateBase: ...
	"""Returns the current GameStateBase or Null if it can't be retrieved"""

	@staticmethod
	def GetGameMode(WorldContextObject: Object) -> GameModeBase: ...
	"""Returns the current GameModeBase or Null if it can't be retrieved, such as on the client"""

	@staticmethod
	def GetCurrentLevelName(WorldContextObject: Object, bRemovePrefixString: bool = ...) -> str: ...
	"""Get the name of the currently-open level.

@param bRemovePrefixString    remove any streaming- or editor- added prefixes from the level name."""

	@staticmethod
	def OpenLevelBySoftObjectPtr(WorldContextObject: Object, Level, bAbsolute: bool = ..., Options: str = ...): ...
	"""Travel to another level

@param       Level                           the level to open
@param       bAbsolute                       if true options are reset, if false options are carried over from current level
@param       Options                         a string of options to use for the travel URL"""

	@staticmethod
	def OpenLevel(WorldContextObject: Object, LevelName: str, bAbsolute: bool = ..., Options: str = ...): ...
	"""Travel to another level

@param       LevelName                       the level to open
@param       bAbsolute                       if true options are reset, if false options are carried over from current level
@param       Options                         a string of options to use for the travel URL"""

	@staticmethod
	def CancelAsyncLoading(): ...
	"""Cancels all currently queued streaming packages"""

	@staticmethod
	def FlushLevelStreaming(WorldContextObject: Object): ...
	"""Flushes level streaming in blocking fashion and returns when all sub-levels are loaded / visible / hidden"""

	@staticmethod
	def GetStreamingLevel(WorldContextObject: Object, PackageName: str) -> LevelStreaming: ...
	"""Returns level streaming object with specified level package name"""

	@staticmethod
	def UnloadStreamLevelBySoftObjectPtr(WorldContextObject: Object, Level, LatentInfo: LatentActionInfo, bShouldBlockOnUnload: bool): ...
	"""Unload a streamed in level (by Object Reference)"""

	@staticmethod
	def UnloadStreamLevel(WorldContextObject: Object, LevelName: str, LatentInfo: LatentActionInfo, bShouldBlockOnUnload: bool): ...
	"""Unload a streamed in level (by Name)"""

	@staticmethod
	def LoadStreamLevelBySoftObjectPtr(WorldContextObject: Object, Level, bMakeVisibleAfterLoad: bool, bShouldBlockOnLoad: bool, LatentInfo: LatentActionInfo): ...
	"""Stream the level (by Object Reference); Calling again before it finishes has no effect"""

	@staticmethod
	def LoadStreamLevel(WorldContextObject: Object, LevelName: str, bMakeVisibleAfterLoad: bool, bShouldBlockOnLoad: bool, LatentInfo: LatentActionInfo): ...
	"""Stream the level (by Name); Calling again before it finishes has no effect"""

	@staticmethod
	def SetPlayerControllerID(Player: PlayerController, ControllerId: int): ...
	"""Sets what controller ID a Player should be using
@param Player                        The player controller of the player to change the controller ID of
@param ControllerId          The controller ID to assign to this player"""

	@staticmethod
	def GetPlayerControllerID(Player: PlayerController) -> int: ...
	"""Gets what controller ID a Player is using
@param Player         The player controller of the player to get the ID of
@return                       The ID of the passed in player. -1 if there is no controller for the passed in player"""

	@staticmethod
	def RemovePlayer(Player: PlayerController, bDestroyPawn: bool): ...
	"""Removes a player from this game.
@param Player                       The player controller of the player to be removed
@param bDestroyPawn         Whether the controlled pawn should be deleted as well"""

	@staticmethod
	def CreatePlayer(WorldContextObject: Object, ControllerId: int = ..., bSpawnPlayerController: bool = ...) -> PlayerController: ...
	"""Create a new player for this game.
@param ControllerId     The ID of the controller that the should control the newly created player.  A value of -1 specifies to use the next available ID
@param bSpawnPawn       Whether a player controller should be spawned immediately for this player. If false a player controller will not be created automatically until transition to the next map.
@return                 The created player controller if one is created."""

	@staticmethod
	def GetPlayerCameraManager(WorldContextObject: Object, PlayerIndex: int) -> PlayerCameraManager: ...
	"""Returns the player's camera manager for the specified player index"""

	@staticmethod
	def GetPlayerCharacter(WorldContextObject: Object, PlayerIndex: int) -> Character: ...
	"""Returns the player character (NULL if the player pawn doesn't exist OR is not a character) at the specified player index"""

	@staticmethod
	def GetPlayerPawn(WorldContextObject: Object, PlayerIndex: int) -> Pawn: ...
	"""Returns the player pawn at the specified player index"""

	@staticmethod
	def GetPlayerControllerFromID(WorldContextObject: Object, ControllerID: int) -> PlayerController: ...
	"""Returns the player controller that has the given controller ID"""

	@staticmethod
	def GetPlayerController(WorldContextObject: Object, PlayerIndex: int) -> PlayerController: ...
	"""Returns the player controller at the specified player index"""

	@staticmethod
	def GetGameInstance(WorldContextObject: Object) -> GameInstance: ...
	"""Returns the game instance object"""

	@staticmethod
	def GetAllActorsOfClassWithTag(WorldContextObject: Object, ActorClass: Actor, Tag: str) -> typing.List[Actor]: ...
	"""Find all Actors in the world of the specified class with the specified tag.
This is a slow operation, use with caution e.g. do not use every frame.
@param  Tag                     Tag to find. Must be specified or result array will be empty.
@param  ActorClass      Class of Actor to find. Must be specified or result array will be empty.
@param  OutActors       Output array of Actors of the specified tag."""

	@staticmethod
	def GetAllActorsWithTag(WorldContextObject: Object, Tag: str) -> typing.List[Actor]: ...
	"""Find all Actors in the world with the specified tag.
This is a slow operation, use with caution e.g. do not use every frame.
@param  Tag                     Tag to find. Must be specified or result array will be empty.
@param  OutActors       Output array of Actors of the specified tag."""

	@staticmethod
	def GetAllActorsWithInterface(WorldContextObject: Object, Interface) -> typing.List[Actor]: ...
	"""Find all Actors in the world with the specified interface.
This is a slow operation, use with caution e.g. do not use every frame.
@param  Interface       Interface to find. Must be specified or result array will be empty.
@param  OutActors       Output array of Actors of the specified interface."""

	@staticmethod
	def GetAllActorsOfClass(WorldContextObject: Object, ActorClass: Actor) -> typing.List[Actor]: ...
	"""Find all Actors in the world of the specified class.
This is a slow operation, use with caution e.g. do not use every frame.
@param  ActorClass      Class of Actor to find. Must be specified or result array will be empty.
@param  OutActors       Output array of Actors of the specified class."""

	@staticmethod
	def GetActorOfClass(WorldContextObject: Object, ActorClass: Actor) -> Actor: ...
	"""Find the first Actor in the world of the specified class.
This is a slow operation, use with caution e.g. do not use every frame.
@param  ActorClass      Class of Actor to find. Must be specified or result will be empty.
@return                         Actor of the specified class."""

	@staticmethod
	def GetActorArrayBounds(Actors: typing.List[Actor], bOnlyCollidingComponents: bool) -> typing.Tuple[Vector, Vector]: ...
	"""Bind the bounds of an array of Actors"""

	@staticmethod
	def GetActorArrayAverageLocation(Actors: typing.List[Actor]) -> Vector: ...
	"""Find the average location (centroid) of an array of Actors"""

	@staticmethod
	def FinishSpawningActor(Actor: Actor, SpawnTransform: Transform) -> Actor: ...
	"""'Finish' spawning an actor.  This will run the construction script."""

	@staticmethod
	def BeginDeferredActorSpawnFromClass(WorldContextObject: Object, ActorClass: Actor, SpawnTransform: Transform, CollisionHandlingOverride: int = ..., Owner: Actor = ...) -> Actor: ...
	"""Spawns an instance of an actor class, but does not automatically run its construction script."""

	@staticmethod
	def BeginSpawningActorFromClass(WorldContextObject: Object, ActorClass: Actor, SpawnTransform: Transform, bNoCollisionFail: bool = ..., Owner: Actor = ...) -> Actor: ...
	"""Begin Spawning Actor from Class"""

	@staticmethod
	def SpawnObject(ObjectClass: Object, Outer: Object) -> Object: ...
	"""--- Create Object"""

	pass

class ImportanceSamplingLibrary(BlueprintFunctionLibrary):
	"""Importance Sampling Library"""

	@staticmethod
	def ImportanceSample(Texture: ImportanceTexture, Rand: Vector2D, Samples: int, Intensity: float) -> typing.Tuple[Vector2D, LinearColor, float, float]: ...
	"""Distribute sample points proportional to Texture2D luminance.
@param Rand - Random 2D point with components evenly distributed between 0 and 1
@param Samples - Total number of samples that will be used
@param Intensity - Total intensity for light
@outparam SamplePosition - Importance sampled 2D output texture coordinate (0-1)
@outparam SampleColor - Representative color near Position from MIP level for SampleSize
@outparam SampleIntensity - Intensity of individual points, scaled by probability and number of samples
@outparam SampleSize - Local density of points near Position (scaled for 1x1 texture space)"""

	@staticmethod
	def BreakImportanceTexture(ImportanceTexture: ImportanceTexture) -> typing.Tuple[Texture2D, int]: ...
	"""Get texture used to create an ImportanceTexture object
@param ImportanceTexture - The source ImportanceTexture object
@outparam Texture - Texture object for this ImportanceTexture.
@param WeightingFunc - How to turn the texture data into probability weights
@return new ImportanceTexture object for use with ImportanceSample"""

	@staticmethod
	def MakeImportanceTexture(Texture: Texture2D, WeightingFunc: int) -> ImportanceTexture: ...
	"""Create an FImportanceTexture object for texture-driven importance sampling from a 2D RGBA8 texture
@param Texture - Texture object to use. Must be RGBA8 format.
@param WeightingFunc - How to turn the texture data into probability weights
@return new ImportanceTexture object for use with ImportanceSample"""

	@staticmethod
	def NextSobolCell3D(Index: int, NumCells: int = ..., PreviousValue: Vector = ...) -> Vector: ...
	"""@param Index - Which sequential point
@param NumCells - Size of cell grid, 1 to 1024. Rounded up to the next power of two
@param PreviousValue - The Sobol value for Index-1
@return Sobol-distributed random 3D position in the same grid cell"""

	@staticmethod
	def RandomSobolCell3D(Index: int, NumCells: int = ..., Cell: Vector = ..., Seed: Vector = ...) -> Vector: ...
	"""@param Index - Which sequential point in the cell (starting at 0)
@param NumCells - Size of cell grid, 1 to 1024. Rounded up to the next power of two
@param Cell - Give a point from this integer grid cell
@param Seed - Random 3D seed (components in the range 0-1) to randomize across multiple sequences
@return Sobol-distributed random 3D vector in the given grid cell"""

	@staticmethod
	def NextSobolCell2D(Index: int, NumCells: int = ..., PreviousValue: Vector2D = ...) -> Vector2D: ...
	"""@param Index - Which sequential point
@param NumCells - Size of cell grid, 1 to 32768. Rounded up to the next power of two
@param PreviousValue - The Sobol value for Index-1
@return Sobol-distributed random 2D position in the same grid cell"""

	@staticmethod
	def RandomSobolCell2D(Index: int, NumCells: int = ..., Cell: Vector2D = ..., Seed: Vector2D = ...) -> Vector2D: ...
	"""@param Index - Which sequential point in the cell (starting at 0)
@param NumCells - Size of cell grid, 1 to 32768. Rounded up to the next power of two
@param Cell - Give a point from this integer grid cell
@param Seed - Random 2D seed (components in the range 0-1) to randomize across multiple sequences
@return Sobol-distributed random 2D position in the given grid cell"""

	@staticmethod
	def NextSobolFloat(Index: int, Dimension: int, PreviousValue: float) -> float: ...
	"""@param Index - Which sequential point
@param Dimension - Which Sobol dimension (0 to 15)
@param PreviousValue - The Sobol value for Index-1
@return Sobol-distributed random number between 0 and 1"""

	@staticmethod
	def RandomSobolFloat(Index: int, Dimension: int, Seed: float) -> float: ...
	"""@param Index - Which sequential point
@param Dimension - Which Sobol dimension (0 to 15)
@param Seed - Random seed (in the range 0-1) to randomize across multiple sequences
@return Sobol-distributed random number between 0 and 1"""

	pass

class KismetGuidLibrary(BlueprintFunctionLibrary):
	"""Kismet Guid Library"""

	@staticmethod
	def Parse_StringToGuid(GuidString: str) -> typing.Tuple[Guid, bool]: ...
	"""Converts a String of format EGuidFormats to a Guid. Returns Guid OutGuid, Returns bool Success"""

	@staticmethod
	def Conv_GuidToString(InGuid: Guid) -> str: ...
	"""Converts a GUID value to a string, in the form 'A-B-C-D'"""

	@staticmethod
	def NewGuid() -> Guid: ...
	"""Returns a new unique GUID"""

	@staticmethod
	def Invalidate_Guid(InGuid: Guid): ...
	"""Invalidates the given GUID"""

	@staticmethod
	def IsValid_Guid(InGuid: Guid) -> bool: ...
	"""Checks whether the given GUID is valid"""

	@staticmethod
	def NotEqual_GuidGuid(A: Guid, B: Guid) -> bool: ...
	"""Returns true if the values are not equal (A != B)"""

	@staticmethod
	def EqualEqual_GuidGuid(A: Guid, B: Guid) -> bool: ...
	"""Returns true if the values are equal (A == B)"""

	pass

class KismetInputLibrary(BlueprintFunctionLibrary):
	"""Kismet Input Library"""

	@staticmethod
	def PointerEvent_GetGestureDelta(Input: PointerEvent) -> Vector2D: ...
	"""Returns the change in gesture value since the last gesture event of the same type."""

	@staticmethod
	def PointerEvent_GetGestureType(Input: PointerEvent) -> int: ...
	"""Returns the type of touch gesture"""

	@staticmethod
	def PointerEvent_IsTouchEvent(Input: PointerEvent) -> bool: ...
	"""Returns true if this event a result from a touch (as opposed to a mouse)"""

	@staticmethod
	def PointerEvent_GetTouchpadIndex(Input: PointerEvent) -> int: ...
	"""Returns the index of the touch pad that generated this event (for platforms with multiple touch pads per user)"""

	@staticmethod
	def PointerEvent_GetPointerIndex(Input: PointerEvent) -> int: ...
	"""Returns the unique identifier of the pointer (e.g., finger index)"""

	@staticmethod
	def PointerEvent_GetUserIndex(Input: PointerEvent) -> int: ...
	"""Returns the index of the user that caused the event"""

	@staticmethod
	def PointerEvent_GetWheelDelta(Input: PointerEvent) -> float: ...
	"""How much did the mouse wheel turn since the last mouse event"""

	@staticmethod
	def PointerEvent_GetEffectingButton(Input: PointerEvent) -> Key: ...
	"""Mouse button that caused this event to be raised (possibly FKey::Invalid)"""

	@staticmethod
	def PointerEvent_IsMouseButtonDown(Input: PointerEvent, MouseButton: Key) -> bool: ...
	"""Mouse buttons that are currently pressed"""

	@staticmethod
	def PointerEvent_GetCursorDelta(Input: PointerEvent) -> Vector2D: ...
	"""Returns the distance the mouse traveled since the last event was handled."""

	@staticmethod
	def PointerEvent_GetLastScreenSpacePosition(Input: PointerEvent) -> Vector2D: ...
	"""Returns the position of the cursor in screen space last time we handled an input event"""

	@staticmethod
	def PointerEvent_GetScreenSpacePosition(Input: PointerEvent) -> Vector2D: ...
	"""Returns The position of the cursor in screen space"""

	@staticmethod
	def GetAnalogValue(Input: AnalogInputEvent) -> float: ...
	"""Get Analog Value"""

	@staticmethod
	def GetUserIndex(Input: KeyEvent) -> int: ...
	"""Get User Index"""

	@staticmethod
	def GetKey(Input: KeyEvent) -> Key: ...
	"""Returns the key for this event.

@return  Key name"""

	@staticmethod
	def InputChord_GetDisplayName(Key: InputChord) -> str: ...
	"""@return The display name of the input chord"""

	@staticmethod
	def InputEvent_IsRightCommandDown(Input: InputEvent) -> bool: ...
	"""Returns true if right command key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsLeftCommandDown(Input: InputEvent) -> bool: ...
	"""Returns true if left command key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsCommandDown(Input: InputEvent) -> bool: ...
	"""Returns true if either command key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsRightAltDown(Input: InputEvent) -> bool: ...
	"""Returns true if right alt key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsLeftAltDown(Input: InputEvent) -> bool: ...
	"""Returns true if left alt key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsAltDown(Input: InputEvent) -> bool: ...
	"""Returns true if either alt key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsRightControlDown(Input: InputEvent) -> bool: ...
	"""Returns true if left control key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsLeftControlDown(Input: InputEvent) -> bool: ...
	"""Returns true if left control key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsControlDown(Input: InputEvent) -> bool: ...
	"""Returns true if either control key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsRightShiftDown(Input: InputEvent) -> bool: ...
	"""Returns true if right shift key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsLeftShiftDown(Input: InputEvent) -> bool: ...
	"""Returns true if left shift key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsShiftDown(Input: InputEvent) -> bool: ...
	"""Returns true if either shift key was down when this event occurred"""

	@staticmethod
	def InputEvent_IsRepeat(Input: InputEvent) -> bool: ...
	"""Returns whether or not this character is an auto-repeated keystroke"""

	@staticmethod
	def Key_GetDisplayName(Key: Key) -> str: ...
	"""Returns the display name of the key."""

	@staticmethod
	def Key_GetNavigationDirectionFromAnalog(InAnalogEvent: AnalogInputEvent) -> int: ...
	"""Returns the navigation action corresponding to this key, or Invalid if not found"""

	@staticmethod
	def Key_GetNavigationDirectionFromKey(InKeyEvent: KeyEvent) -> int: ...
	"""Returns the navigation action corresponding to this key, or Invalid if not found"""

	@staticmethod
	def Key_GetNavigationActionFromKey(InKeyEvent: KeyEvent) -> int: ...
	"""Returns the navigation action corresponding to this key, or Invalid if not found"""

	@staticmethod
	def Key_IsValid(Key: Key) -> bool: ...
	"""Returns true if this is a valid key."""

	@staticmethod
	def Key_IsDigital(Key: Key) -> bool: ...
	"""Returns true if the key is a digital button press"""

	@staticmethod
	def Key_IsAnalog(Key: Key) -> bool: ...
	"""Returns true if the key is an analog axis"""

	@staticmethod
	def Key_IsButtonAxis(Key: Key) -> bool: ...
	"""Returns true if the key is a 1D axis emulating a digital button press."""

	@staticmethod
	def Key_IsAxis3D(Key: Key) -> bool: ...
	"""Returns true if the key is a 3D (vector) axis"""

	@staticmethod
	def Key_IsAxis2D(Key: Key) -> bool: ...
	"""Returns true if the key is a 2D (vector) axis"""

	@staticmethod
	def Key_IsAxis1D(Key: Key) -> bool: ...
	"""Returns true if the key is a 1D (float) axis"""

	@staticmethod
	def Key_IsKeyboardKey(Key: Key) -> bool: ...
	"""Returns true if the key is a keyboard button"""

	@staticmethod
	def Key_IsMouseButton(Key: Key) -> bool: ...
	"""Returns true if the key is a mouse button"""

	@staticmethod
	def Key_IsGamepadKey(Key: Key) -> bool: ...
	"""Returns true if the key is a gamepad button"""

	@staticmethod
	def Key_IsModifierKey(Key: Key) -> bool: ...
	"""Returns true if the key is a modifier key: Ctrl, Command, Alt, Shift"""

	@staticmethod
	def EqualEqual_InputChordInputChord(A: InputChord, B: InputChord) -> bool: ...
	"""Test if the input chords are equal (A == B)
@param A - The chord to compare against
@param B - The chord to compare
Returns true if the chords are equal, false otherwise"""

	@staticmethod
	def EqualEqual_KeyKey(A: Key, B: Key) -> bool: ...
	"""Test if the input key are equal (A == B)
@param A - The key to compare against
@param B - The key to compare
Returns true if the key are equal, false otherwise"""

	@staticmethod
	def CalibrateTilt(): ...
	"""Calibrate the tilt for the input device"""

	pass

class KismetInternationalizationLibrary(BlueprintFunctionLibrary):
	"""Kismet Internationalization Library"""

	@staticmethod
	def GetCultureDisplayName(Culture: str, Localized: bool = ...) -> str: ...
	"""Get the display name of the given culture.
@param Culture The culture to get the display name of, as an IETF language tag (eg, 'zh-Hans-CN')
@param Localized True to get the localized display name (the name of the culture in its own language), or False to get the display name in the current language.
@return The display name of the culture, or the given culture code on failure."""

	@staticmethod
	def GetSuitableCulture(AvailableCultures: typing.List[str], CultureToMatch: str, FallbackCulture: str = ...) -> str: ...
	"""Given a list of available cultures, try and find the most suitable culture from the list based on culture prioritization.
  eg) If your list was [en, fr, de] and the given culture was 'en-US', this function would return 'en'.
  eg) If your list was [zh, ar, pl] and the given culture was 'en-US', this function would return the fallback culture.
@param AvailableCultures List of available cultures to filter against (see GetLocalizedCultures).
@param CultureToMatch Culture to try and match (see GetCurrentLanguage).
@param FallbackCulture The culture to return if there is no suitable match in the list (typically your native culture, see GetNativeCulture).
@return The culture as an IETF language tag (eg, 'zh-Hans-CN')."""

	@staticmethod
	def GetLocalizedCultures(IncludeGame: bool = ..., IncludeEngine: bool = ..., IncludeEditor: bool = ..., IncludeAdditional: bool = ...) -> typing.List[str]: ...
	"""Get the list of cultures that have localization data available for them.
@param IncludeGame Check for localized game resources.
@param IncludeEngine Check for localized engine resources.
@param IncludeEditor Check for localized editor resources.
@param IncludeAdditional Check for localized additional (eg, plugin) resources.
@return The list of cultures as IETF language tags (eg, 'zh-Hans-CN')."""

	@staticmethod
	def GetNativeCulture(TextCategory: int) -> str: ...
	"""Get the native culture for the given localization category.
@param Category The localization category to query.
@return The culture as an IETF language tag (eg, 'zh-Hans-CN')."""

	@staticmethod
	def ClearCurrentAssetGroupCulture(AssetGroup: str, SaveToConfig: bool = ...): ...
	"""Clear the given asset group category culture.
@param AssetGroup The asset group to clear the culture for.
@param SaveToConfig If true, save the new setting to the users' 'GameUserSettings' config so that it persists after a reload."""

	@staticmethod
	def GetCurrentAssetGroupCulture(AssetGroup: str) -> str: ...
	"""Get the given asset group category culture.
@note Returns the current language if the group category doesn't have a culture override.
@param AssetGroup The asset group to get the culture for.
@return The culture as an IETF language tag (eg, 'zh-Hans-CN')."""

	@staticmethod
	def SetCurrentAssetGroupCulture(AssetGroup: str, Culture: str, SaveToConfig: bool = ...) -> bool: ...
	"""Set the given asset group category culture from an IETF language tag (eg, 'zh-Hans-CN').
@param AssetGroup The asset group to set the culture for.
@param Culture The culture to set, as an IETF language tag (eg, 'zh-Hans-CN').
@param SaveToConfig If true, save the new setting to the users' 'GameUserSettings' config so that it persists after a reload.
@return True if the culture was set, false otherwise."""

	@staticmethod
	def SetCurrentLanguageAndLocale(Culture: str, SaveToConfig: bool = ...) -> bool: ...
	"""Set the current language (for localization) and locale (for internationalization).
@param Culture The language and locale to set, as an IETF language tag (eg, 'zh-Hans-CN').
@param SaveToConfig If true, save the new setting to the users' 'GameUserSettings' config so that it persists after a reload.
@return True if the language and locale were set, false otherwise."""

	@staticmethod
	def GetCurrentLocale() -> str: ...
	"""Get the current locale (for internationalization) as an IETF language tag:
 - A two-letter ISO 639-1 language code (eg, 'zh').
 - An optional four-letter ISO 15924 script code (eg, 'Hans').
 - An optional two-letter ISO 3166-1 country code (eg, 'CN').
@return The locale as an IETF language tag (eg, 'zh-Hans-CN')."""

	@staticmethod
	def SetCurrentLocale(Culture: str, SaveToConfig: bool = ...) -> bool: ...
	"""Set *only* the current locale (for internationalization).
@note Unless you're doing something advanced, you likely want SetCurrentLanguageAndLocale or SetCurrentCulture instead.
@param Culture The locale to set, as an IETF language tag (eg, 'zh-Hans-CN').
@param SaveToConfig If true, save the new setting to the users' 'GameUserSettings' config so that it persists after a reload.
@return True if the locale was set, false otherwise."""

	@staticmethod
	def GetCurrentLanguage() -> str: ...
	"""Get the current language (for localization) as an IETF language tag:
 - A two-letter ISO 639-1 language code (eg, 'zh').
 - An optional four-letter ISO 15924 script code (eg, 'Hans').
 - An optional two-letter ISO 3166-1 country code (eg, 'CN').
@return The language as an IETF language tag (eg, 'zh-Hans-CN')."""

	@staticmethod
	def SetCurrentLanguage(Culture: str, SaveToConfig: bool = ...) -> bool: ...
	"""Set *only* the current language (for localization).
@note Unless you're doing something advanced, you likely want SetCurrentLanguageAndLocale or SetCurrentCulture instead.
@param Culture The language to set, as an IETF language tag (eg, 'zh-Hans-CN').
@param SaveToConfig If true, save the new setting to the users' 'GameUserSettings' config so that it persists after a reload.
@return True if the language was set, false otherwise."""

	@staticmethod
	def GetCurrentCulture() -> str: ...
	"""Get the current culture as an IETF language tag:
 - A two-letter ISO 639-1 language code (eg, 'zh').
 - An optional four-letter ISO 15924 script code (eg, 'Hans').
 - An optional two-letter ISO 3166-1 country code (eg, 'CN').
@note This function exists for legacy API parity with SetCurrentCulture and is equivalent to GetCurrentLanguage.
@return The culture as an IETF language tag (eg, 'zh-Hans-CN')."""

	@staticmethod
	def SetCurrentCulture(Culture: str, SaveToConfig: bool = ...) -> bool: ...
	"""Set the current culture.
@note This function is a sledgehammer, and will set both the language and locale, as well as clear out any asset group cultures that may be set.
@param Culture The culture to set, as an IETF language tag (eg, 'zh-Hans-CN').
@param SaveToConfig If true, save the new setting to the users' 'GameUserSettings' config so that it persists after a reload.
@return True if the culture was set, false otherwise."""

	pass

class KismetMaterialLibrary(BlueprintFunctionLibrary):
	"""Kismet Material Library"""

	@staticmethod
	def CreateDynamicMaterialInstance(WorldContextObject: Object, Parent: MaterialInterface, OptionalName: str = ..., CreationFlags: int = ...) -> MaterialInstanceDynamic: ...
	"""Creates a Dynamic Material Instance which you can modify during gameplay."""

	@staticmethod
	def GetVectorParameterValue(WorldContextObject: Object, Collection: MaterialParameterCollection, ParameterName: str) -> LinearColor: ...
	"""Gets a vector parameter value from the material collection instance. Logs if ParameterName is invalid."""

	@staticmethod
	def GetScalarParameterValue(WorldContextObject: Object, Collection: MaterialParameterCollection, ParameterName: str) -> float: ...
	"""Gets a scalar parameter value from the material collection instance. Logs if ParameterName is invalid."""

	@staticmethod
	def SetVectorParameterValue(WorldContextObject: Object, Collection: MaterialParameterCollection, ParameterName: str, ParameterValue: LinearColor): ...
	"""Sets a vector parameter value on the material collection instance. Logs if ParameterName is invalid."""

	@staticmethod
	def SetScalarParameterValue(WorldContextObject: Object, Collection: MaterialParameterCollection, ParameterName: str, ParameterValue: float): ...
	"""Sets a scalar parameter value on the material collection instance. Logs if ParameterName is invalid."""

	pass

class KismetMathLibrary(BlueprintFunctionLibrary):
	"""Kismet Math Library"""

	@staticmethod
	def DynamicWeightedMovingAverage_FRotator(CurrentSample: Rotator, PreviousSample: Rotator, MaxDistance: float, MinWeight: float, MaxWeight: float) -> Rotator: ...
	"""Calculates the new value in a weighted moving average series using the previous value and a weight range.
The weight range is used to dynamically adjust based upon distance between the samples
This allows you to smooth a value more aggressively for small noise and let large movements be smoothed less (or vice versa)

@param CurrentSample - The value to blend with the previous sample to get a new weighted value
@param PreviousSample - The last value from the series
@param MaxDistance - Distance to use as the blend between min weight or max weight
@param MinWeight - The weight use when the distance is small
@param MaxWeight - The weight use when the distance is large

@return the next value in the series"""

	@staticmethod
	def DynamicWeightedMovingAverage_FVector(CurrentSample: Vector, PreviousSample: Vector, MaxDistance: float, MinWeight: float, MaxWeight: float) -> Vector: ...
	"""Calculates the new value in a weighted moving average series using the previous value and a weight range.
The weight range is used to dynamically adjust based upon distance between the samples
This allows you to smooth a value more aggressively for small noise and let large movements be smoothed less (or vice versa)

@param CurrentSample - The value to blend with the previous sample to get a new weighted value
@param PreviousSample - The last value from the series
@param MaxDistance - Distance to use as the blend between min weight or max weight
@param MinWeight - The weight use when the distance is small
@param MaxWeight - The weight use when the distance is large

@return the next value in the series"""

	@staticmethod
	def DynamicWeightedMovingAverage_Float(CurrentSample: float, PreviousSample: float, MaxDistance: float, MinWeight: float, MaxWeight: float) -> float: ...
	"""Calculates the new value in a weighted moving average series using the previous value and a weight range.
The weight range is used to dynamically adjust based upon distance between the samples
This allows you to smooth a value more aggressively for small noise and let large movements be smoothed less (or vice versa)

@param CurrentSample - The value to blend with the previous sample to get a new weighted value
@param PreviousSample - The last value from the series
@param MaxDistance - Distance to use as the blend between min weight or max weight
@param MinWeight - The weight use when the distance is small
@param MaxWeight - The weight use when the distance is large

@return the next value in the series"""

	@staticmethod
	def WeightedMovingAverage_FRotator(CurrentSample: Rotator, PreviousSample: Rotator, Weight: float) -> Rotator: ...
	"""Calculates the new value in a weighted moving average series using the previous value and the weight

@param CurrentSample - The value to blend with the previous sample to get a new weighted value
@param PreviousSample - The last value from the series
@param Weight - The weight to blend with

@return the next value in the series"""

	@staticmethod
	def WeightedMovingAverage_FVector(CurrentSample: Vector, PreviousSample: Vector, Weight: float) -> Vector: ...
	"""Calculates the new value in a weighted moving average series using the previous value and the weight

@param CurrentSample - The value to blend with the previous sample to get a new weighted value
@param PreviousSample - The last value from the series
@param Weight - The weight to blend with

@return the next value in the series"""

	@staticmethod
	def WeightedMovingAverage_Float(CurrentSample: float, PreviousSample: float, Weight: float) -> float: ...
	"""Calculates the new value in a weighted moving average series using the previous value and the weight

@param CurrentSample - The value to blend with the previous sample to get a new weighted value
@param PreviousSample - The last value from the series
@param Weight - The weight to blend with

@return the next value in the series"""

	@staticmethod
	def LinePlaneIntersection_OriginNormal(LineStart: Vector, LineEnd: Vector, PlaneOrigin: Vector, PlaneNormal: Vector) -> typing.Tuple[bool, float, Vector]: ...
	"""Computes the intersection point between a line and a plane.
@param               T - The t of the intersection between the line and the plane
@param               Intersection - The point of intersection between the line and the plane
@return              True if the intersection test was successful."""

	@staticmethod
	def LinePlaneIntersection(LineStart: Vector, LineEnd: Vector, APlane: Plane) -> typing.Tuple[bool, float, Vector]: ...
	"""Computes the intersection point between a line and a plane.
@param               T - The t of the intersection between the line and the plane
@param               Intersection - The point of intersection between the line and the plane
@return              True if the intersection test was successful."""

	@staticmethod
	def GetSlopeDegreeAngles(MyRightYAxis: Vector, FloorNormal: Vector, UpVector: Vector) -> typing.Tuple[float, float]: ...
	"""Returns Slope Pitch and Roll angles in degrees based on the following information:

@param        MyRightYAxis                            Right (Y) direction unit vector of Actor standing on Slope.
@param        FloorNormal                                     Floor Normal (unit) vector.
@param        UpVector                                        UpVector of reference frame.
@outparam OutSlopePitchDegreeAngle    Slope Pitch angle (degrees)
@outparam OutSlopeRollDegreeAngle             Slope Roll angle (degrees)"""

	@staticmethod
	def IsPointInBoxWithTransform(Point: Vector, BoxWorldTransform: Transform, BoxExtent: Vector) -> bool: ...
	"""Determines whether a given point is in a box with a given transform. Includes points on the box.

@param Point                          Point to test
@param BoxWorldTransform      Component-to-World transform of the box.
@param BoxExtent                      Extents of the box (distance in each axis from origin), in component space.
@return Whether the point is in the box."""

	@staticmethod
	def IsPointInBox(Point: Vector, BoxOrigin: Vector, BoxExtent: Vector) -> bool: ...
	"""Determines whether the given point is in a box. Includes points on the box.

@param Point                 Point to test
@param BoxOrigin             Origin of the box
@param BoxExtent             Extents of the box (distance in each axis from origin)
@return Whether the point is in the box."""

	@staticmethod
	def PointsAreCoplanar(Points: typing.List[Vector], Tolerance: float = ...) -> bool: ...
	"""Determines whether a given set of points are coplanar, with a tolerance. Any three points or less are always coplanar.

@param Points - The set of points to determine coplanarity for.
@param Tolerance - Larger numbers means more variance is allowed.

@return Whether the points are relatively coplanar, based on the tolerance"""

	@staticmethod
	def MinimumAreaRectangle(WorldContextObject: Object, InVerts: typing.List[Vector], SampleSurfaceNormal: Vector, bDebugDraw: bool = ...) -> typing.Tuple[Vector, Rotator, float, float]: ...
	"""Finds the minimum area rectangle that encloses all of the points in InVerts
Uses algorithm found in http://www.geometrictools.com/Documentation/MinimumAreaRectangle.pdf

@param               InVerts - Points to enclose in the rectangle
@outparam    OutRectCenter - Center of the enclosing rectangle
@outparam    OutRectSideA - Vector oriented and sized to represent one edge of the enclosing rectangle, orthogonal to OutRectSideB
@outparam    OutRectSideB - Vector oriented and sized to represent one edge of the enclosing rectangle, orthogonal to OutRectSideA"""

	@staticmethod
	def PerlinNoise1D(Value: float) -> float: ...
	"""Generates a 1D Perlin noise from the given value.  Returns a continuous random value between -1.0 and 1.0.

@param       Value   The input value that Perlin noise will be generated from.  This is usually a steadily incrementing time value.

@return      Perlin noise in the range of -1.0 to 1.0"""

	@staticmethod
	def RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir: Vector, MaxYawInDegrees: float, MaxPitchInDegrees: float, Stream: RandomStream) -> Vector: ...
	"""Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
The shape of the cone can be modified according to the yaw and pitch angles.

@param MaxYawInDegrees        The yaw angle of the cone (from ConeDir to horizontal edge), in degrees.
@param MaxPitchInDegrees      The pitch angle of the cone (from ConeDir to vertical edge), in degrees.
@param Stream                         The random stream from which to obtain the vector."""

	@staticmethod
	def RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir: Vector, MaxYawInRadians: float, MaxPitchInRadians: float, Stream: RandomStream) -> Vector: ...
	"""Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
The shape of the cone can be modified according to the yaw and pitch angles.

@param MaxYawInRadians        The yaw angle of the cone (from ConeDir to horizontal edge), in radians.
@param MaxPitchInRadians      The pitch angle of the cone (from ConeDir to vertical edge), in radians.
@param Stream                         The random stream from which to obtain the vector."""

	@staticmethod
	def RandomUnitVectorInConeInDegreesFromStream(ConeDir: Vector, ConeHalfAngleInDegrees: float, Stream: RandomStream) -> Vector: ...
	"""Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
@param ConeDir                                       The base 'center' direction of the cone.
@param ConeHalfAngleInDegrees        The half-angle of the cone (from ConeDir to edge), in degrees.
@param Stream                                        The random stream from which to obtain the vector."""

	@staticmethod
	def RandomUnitVectorInConeInRadiansFromStream(ConeDir: Vector, ConeHalfAngleInRadians: float, Stream: RandomStream) -> Vector: ...
	"""Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
@param ConeDir                                       The base 'center' direction of the cone.
@param ConeHalfAngleInRadians        The half-angle of the cone (from ConeDir to edge), in radians.
@param Stream                                        The random stream from which to obtain the vector."""

	@staticmethod
	def SetRandomStreamSeed(Stream: RandomStream, NewSeed: int): ...
	"""Set the seed of a random stream to a specific number"""

	@staticmethod
	def SeedRandomStream(Stream: RandomStream): ...
	"""Create a new random seed for a random stream"""

	@staticmethod
	def ResetRandomStream(Stream: RandomStream): ...
	"""Reset a random stream"""

	@staticmethod
	def RandomRotatorFromStream(bRoll: bool, Stream: RandomStream) -> Rotator: ...
	"""Create a random rotation"""

	@staticmethod
	def RandomUnitVectorFromStream(Stream: RandomStream) -> Vector: ...
	"""Returns a random vector with length of 1.0"""

	@staticmethod
	def RandomFloatInRangeFromStream(Min: float, Max: float, Stream: RandomStream) -> float: ...
	"""Generate a random number between Min and Max"""

	@staticmethod
	def RandomFloatFromStream(Stream: RandomStream) -> float: ...
	"""Returns a random float between 0 and 1"""

	@staticmethod
	def RandomBoolFromStream(Stream: RandomStream) -> bool: ...
	"""Returns a random bool"""

	@staticmethod
	def RandomIntegerInRangeFromStream(Min: int, Max: int, Stream: RandomStream) -> int: ...
	"""Return a random integer between Min and Max (>= Min and <= Max)"""

	@staticmethod
	def RandomIntegerFromStream(Max: int, Stream: RandomStream) -> int: ...
	"""Returns a uniformly distributed random number between 0 and Max - 1"""

	@staticmethod
	def ResetVectorSpringState(SpringState: VectorSpringState): ...
	"""Resets the state of a given spring"""

	@staticmethod
	def ResetFloatSpringState(SpringState: FloatSpringState): ...
	"""Resets the state of a given spring"""

	@staticmethod
	def FloatSpringInterp(Current: float, Target: float, SpringState: FloatSpringState, Stiffness: float, CriticalDampingFactor: float, DeltaTime: float, Mass: float = ...) -> float: ...
	"""Uses a simple spring model to interpolate a float from Current to Target.

@param Current                               Current value
@param Target                                Target value
@param SpringState                   Data related to spring model (velocity, error, etc..) - Create a unique variable per spring
@param Stiffness                             How stiff the spring model is (more stiffness means more oscillation around the target value)
@param CriticalDampingFactor How much damping to apply to the spring (0 means no damping, 1 means critically damped which means no oscillation)
@param Mass                                  Multiplier that acts like mass on a spring"""

	@staticmethod
	def RInterpTo_Constant(Current: Rotator, Target: Rotator, DeltaTime: float, InterpSpeed: float) -> Rotator: ...
	"""Tries to reach Target rotation at a constant rate.

@param               Current                 Actual rotation
@param               Target                  Target rotation
@param               DeltaTime               Time since last tick
@param               InterpSpeed             Interpolation speed
@return              New interpolated position"""

	@staticmethod
	def RInterpTo(Current: Rotator, Target: Rotator, DeltaTime: float, InterpSpeed: float) -> Rotator: ...
	"""Tries to reach Target rotation based on Current rotation, giving a nice smooth feeling when rotating to Target rotation.

@param               Current                 Actual rotation
@param               Target                  Target rotation
@param               DeltaTime               Time since last tick
@param               InterpSpeed             Interpolation speed, if the speed given is 0, then jump to the target.
@return              New interpolated position"""

	@staticmethod
	def FInterpTo_Constant(Current: float, Target: float, DeltaTime: float, InterpSpeed: float) -> float: ...
	"""Tries to reach Target at a constant rate.

@param               Current                 Actual position
@param               Target                  Target position
@param               DeltaTime               Time since last tick
@param               InterpSpeed             Interpolation speed
@return              New interpolated position"""

	@staticmethod
	def FInterpTo(Current: float, Target: float, DeltaTime: float, InterpSpeed: float) -> float: ...
	"""Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.

@param               Current                 Actual position
@param               Target                  Target position
@param               DeltaTime               Time since last tick
@param               InterpSpeed             Interpolation speed, if the speed given is 0, then jump to the target.
@return              New interpolated position"""

	@staticmethod
	def Conv_TransformToMatrix(Transform: Transform) -> Matrix: ...
	"""Convert a Transform to a Matrix with scale"""

	@staticmethod
	def Transform_Determinant(Transform: Transform) -> float: ...
	"""Calculates the determinant of the transform (converts to FMatrix internally)"""

	@staticmethod
	def TInterpTo(Current: Transform, Target: Transform, DeltaTime: float, InterpSpeed: float) -> Transform: ...
	"""Tries to reach Target transform based on distance from Current position, giving a nice smooth feeling when tracking a position.

@param               Current                 Actual transform
@param               Target                  Target transform
@param               DeltaTime               Time since last tick
@param               InterpSpeed             Interpolation speed, if the speed given is 0, then jump to the target.
@return              New interpolated transform"""

	@staticmethod
	def TEase(A: Transform, B: Transform, Alpha: float, EasingFunc: int, BlendExp: float = ..., Steps: int = ...) -> Transform: ...
	"""Ease between A and B using a specified easing function."""

	@staticmethod
	def TLerp(A: Transform, B: Transform, Alpha: float, InterpMode: int = ...) -> Transform: ...
	"""Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)."""

	@staticmethod
	def InvertTransform(T: Transform) -> Transform: ...
	"""Returns the inverse of the given transform T.

Example: Given a LocalToWorld transform, WorldToLocal will be returned.

@param       T       The transform you wish to invert
@return      The inverse of T."""

	@staticmethod
	def ConvertTransformToRelative(Transform: Transform, ParentTransform: Transform) -> Transform: ...
	"""Convert Transform to Relative"""

	@staticmethod
	def MakeRelativeTransform(A: Transform, RelativeTo: Transform) -> Transform: ...
	"""Computes a relative transform of one transform compared to another.

Example: ChildOffset = MakeRelativeTransform(Child.GetActorTransform(), Parent.GetActorTransform())
This computes the relative transform of the Child from the Parent.

@param               A                               The object's transform
@param               RelativeTo              The transform the result is relative to (in the same space as A)
@return              The new relative transform"""

	@staticmethod
	def InverseTransformRotation(T: Transform, Rotation: Rotator) -> Rotator: ...
	"""Transform a rotator by the inverse of the supplied transform.
For example, if T was an object's transform, this would transform a rotation from world space to local space."""

	@staticmethod
	def InverseTransformDirection(T: Transform, Direction: Vector) -> Vector: ...
	"""Transform a direction vector by the inverse of the supplied transform - will not change its length.
For example, if T was an object's transform, this would transform a direction from world space to local space."""

	@staticmethod
	def InverseTransformLocation(T: Transform, Location: Vector) -> Vector: ...
	"""Transform a position by the inverse of the supplied transform.
For example, if T was an object's transform, this would transform a position from world space to local space."""

	@staticmethod
	def TransformRotation(T: Transform, Rotation: Rotator) -> Rotator: ...
	"""Transform a rotator by the supplied transform.
For example, if T was an object's transform, this would transform a rotation from local space to world space."""

	@staticmethod
	def TransformDirection(T: Transform, Direction: Vector) -> Vector: ...
	"""Transform a direction vector by the supplied transform - will not change its length.
For example, if T was an object's transform, this would transform a direction from local space to world space."""

	@staticmethod
	def TransformLocation(T: Transform, Location: Vector) -> Vector: ...
	"""Transform a position by the supplied transform.
For example, if T was an object's transform, this would transform a position from local space to world space."""

	@staticmethod
	def ComposeTransforms(A: Transform, B: Transform) -> Transform: ...
	"""Compose two transforms in order: A * B.

Order matters when composing transforms:
A * B will yield a transform that logically first applies A then B to any subsequent transformation.

Example: LocalToWorld = ComposeTransforms(DeltaRotation, LocalToWorld) will change rotation in local space by DeltaRotation.
Example: LocalToWorld = ComposeTransforms(LocalToWorld, DeltaRotation) will change rotation in world space by DeltaRotation.

@return New transform: A * B"""

	@staticmethod
	def NearlyEqual_TransformTransform(A: Transform, B: Transform, LocationTolerance: float = ..., RotationTolerance: float = ..., Scale3DTolerance: float = ...) -> bool: ...
	"""Returns true if transform A is nearly equal to B
@param LocationTolerance        How close position of transforms need to be to be considered equal
@param RotationTolerance        How close rotations of transforms need to be to be considered equal
@param Scale3DTolerance         How close scale of transforms need to be to be considered equal"""

	@staticmethod
	def EqualEqual_TransformTransform(A: Transform, B: Transform) -> bool: ...
	"""Returns true if transform A is equal to transform B"""

	@staticmethod
	def BreakTransform(InTransform: Transform) -> typing.Tuple[Vector, Rotator, Vector]: ...
	"""Breaks apart a transform into location, rotation and scale"""

	@staticmethod
	def MakeTransform(Location: Vector, Rotation: Rotator, Scale: Vector) -> Transform: ...
	"""Make a transform from location, rotation and scale"""

	@staticmethod
	def NotEqual_NameName(A: str, B: str) -> bool: ...
	"""Returns true if A and B are not equal (A != B)"""

	@staticmethod
	def EqualEqual_NameName(A: str, B: str) -> bool: ...
	"""Returns true if A and B are equal (A == B)"""

	@staticmethod
	def ClassIsChildOf(TestClass: Object, ParentClass: Object) -> bool: ...
	"""Determine if a class is a child of another class.

@return      true if TestClass == ParentClass, or if TestClass is a child of ParentClass; false otherwise, or if either
                     the value for either parameter is 'None'."""

	@staticmethod
	def NotEqual_ClassClass(A: Object, B: Object) -> bool: ...
	"""Returns true if A and B are not equal (A != B)"""

	@staticmethod
	def EqualEqual_ClassClass(A: Object, B: Object) -> bool: ...
	"""Returns true if A and B are equal (A == B)"""

	@staticmethod
	def NotEqual_ObjectObject(A: Object, B: Object) -> bool: ...
	"""Returns true if A and B are not equal (A != B)"""

	@staticmethod
	def EqualEqual_ObjectObject(A: Object, B: Object) -> bool: ...
	"""Returns true if A and B are equal (A == B)"""

	@staticmethod
	def SelectClass(A: Object, B: Object, bSelectA: bool) -> Object: ...
	"""If bPickA is true, A is returned, otherwise B is"""

	@staticmethod
	def SelectObject(A: Object, B: Object, bSelectA: bool) -> Object: ...
	"""If bPickA is true, A is returned, otherwise B is"""

	@staticmethod
	def SelectTransform(A: Transform, B: Transform, bPickA: bool) -> Transform: ...
	"""If bPickA is true, A is returned, otherwise B is"""

	@staticmethod
	def SelectColor(A: LinearColor, B: LinearColor, bPickA: bool) -> LinearColor: ...
	"""If bPickA is true, A is returned, otherwise B is"""

	@staticmethod
	def SelectRotator(A: Rotator, B: Rotator, bPickA: bool) -> Rotator: ...
	"""If bPickA is true, A is returned, otherwise B is"""

	@staticmethod
	def SelectVector(A: Vector, B: Vector, bPickA: bool) -> Vector: ...
	"""If bPickA is true, A is returned, otherwise B is"""

	@staticmethod
	def SelectFloat(A: float, B: float, bPickA: bool) -> float: ...
	"""If bPickA is true, A is returned, otherwise B is"""

	@staticmethod
	def SelectInt(A: int, B: int, bPickA: bool) -> int: ...
	"""If bPickA is true, A is returned, otherwise B is"""

	@staticmethod
	def SelectString(A: str, B: str, bPickA: bool) -> str: ...
	"""If bPickA is true, A is returned, otherwise B is"""

	@staticmethod
	def BreakRandomStream(InRandomStream: RandomStream) -> int: ...
	"""Breaks apart a random number generator"""

	@staticmethod
	def MakeRandomStream(InitialSeed: int) -> RandomStream: ...
	"""Makes a SRand-based random number generator"""

	@staticmethod
	def MakeBox2D(Min: Vector2D, Max: Vector2D) -> Box2D: ...
	"""Makes an FBox2D from Min and Max and sets IsValid to true"""

	@staticmethod
	def MakeBox(Min: Vector, Max: Vector) -> Box: ...
	"""Makes an FBox from Min and Max and sets IsValid to true"""

	@staticmethod
	def Conv_FloatToVector(InFloat: float) -> Vector: ...
	"""Convert a float into a vector, where each element is that float"""

	@staticmethod
	def Conv_IntVectorToVector(InIntVector: IntVector) -> Vector: ...
	"""Convert an IntVector to a vector"""

	@staticmethod
	def Conv_ColorToLinearColor(InColor: Color) -> LinearColor: ...
	"""Converts a color to LinearColor"""

	@staticmethod
	def Conv_ByteToInt(InByte: int) -> int: ...
	"""Converts a byte to an integer"""

	@staticmethod
	def Conv_BoolToByte(InBool: bool) -> int: ...
	"""Converts a bool to a byte"""

	@staticmethod
	def Conv_BoolToFloat(InBool: bool) -> float: ...
	"""Converts a bool to a float (0.0f or 1.0f)"""

	@staticmethod
	def Conv_BoolToInt(InBool: bool) -> int: ...
	"""Converts a bool to an int"""

	@staticmethod
	def Conv_IntToBool(InInt: int) -> bool: ...
	"""Converts a int to a bool"""

	@staticmethod
	def Conv_IntToIntVector(InInt: int) -> IntVector: ...
	"""Converts an integer to an IntVector"""

	@staticmethod
	def Conv_Int64ToByte(InInt: long) -> int: ...
	"""Converts a 64 bit integer to a byte (if the integer is too large, returns the low 8 bits)"""

	@staticmethod
	def Conv_Int64ToInt(InInt: long) -> int: ...
	"""Converts a 64 bit integer to a 32 bit integer (if the integer is too large, returns the low 32 bits)"""

	@staticmethod
	def Conv_IntToByte(InInt: int) -> int: ...
	"""Converts an integer to a byte (if the integer is too large, returns the low 8 bits)"""

	@staticmethod
	def Conv_IntToInt64(InInt: int) -> long: ...
	"""Converts an integer to a 64 bit integer"""

	@staticmethod
	def Conv_IntToFloat(InInt: int) -> float: ...
	"""Converts an integer to a float"""

	@staticmethod
	def Conv_ByteToFloat(InByte: int) -> float: ...
	"""Converts a byte to a float"""

	@staticmethod
	def BreakFrameRate(InFrameRate: FrameRate) -> typing.Tuple[int, int]: ...
	"""Breaks a FFrameRate into a numerator and denominator."""

	@staticmethod
	def MakeFrameRate(Numerator: int, Denominator: int = ...) -> FrameRate: ...
	"""Creates a FFrameRate from a Numerator and a Denominator. Enforces that the Denominator is at least one."""

	@staticmethod
	def BreakQualifiedFrameTime(InFrameTime: QualifiedFrameTime) -> typing.Tuple[FrameNumber, FrameRate, float]: ...
	"""Breaks a FQualifiedFrameTime into its component parts again."""

	@staticmethod
	def MakeQualifiedFrameTime(Frame: FrameNumber, FrameRate: FrameRate, SubFrame: float = ...) -> QualifiedFrameTime: ...
	"""Creates a FQualifiedFrameTime out of a frame number, frame rate, and optional 0-1 clamped subframe."""

	@staticmethod
	def TimespanFromString(TimespanString: str) -> typing.Tuple[bool, Timespan]: ...
	"""Converts a time span string to a Timespan object"""

	@staticmethod
	def TimespanRatio(A: Timespan, B: Timespan) -> float: ...
	"""Returns the ratio between two time spans (A / B), handles zero values"""

	@staticmethod
	def FromSeconds(Seconds: float) -> Timespan: ...
	"""Returns a time span that represents the specified number of seconds"""

	@staticmethod
	def FromMinutes(Minutes: float) -> Timespan: ...
	"""Returns a time span that represents the specified number of minutes"""

	@staticmethod
	def FromMilliseconds(Milliseconds: float) -> Timespan: ...
	"""Returns a time span that represents the specified number of milliseconds"""

	@staticmethod
	def FromHours(Hours: float) -> Timespan: ...
	"""Returns a time span that represents the specified number of hours"""

	@staticmethod
	def FromDays(Days: float) -> Timespan: ...
	"""Returns a time span that represents the specified number of days"""

	@staticmethod
	def GetTotalSeconds(A: Timespan) -> float: ...
	"""Returns the total number of seconds in A"""

	@staticmethod
	def GetTotalMinutes(A: Timespan) -> float: ...
	"""Returns the total number of minutes in A"""

	@staticmethod
	def GetTotalMilliseconds(A: Timespan) -> float: ...
	"""Returns the total number of milliseconds in A"""

	@staticmethod
	def GetTotalHours(A: Timespan) -> float: ...
	"""Returns the total number of hours in A"""

	@staticmethod
	def GetTotalDays(A: Timespan) -> float: ...
	"""Returns the total number of days in A"""

	@staticmethod
	def GetSeconds(A: Timespan) -> int: ...
	"""Returns the seconds component of A"""

	@staticmethod
	def GetMinutes(A: Timespan) -> int: ...
	"""Returns the minutes component of A"""

	@staticmethod
	def GetMilliseconds(A: Timespan) -> int: ...
	"""Returns the milliseconds component of A"""

	@staticmethod
	def GetHours(A: Timespan) -> int: ...
	"""Returns the hours component of A"""

	@staticmethod
	def GetDuration(A: Timespan) -> Timespan: ...
	"""Returns the absolute value of A"""

	@staticmethod
	def GetDays(A: Timespan) -> int: ...
	"""Returns the days component of A"""

	@staticmethod
	def LessEqual_TimespanTimespan(A: Timespan, B: Timespan) -> bool: ...
	"""Returns true if A is less than or equal to B (A <= B)"""

	@staticmethod
	def Less_TimespanTimespan(A: Timespan, B: Timespan) -> bool: ...
	"""Returns true if A is less than B (A < B)"""

	@staticmethod
	def GreaterEqual_TimespanTimespan(A: Timespan, B: Timespan) -> bool: ...
	"""Returns true if A is greater than or equal to B (A >= B)"""

	@staticmethod
	def Greater_TimespanTimespan(A: Timespan, B: Timespan) -> bool: ...
	"""Returns true if A is greater than B (A > B)"""

	@staticmethod
	def NotEqual_TimespanTimespan(A: Timespan, B: Timespan) -> bool: ...
	"""Returns true if the values are not equal (A != B)"""

	@staticmethod
	def EqualEqual_TimespanTimespan(A: Timespan, B: Timespan) -> bool: ...
	"""Returns true if the values are equal (A == B)"""

	@staticmethod
	def Divide_TimespanFloat(A: Timespan, Scalar: float) -> Timespan: ...
	"""Scalar division (A / s)"""

	@staticmethod
	def Multiply_TimespanFloat(A: Timespan, Scalar: float) -> Timespan: ...
	"""Scalar multiplication (A * s)"""

	@staticmethod
	def Subtract_TimespanTimespan(A: Timespan, B: Timespan) -> Timespan: ...
	"""Subtraction (A - B)"""

	@staticmethod
	def Add_TimespanTimespan(A: Timespan, B: Timespan) -> Timespan: ...
	"""Addition (A + B)"""

	@staticmethod
	def BreakTimespan2(InTimespan: Timespan) -> typing.Tuple[int, int, int, int, int]: ...
	"""Breaks a Timespan into its components"""

	@staticmethod
	def BreakTimespan(InTimespan: Timespan) -> typing.Tuple[int, int, int, int, int]: ...
	"""Breaks a Timespan into its components"""

	@staticmethod
	def MakeTimespan2(Days: int, Hours: int, Minutes: int, Seconds: int, FractionNano: int) -> Timespan: ...
	"""Makes a Timespan struct"""

	@staticmethod
	def MakeTimespan(Days: int, Hours: int, Minutes: int, Seconds: int, Milliseconds: int) -> Timespan: ...
	"""Makes a Timespan struct"""

	@staticmethod
	def TimespanZeroValue() -> Timespan: ...
	"""Returns a zero time span value"""

	@staticmethod
	def TimespanMinValue() -> Timespan: ...
	"""Returns the minimum time span value"""

	@staticmethod
	def TimespanMaxValue() -> Timespan: ...
	"""Returns the maximum time span value"""

	@staticmethod
	def DateTimeFromString(DateTimeString: str) -> typing.Tuple[bool, DateTime]: ...
	"""Converts a date string to a DateTime object"""

	@staticmethod
	def DateTimeFromIsoString(IsoString: str) -> typing.Tuple[bool, DateTime]: ...
	"""Converts a date string in ISO-8601 format to a DateTime object"""

	@staticmethod
	def UtcNow() -> DateTime: ...
	"""Returns the UTC date and time on this computer"""

	@staticmethod
	def Today() -> DateTime: ...
	"""Returns the local date on this computer"""

	@staticmethod
	def Now() -> DateTime: ...
	"""Returns the local date and time on this computer"""

	@staticmethod
	def DateTimeMinValue() -> DateTime: ...
	"""Returns the minimum date and time value"""

	@staticmethod
	def DateTimeMaxValue() -> DateTime: ...
	"""Returns the maximum date and time value"""

	@staticmethod
	def IsLeapYear(Year: int) -> bool: ...
	"""Returns whether given year is a leap year"""

	@staticmethod
	def DaysInYear(Year: int) -> int: ...
	"""Returns the number of days in the given year"""

	@staticmethod
	def DaysInMonth(Year: int, Month: int) -> int: ...
	"""Returns the number of days in the given year and month"""

	@staticmethod
	def IsMorning(A: DateTime) -> bool: ...
	"""Returns whether A's time is in the morning"""

	@staticmethod
	def IsAfternoon(A: DateTime) -> bool: ...
	"""Returns whether A's time is in the afternoon"""

	@staticmethod
	def GetYear(A: DateTime) -> int: ...
	"""Returns the year component of A"""

	@staticmethod
	def GetTimeOfDay(A: DateTime) -> Timespan: ...
	"""Returns the time elapsed since midnight of A"""

	@staticmethod
	def GetSecond(A: DateTime) -> int: ...
	"""Returns the second component of A"""

	@staticmethod
	def GetMonth(A: DateTime) -> int: ...
	"""Returns the month component of A"""

	@staticmethod
	def GetMinute(A: DateTime) -> int: ...
	"""Returns the minute component of A"""

	@staticmethod
	def GetMillisecond(A: DateTime) -> int: ...
	"""Returns the millisecond component of A"""

	@staticmethod
	def GetHour12(A: DateTime) -> int: ...
	"""Returns the hour component of A (12h format)"""

	@staticmethod
	def GetHour(A: DateTime) -> int: ...
	"""Returns the hour component of A (24h format)"""

	@staticmethod
	def GetDayOfYear(A: DateTime) -> int: ...
	"""Returns the day of year of A"""

	@staticmethod
	def GetDay(A: DateTime) -> int: ...
	"""Returns the day component of A (1 to 31)"""

	@staticmethod
	def GetDate(A: DateTime) -> DateTime: ...
	"""Returns the date component of A"""

	@staticmethod
	def LessEqual_DateTimeDateTime(A: DateTime, B: DateTime) -> bool: ...
	"""Returns true if A is less than or equal to B (A <= B)"""

	@staticmethod
	def Less_DateTimeDateTime(A: DateTime, B: DateTime) -> bool: ...
	"""Returns true if A is less than B (A < B)"""

	@staticmethod
	def GreaterEqual_DateTimeDateTime(A: DateTime, B: DateTime) -> bool: ...
	"""Returns true if A is greater than or equal to B (A >= B)"""

	@staticmethod
	def Greater_DateTimeDateTime(A: DateTime, B: DateTime) -> bool: ...
	"""Returns true if A is greater than B (A > B)"""

	@staticmethod
	def NotEqual_DateTimeDateTime(A: DateTime, B: DateTime) -> bool: ...
	"""Returns true if the values are not equal (A != B)"""

	@staticmethod
	def EqualEqual_DateTimeDateTime(A: DateTime, B: DateTime) -> bool: ...
	"""Returns true if the values are equal (A == B)"""

	@staticmethod
	def Subtract_DateTimeDateTime(A: DateTime, B: DateTime) -> Timespan: ...
	"""Subtraction (A - B)"""

	@staticmethod
	def Add_DateTimeDateTime(A: DateTime, B: DateTime) -> DateTime: ...
	"""Addition (A + B)"""

	@staticmethod
	def Subtract_DateTimeTimespan(A: DateTime, B: Timespan) -> DateTime: ...
	"""Subtraction (A - B)"""

	@staticmethod
	def Add_DateTimeTimespan(A: DateTime, B: Timespan) -> DateTime: ...
	"""Addition (A + B)"""

	@staticmethod
	def BreakDateTime(InDateTime: DateTime) -> typing.Tuple[int, int, int, int, int, int, int]: ...
	"""Breaks a DateTime into its components"""

	@staticmethod
	def MakeDateTime(Year: int, Month: int, Day: int, Hour: int = ..., Minute: int = ..., Second: int = ..., Millisecond: int = ...) -> DateTime: ...
	"""Makes a DateTime struct"""

	@staticmethod
	def MakePlaneFromPointAndNormal(Point: Vector, Normal: Vector) -> Plane: ...
	"""Creates a plane with a facing direction of Normal at the given Point

@param Point  A point on the plane
@param Normal  The Normal of the plane at Point
@return Plane instance"""

	@staticmethod
	def Divide_LinearColorLinearColor(A: LinearColor, B: LinearColor) -> LinearColor: ...
	"""Element-wise multiplication of two linear colors (R/R, G/G, B/B, A/A)"""

	@staticmethod
	def Multiply_LinearColorFloat(A: LinearColor, B: float) -> LinearColor: ...
	"""Element-wise multiplication of a linear color by a float (F*R, F*G, F*B, F*A)"""

	@staticmethod
	def Multiply_LinearColorLinearColor(A: LinearColor, B: LinearColor) -> LinearColor: ...
	"""Element-wise multiplication of two linear colors (R*R, G*G, B*B, A*A)"""

	@staticmethod
	def Subtract_LinearColorLinearColor(A: LinearColor, B: LinearColor) -> LinearColor: ...
	"""Element-wise subtraction of two linear colors (R-R, G-G, B-B, A-A)"""

	@staticmethod
	def Add_LinearColorLinearColor(A: LinearColor, B: LinearColor) -> LinearColor: ...
	"""Element-wise addition of two linear colors (R+R, G+G, B+B, A+A)"""

	@staticmethod
	def NotEqual_LinearColorLinearColor(A: LinearColor, B: LinearColor) -> bool: ...
	"""Returns true if linear color A is not equal to linear color B (A != B) within a specified error tolerance"""

	@staticmethod
	def EqualEqual_LinearColorLinearColor(A: LinearColor, B: LinearColor) -> bool: ...
	"""Returns true if linear color A is equal to linear color B (A == B) within a specified error tolerance"""

	@staticmethod
	def LinearColor_IsNearEqual(A: LinearColor, B: LinearColor, Tolerance: float = ...) -> bool: ...
	"""Returns true if linear color A is equal to linear color B (A == B) within a specified error tolerance"""

	@staticmethod
	def LinearColorLerpUsingHSV(A: LinearColor, B: LinearColor, Alpha: float) -> LinearColor: ...
	"""Linearly interpolates between two colors by the specified Alpha amount (100% of A when Alpha=0 and 100% of B when Alpha=1).  The interpolation is performed in HSV color space taking the shortest path to the new color's hue.  This can give better results than a normal lerp, but is much more expensive.  The incoming colors are in RGB space, and the output color will be RGB.  The alpha value will also be interpolated.

@param       A               The color and alpha to interpolate from as linear RGBA
@param       B               The color and alpha to interpolate to as linear RGBA
@param       Alpha   Scalar interpolation amount (usually between 0.0 and 1.0 inclusive)

@return      The interpolated color in linear RGB space along with the interpolated alpha value"""

	@staticmethod
	def LinearColorLerp(A: LinearColor, B: LinearColor, Alpha: float) -> LinearColor: ...
	"""Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)"""

	@staticmethod
	def CInterpTo(Current: LinearColor, Target: LinearColor, DeltaTime: float, InterpSpeed: float) -> LinearColor: ...
	"""Interpolate Linear Color from Current to Target. Scaled by distance to Target, so it has a strong start speed and ease out.

@param               Current                 Current Color
@param               Target                  Target Color
@param               DeltaTime               Time since last tick
@param               InterpSpeed             Interpolation speed, if the speed given is 0, then jump to the target.
@return              New interpolated Color"""

	@staticmethod
	def LinearColor_GetMin(InColor: LinearColor) -> float: ...
	"""Returns the minimum color channel value in this color structure

@return The minimum color channel value"""

	@staticmethod
	def LinearColor_GetMax(InColor: LinearColor) -> float: ...
	"""Returns the maximum color channel value in this color structure

@return The maximum color channel value"""

	@staticmethod
	def LinearColor_GetLuminance(InColor: LinearColor) -> float: ...
	"""Returns the perceived brightness of a color on a display taking into account the impact on the human eye per color channel: green > red > blue."""

	@staticmethod
	def LinearColor_ToNewOpacity(InColor: LinearColor, InOpacity: float) -> LinearColor: ...
	"""Returns a copy of this color using the specified opacity/alpha."""

	@staticmethod
	def LinearColor_Distance(C1: LinearColor, C2: LinearColor) -> float: ...
	"""Euclidean distance between two color points."""

	@staticmethod
	def LinearColor_Desaturated(InColor: LinearColor, InDesaturation: float) -> LinearColor: ...
	"""Returns a desaturated color, with 0 meaning no desaturation and 1 == full desaturation

@param       Desaturation    Desaturation factor in range [0..1]
@return      Desaturated color"""

	@staticmethod
	def LinearColor_QuantizeRound(InColor: LinearColor) -> Color: ...
	"""Quantizes the linear color with rounding and returns the result as an 8-bit color.  This bypasses the SRGB conversion."""

	@staticmethod
	def LinearColor_Quantize(InColor: LinearColor) -> Color: ...
	"""Quantizes the linear color and returns the result as an 8-bit color.  This bypasses the SRGB conversion."""

	@staticmethod
	def Conv_LinearColorToColor(InLinearColor: LinearColor, InUseSRGB: bool = ...) -> Color: ...
	"""Quantizes the linear color and returns the result as a FColor with optional sRGB conversion and quality as goal."""

	@staticmethod
	def LinearColor_ToRGBE(InLinearColor: LinearColor) -> Color: ...
	"""Convert from linear to 8-bit RGBE as outlined in Gregory Ward's Real Pixels article, Graphics Gems II, page 80."""

	@staticmethod
	def Conv_LinearColorToVector(InLinearColor: LinearColor) -> Vector: ...
	"""Converts a LinearColor to a vector"""

	@staticmethod
	def RGBLinearToHSV(RGB: LinearColor) -> LinearColor: ...
	"""Converts a RGB linear color to HSV (where H is in R, S is in G, and V is in B)"""

	@staticmethod
	def RGBToHSV_Vector(RGB: LinearColor) -> LinearColor: ...
	"""Converts a RGB linear color to HSV (where H is in R (0..360), S is in G (0..1), and V is in B (0..1))"""

	@staticmethod
	def RGBToHSV(InColor: LinearColor) -> typing.Tuple[float, float, float, float]: ...
	"""Breaks apart a color into individual HSV components (as well as alpha) (Hue is [0..360) while Saturation and Value are 0..1)"""

	@staticmethod
	def HSVToRGBLinear(HSV: LinearColor) -> LinearColor: ...
	"""Converts a HSV linear color (where H is in R, S is in G, and V is in B) to linear RGB"""

	@staticmethod
	def HSVToRGB_Vector(HSV: LinearColor) -> LinearColor: ...
	"""Converts a HSV linear color (where H is in R (0..360), S is in G (0..1), and V is in B (0..1)) to RGB"""

	@staticmethod
	def HSVToRGB(H: float, S: float, V: float, A: float = ...) -> LinearColor: ...
	"""Make a color from individual color components (HSV space; Hue is [0..360) while Saturation and Value are 0..1)"""

	@staticmethod
	def Conv_FloatToLinearColor(InFloat: float) -> LinearColor: ...
	"""Convert a float into a LinearColor, where each element is that float"""

	@staticmethod
	def LinearColor_SetRandomHue(InOutColor: LinearColor): ...
	"""Sets to a random color. Choses a quite nice color based on a random hue."""

	@staticmethod
	def LinearColor_SetTemperature(InOutColor: LinearColor, InTemperature: float): ...
	"""Converts temperature in Kelvins of a black body radiator to RGB chromaticity."""

	@staticmethod
	def LinearColor_SetFromPow22(InOutColor: LinearColor, InColor: Color): ...
	"""Assigns an FColor coming from an observed Pow(1/2.2) output, into a linear color.
@param InColor The Pow(1/2.2) color that needs to be converted into linear space."""

	@staticmethod
	def LinearColor_SetFromSRGB(InOutColor: LinearColor, InSRGB: Color): ...
	"""Assigns an FColor coming from an observed sRGB output, into a linear color.
@param InSRGB The sRGB color that needs to be converted into linear space."""

	@staticmethod
	def LinearColor_SetFromHSV(InOutColor: LinearColor, H: float, S: float, V: float, A: float = ...): ...
	"""Assigns an HSV color to a linear space RGB color"""

	@staticmethod
	def LinearColor_SetRGBA(InOutColor: LinearColor, R: float, G: float, B: float, A: float = ...): ...
	"""Assign individual linear RGBA components."""

	@staticmethod
	def LinearColor_Set(InOutColor: LinearColor, InColor: LinearColor): ...
	"""Assign contents of InColor"""

	@staticmethod
	def BreakColor(InColor: LinearColor) -> typing.Tuple[float, float, float, float]: ...
	"""Breaks apart a color into individual RGB components (as well as alpha)"""

	@staticmethod
	def MakeColor(R: float, G: float, B: float, A: float = ...) -> LinearColor: ...
	"""Make a color from individual color components (RGB space)"""

	@staticmethod
	def LinearColor_Transparent() -> LinearColor: ...
	"""Transparent linear color - black with 0 opacity/alpha"""

	@staticmethod
	def LinearColor_Yellow() -> LinearColor: ...
	"""Yellow linear color"""

	@staticmethod
	def LinearColor_Blue() -> LinearColor: ...
	"""Blue linear color"""

	@staticmethod
	def LinearColor_Green() -> LinearColor: ...
	"""Green linear color"""

	@staticmethod
	def LinearColor_Red() -> LinearColor: ...
	"""Red linear color"""

	@staticmethod
	def LinearColor_Black() -> LinearColor: ...
	"""Black linear color"""

	@staticmethod
	def LinearColor_Gray() -> LinearColor: ...
	"""Grey linear color"""

	@staticmethod
	def LinearColor_White() -> LinearColor: ...
	"""White linear color"""

	@staticmethod
	def Quat_UnrotateVector(Q: Quat, V: Vector) -> Vector: ...
	"""Rotate a vector by the inverse of this quaternion.

@param V the vector to be rotated
@return vector after rotation by the inverse of this quaternion."""

	@staticmethod
	def Quat_RotateVector(Q: Quat, V: Vector) -> Vector: ...
	"""Rotate a vector by this quaternion.

@param V the vector to be rotated
@return vector after rotation"""

	@staticmethod
	def Quat_SizeSquared(Q: Quat) -> float: ...
	"""Get the squared length of the quaternion.

@return The squared length of the quaternion."""

	@staticmethod
	def Quat_Size(Q: Quat) -> float: ...
	"""Get the length of the quaternion.

@return The length of the quaternion."""

	@staticmethod
	def Quat_Rotator(Q: Quat) -> Rotator: ...
	"""Convert to Rotator representation of this Quaternion."""

	@staticmethod
	def Quat_MakeFromEuler(Euler: Vector) -> Quat: ...
	"""Convert a vector of floating-point Euler angles (in degrees) into a Quaternion.

@param Euler the Euler angles
@return constructed Quat"""

	@staticmethod
	def Quat_SetFromEuler(Q: Quat, Euler: Vector): ...
	"""Convert a vector of floating-point Euler angles (in degrees) into a Quaternion.

@param Q Quaternion to update
@param Euler the Euler angles"""

	@staticmethod
	def Quat_SetComponents(Q: Quat, X: float, Y: float, Z: float, W: float): ...
	"""Set X, Y, Z, W components of Quaternion."""

	@staticmethod
	def Quat_Log(Q: Quat) -> Quat: ...
	"""Quaternion with W=0 and V=theta*v. Used in combination with Exp()."""

	@staticmethod
	def Quat_Inversed(Q: Quat) -> Quat: ...
	"""Return an inversed copy of this quaternion."""

	@staticmethod
	def Quat_GetRotationAxis(Q: Quat) -> Vector: ...
	"""Get the axis of rotation of the Quaternion.
This is the axis around which rotation occurs to transform the canonical coordinate system to the target orientation.
For the identity Quaternion which has no such rotation, FVector(1,0,0) is returned."""

	@staticmethod
	def Quat_Normalized(Q: Quat, Tolerance: float = ...) -> Quat: ...
	"""Get a normalized copy of this quaternion.
If it is too small, returns an identity quaternion.

@param Tolerance Minimum squared length of quaternion for normalization."""

	@staticmethod
	def Quat_Normalize(Q: Quat, Tolerance: float = ...): ...
	"""Normalize this quaternion if it is large enough as compared to the supplied tolerance.
If it is too small then set it to the identity quaternion.

@param Tolerance Minimum squared length of quaternion for normalization."""

	@staticmethod
	def Quat_VectorUp(Q: Quat) -> Vector: ...
	"""Get the up direction (Z axis) after it has been rotated by this Quaternion."""

	@staticmethod
	def Quat_VectorRight(Q: Quat) -> Vector: ...
	"""Get the right direction (Y axis) after it has been rotated by this Quaternion."""

	@staticmethod
	def Quat_VectorForward(Q: Quat) -> Vector: ...
	"""Get the forward direction (X axis) after it has been rotated by this Quaternion."""

	@staticmethod
	def Quat_GetAxisZ(Q: Quat) -> Vector: ...
	"""Get the up direction (Z axis) after it has been rotated by this Quaternion."""

	@staticmethod
	def Quat_GetAxisY(Q: Quat) -> Vector: ...
	"""Get the right direction (Y axis) after it has been rotated by this Quaternion."""

	@staticmethod
	def Quat_GetAxisX(Q: Quat) -> Vector: ...
	"""Get the forward direction (X axis) after it has been rotated by this Quaternion."""

	@staticmethod
	def Quat_GetAngle(Q: Quat) -> float: ...
	"""Get the angle of this quaternion"""

	@staticmethod
	def Quat_Exp(Q: Quat) -> Quat: ...
	"""Used in combination with Log().
Assumes a quaternion with W=0 and V=theta*v (where |v| = 1).
Exp(q) = (sin(theta)*v, cos(theta))"""

	@staticmethod
	def Quat_Euler(Q: Quat) -> Vector: ...
	"""Convert a Quaternion into floating-point Euler angles (in degrees)."""

	@staticmethod
	def Quat_EnforceShortestArcWith(A: Quat, B: Quat): ...
	"""Modify the quaternion to ensure that the delta between it and B represents the shortest possible rotation angle."""

	@staticmethod
	def Quat_AngularDistance(A: Quat, B: Quat) -> float: ...
	"""Find the angular distance/difference between two rotation quaternions.

@param B Quaternion to find angle distance to
@return angular distance in radians"""

	@staticmethod
	def Quat_IsNonFinite(Q: Quat) -> bool: ...
	"""Determine if there are any non-finite values (NaN or Inf) in this Quat."""

	@staticmethod
	def Quat_IsFinite(Q: Quat) -> bool: ...
	"""Determine if all the values  are finite (not NaN nor Inf) in this Quat."""

	@staticmethod
	def Quat_IsNormalized(Q: Quat) -> bool: ...
	"""Return true if this quaternion is normalized"""

	@staticmethod
	def Quat_IsIdentity(Q: Quat, Tolerance: float = ...) -> bool: ...
	"""Checks whether this Quaternion is an Identity Quaternion.
Assumes Quaternion tested is normalized.

@param Tolerance Error tolerance for comparison with Identity Quaternion.
@return true if Quaternion is a normalized Identity Quaternion."""

	@staticmethod
	def Multiply_QuatQuat(A: Quat, B: Quat) -> Quat: ...
	"""Gets the result of multiplying two quaternions (A * B).

Order matters when composing quaternions: C = A * B will yield a quaternion C that logically
first applies B then A to any subsequent transformation (right first, then left).

@param B The Quaternion to multiply by.
@return The result of multiplication (A * B)."""

	@staticmethod
	def Subtract_QuatQuat(A: Quat, B: Quat) -> Quat: ...
	"""Returns subtraction of Vector B from Vector A (A - B)"""

	@staticmethod
	def Add_QuatQuat(A: Quat, B: Quat) -> Quat: ...
	"""Returns addition of Vector A and Vector B (A + B)"""

	@staticmethod
	def NotEqual_QuatQuat(A: Quat, B: Quat, ErrorTolerance: float = ...) -> bool: ...
	"""Returns true if Quat A is not equal to Quat B (A != B) within a specified error tolerance"""

	@staticmethod
	def EqualEqual_QuatQuat(A: Quat, B: Quat, Tolerance: float = ...) -> bool: ...
	"""Returns true if Quaternion A is equal to Quaternion B (A == B) within a specified error tolerance"""

	@staticmethod
	def Quat_Identity() -> Quat: ...
	"""Identity quaternion constant"""

	@staticmethod
	def Matrix_Mirror(M: Matrix, MirrorAxis: int, FlipAxis: int) -> Matrix: ...
	"""Utility for mirroring this transform across a certain plane, and flipping one of the axis as well.
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_GetFrustumBottomPlane(M: Matrix) -> typing.Tuple[bool, Plane]: ...
	"""Get the bottom plane of the Frustum of this matrix
(Assumes Matrix represents a View Projection Matrix)
@param OutPlane the bottom plane of the Frustum of this matrix"""

	@staticmethod
	def Matrix_GetFrustumTopPlane(M: Matrix) -> typing.Tuple[bool, Plane]: ...
	"""Get the top plane of the Frustum of this matrix
(Assumes Matrix represents a View Projection Matrix)
@param OutPlane the top plane of the Frustum of this matrix"""

	@staticmethod
	def Matrix_GetFrustumRightPlane(M: Matrix) -> typing.Tuple[bool, Plane]: ...
	"""Get the right plane of the Frustum of this matrix
(Assumes Matrix represents a View Projection Matrix)
@param OutPlane the right plane of the Frustum of this matrix"""

	@staticmethod
	def Matrix_GetFrustumLeftPlane(M: Matrix) -> typing.Tuple[bool, Plane]: ...
	"""Get the left plane of the Frustum of this matrix
(Assumes Matrix represents a View Projection Matrix)
@param OutPlane the left plane of the Frustum of this matrix"""

	@staticmethod
	def Matrix_GetFrustumFarPlane(M: Matrix) -> typing.Tuple[bool, Plane]: ...
	"""Get the far plane of the Frustum of this matrix
(Assumes Matrix represents a View Projection Matrix)
@param OutPlane the far plane of the Frustum of this matrix"""

	@staticmethod
	def Matrix_GetFrustumNearPlane(M: Matrix) -> typing.Tuple[bool, Plane]: ...
	"""Get the near plane of the Frustum of this matrix
(Assumes Matrix represents a View Projection Matrix)
@param OutPlane the near plane of the Frustum of this matrix"""

	@staticmethod
	def Matrix_ToQuat(M: Matrix) -> Quat: ...
	"""Transform a rotation matrix into a quaternion.
(Assumes Matrix represents a transform)

@warning rotation part will need to be unit length for this to be right!"""

	@staticmethod
	def Matrix_GetRotator(M: Matrix) -> Rotator: ...
	"""Get the rotator representation of this matrix
(Assumes Matrix represents a transform)
@return rotator representation of this matrix"""

	@staticmethod
	def Matrix_SetColumn(M: Matrix, Column: int, Value: Vector): ...
	"""Matrix Set Column"""

	@staticmethod
	def Matrix_GetColumn(M: Matrix, Column: int) -> Vector: ...
	"""get a column of this matrix

@param i index into the column of the matrix
@return vector of the column"""

	@staticmethod
	def Matrix_SetOrigin(M: Matrix, NewOrigin: Vector): ...
	"""Set the origin of the coordinate system to the given vector
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_SetAxis(M: Matrix, Axis: int, AxisVector: Vector): ...
	"""set an axis of this matrix
(Assumes Matrix represents a transform)

@param i index into the axis of the matrix
@param Axis vector of the axis"""

	@staticmethod
	def Matrix_GetUnitAxes(M: Matrix) -> typing.Tuple[Vector, Vector, Vector]: ...
	"""get unit length axes of this matrix
(Assumes Matrix represents a transform)

@param X axes returned to this param
@param Y axes returned to this param
@param Z axes returned to this param"""

	@staticmethod
	def Matrix_GetUnitAxis(M: Matrix, Axis: int) -> Vector: ...
	"""get unit length axis of this matrix
(Assumes Matrix represents a transform)

@param i index into the axis of the matrix
@return vector of the axis"""

	@staticmethod
	def Matrix_GetScaledAxes(M: Matrix) -> typing.Tuple[Vector, Vector, Vector]: ...
	"""get axes of this matrix scaled by the scale of the matrix
(Assumes Matrix represents a transform)

@param X axes returned to this param
@param Y axes returned to this param
@param Z axes returned to this param"""

	@staticmethod
	def Matrix_GetScaledAxis(M: Matrix, Axis: int) -> Vector: ...
	"""get axis of this matrix scaled by the scale of the matrix
(Assumes Matrix represents a transform)

@param i index into the axis of the matrix
@ return vector of the axis"""

	@staticmethod
	def Matrix_ApplyScale(M: Matrix, Scale: float) -> Matrix: ...
	"""Apply Scale to this matrix
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_GetMaximumAxisScale(M: Matrix) -> float: ...
	"""@return the maximum magnitude of any row of the matrix.
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_ScaleTranslation(M: Matrix, Scale3D: Vector) -> Matrix: ...
	"""Scale the translation part of the matrix by the supplied vector.
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_ContainsNaN(M: Matrix) -> bool: ...
	"""Returns true if any element of this matrix is NaN"""

	@staticmethod
	def Matrix_ConcatenateTranslation(M: Matrix, Translation: Vector) -> Matrix: ...
	"""Returns a matrix with an additional translation concatenated.
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_RemoveTranslation(M: Matrix) -> Matrix: ...
	"""Remove any translation from this matrix
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_GetScaleVector(M: Matrix, Tolerance: float = ...) -> Vector: ...
	"""return a 3D scale vector calculated from this matrix (where each component is the magnitude of a row vector) with error Tolerance.
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_GetMatrixWithoutScale(M: Matrix, Tolerance: float = ...) -> Matrix: ...
	"""Returns matrix after RemoveScaling with error Tolerance
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_RemoveScaling(M: Matrix, Tolerance: float = ...): ...
	"""Remove any scaling from this matrix (ie magnitude of each row is 1) with error Tolerance
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_GetTransposeAdjoint(M: Matrix) -> Matrix: ...
	"""Get the Transose Adjoint of the Matrix."""

	@staticmethod
	def Matrix_GetInverse(M: Matrix) -> Matrix: ...
	"""Get the inverse of the Matrix. Handles nil matrices."""

	@staticmethod
	def Matrix_GetRotDeterminant(M: Matrix) -> float: ...
	"""@return the determinant of rotation 3x3 matrix
(Assumes Top Left 3x3 Submatrix represents a Rotation)"""

	@staticmethod
	def Matrix_GetDeterminant(M: Matrix) -> float: ...
	"""@return determinant of this matrix."""

	@staticmethod
	def Matrix_GetTransposed(M: Matrix) -> Matrix: ...
	"""Transpose."""

	@staticmethod
	def Matrix_InverseTransformVector(M: Matrix, V: Vector) -> Vector: ...
	"""Transform a direction vector by the inverse of this matrix - will not take into account translation part.
If you want to transform a surface normal (or plane) and correctly account for non-uniform scaling you should use TransformByUsingAdjointT with adjoint of matrix inverse.
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_TransformVector(M: Matrix, V: Vector) -> Vector4: ...
	"""Transform a direction vector - will not take into account translation part of the FMatrix.
If you want to transform a surface normal (or plane) and correctly account for non-uniform scaling you should use TransformByUsingAdjointT.
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_InverseTransformPosition(M: Matrix, V: Vector) -> Vector: ...
	"""Inverts the matrix and then transforms V - correctly handles scaling in this matrix.
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_TransformPosition(M: Matrix, V: Vector) -> Vector4: ...
	"""Transform a location - will take into account translation part of the FMatrix.
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Matrix_TransformVector4(M: Matrix, V: Vector4) -> Vector4: ...
	"""Transform a vector by the matrix.
(Assumes Matrix represents a transform)"""

	@staticmethod
	def NotEqual_MatrixMatrix(A: Matrix, B: Matrix, Tolerance: float = ...) -> bool: ...
	"""Checks whether another Matrix is not equal to this, within specified tolerance.

@param Other The other Matrix.
@return true if two Matrix are not equal, within specified tolerance, otherwise false."""

	@staticmethod
	def EqualEqual_MatrixMatrix(A: Matrix, B: Matrix, Tolerance: float = ...) -> bool: ...
	"""Checks whether another Matrix is equal to this, within specified tolerance.

@param Other The other Matrix.
@param Tolerance Error Tolerance.
@return true if two Matrix are equal, within specified tolerance, otherwise false."""

	@staticmethod
	def Multiply_MatrixFloat(A: Matrix, B: float) -> Matrix: ...
	"""Multiplies all values of the matrix by a float.
If your Matrix represents a Transform that you wish to scale you should use Apply Scale instead"""

	@staticmethod
	def Add_MatrixMatrix(A: Matrix, B: Matrix) -> Matrix: ...
	"""Gets the result of adding a matrix to this.

@param Other The Matrix to add.
@return The result of addition."""

	@staticmethod
	def Multiply_MatrixMatrix(A: Matrix, B: Matrix) -> Matrix: ...
	"""Gets the result of multiplying a Matrix to this.

@param Other The matrix to multiply this by.
@return The result of multiplication."""

	@staticmethod
	def Matrix_Identity() -> Matrix: ...
	"""Identity matrix"""

	@staticmethod
	def Matrix_GetOrigin(InMatrix: Matrix) -> Vector: ...
	"""Get the origin of the co-ordinate system
(Assumes Matrix represents a transform)

@return co-ordinate system origin"""

	@staticmethod
	def Conv_MatrixToRotator(InMatrix: Matrix) -> Rotator: ...
	"""Convert a Matrix to a Rotator
(Assumes Matrix represents a transform)"""

	@staticmethod
	def Conv_MatrixToTransform(InMatrix: Matrix) -> Transform: ...
	"""Convert a Matrix to a Transform
(Assumes Matrix represents a transform)"""

	@staticmethod
	def NormalizeAxis(Angle: float) -> float: ...
	"""Clamps an angle to the range of [-180, 180].

@param Angle The Angle to clamp.
@return The clamped angle."""

	@staticmethod
	def ClampAxis(Angle: float) -> float: ...
	"""Clamps an angle to the range of [0, 360].

@param Angle The angle to clamp.
@return The clamped angle."""

	@staticmethod
	def NormalizedDeltaRotator(A: Rotator, B: Rotator) -> Rotator: ...
	"""Normalized A-B"""

	@staticmethod
	def REase(A: Rotator, B: Rotator, Alpha: float, bShortestPath: bool, EasingFunc: int, BlendExp: float = ..., Steps: int = ...) -> Rotator: ...
	"""Easing between A and B using a specified easing function"""

	@staticmethod
	def RLerp(A: Rotator, B: Rotator, Alpha: float, bShortestPath: bool) -> Rotator: ...
	"""Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)"""

	@staticmethod
	def RandomRotator(bRoll: bool = ...) -> Rotator: ...
	"""Generates a random rotation, with optional random roll."""

	@staticmethod
	def GetAxes(A: Rotator) -> typing.Tuple[Vector, Vector, Vector]: ...
	"""Get the reference frame direction vectors (axes) described by this rotation"""

	@staticmethod
	def Conv_RotatorToTransform(InRotator: Rotator) -> Transform: ...
	"""Convert Rotator to Transform"""

	@staticmethod
	def Conv_RotatorToVector(InRot: Rotator) -> Vector: ...
	"""Get the X direction vector after this rotation"""

	@staticmethod
	def GetUpVector(InRot: Rotator) -> Vector: ...
	"""Rotate the world up vector by the given rotation"""

	@staticmethod
	def GetRightVector(InRot: Rotator) -> Vector: ...
	"""Rotate the world right vector by the given rotation"""

	@staticmethod
	def GetForwardVector(InRot: Rotator) -> Vector: ...
	"""Rotate the world forward vector by the given rotation"""

	@staticmethod
	def NegateRotator(A: Rotator) -> Rotator: ...
	"""Negate a rotator"""

	@staticmethod
	def ComposeRotators(A: Rotator, B: Rotator) -> Rotator: ...
	"""Combine 2 rotations to give you the resulting rotation of first applying A, then B."""

	@staticmethod
	def Multiply_RotatorInt(A: Rotator, B: int) -> Rotator: ...
	"""Returns rotator representing rotator A scaled by B"""

	@staticmethod
	def Multiply_RotatorFloat(A: Rotator, B: float) -> Rotator: ...
	"""Returns rotator representing rotator A scaled by B"""

	@staticmethod
	def NotEqual_RotatorRotator(A: Rotator, B: Rotator, ErrorTolerance: float = ...) -> bool: ...
	"""Returns true if rotator A is not equal to rotator B (A != B) within a specified error tolerance"""

	@staticmethod
	def EqualEqual_RotatorRotator(A: Rotator, B: Rotator, ErrorTolerance: float = ...) -> bool: ...
	"""Returns true if rotator A is equal to rotator B (A == B) within a specified error tolerance"""

	@staticmethod
	def BreakRotIntoAxes(InRot: Rotator) -> typing.Tuple[Vector, Vector, Vector]: ...
	"""Breaks apart a rotator into its component axes"""

	@staticmethod
	def BreakRotator(InRot: Rotator) -> typing.Tuple[float, float, float]: ...
	"""Breaks apart a rotator into {Roll, Pitch, Yaw} angles in degrees"""

	@staticmethod
	def FindLookAtRotation(Start: Vector, Target: Vector) -> Rotator: ...
	"""Find a rotation for an object at Start location to point at Target location."""

	@staticmethod
	def MakeRotationFromAxes(Forward: Vector, Right: Vector, Up: Vector) -> Rotator: ...
	"""Build a reference frame from three axes"""

	@staticmethod
	def MakeRotFromZY(Z: Vector, Y: Vector) -> Rotator: ...
	"""Builds a matrix with given Z and Y axes. Z will remain fixed, Y may be changed minimally to enforce orthogonality. X will be computed. Inputs need not be normalized."""

	@staticmethod
	def MakeRotFromZX(Z: Vector, X: Vector) -> Rotator: ...
	"""Builds a matrix with given Z and X axes. Z will remain fixed, X may be changed minimally to enforce orthogonality. Y will be computed. Inputs need not be normalized."""

	@staticmethod
	def MakeRotFromYZ(Y: Vector, Z: Vector) -> Rotator: ...
	"""Builds a matrix with given Y and Z axes. Y will remain fixed, Z may be changed minimally to enforce orthogonality. X will be computed. Inputs need not be normalized."""

	@staticmethod
	def MakeRotFromYX(Y: Vector, X: Vector) -> Rotator: ...
	"""Builds a matrix with given Y and X axes. Y will remain fixed, X may be changed minimally to enforce orthogonality. Z will be computed. Inputs need not be normalized."""

	@staticmethod
	def MakeRotFromXZ(X: Vector, Z: Vector) -> Rotator: ...
	"""Builds a matrix with given X and Z axes. X will remain fixed, Z may be changed minimally to enforce orthogonality. Y will be computed. Inputs need not be normalized."""

	@staticmethod
	def MakeRotFromXY(X: Vector, Y: Vector) -> Rotator: ...
	"""Builds a matrix with given X and Y axes. X will remain fixed, Y may be changed minimally to enforce orthogonality. Z will be computed. Inputs need not be normalized."""

	@staticmethod
	def MakeRotFromZ(Z: Vector) -> Rotator: ...
	"""Builds a rotation matrix given only a ZAxis. X and Y are unspecified but will be orthonormal. ZAxis need not be normalized."""

	@staticmethod
	def MakeRotFromY(Y: Vector) -> Rotator: ...
	"""Builds a rotation matrix given only a YAxis. X and Z are unspecified but will be orthonormal. YAxis need not be normalized."""

	@staticmethod
	def MakeRotFromX(X: Vector) -> Rotator: ...
	"""Builds a rotator given only a XAxis. Y and Z are unspecified but will be orthonormal. XAxis need not be normalized."""

	@staticmethod
	def MakeRotator(Roll: float, Pitch: float, Yaw: float) -> Rotator: ...
	"""Makes a rotator {Roll, Pitch, Yaw} from rotation values supplied in degrees"""

	@staticmethod
	def TransformVector4(Matrix: Matrix, Vec4: Vector4) -> Vector4: ...
	"""Transform the input vector4 by a provided matrix4x4 and returns the resulting vector4.

@return Transformed vector4."""

	@staticmethod
	def Vector4_MirrorByVector3(Direction: Vector4, SurfaceNormal: Vector4) -> Vector4: ...
	"""Given a direction vector and a surface normal, returns the vector reflected across the surface normal.
Produces a result like shining a laser at a mirror!
The W element is ignored.

@param Direction Direction vector the ray is coming from.
@param SurfaceNormal A normal of the surface the ray should be reflected on.

@returns Reflected vector."""

	@staticmethod
	def Vector4_Normalize3(A: Vector4, Tolerance: float = ...): ...
	"""Normalize this vector in-place if it is large enough or set it to (0,0,0,0) otherwise. The W element is ignored and the returned vector has W=0.

@param Tolerance Minimum squared length of vector for normalization."""

	@staticmethod
	def Vector4_NormalUnsafe3(A: Vector4) -> Vector4: ...
	"""Calculates normalized unit version of vector without checking for zero length. The W element is ignored and the returned vector has W=0.

@return Normalized version of vector."""

	@staticmethod
	def Vector4_Normal3(A: Vector4, Tolerance: float = ...) -> Vector4: ...
	"""Gets a normalized unit copy of the vector, ensuring it is safe to do so based on the length. The W element is ignored and the returned vector has W=0.
Returns zero vector if vector length is too small to safely normalize.

@param Tolerance Minimum squared vector length.
@return A normalized copy if safe, (0,0,0) otherwise."""

	@staticmethod
	def Vector4_IsNormal3(A: Vector4) -> bool: ...
	"""Determines if vector is normalized / unit (length 1). The W element is ignored.

@return true if normalized, false otherwise."""

	@staticmethod
	def Vector4_IsUnit3(A: Vector4, SquaredLenthTolerance: float = ...) -> bool: ...
	"""Determines if vector is normalized / unit (length 1) within specified squared tolerance. The W element is ignored.

@return true if unit, false otherwise."""

	@staticmethod
	def Vector4_SizeSquared3(A: Vector4) -> float: ...
	"""Returns the squared length of the vector. The W element is ignored."""

	@staticmethod
	def Vector4_Size3(A: Vector4) -> float: ...
	"""Returns the length of the vector. The W element is ignored."""

	@staticmethod
	def Vector4_SizeSquared(A: Vector4) -> float: ...
	"""Returns the squared length of the vector."""

	@staticmethod
	def Vector4_Size(A: Vector4) -> float: ...
	"""Returns the length of the vector."""

	@staticmethod
	def Vector4_IsZero(A: Vector4) -> bool: ...
	"""Checks whether all components of the vector are exactly zero.

@return true if vector is exactly zero, otherwise false."""

	@staticmethod
	def Vector4_IsNearlyZero3(A: Vector4, Tolerance: float = ...) -> bool: ...
	"""Checks whether vector is near to zero within a specified tolerance. The W element is ignored.

@param Tolerance Error tolerance.
@return true if vector is in tolerance to zero, otherwise false."""

	@staticmethod
	def Vector4_IsNAN(A: Vector4) -> bool: ...
	"""Determines if any component is not a number (NAN)

@return true if one or more components is NAN, otherwise false."""

	@staticmethod
	def Vector4_DotProduct3(A: Vector4, B: Vector4) -> float: ...
	"""Returns the dot product of two vectors - see http://mathworld.wolfram.com/DotProduct.html The W element is ignored."""

	@staticmethod
	def Vector4_DotProduct(A: Vector4, B: Vector4) -> float: ...
	"""Returns the dot product of two vectors - see http://mathworld.wolfram.com/DotProduct.html"""

	@staticmethod
	def Vector4_CrossProduct3(A: Vector4, B: Vector4) -> Vector4: ...
	"""Returns the cross product of two vectors - see  http://mathworld.wolfram.com/CrossProduct.html"""

	@staticmethod
	def Vector4_Set(A: Vector4, X: float, Y: float, Z: float, W: float): ...
	"""Set the values of the vector directly.

@param InX New X coordinate.
@param InY New Y coordinate.
@param InZ New Z coordinate.
@param InW New W coordinate."""

	@staticmethod
	def Vector4_Assign(A: Vector4, InVector: Vector4): ...
	"""Assign the values of the supplied vector.

@param InVector Vector to copy values from."""

	@staticmethod
	def Vector4_Negated(A: Vector4) -> Vector4: ...
	"""Gets a negated copy of the vector. Equivalent to -Vector for scripts."""

	@staticmethod
	def NotEqual_Vector4Vector4(A: Vector4, B: Vector4, ErrorTolerance: float = ...) -> bool: ...
	"""Returns true if vector A is not equal to vector B (A != B) within a specified error tolerance"""

	@staticmethod
	def NotEqualExactly_Vector4Vector4(A: Vector4, B: Vector4) -> bool: ...
	"""Returns true if vector A is not equal to vector B (A != B) within a specified error tolerance"""

	@staticmethod
	def EqualEqual_Vector4Vector4(A: Vector4, B: Vector4, ErrorTolerance: float = ...) -> bool: ...
	"""Returns true if vector A is equal to vector B (A == B) within a specified error tolerance"""

	@staticmethod
	def EqualExactly_Vector4Vector4(A: Vector4, B: Vector4) -> bool: ...
	"""Returns true if vector A is equal to vector B (A == B)"""

	@staticmethod
	def Divide_Vector4Vector4(A: Vector4, B: Vector4) -> Vector4: ...
	"""Element-wise Vector divide (Result = {A.x/B.x, A.y/B.y, A.z/B.z, A.w/B.w})"""

	@staticmethod
	def Multiply_Vector4Vector4(A: Vector4, B: Vector4) -> Vector4: ...
	"""Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y, A.z*B.z, A.w*B.w})"""

	@staticmethod
	def Subtract_Vector4Vector4(A: Vector4, B: Vector4) -> Vector4: ...
	"""Returns subtraction of Vector B from Vector A (A - B)"""

	@staticmethod
	def Add_Vector4Vector4(A: Vector4, B: Vector4) -> Vector4: ...
	"""Returns addition of Vector A and Vector B (A + B)"""

	@staticmethod
	def Conv_Vector4ToQuaternion(InVec: Vector4) -> Quat: ...
	"""Return the Quaternion orientation corresponding to the direction in which the vector points.
Similar to the FRotator version, returns a result without roll such that it preserves the up vector.

@note If you don't care about preserving the up vector and just want the most direct rotation, you can use the faster
'FQuat::FindBetweenVectors(FVector::ForwardVector, YourVector)' or 'FQuat::FindBetweenNormals(...)' if you know the vector is of unit length.

@return Quaternion from the Vector's direction, without any roll."""

	@staticmethod
	def Conv_Vector4ToRotator(InVec: Vector4) -> Rotator: ...
	"""Return the FRotator orientation corresponding to the direction in which the vector points.
Sets Yaw and Pitch to the proper numbers, and sets Roll to zero because the roll can't be determined from a vector.

@return FRotator from the Vector's direction, without any roll."""

	@staticmethod
	def Conv_Vector4ToVector(InVector4: Vector4) -> Vector: ...
	"""Convert a Vector4 to a Vector (dropping the W element)"""

	@staticmethod
	def BreakVector4(InVec: Vector4) -> typing.Tuple[float, float, float, float]: ...
	"""Breaks a 4D vector apart into X, Y, Z, W."""

	@staticmethod
	def MakeVector4(X: float, Y: float, Z: float, W: float) -> Vector4: ...
	"""Makes a 4D vector {X, Y, Z, W}"""

	@staticmethod
	def Vector4_Zero() -> Vector4: ...
	"""4D vector zero constant (0,0,0)"""

	@staticmethod
	def RandomUnitVectorInEllipticalConeInDegrees(ConeDir: Vector, MaxYawInDegrees: float, MaxPitchInDegrees: float) -> Vector: ...
	"""Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
The shape of the cone can be modified according to the yaw and pitch angles.

@param MaxYawInDegrees        The yaw angle of the cone (from ConeDir to horizontal edge), in degrees.
@param MaxPitchInDegrees      The pitch angle of the cone (from ConeDir to vertical edge), in degrees."""

	@staticmethod
	def RandomUnitVectorInEllipticalConeInRadians(ConeDir: Vector, MaxYawInRadians: float, MaxPitchInRadians: float) -> Vector: ...
	"""Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
The shape of the cone can be modified according to the yaw and pitch angles.

@param MaxYawInRadians        The yaw angle of the cone (from ConeDir to horizontal edge), in radians.
@param MaxPitchInRadians      The pitch angle of the cone (from ConeDir to vertical edge), in radians."""

	@staticmethod
	def RandomUnitVectorInConeInDegrees(ConeDir: Vector, ConeHalfAngleInDegrees: float) -> Vector: ...
	"""Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
@param ConeDir                                       The base 'center' direction of the cone.
@param ConeHalfAngleInDegrees        The half-angle of the cone (from ConeDir to edge), in degrees."""

	@staticmethod
	def RandomUnitVectorInConeInRadians(ConeDir: Vector, ConeHalfAngleInRadians: float) -> Vector: ...
	"""Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
@param ConeDir                                       The base 'center' direction of the cone.
@param ConeHalfAngleInRadians        The half-angle of the cone (from ConeDir to edge), in radians."""

	@staticmethod
	def RandomPointInBoundingBox(Origin: Vector, BoxExtent: Vector) -> Vector: ...
	"""Returns a random point within the specified bounding box using the first vector as an origin and the second as the box extents."""

	@staticmethod
	def RandomUnitVector() -> Vector: ...
	"""Returns a random vector with length of 1"""

	@staticmethod
	def GetPointDistanceToLine(Point: Vector, LineOrigin: Vector, LineDirection: Vector) -> float: ...
	"""Find the distance from a point to the closest point on an infinite line.

@param Point                  Point for which we find the distance to the closest point on the line.
@param LineOrigin             Point of reference on the line.
@param LineDirection  Direction of the line. Not required to be normalized.
@return The distance from the given point to the closest point on the line."""

	@staticmethod
	def GetPointDistanceToSegment(Point: Vector, SegmentStart: Vector, SegmentEnd: Vector) -> float: ...
	"""Find the distance from a point to the closest point on a segment.

@param Point                  Point for which we find the distance to the closest point on the segment.
@param SegmentStart   Start of the segment.
@param SegmentEnd             End of the segment.
@return The distance from the given point to the closest point on the segment."""

	@staticmethod
	def FindClosestPointOnLine(Point: Vector, LineOrigin: Vector, LineDirection: Vector) -> Vector: ...
	"""Find the closest point on an infinite line to a given point.

@param Point                 Point for which we find the closest point on the line.
@param LineOrigin    Point of reference on the line.
@param LineDirection Direction of the line. Not required to be normalized.
@return The closest point on the line to the given point."""

	@staticmethod
	def FindClosestPointOnSegment(Point: Vector, SegmentStart: Vector, SegmentEnd: Vector) -> Vector: ...
	"""Find the closest point on a segment to a given point.

@param Point                 Point for which we find the closest point on the segment.
@param SegmentStart  Start of the segment.
@param SegmentEnd    End of the segment.
@return The closest point on the segment to the given point."""

	@staticmethod
	def FindNearestPointsOnLineSegments(Segment1Start: Vector, Segment1End: Vector, Segment2Start: Vector, Segment2End: Vector) -> typing.Tuple[Vector, Vector]: ...
	"""Find closest points between 2 segments.

@param       Segment1Start   Start of the 1st segment.
@param       Segment1End             End of the 1st segment.
@param       Segment2Start   Start of the 2nd segment.
@param       Segment2End             End of the 2nd segment.
@param       Segment1Point   Closest point on segment 1 to segment 2.
@param       Segment2Point   Closest point on segment 2 to segment 1."""

	@staticmethod
	def ProjectVectorOnToPlane(V: Vector, PlaneNormal: Vector) -> Vector: ...
	"""Projects a vector onto a plane defined by a normalized vector (PlaneNormal).

@param  V Vector to project onto the plane.
@param  PlaneNormal Normal of the plane.
@return Vector projected onto the plane."""

	@staticmethod
	def ProjectPointOnToPlane(Point: Vector, PlaneBase: Vector, PlaneNormal: Vector) -> Vector: ...
	"""Projects/snaps a point onto a plane defined by a point on the plane and a plane normal.

@param  Point Point to project onto the plane.
@param  PlaneBase A point on the plane.
@param  PlaneNormal Normal of the plane.
@return Point projected onto the plane."""

	@staticmethod
	def ProjectVectorOnToVector(V: Vector, Target: Vector) -> Vector: ...
	"""Projects one vector (V) onto another (Target) and returns the projected vector.
If Target is nearly zero in length, returns the zero vector.

@param  V Vector to project.
@param  Target Vector on which we are projecting.
@return V projected on to Target."""

	@staticmethod
	def Vector_ProjectOnToNormal(V: Vector, InNormal: Vector) -> Vector: ...
	"""Gets a copy of this vector projected onto the input vector, which is assumed to be unit length.

@param  InNormal Vector to project onto (assumed to be unit length).
@return Projected vector."""

	@staticmethod
	def Vector_BoundedToBox(InVect: Vector, InBoxMin: Vector, InBoxMax: Vector) -> Vector: ...
	"""Get a copy of this vector, clamped inside of the specified axis aligned cube."""

	@staticmethod
	def Vector_AddBounded(A: Vector, InAddVect: Vector, InRadius: float): ...
	"""Add a vector to this and clamp the result to an axis aligned cube centered at the origin.

@param InAddVect Vector to add.
@param InRadius Half size of the cube."""

	@staticmethod
	def Vector_BoundedToCube(InVect: Vector, InRadius: float) -> Vector: ...
	"""Get a copy of this vector, clamped inside of an axis aligned cube centered at the origin.

@param InRadius Half size of the cube (or radius of sphere circumscribed in the cube).
@return A copy of this vector, bound by cube."""

	@staticmethod
	def Vector_SnappedToGrid(InVect: Vector, InGridSize: float) -> Vector: ...
	"""Gets a copy of this vector snapped to a grid.

@param InGridSize Grid dimension / step.
@return A copy of this vector snapped to a grid."""

	@staticmethod
	def Vector_MirrorByPlane(A: Vector, InPlane: Plane) -> Vector: ...
	"""Mirrors a vector about a plane.

@param Plane Plane to mirror about.
@return Mirrored vector."""

	@staticmethod
	def MirrorVectorByNormal(InVect: Vector, InNormal: Vector) -> Vector: ...
	"""Given a direction vector and a surface normal, returns the vector reflected across the surface normal.
Produces a result like shining a laser at a mirror!

@param InVect Direction vector the ray is coming from.
@param InNormal A normal of the surface the ray should be reflected on.

@returns Reflected vector."""

	@staticmethod
	def GetReflectionVector(Direction: Vector, SurfaceNormal: Vector) -> Vector: ...
	"""Given a direction vector and a surface normal, returns the vector reflected across the surface normal.
Produces a result like shining a laser at a mirror!

@param Direction Direction vector the ray is coming from.
@param SurfaceNormal A normal of the surface the ray should be reflected on.

@returns Reflected vector."""

	@staticmethod
	def Vector_Reciprocal(A: Vector) -> Vector: ...
	"""Gets the reciprocal of this vector, avoiding division by zero.
Zero components are set to BIG_NUMBER.

@return Reciprocal of this vector."""

	@staticmethod
	def VectorSpringInterp(Current: Vector, Target: Vector, SpringState: VectorSpringState, Stiffness: float, CriticalDampingFactor: float, DeltaTime: float, Mass: float = ...) -> Vector: ...
	"""Uses a simple spring model to interpolate a vector from Current to Target.

@param Current                                Current value
@param Target                                 Target value
@param SpringState                    Data related to spring model (velocity, error, etc..) - Create a unique variable per spring
@param Stiffness                              How stiff the spring model is (more stiffness means more oscillation around the target value)
@param CriticalDampingFactor  How much damping to apply to the spring (0 means no damping, 1 means critically damped which means no oscillation)
@param Mass                                   Multiplier that acts like mass on a spring"""

	@staticmethod
	def VInterpTo_Constant(Current: Vector, Target: Vector, DeltaTime: float, InterpSpeed: float) -> Vector: ...
	"""Tries to reach Target at a constant rate.

@param               Current                 Actual position
@param               Target                  Target position
@param               DeltaTime               Time since last tick
@param               InterpSpeed             Interpolation speed
@return              New interpolated position"""

	@staticmethod
	def VInterpTo(Current: Vector, Target: Vector, DeltaTime: float, InterpSpeed: float) -> Vector: ...
	"""Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.

@param               Current                 Actual position
@param               Target                  Target position
@param               DeltaTime               Time since last tick
@param               InterpSpeed             Interpolation speed, if the speed given is 0, then jump to the target.
@return              New interpolated position"""

	@staticmethod
	def VEase(A: Vector, B: Vector, Alpha: float, EasingFunc: int, BlendExp: float = ..., Steps: int = ...) -> Vector: ...
	"""Easing between A and B using a specified easing function"""

	@staticmethod
	def VLerp(A: Vector, B: Vector, Alpha: float) -> Vector: ...
	"""Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)"""

	@staticmethod
	def Vector_Normalize(A: Vector, Tolerance: float = ...): ...
	"""Normalize this vector in-place if it is large enough or set it to (0,0,0) otherwise.

@param Tolerance Minimum squared length of vector for normalization."""

	@staticmethod
	def Vector_NormalUnsafe(A: Vector) -> Vector: ...
	"""Calculates normalized unit version of vector without checking for zero length.

@return Normalized version of vector."""

	@staticmethod
	def Vector_Normal2D(A: Vector, Tolerance: float = ...) -> Vector: ...
	"""Gets a normalized unit copy of the 2D components of the vector, ensuring it is safe to do so. Z is set to zero.
Returns zero vector if vector length is too small to normalize.

@param Tolerance Minimum squared vector length.
@return Normalized copy if safe, (0,0,0) otherwise."""

	@staticmethod
	def Normal(A: Vector, Tolerance: float = ...) -> Vector: ...
	"""Gets a normalized unit copy of the vector, ensuring it is safe to do so based on the length.
Returns zero vector if vector length is too small to safely normalize.

@param Tolerance Minimum squared vector length.
@return A normalized copy if safe, (0,0,0) otherwise."""

	@staticmethod
	def Vector_IsNormal(A: Vector) -> bool: ...
	"""Determines if vector is normalized / unit (length 1).

@return true if normalized, false otherwise."""

	@staticmethod
	def Vector_IsUnit(A: Vector, SquaredLenthTolerance: float = ...) -> bool: ...
	"""Determines if vector is normalized / unit (length 1) within specified squared tolerance.

@return true if unit, false otherwise."""

	@staticmethod
	def Vector_IsUniform(A: Vector, Tolerance: float = ...) -> bool: ...
	"""Checks whether all components of this vector are the same, within a tolerance.

@param Tolerance Error tolerance.
@return true if the vectors are equal within tolerance limits, false otherwise."""

	@staticmethod
	def Vector_IsNAN(A: Vector) -> bool: ...
	"""Determines if any component is not a number (NAN)

@return true if one or more components is NAN, otherwise false."""

	@staticmethod
	def Vector_IsZero(A: Vector) -> bool: ...
	"""Checks whether all components of the vector are exactly zero.

@return true if vector is exactly zero, otherwise false."""

	@staticmethod
	def Vector_IsNearlyZero(A: Vector, Tolerance: float = ...) -> bool: ...
	"""Checks whether vector is near to zero within a specified tolerance.

@param Tolerance Error tolerance.
@return true if vector is in tolerance to zero, otherwise false."""

	@staticmethod
	def VSizeXYSquared(A: Vector) -> float: ...
	"""Returns the squared length of the vector's XY components."""

	@staticmethod
	def VSizeXY(A: Vector) -> float: ...
	"""Returns the length of the vector's XY components."""

	@staticmethod
	def VSizeSquared(A: Vector) -> float: ...
	"""Returns the squared length of the vector"""

	@staticmethod
	def VSize(A: Vector) -> float: ...
	"""Returns the length of the vector"""

	@staticmethod
	def Vector_Distance2DSquared(V1: Vector, V2: Vector) -> float: ...
	"""Squared euclidean distance between two points in the XY plane (ignoring Z).

@param V1 The first point.
@param V2 The second point.
@return The distance between two points in the XY plane."""

	@staticmethod
	def Vector_Distance2D(V1: Vector, V2: Vector) -> float: ...
	"""Euclidean distance between two points in the XY plane (ignoring Z).

@param V1 The first point.
@param V2 The second point.
@return The distance between two points in the XY plane."""

	@staticmethod
	def Vector_DistanceSquared(V1: Vector, V2: Vector) -> float: ...
	"""Squared distance between two points.

@param V1 The first point.
@param V2 The second point.
@return The squared distance between two points."""

	@staticmethod
	def Vector_Distance(V1: Vector, V2: Vector) -> float: ...
	"""Distance between two points.

@param V1 The first point.
@param V2 The second point.
@return The distance between two points."""

	@staticmethod
	def FTruncVector(InVector: Vector) -> IntVector: ...
	"""Rounds A to an integer with truncation towards zero for each element in a vector.  (e.g. -1.7 truncated to -1, 2.8 truncated to 2)"""

	@staticmethod
	def GetVectorArrayAverage(Vectors: typing.List[Vector]) -> Vector: ...
	"""Find the average of an array of vectors"""

	@staticmethod
	def GetAzimuthAndElevation(InDirection: Vector, ReferenceFrame: Transform) -> typing.Tuple[float, float]: ...
	"""Breaks a direction vector apart into Azimuth (Yaw) and Elevation (Pitch) rotation values given in degrees. (non-clamped)
       Relative to the provided reference frame (an Actor's WorldTransform for example)"""

	@staticmethod
	def GetYawPitchFromVector(InVec: Vector) -> typing.Tuple[float, float]: ...
	"""Breaks a vector apart into Yaw, Pitch rotation values given in degrees. (non-clamped)"""

	@staticmethod
	def GetDirectionUnitVector(From: Vector, To: Vector) -> Vector: ...
	"""Find the unit direction vector from one position to another or (0,0,0) if positions are the same."""

	@staticmethod
	def Vector_UnitCartesianToSpherical(A: Vector) -> Vector2D: ...
	"""Converts a Cartesian unit vector into spherical coordinates on the unit sphere.
@return Output Theta will be in the range [0, PI], and output Phi will be in the range [-PI, PI]."""

	@staticmethod
	def Vector_ToDegrees(A: Vector) -> Vector: ...
	"""Converts a vector containing radian values to a vector containing degree values.

@return Vector  containing degree values"""

	@staticmethod
	def Vector_ToRadians(A: Vector) -> Vector: ...
	"""Converts a vector containing degree values to a vector containing radian values.

@return Vector containing radian values"""

	@staticmethod
	def Vector_CosineAngle2D(A: Vector, B: Vector) -> float: ...
	"""Returns the cosine of the angle between this vector and another projected onto the XY plane (no Z).

@param B the other vector to find the 2D cosine of the angle with.
@return The cosine."""

	@staticmethod
	def Vector_HeadingAngle(A: Vector) -> float: ...
	"""Convert a direction vector into a 'heading' angle.

@return 'Heading' angle between +/-PI radians. 0 is pointing down +X."""

	@staticmethod
	def Vector_GetProjection(A: Vector) -> Vector: ...
	"""Projects 2D components of vector based on Z.

@return Projected version of vector based on Z."""

	@staticmethod
	def Vector_GetSignVector(A: Vector) -> Vector: ...
	"""Get a copy of the vector as sign only.
Each component is set to +1 or -1, with the sign of zero treated as +1.

@param A copy of the vector with each component set to +1 or -1"""

	@staticmethod
	def Vector_ComponentMax(A: Vector, B: Vector) -> Vector: ...
	"""Find the maximum elements (X, Y and Z) between the two vector's components"""

	@staticmethod
	def Vector_ComponentMin(A: Vector, B: Vector) -> Vector: ...
	"""Find the minimum elements (X, Y and Z) between the two vector's components"""

	@staticmethod
	def Vector_GetAbs(A: Vector) -> Vector: ...
	"""Get a copy of this vector with absolute value of each component.

@return A copy of this vector with absolute value of each component."""

	@staticmethod
	def Vector_GetAbsMin(A: Vector) -> float: ...
	"""Find the minimum absolute element (abs(X), abs(Y) or abs(Z)) of a vector"""

	@staticmethod
	def Vector_GetAbsMax(A: Vector) -> float: ...
	"""Find the maximum absolute element (abs(X), abs(Y) or abs(Z)) of a vector"""

	@staticmethod
	def GetMaxElement(A: Vector) -> float: ...
	"""Find the maximum element (X, Y or Z) of a vector"""

	@staticmethod
	def GetMinElement(A: Vector) -> float: ...
	"""Find the minimum element (X, Y or Z) of a vector"""

	@staticmethod
	def Vector_ClampSizeMax2D(A: Vector, Max: float) -> Vector: ...
	"""Create a copy of this vector, with the maximum 2D magnitude/size/length clamped to MaxSize. Z is unchanged."""

	@staticmethod
	def Vector_ClampSizeMax(A: Vector, Max: float) -> Vector: ...
	"""Create a copy of this vector, with its maximum magnitude/size/length clamped to MaxSize."""

	@staticmethod
	def Vector_ClampSize2D(A: Vector, Min: float, Max: float) -> Vector: ...
	"""Create a copy of this vector, with the 2D magnitude/size/length clamped between Min and Max. Z is unchanged."""

	@staticmethod
	def ClampVectorSize(A: Vector, Min: float, Max: float) -> Vector: ...
	"""Create a copy of this vector, with its magnitude/size/length clamped between Min and Max."""

	@staticmethod
	def Vector_UnwindEuler(A: Vector): ...
	"""When this vector contains Euler angles (degrees), ensure that angles are between +/-180"""

	@staticmethod
	def LessLess_VectorRotator(A: Vector, B: Rotator) -> Vector: ...
	"""Returns result of vector A rotated by the inverse of Rotator B"""

	@staticmethod
	def RotateAngleAxis(InVect: Vector, AngleDeg: float, Axis: Vector) -> Vector: ...
	"""Returns result of vector A rotated by AngleDeg around Axis"""

	@staticmethod
	def GreaterGreater_VectorRotator(A: Vector, B: Rotator) -> Vector: ...
	"""Returns result of vector A rotated by Rotator B"""

	@staticmethod
	def Cross_VectorVector(A: Vector, B: Vector) -> Vector: ...
	"""Returns the cross product of two 3d vectors - see http://mathworld.wolfram.com/CrossProduct.html"""

	@staticmethod
	def Dot_VectorVector(A: Vector, B: Vector) -> float: ...
	"""Returns the dot product of two 3d vectors - see http://mathworld.wolfram.com/DotProduct.html"""

	@staticmethod
	def NotEqual_VectorVector(A: Vector, B: Vector, ErrorTolerance: float = ...) -> bool: ...
	"""Returns true if vector A is not equal to vector B (A != B) within a specified error tolerance"""

	@staticmethod
	def NotEqualExactly_VectorVector(A: Vector, B: Vector) -> bool: ...
	"""Returns true if vector A is not equal to vector B (A != B)"""

	@staticmethod
	def EqualEqual_VectorVector(A: Vector, B: Vector, ErrorTolerance: float = ...) -> bool: ...
	"""Returns true if vector A is equal to vector B (A == B) within a specified error tolerance"""

	@staticmethod
	def EqualExactly_VectorVector(A: Vector, B: Vector) -> bool: ...
	"""Returns true if vector A is equal to vector B (A == B)"""

	@staticmethod
	def NegateVector(A: Vector) -> Vector: ...
	"""Negate a vector."""

	@staticmethod
	def Divide_VectorInt(A: Vector, B: int = ...) -> Vector: ...
	"""Vector divide by an integer"""

	@staticmethod
	def Divide_VectorFloat(A: Vector, B: float = ...) -> Vector: ...
	"""Vector divide by a float"""

	@staticmethod
	def Divide_VectorVector(A: Vector, B: Vector = ...) -> Vector: ...
	"""Element-wise Vector division (Result = {A.x/B.x, A.y/B.y, A.z/B.z})"""

	@staticmethod
	def Multiply_VectorInt(A: Vector, B: int) -> Vector: ...
	"""Scales Vector A by B"""

	@staticmethod
	def Multiply_VectorFloat(A: Vector, B: float) -> Vector: ...
	"""Scales Vector A by B"""

	@staticmethod
	def Multiply_VectorVector(A: Vector, B: Vector) -> Vector: ...
	"""Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y, A.z*B.z})"""

	@staticmethod
	def Subtract_VectorInt(A: Vector, B: int) -> Vector: ...
	"""Subtracts an integer from each component of a vector"""

	@staticmethod
	def Subtract_VectorFloat(A: Vector, B: float) -> Vector: ...
	"""Subtracts a float from each component of a vector"""

	@staticmethod
	def Subtract_VectorVector(A: Vector, B: Vector) -> Vector: ...
	"""Vector subtraction"""

	@staticmethod
	def Add_VectorInt(A: Vector, B: int) -> Vector: ...
	"""Adds an integer to each component of a vector"""

	@staticmethod
	def Add_VectorFloat(A: Vector, B: float) -> Vector: ...
	"""Adds a float to each component of a vector"""

	@staticmethod
	def Add_VectorVector(A: Vector, B: Vector) -> Vector: ...
	"""Vector addition"""

	@staticmethod
	def Conv_VectorToQuaternion(InVec: Vector) -> Quat: ...
	"""Return the Quaternion orientation corresponding to the direction in which the vector points.
Similar to the FRotator version, returns a result without roll such that it preserves the up vector.

@note If you don't care about preserving the up vector and just want the most direct rotation, you can use the faster
'FQuat::FindBetweenVectors(FVector::ForwardVector, YourVector)' or 'FQuat::FindBetweenNormals(...)' if you know the vector is of unit length.

@return Quaternion from the Vector's direction, without any roll."""

	@staticmethod
	def RotatorFromAxisAndAngle(Axis: Vector, Angle: float) -> Rotator: ...
	"""Create a rotation from an this axis and supplied angle (in degrees)"""

	@staticmethod
	def Conv_VectorToRotator(InVec: Vector) -> Rotator: ...
	"""Return the FRotator orientation corresponding to the direction in which the vector points.
Sets Yaw and Pitch to the proper numbers, and sets Roll to zero because the roll can't be determined from a vector.

@return FRotator from the Vector's direction, without any roll."""

	@staticmethod
	def Conv_VectorToVector2D(InVector: Vector) -> Vector2D: ...
	"""Convert a Vector to a Vector2D using the Vector's (X, Y) coordinates"""

	@staticmethod
	def Conv_VectorToTransform(InLocation: Vector) -> Transform: ...
	"""Convert a vector to a transform. Uses vector as location"""

	@staticmethod
	def Conv_VectorToLinearColor(InVec: Vector) -> LinearColor: ...
	"""Converts a vector to LinearColor"""

	@staticmethod
	def BreakVector(InVec: Vector) -> typing.Tuple[float, float, float]: ...
	"""Breaks a vector apart into X, Y, Z"""

	@staticmethod
	def Vector_Set(A: Vector, X: float, Y: float, Z: float): ...
	"""Set the values of the vector directly.

@param InX New X coordinate.
@param InY New Y coordinate.
@param InZ New Z coordinate."""

	@staticmethod
	def Vector_Assign(A: Vector, InVector: Vector): ...
	"""Assign the values of the supplied vector.

@param InVector Vector to copy values from."""

	@staticmethod
	def CreateVectorFromYawPitch(Yaw: float, Pitch: float, Length: float = ...) -> Vector: ...
	"""Creates a directional vector from rotation values {Pitch, Yaw} supplied in degrees with specified Length"""

	@staticmethod
	def MakeVector(X: float, Y: float, Z: float) -> Vector: ...
	"""Makes a vector {X, Y, Z}"""

	@staticmethod
	def Vector_Left() -> Vector: ...
	"""3D vector Unreal left direction constant (0,-1,0)"""

	@staticmethod
	def Vector_Right() -> Vector: ...
	"""3D vector Unreal right direction constant (0,1,0)"""

	@staticmethod
	def Vector_Down() -> Vector: ...
	"""3D vector Unreal down direction constant (0,0,-1)"""

	@staticmethod
	def Vector_Up() -> Vector: ...
	"""3D vector Unreal up direction constant (0,0,1)"""

	@staticmethod
	def Vector_Backward() -> Vector: ...
	"""3D vector Unreal backward direction constant (-1,0,0)"""

	@staticmethod
	def Vector_Forward() -> Vector: ...
	"""3D vector Unreal forward direction constant (1,0,0)"""

	@staticmethod
	def Vector_One() -> Vector: ...
	"""3D vector one constant (1,1,1)"""

	@staticmethod
	def Vector_Zero() -> Vector: ...
	"""3D vector zero constant (0,0,0)"""

	@staticmethod
	def VSize2DSquared(A: Vector2D) -> float: ...
	"""Returns the squared length of a 2D Vector."""

	@staticmethod
	def VSize2D(A: Vector2D) -> float: ...
	"""Returns the length of a 2D Vector."""

	@staticmethod
	def ToSign2D(A: Vector2D) -> Vector2D: ...
	"""Get a copy of the vector as sign only.
Each component is set to +1 or -1, with the sign of zero treated as +1.

@return A copy of the vector with each component set to +1 or -1"""

	@staticmethod
	def ToRounded2D(A: Vector2D) -> Vector2D: ...
	"""Get this vector as a vector where each component has been rounded to the nearest int.

@return New FVector2D from this vector that is rounded."""

	@staticmethod
	def ToDirectionAndLength2D(A: Vector2D) -> typing.Tuple[Vector2D, float]: ...
	"""Util to convert this vector into a unit direction vector and its original length.

@param OutDir Reference passed in to store unit direction vector.
@param OutLength Reference passed in to store length of the vector."""

	@staticmethod
	def Spherical2DToUnitCartesian(A: Vector2D) -> Vector: ...
	"""Converts spherical coordinates on the unit sphere into a Cartesian unit length vector."""

	@staticmethod
	def Normalize2D(A: Vector2D, Tolerance: float = ...): ...
	"""Normalize this vector in-place if it is large enough, set it to (0,0) otherwise.

@param Tolerance Minimum squared length of vector for normalization.
@see NormalSafe2D()"""

	@staticmethod
	def Normal2D(A: Vector2D) -> Vector2D: ...
	"""Returns a unit normal version of the 2D vector"""

	@staticmethod
	def NormalSafe2D(A: Vector2D, Tolerance: float = ...) -> Vector2D: ...
	"""Gets a normalized copy of the vector, checking it is safe to do so based on the length.
Returns zero vector if vector length is too small to safely normalize.

@param Tolerance Minimum squared length of vector for normalization.
@return A normalized copy of the vector if safe, (0,0) otherwise."""

	@staticmethod
	def Vector2DInterpTo_Constant(Current: Vector2D, Target: Vector2D, DeltaTime: float, InterpSpeed: float) -> Vector2D: ...
	"""Tries to reach Target at a constant rate.

@param               Current                 Actual position
@param               Target                  Target position
@param               DeltaTime               Time since last tick
@param               InterpSpeed             Interpolation speed
@return              New interpolated position"""

	@staticmethod
	def Vector2DInterpTo(Current: Vector2D, Target: Vector2D, DeltaTime: float, InterpSpeed: float) -> Vector2D: ...
	"""Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.

@param               Current                 Actual position
@param               Target                  Target position
@param               DeltaTime               Time since last tick
@param               InterpSpeed             Interpolation speed, if the speed given is 0, then jump to the target.
@return              New interpolated position"""

	@staticmethod
	def IsZero2D(A: Vector2D) -> bool: ...
	"""Checks whether all components of the vector are exactly zero.

@return true if vector is exactly zero, otherwise false."""

	@staticmethod
	def IsNearlyZero2D(A: Vector2D, Tolerance: float = ...) -> bool: ...
	"""Checks whether vector is near to zero within a specified tolerance.

@param Tolerance Error tolerance.
@return true if vector is in tolerance to zero, otherwise false."""

	@staticmethod
	def GetRotated2D(A: Vector2D, AngleDeg: float) -> Vector2D: ...
	"""Rotates around axis (0,0,1)

@param AngleDeg Angle to rotate (in degrees)
@return Rotated Vector"""

	@staticmethod
	def GetMin2D(A: Vector2D) -> float: ...
	"""Get the minimum value of the vector's components.

@return The minimum value of the vector's components."""

	@staticmethod
	def GetMax2D(A: Vector2D) -> float: ...
	"""Get the maximum value of the vector's components.

@return The maximum value of the vector's components."""

	@staticmethod
	def GetAbsMax2D(A: Vector2D) -> float: ...
	"""Get the maximum absolute value of the vector's components.

@return The maximum absolute value of the vector's components."""

	@staticmethod
	def GetAbs2D(A: Vector2D) -> Vector2D: ...
	"""Get a copy of this vector with absolute value of each component.

@return A copy of this vector with absolute value of each component."""

	@staticmethod
	def DotProduct2D(A: Vector2D, B: Vector2D) -> float: ...
	"""Returns the dot product of two 2d vectors - see http://mathworld.wolfram.com/DotProduct.html"""

	@staticmethod
	def DistanceSquared2D(V1: Vector2D, V2: Vector2D) -> float: ...
	"""Squared distance between two 2D points.

@param V1 The first point.
@param V2 The second point.
@return The squared distance between two 2D points."""

	@staticmethod
	def Distance2D(V1: Vector2D, V2: Vector2D) -> float: ...
	"""Distance between two 2D points.

@param V1 The first point.
@param V2 The second point.
@return The distance between two 2D points."""

	@staticmethod
	def CrossProduct2D(A: Vector2D, B: Vector2D) -> float: ...
	"""Returns the cross product of two 2d vectors - see  http://mathworld.wolfram.com/CrossProduct.html"""

	@staticmethod
	def ClampAxes2D(A: Vector2D, MinAxisVal: float, MaxAxisVal: float) -> Vector2D: ...
	"""Creates a copy of this vector with both axes clamped to the given range.
@return New vector with clamped axes."""

	@staticmethod
	def Set2D(A: Vector2D, X: float, Y: float): ...
	"""Set the values of the vector directly.

@param InX New X coordinate.
@param InY New Y coordinate."""

	@staticmethod
	def Negated2D(A: Vector2D) -> Vector2D: ...
	"""Gets a negated copy of the vector."""

	@staticmethod
	def NotEqual_Vector2DVector2D(A: Vector2D, B: Vector2D, ErrorTolerance: float = ...) -> bool: ...
	"""Returns true if vector2D A is not equal to vector2D B (A != B) within a specified error tolerance"""

	@staticmethod
	def NotEqualExactly_Vector2DVector2D(A: Vector2D, B: Vector2D) -> bool: ...
	"""Returns true if vector2D A is not equal to vector2D B (A != B) within a specified error tolerance"""

	@staticmethod
	def EqualEqual_Vector2DVector2D(A: Vector2D, B: Vector2D, ErrorTolerance: float = ...) -> bool: ...
	"""Returns true if vector2D A is equal to vector2D B (A == B) within a specified error tolerance"""

	@staticmethod
	def EqualExactly_Vector2DVector2D(A: Vector2D, B: Vector2D) -> bool: ...
	"""Returns true if vector A is equal to vector B (A == B)"""

	@staticmethod
	def Divide_Vector2DFloat(A: Vector2D, B: float = ...) -> Vector2D: ...
	"""Returns Vector A divided by B"""

	@staticmethod
	def Divide_Vector2DVector2D(A: Vector2D, B: Vector2D) -> Vector2D: ...
	"""Element-wise Vector divide (Result = {A.x/B.x, A.y/B.y})"""

	@staticmethod
	def Multiply_Vector2DFloat(A: Vector2D, B: float) -> Vector2D: ...
	"""Returns Vector A scaled by B"""

	@staticmethod
	def Multiply_Vector2DVector2D(A: Vector2D, B: Vector2D) -> Vector2D: ...
	"""Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y})"""

	@staticmethod
	def Subtract_Vector2DFloat(A: Vector2D, B: float) -> Vector2D: ...
	"""Returns Vector A subtracted by B"""

	@staticmethod
	def Subtract_Vector2DVector2D(A: Vector2D, B: Vector2D) -> Vector2D: ...
	"""Returns subtraction of Vector B from Vector A (A - B)"""

	@staticmethod
	def Add_Vector2DFloat(A: Vector2D, B: float) -> Vector2D: ...
	"""Returns Vector A added by B"""

	@staticmethod
	def Add_Vector2DVector2D(A: Vector2D, B: Vector2D) -> Vector2D: ...
	"""Returns addition of Vector A and Vector B (A + B)"""

	@staticmethod
	def Conv_Vector2DToIntPoint(InVector2D: Vector2D) -> IntPoint: ...
	"""Convert a Vector2D to an IntPoint"""

	@staticmethod
	def Conv_Vector2DToVector(InVector2D: Vector2D, Z: float = ...) -> Vector: ...
	"""Convert a Vector2D to a Vector"""

	@staticmethod
	def BreakVector2D(InVec: Vector2D) -> typing.Tuple[float, float]: ...
	"""Breaks a 2D vector apart into X, Y."""

	@staticmethod
	def MakeVector2D(X: float, Y: float) -> Vector2D: ...
	"""Makes a 2d vector {X, Y}"""

	@staticmethod
	def Vector2D_Zero() -> Vector2D: ...
	"""2D zero vector constant (0,0)"""

	@staticmethod
	def Vector2D_Unit45Deg() -> Vector2D: ...
	"""2D unit vector constant along the 45 degree angle or symmetrical positive axes (sqrt(.5),sqrt(.5)) or (.707,.707). https://en.wikipedia.org/wiki/Unit_vector"""

	@staticmethod
	def Vector2D_One() -> Vector2D: ...
	"""2D one vector constant (1,1)"""

	@staticmethod
	def NotEqual_IntPointIntPoint(A: IntPoint, B: IntPoint) -> bool: ...
	"""Returns true if IntPoint A is NOT equal to IntPoint B (A != B)"""

	@staticmethod
	def Equal_IntPointIntPoint(A: IntPoint, B: IntPoint) -> bool: ...
	"""Returns true if IntPoint A is equal to IntPoint B (A == B)"""

	@staticmethod
	def Divide_IntPointInt(A: IntPoint, B: int) -> IntPoint: ...
	"""Division (A * B)"""

	@staticmethod
	def Divide_IntPointIntPoint(A: IntPoint, B: IntPoint) -> IntPoint: ...
	"""Returns IntPoint A divided by B"""

	@staticmethod
	def Multiply_IntPointInt(A: IntPoint, B: int) -> IntPoint: ...
	"""Multiplication (A * B)"""

	@staticmethod
	def Multiply_IntPointIntPoint(A: IntPoint, B: IntPoint) -> IntPoint: ...
	"""Returns IntPoint A multiplied by B"""

	@staticmethod
	def Subtract_IntPointInt(A: IntPoint, B: int) -> IntPoint: ...
	"""Subtraction (A - B)"""

	@staticmethod
	def Subtract_IntPointIntPoint(A: IntPoint, B: IntPoint) -> IntPoint: ...
	"""Returns IntPoint A subtracted by B"""

	@staticmethod
	def Add_IntPointInt(A: IntPoint, B: int) -> IntPoint: ...
	"""Addition (A - B)"""

	@staticmethod
	def Add_IntPointIntPoint(A: IntPoint, B: IntPoint) -> IntPoint: ...
	"""Returns IntPoint A added by B"""

	@staticmethod
	def Conv_IntPointToVector2D(InIntPoint: IntPoint) -> Vector2D: ...
	"""Convert an IntPoint to a Vector2D"""

	@staticmethod
	def IntPoint_Down() -> IntPoint: ...
	"""Down Int Point (0, 1)"""

	@staticmethod
	def IntPoint_Right() -> IntPoint: ...
	"""Right Int Point (1, 0)"""

	@staticmethod
	def IntPoint_Left() -> IntPoint: ...
	"""Left Int Point (-1, 0)"""

	@staticmethod
	def IntPoint_Up() -> IntPoint: ...
	"""Up Int Point (0, -1)"""

	@staticmethod
	def IntPoint_One() -> IntPoint: ...
	"""One Int Point (1, 1)"""

	@staticmethod
	def IntPoint_Zero() -> IntPoint: ...
	"""Zero Int Point (0, 0)"""

	@staticmethod
	def FixedTurn(InCurrent: float, InDesired: float, InDeltaRate: float) -> float: ...
	"""Returns a new rotation component value

@param InCurrent is the current rotation value
@param InDesired is the desired rotation value
@param  is the rotation amount to apply

@return a new rotation component value clamped in the range (-360,360)"""

	@staticmethod
	def MakePulsatingValue(InCurrentTime: float, InPulsesPerSecond: float = ..., InPhase: float = ...) -> float: ...
	"""Simple function to create a pulsating scalar value

@param  InCurrentTime  Current absolute time
@param  InPulsesPerSecond  How many full pulses per second?
@param  InPhase  Optional phase amount, between 0.0 and 1.0 (to synchronize pulses)

@return  Pulsating value (0.0-1.0)"""

	@staticmethod
	def FInterpEaseInOut(A: float, B: float, Alpha: float, Exponent: float) -> float: ...
	"""Interpolate between A and B, applying an ease in/out function.  Exp controls the degree of the curve."""

	@staticmethod
	def MultiplyByPi(Value: float) -> float: ...
	"""Multiplies the input value by pi."""

	@staticmethod
	def MapRangeClamped(Value: float, InRangeA: float, InRangeB: float, OutRangeA: float, OutRangeB: float) -> float: ...
	"""Returns Value mapped from one range into another where the Value is clamped to the Input Range.  (e.g. 0.5 normalized from the range 0->1 to 0->50 would result in 25)"""

	@staticmethod
	def MapRangeUnclamped(Value: float, InRangeA: float, InRangeB: float, OutRangeA: float, OutRangeB: float) -> float: ...
	"""Returns Value mapped from one range into another.  (e.g. 20 normalized from the range 10->50 to 20->40 would result in 25)"""

	@staticmethod
	def NormalizeToRange(Value: float, RangeMin: float, RangeMax: float) -> float: ...
	"""Returns Value normalized to the given range.  (e.g. 20 normalized to the range 10->50 would result in 0.25)"""

	@staticmethod
	def SignOfFloat(A: float) -> float: ...
	"""Sign (float, returns -1 if A < 0, 0 if A is zero, and +1 if A > 0)"""

	@staticmethod
	def FMod(Dividend: float, Divisor: float) -> typing.Tuple[int, float]: ...
	"""Returns the number of times Divisor will go into Dividend (i.e., Dividend divided by Divisor), as well as the remainder"""

	@staticmethod
	def FCeil64(A: float) -> long: ...
	"""Rounds A up towards positive infinity / up to the next integer (e.g., -1.6 becomes -1 and 1.6 becomes 2)"""

	@staticmethod
	def FTrunc64(A: float) -> long: ...
	"""Rounds A towards zero, truncating the fractional part (e.g., -1.6 becomes -1 and 1.6 becomes 1)"""

	@staticmethod
	def FFloor64(A: float) -> long: ...
	"""Rounds A down towards negative infinity / down to the previous integer (e.g., -1.6 becomes -2 and 1.6 becomes 1)"""

	@staticmethod
	def Round64(A: float) -> long: ...
	"""Rounds A to the nearest integer (e.g., -1.6 becomes -2 and 1.6 becomes 2)"""

	@staticmethod
	def FCeil(A: float) -> int: ...
	"""Rounds A up towards positive infinity / up to the next integer (e.g., -1.6 becomes -1 and 1.6 becomes 2)"""

	@staticmethod
	def FTrunc(A: float) -> int: ...
	"""Rounds A towards zero, truncating the fractional part (e.g., -1.6 becomes -1 and 1.6 becomes 1)"""

	@staticmethod
	def FFloor(A: float) -> int: ...
	"""Rounds A down towards negative infinity / down to the previous integer (e.g., -1.6 becomes -2 and 1.6 becomes 1)"""

	@staticmethod
	def Round(A: float) -> int: ...
	"""Rounds A to the nearest integer (e.g., -1.6 becomes -2 and 1.6 becomes 2)"""

	@staticmethod
	def Ease(A: float, B: float, Alpha: float, EasingFunc: int, BlendExp: float = ..., Steps: int = ...) -> float: ...
	"""Easeing  between A and B using a specified easing function"""

	@staticmethod
	def Lerp(A: float, B: float, Alpha: float) -> float: ...
	"""Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)"""

	@staticmethod
	def MinOfByteArray(ByteArray: typing.List[int]) -> typing.Tuple[int, int]: ...
	"""Returns min of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty."""

	@staticmethod
	def MaxOfByteArray(ByteArray: typing.List[int]) -> typing.Tuple[int, int]: ...
	"""Returns max of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty."""

	@staticmethod
	def MinOfFloatArray(FloatArray: typing.List[float]) -> typing.Tuple[int, float]: ...
	"""Returns min of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty."""

	@staticmethod
	def MaxOfFloatArray(FloatArray: typing.List[float]) -> typing.Tuple[int, float]: ...
	"""Returns max of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty."""

	@staticmethod
	def MinOfIntArray(IntArray: typing.List[int]) -> typing.Tuple[int, int]: ...
	"""Returns min of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty."""

	@staticmethod
	def MaxOfIntArray(IntArray: typing.List[int]) -> typing.Tuple[int, int]: ...
	"""Returns max of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty."""

	@staticmethod
	def SafeDivide(A: float, B: float) -> float: ...
	"""This functions returns 0 if B (the denominator) is zero"""

	@staticmethod
	def FWrap(Value: float, Min: float, Max: float) -> float: ...
	"""Returns Value wrapped from A and B (inclusive)"""

	@staticmethod
	def FClamp(Value: float, Min: float, Max: float) -> float: ...
	"""Returns Value clamped between A and B (inclusive)"""

	@staticmethod
	def FMax(A: float, B: float) -> float: ...
	"""Returns the maximum value of A and B"""

	@staticmethod
	def FMin(A: float, B: float) -> float: ...
	"""Returns the minimum value of A and B"""

	@staticmethod
	def ClampAngle(AngleDegrees: float, MinAngleDegrees: float, MaxAngleDegrees: float) -> float: ...
	"""Clamps an arbitrary angle to be between the given angles.  Will clamp to nearest boundary.

@param MinAngleDegrees       'from' angle that defines the beginning of the range of valid angles (sweeping clockwise)
@param MaxAngleDegrees       'to' angle that defines the end of the range of valid angles
@return Returns clamped angle in the range -180..180."""

	@staticmethod
	def DegAtan2(Y: float, X: float) -> float: ...
	"""Returns the inverse tan (atan2) of A/B (result is in Degrees)"""

	@staticmethod
	def DegAtan(A: float) -> float: ...
	"""Returns the inverse tan (atan) (result is in Degrees)"""

	@staticmethod
	def DegTan(A: float) -> float: ...
	"""Returns the tan of A (expects Degrees)"""

	@staticmethod
	def DegAcos(A: float) -> float: ...
	"""Returns the inverse cos (arccos) of A (result is in Degrees)"""

	@staticmethod
	def DegCos(A: float) -> float: ...
	"""Returns the cos of A (expects Degrees)"""

	@staticmethod
	def DegAsin(A: float) -> float: ...
	"""Returns the inverse sin (arcsin) of A (result is in Degrees)"""

	@staticmethod
	def DegSin(A: float) -> float: ...
	"""Returns the sin of A (expects Degrees)"""

	@staticmethod
	def RadiansToDegrees(A: float) -> float: ...
	"""Returns degrees value based on the input radians"""

	@staticmethod
	def DegreesToRadians(A: float) -> float: ...
	"""Returns radians value based on the input degrees"""

	@staticmethod
	def GetTAU() -> float: ...
	"""Returns the value of TAU (= 2 * PI)"""

	@staticmethod
	def GetPI() -> float: ...
	"""Returns the value of PI"""

	@staticmethod
	def RandomFloatInRange(Min: float, Max: float) -> float: ...
	"""Generate a random number between Min and Max"""

	@staticmethod
	def RandomFloat() -> float: ...
	"""Returns a random float between 0 and 1"""

	@staticmethod
	def Square(A: float) -> float: ...
	"""Returns square of A (A*A)"""

	@staticmethod
	def Sqrt(A: float) -> float: ...
	"""Returns square root of A"""

	@staticmethod
	def Loge(A: float) -> float: ...
	"""Returns natural log of A (if e^R == A, returns R)"""

	@staticmethod
	def Log(A: float, Base: float = ...) -> float: ...
	"""Returns log of A base B (if B^R == A, returns R)"""

	@staticmethod
	def Exp(A: float) -> float: ...
	"""Returns exponential(e) to the power A (e^A)"""

	@staticmethod
	def Atan2(Y: float, X: float) -> float: ...
	"""Returns the inverse tan (atan2) of A/B (result is in Radians)"""

	@staticmethod
	def Atan(A: float) -> float: ...
	"""Returns the inverse tan (atan) (result is in Radians)"""

	@staticmethod
	def Tan(A: float) -> float: ...
	"""Returns the tan of A (expects Radians)"""

	@staticmethod
	def Acos(A: float) -> float: ...
	"""Returns the inverse cosine (arccos) of A (result is in Radians)"""

	@staticmethod
	def Cos(A: float) -> float: ...
	"""Returns the cosine of A (expects Radians)"""

	@staticmethod
	def Asin(A: float) -> float: ...
	"""Returns the inverse sine (arcsin) of A (result is in Radians)"""

	@staticmethod
	def Sin(A: float) -> float: ...
	"""Returns the sine of A (expects Radians)"""

	@staticmethod
	def Abs(A: float) -> float: ...
	"""Returns the absolute (positive) value of A"""

	@staticmethod
	def GridSnap_Float(Location: float, GridSize: float) -> float: ...
	"""Snaps a value to the nearest grid multiple. E.g.,
            Location = 5.1, GridSize = 10.0 : return value = 10.0
If GridSize is 0 Location is returned
if GridSize is very small precision issues may occur."""

	@staticmethod
	def Hypotenuse(Width: float, Height: float) -> float: ...
	"""Returns the hypotenuse of a right-angled triangle given the width and height."""

	@staticmethod
	def InRange_FloatFloat(Value: float, Min: float, Max: float, InclusiveMin: bool = ..., InclusiveMax: bool = ...) -> bool: ...
	"""Returns true if value is between Min and Max (V >= Min && V <= Max)
If InclusiveMin is true, value needs to be equal or larger than Min, else it needs to be larger
If InclusiveMax is true, value needs to be smaller or equal than Max, else it needs to be smaller"""

	@staticmethod
	def NotEqual_FloatFloat(A: float, B: float) -> bool: ...
	"""Returns true if A does not equal B (A != B)"""

	@staticmethod
	def NearlyEqual_FloatFloat(A: float, B: float, ErrorTolerance: float = ...) -> bool: ...
	"""Returns true if A is nearly equal to B (|A - B| < ErrorTolerance)"""

	@staticmethod
	def EqualEqual_FloatFloat(A: float, B: float) -> bool: ...
	"""Returns true if A is exactly equal to B (A == B)"""

	@staticmethod
	def GreaterEqual_FloatFloat(A: float, B: float) -> bool: ...
	"""Returns true if A is greater than or equal to B (A >= B)"""

	@staticmethod
	def LessEqual_FloatFloat(A: float, B: float) -> bool: ...
	"""Returns true if A is Less than or equal to B (A <= B)"""

	@staticmethod
	def Greater_FloatFloat(A: float, B: float) -> bool: ...
	"""Returns true if A is greater than B (A > B)"""

	@staticmethod
	def Less_FloatFloat(A: float, B: float) -> bool: ...
	"""Returns true if A is Less than B (A < B)"""

	@staticmethod
	def Subtract_FloatFloat(A: float, B: float = ...) -> float: ...
	"""Subtraction (A - B)"""

	@staticmethod
	def Add_FloatFloat(A: float, B: float = ...) -> float: ...
	"""Addition (A + B)"""

	@staticmethod
	def Fraction(A: float) -> float: ...
	"""Returns the fractional part of a float."""

	@staticmethod
	def Percent_FloatFloat(A: float, B: float = ...) -> float: ...
	"""Modulo (A % B)"""

	@staticmethod
	def Divide_FloatFloat(A: float, B: float = ...) -> float: ...
	"""Division (A / B)"""

	@staticmethod
	def Multiply_IntFloat(A: int, B: float) -> float: ...
	"""Multiplication (A * B)"""

	@staticmethod
	def Multiply_FloatFloat(A: float, B: float) -> float: ...
	"""Multiplication (A * B)"""

	@staticmethod
	def MultiplyMultiply_FloatFloat(Base: float, Exp: float) -> float: ...
	"""Power (Base to the Exp-th power)"""

	@staticmethod
	def Abs_Int64(A: long) -> long: ...
	"""Returns the absolute (positive) value of A"""

	@staticmethod
	def ClampInt64(Value: long, Min: long, Max: long) -> long: ...
	"""Returns Value clamped to be between A and B (inclusive)"""

	@staticmethod
	def MaxInt64(A: long, B: long) -> long: ...
	"""Returns the maximum value of A and B"""

	@staticmethod
	def MinInt64(A: long, B: long) -> long: ...
	"""Returns the minimum value of A and B"""

	@staticmethod
	def RandomInteger64InRange(Min: long, Max: long) -> long: ...
	"""Return a random integer64 between Min and Max (>= Min and <= Max)"""

	@staticmethod
	def RandomInteger64(Max: long) -> long: ...
	"""Returns a uniformly distributed random number between 0 and Max - 1"""

	@staticmethod
	def SignOfInteger64(A: long) -> long: ...
	"""Sign (integer64, returns -1 if A < 0, 0 if A is zero, and +1 if A > 0)"""

	@staticmethod
	def Not_Int64(A: long) -> long: ...
	"""Bitwise NOT (~A)"""

	@staticmethod
	def Or_Int64Int64(A: long, B: long) -> long: ...
	"""Bitwise OR (A | B)"""

	@staticmethod
	def Xor_Int64Int64(A: long, B: long) -> long: ...
	"""Bitwise XOR (A ^ B)"""

	@staticmethod
	def And_Int64Int64(A: long, B: long) -> long: ...
	"""Bitwise AND (A & B)"""

	@staticmethod
	def InRange_Int64Int64(Value: long, Min: long, Max: long, InclusiveMin: bool = ..., InclusiveMax: bool = ...) -> bool: ...
	"""Returns true if value is between Min and Max (V >= Min && V <= Max)
If InclusiveMin is true, value needs to be equal or larger than Min, else it needs to be larger
If InclusiveMax is true, value needs to be smaller or equal than Max, else it needs to be smaller"""

	@staticmethod
	def NotEqual_Int64Int64(A: long, B: long) -> bool: ...
	"""Returns true if A is not equal to B (A != B)"""

	@staticmethod
	def EqualEqual_Int64Int64(A: long, B: long) -> bool: ...
	"""Returns true if A is equal to B (A == B)"""

	@staticmethod
	def GreaterEqual_Int64Int64(A: long, B: long) -> bool: ...
	"""Returns true if A is greater than or equal to B (A >= B)"""

	@staticmethod
	def LessEqual_Int64Int64(A: long, B: long) -> bool: ...
	"""Returns true if A is less than or equal to B (A <= B)"""

	@staticmethod
	def Greater_Int64Int64(A: long, B: long) -> bool: ...
	"""Returns true if A is greater than B (A > B)"""

	@staticmethod
	def Less_Int64Int64(A: long, B: long) -> bool: ...
	"""Returns true if A is less than B (A < B)"""

	@staticmethod
	def Subtract_Int64Int64(A: long, B: long = ...) -> long: ...
	"""Subtraction (A - B)"""

	@staticmethod
	def Add_Int64Int64(A: long, B: long = ...) -> long: ...
	"""Addition (A + B)"""

	@staticmethod
	def Divide_Int64Int64(A: long, B: long = ...) -> long: ...
	"""Division (A / B)"""

	@staticmethod
	def Multiply_Int64Int64(A: long, B: long) -> long: ...
	"""Multiplication (A * B)"""

	@staticmethod
	def Abs_Int(A: int) -> int: ...
	"""Returns the absolute (positive) value of A"""

	@staticmethod
	def Wrap(Value: int, Min: int, Max: int) -> int: ...
	"""Returns Value between A and B (inclusive) that wraps around"""

	@staticmethod
	def Clamp(Value: int, Min: int, Max: int) -> int: ...
	"""Returns Value clamped to be between A and B (inclusive)"""

	@staticmethod
	def Max(A: int, B: int) -> int: ...
	"""Returns the maximum value of A and B"""

	@staticmethod
	def Min(A: int, B: int) -> int: ...
	"""Returns the minimum value of A and B"""

	@staticmethod
	def RandomIntegerInRange(Min: int, Max: int) -> int: ...
	"""Return a random integer between Min and Max (>= Min and <= Max)"""

	@staticmethod
	def RandomInteger(Max: int) -> int: ...
	"""Returns a uniformly distributed random number between 0 and Max - 1"""

	@staticmethod
	def SignOfInteger(A: int) -> int: ...
	"""Sign (integer, returns -1 if A < 0, 0 if A is zero, and +1 if A > 0)"""

	@staticmethod
	def Not_Int(A: int) -> int: ...
	"""Bitwise NOT (~A)"""

	@staticmethod
	def Or_IntInt(A: int, B: int) -> int: ...
	"""Bitwise OR (A | B)"""

	@staticmethod
	def Xor_IntInt(A: int, B: int) -> int: ...
	"""Bitwise XOR (A ^ B)"""

	@staticmethod
	def And_IntInt(A: int, B: int) -> int: ...
	"""Bitwise AND (A & B)"""

	@staticmethod
	def InRange_IntInt(Value: int, Min: int, Max: int, InclusiveMin: bool = ..., InclusiveMax: bool = ...) -> bool: ...
	"""Returns true if value is between Min and Max (V >= Min && V <= Max)
If InclusiveMin is true, value needs to be equal or larger than Min, else it needs to be larger
If InclusiveMax is true, value needs to be smaller or equal than Max, else it needs to be smaller"""

	@staticmethod
	def NotEqual_IntInt(A: int, B: int) -> bool: ...
	"""Returns true if A is not equal to B (A != B)"""

	@staticmethod
	def EqualEqual_IntInt(A: int, B: int) -> bool: ...
	"""Returns true if A is equal to B (A == B)"""

	@staticmethod
	def GreaterEqual_IntInt(A: int, B: int) -> bool: ...
	"""Returns true if A is greater than or equal to B (A >= B)"""

	@staticmethod
	def LessEqual_IntInt(A: int, B: int) -> bool: ...
	"""Returns true if A is less than or equal to B (A <= B)"""

	@staticmethod
	def Greater_IntInt(A: int, B: int) -> bool: ...
	"""Returns true if A is greater than B (A > B)"""

	@staticmethod
	def Less_IntInt(A: int, B: int) -> bool: ...
	"""Returns true if A is less than B (A < B)"""

	@staticmethod
	def Subtract_IntInt(A: int, B: int = ...) -> int: ...
	"""Subtraction (A - B)"""

	@staticmethod
	def Add_IntInt(A: int, B: int = ...) -> int: ...
	"""Addition (A + B)"""

	@staticmethod
	def Percent_IntInt(A: int, B: int = ...) -> int: ...
	"""Modulo (A % B)"""

	@staticmethod
	def Divide_IntInt(A: int, B: int = ...) -> int: ...
	"""Division (A / B)"""

	@staticmethod
	def Multiply_IntInt(A: int, B: int) -> int: ...
	"""Multiplication (A * B)"""

	@staticmethod
	def NotEqual_ByteByte(A: int, B: int) -> bool: ...
	"""Returns true if A is not equal to B (A != B)"""

	@staticmethod
	def EqualEqual_ByteByte(A: int, B: int) -> bool: ...
	"""Returns true if A is equal to B (A == B)"""

	@staticmethod
	def GreaterEqual_ByteByte(A: int, B: int) -> bool: ...
	"""Returns true if A is greater than or equal to B (A >= B)"""

	@staticmethod
	def LessEqual_ByteByte(A: int, B: int) -> bool: ...
	"""Returns true if A is less than or equal to B (A <= B)"""

	@staticmethod
	def Greater_ByteByte(A: int, B: int) -> bool: ...
	"""Returns true if A is greater than B (A > B)"""

	@staticmethod
	def Less_ByteByte(A: int, B: int) -> bool: ...
	"""Returns true if A is less than B (A < B)"""

	@staticmethod
	def BMax(A: int, B: int) -> int: ...
	"""Returns the maximum value of A and B"""

	@staticmethod
	def BMin(A: int, B: int) -> int: ...
	"""Returns the minimum value of A and B"""

	@staticmethod
	def Subtract_ByteByte(A: int, B: int = ...) -> int: ...
	"""Subtraction (A - B)"""

	@staticmethod
	def Add_ByteByte(A: int, B: int = ...) -> int: ...
	"""Addition (A + B)"""

	@staticmethod
	def Percent_ByteByte(A: int, B: int = ...) -> int: ...
	"""Modulo (A % B)"""

	@staticmethod
	def Divide_ByteByte(A: int, B: int = ...) -> int: ...
	"""Division (A / B)"""

	@staticmethod
	def Multiply_ByteByte(A: int, B: int) -> int: ...
	"""Multiplication (A * B)"""

	@staticmethod
	def BooleanNOR(A: bool, B: bool) -> bool: ...
	"""Returns the logical Not OR of two values (A NOR B)"""

	@staticmethod
	def BooleanXOR(A: bool, B: bool) -> bool: ...
	"""Returns the logical eXclusive OR of two values (A XOR B)"""

	@staticmethod
	def BooleanOR(A: bool, B: bool) -> bool: ...
	"""Returns the logical OR of two values (A OR B)"""

	@staticmethod
	def BooleanNAND(A: bool, B: bool) -> bool: ...
	"""Returns the logical NAND of two values (A AND B)"""

	@staticmethod
	def BooleanAND(A: bool, B: bool) -> bool: ...
	"""Returns the logical AND of two values (A AND B)"""

	@staticmethod
	def NotEqual_BoolBool(A: bool, B: bool) -> bool: ...
	"""Returns true if the values are not equal (A != B)"""

	@staticmethod
	def EqualEqual_BoolBool(A: bool, B: bool) -> bool: ...
	"""Returns true if the values are equal (A == B)"""

	@staticmethod
	def Not_PreBool(A: bool) -> bool: ...
	"""Returns the logical complement of the Boolean value (NOT A)"""

	@staticmethod
	def RandomBoolWithWeightFromStream(Weight: float, RandomStream: RandomStream) -> bool: ...
	"""Get a random chance with the specified weight. Range of weight is 0.0 - 1.0 E.g.,
              Weight = .6 return value = True 60% of the time"""

	@staticmethod
	def RandomBoolWithWeight(Weight: float) -> bool: ...
	"""Get a random chance with the specified weight. Range of weight is 0.0 - 1.0 E.g.,
             Weight = .6 return value = True 60% of the time"""

	@staticmethod
	def RandomBool() -> bool: ...
	"""Returns a uniformly distributed random bool"""

	pass

class KismetRenderingLibrary(BlueprintFunctionLibrary):
	"""Kismet Rendering Library"""

	@staticmethod
	def SetCastInsetShadowForAllAttachments(PrimitiveComponent: PrimitiveComponent, bCastInsetShadow: bool, bLightAttachmentsAsGroup: bool): ...
	"""Set the inset shadow casting state of the given component and all its child attachments.
    Also choose if all attachments should be grouped for the inset shadow rendering. If enabled, one depth target will be shared for all attachments."""

	@staticmethod
	def BreakSkinWeightInfo(InWeight: SkelMeshSkinWeightInfo) -> typing.Tuple[int, int, int, int, int, int, int, int]: ...
	"""Break FSkelMeshSkinWeightInfo"""

	@staticmethod
	def MakeSkinWeightInfo(Bone0: int, Weight0: int, Bone1: int, Weight1: int, Bone2: int, Weight2: int, Bone3: int, Weight3: int) -> SkelMeshSkinWeightInfo: ...
	"""Create FSkelMeshSkinWeightInfo"""

	@staticmethod
	def EndDrawCanvasToRenderTarget(WorldContextObject: Object, Context: DrawToRenderTargetContext): ...
	"""Must be paired with a BeginDrawCanvasToRenderTarget to complete rendering to a render target."""

	@staticmethod
	def BeginDrawCanvasToRenderTarget(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D) -> typing.Tuple[Canvas, Vector2D, DrawToRenderTargetContext]: ...
	"""Returns a Canvas object that can be used to draw to the specified render target.
Canvas has functions like DrawMaterial with size parameters that can be used to draw to a specific area of a render target.
Be sure to call EndDrawCanvasToRenderTarget to complete the rendering!"""

	@staticmethod
	def ImportBufferAsTexture2D(WorldContextObject: Object, Buffer: typing.List[int]) -> Texture2D: ...
	"""Imports a texture from a buffer and creates Texture2D from it."""

	@staticmethod
	def ImportFileAsTexture2D(WorldContextObject: Object, FileName: str) -> Texture2D: ...
	"""Imports a texture file from disk and creates Texture2D from it."""

	@staticmethod
	def ExportTexture2D(WorldContextObject: Object, Texture: Texture2D, FilePath: str, FileName: str): ...
	"""Exports a Texture2D as a HDR image onto the disk."""

	@staticmethod
	def ReadRenderTargetRawUV(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, U: float, V: float) -> LinearColor: ...
	"""Incredibly inefficient and slow operation! Read a value as-is color from a render target using UV [0,1]x[0,1] coordinates."""

	@staticmethod
	def ReadRenderTargetRawPixel(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, X: int, Y: int) -> LinearColor: ...
	"""Incredibly inefficient and slow operation! Read a value as-is from a render target using integer pixel coordinates."""

	@staticmethod
	def ReadRenderTargetUV(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, U: float, V: float) -> Color: ...
	"""Incredibly inefficient and slow operation! Read a value as sRGB color from a render target using UV [0,1]x[0,1] coordinates.
LDR render targets are assumed to be in sRGB space. HDR ones are assumed to be in linear space.
Result is 8-bit per channel [0,255] BGRA in sRGB space."""

	@staticmethod
	def ReadRenderTargetPixel(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, X: int, Y: int) -> Color: ...
	"""Incredibly inefficient and slow operation! Read a value as sRGB color from a render target using integer pixel coordinates.
LDR render targets are assumed to be in sRGB space. HDR ones are assumed to be in linear space.
Result is 8-bit per channel [0,255] BGRA in sRGB space."""

	@staticmethod
	def ExportRenderTarget(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, FilePath: str, FileName: str): ...
	"""Exports a render target as a HDR or PNG image onto the disk (depending on the format of the render target)"""

	@staticmethod
	def ConvertRenderTargetToTexture2DEditorOnly(WorldContextObject: Object, RenderTarget: TextureRenderTarget2D, Texture: Texture2D): ...
	"""Copies the contents of a render target to a UTexture2D
Only works in the editor"""

	@staticmethod
	def RenderTargetCreateStaticTexture2DEditorOnly(RenderTarget: TextureRenderTarget2D, Name: str = ..., CompressionSettings: int = ..., MipSettings: int = ...) -> Texture2D: ...
	"""Creates a new Static Texture from a Render Target 2D. Render Target Must be power of two and use four channels.
Only works in the editor"""

	@staticmethod
	def DrawMaterialToRenderTarget(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, Material: MaterialInterface): ...
	"""Renders a quad with the material applied to the specified render target.
This sets the render target even if it is already set, which is an expensive operation.
Use BeginDrawCanvasToRenderTarget / EndDrawCanvasToRenderTarget instead if rendering multiple primitives to the same render target."""

	@staticmethod
	def ReleaseRenderTarget2D(TextureRenderTarget: TextureRenderTarget2D): ...
	"""Manually releases GPU resources of a render target. This is useful for blueprint creating a lot of render target that would
normally be released too late by the garbage collector that can be problematic on platforms that have tight GPU memory constrains."""

	@staticmethod
	def CreateRenderTargetVolume(WorldContextObject: Object, Width: int = ..., Height: int = ..., Depth: int = ..., Format: int = ..., ClearColor: LinearColor = ..., bAutoGenerateMipMaps: bool = ...) -> TextureRenderTargetVolume: ...
	"""Creates a new volume render target and initializes it to the specified dimensions"""

	@staticmethod
	def CreateRenderTarget2DArray(WorldContextObject: Object, Width: int = ..., Height: int = ..., Slices: int = ..., Format: int = ..., ClearColor: LinearColor = ..., bAutoGenerateMipMaps: bool = ...) -> TextureRenderTarget2DArray: ...
	"""Creates a new render target array and initializes it to the specified dimensions"""

	@staticmethod
	def CreateRenderTarget2D(WorldContextObject: Object, Width: int = ..., Height: int = ..., Format: int = ..., ClearColor: LinearColor = ..., bAutoGenerateMipMaps: bool = ...) -> TextureRenderTarget2D: ...
	"""Creates a new render target and initializes it to the specified dimensions"""

	@staticmethod
	def ClearRenderTarget2D(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, ClearColor: LinearColor = ...): ...
	"""Clears the specified render target with the given ClearColor."""

	pass

class KismetStringLibrary(BlueprintFunctionLibrary):
	"""Kismet String Library"""

	@staticmethod
	def TimeSecondsToString(InSeconds: float) -> str: ...
	"""Convert a number of seconds into minutes:seconds.milliseconds format string (including leading zeroes)

@return A new string built from the seconds parameter"""

	@staticmethod
	def Mid(SourceString: str, Start: int, Count: int) -> str: ...
	"""Returns the substring from Start position for Count characters."""

	@staticmethod
	def RightChop(SourceString: str, Count: int) -> str: ...
	"""Returns the string to the right of the specified location, counting forward from the left (from the beginning of the word)."""

	@staticmethod
	def Right(SourceString: str, Count: int) -> str: ...
	"""Returns the string to the right of the specified location, counting back from the right (end of the word)."""

	@staticmethod
	def LeftChop(SourceString: str, Count: int) -> str: ...
	"""Returns the left most characters from the string chopping the given number of characters from the end"""

	@staticmethod
	def Left(SourceString: str, Count: int) -> str: ...
	"""Returns the left most given number of characters"""

	@staticmethod
	def Split(SourceString: str, InStr: str, SearchCase: int = ..., SearchDir: int = ...) -> typing.Tuple[bool, str, str]: ...
	"""Splits this string at given string position case sensitive.

@param InStr The string to search and split at
@param LeftS out the string to the left of InStr, not updated if return is false
@param RightS out the string to the right of InStr, not updated if return is false
@param SearchCase             Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
@param SearchDir                      Indicates whether the search starts at the begining or at the end ( defaults to ESearchDir::FromStart )
@return true if string is split, otherwise false"""

	@staticmethod
	def ReplaceInline(SourceString: str, SearchText: str, ReplacementText: str, SearchCase: int = ...) -> int: ...
	"""Replace all occurrences of SearchText with ReplacementText in this string.

@param       SearchText      the text that should be removed from this string
@param       ReplacementText         the text to insert in its place
@param SearchCase    Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )

@return      the number of occurrences of SearchText that were replaced."""

	@staticmethod
	def Replace(SourceString: str, From: str, To: str, SearchCase: int = ...) -> str: ...
	"""Replace all occurrences of a substring in this string

@param From substring to replace
@param To substring to replace From with
@param SearchCase    Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
@return a copy of this string with the replacement made"""

	@staticmethod
	def Reverse(SourceString: str) -> str: ...
	"""Returns a copy of this string, with the characters in reverse order"""

	@staticmethod
	def CullArray(SourceString: str) -> typing.Tuple[int, typing.List[str]]: ...
	"""Takes an array of strings and removes any zero length entries.

@param       InArray The array to cull

@return      The number of elements left in InArray"""

	@staticmethod
	def TrimTrailing(SourceString: str) -> str: ...
	"""Removes trailing whitespace characters"""

	@staticmethod
	def Trim(SourceString: str) -> str: ...
	"""Removes whitespace characters from the front of this string."""

	@staticmethod
	def MatchesWildcard(SourceString: str, Wildcard: str, SearchCase: int = ...) -> bool: ...
	"""Searches this string for a given wild card

@param Wildcard              *?-type wildcard
@param SearchCase    Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
@return true if this string matches the *?-type wildcard given.
@warning This is a simple, SLOW routine. Use with caution"""

	@staticmethod
	def EndsWith(SourceString: str, InSuffix: str, SearchCase: int = ...) -> bool: ...
	"""Test whether this string ends with given string.

@param SearchCase            Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
@return true if this string ends with specified text, false otherwise"""

	@staticmethod
	def StartsWith(SourceString: str, InPrefix: str, SearchCase: int = ...) -> bool: ...
	"""Test whether this string starts with given string.

@param SearchCase            Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
@return true if this string begins with specified text, false otherwise"""

	@staticmethod
	def IsNumeric(SourceString: str) -> bool: ...
	"""* Checks if a string contains only numeric characters
* @param       SourceString    The string to check
* @return true if the string only contains numeric characters"""

	@staticmethod
	def RightPad(SourceString: str, ChCount: int) -> str: ...
	"""* Pad the right of this string for a specified number of characters
* @param       SourceString    The string to pad
* @param       ChCount                 Amount of padding required
* @return      The padded string"""

	@staticmethod
	def LeftPad(SourceString: str, ChCount: int) -> str: ...
	"""* Pad the left of this string for a specified number of characters
* @param       SourceString    The string to pad
* @param       ChCount                 Amount of padding required
* @return      The padded string"""

	@staticmethod
	def ToLower(SourceString: str) -> str: ...
	"""Returns a string converted to Lower case
@param        SourceString    The string to convert
@return       The string in lower case"""

	@staticmethod
	def ToUpper(SourceString: str) -> str: ...
	"""Returns a string converted to Upper case
@param       SourceString    The string to convert
@return      The string in upper case"""

	@staticmethod
	def GetCharacterArrayFromString(SourceString: str) -> typing.List[str]: ...
	"""Returns an array that contains one entry for each character in SourceString
@param        SourceString    The string to break apart into characters
@return       An array containing one entry for each character in SourceString"""

	@staticmethod
	def JoinStringArray(SourceArray: typing.List[str], Separator: str = ...) -> str: ...
	"""Concatenates an array of strings into a single string.
@param SourceArray - The array of strings to concatenate.
@param Separator - The string used to separate each element.
@return The final, joined, separated string."""

	@staticmethod
	def ParseIntoArray(SourceString: str, Delimiter: str = ..., CullEmptyStrings: bool = ...) -> typing.List[str]: ...
	"""Gets an array of strings from a source string divided up by a separator and empty strings can optionally be culled.
@param SourceString - The string to chop up
@param Delimiter - The string to delimit on
@param CullEmptyStrings = true - Cull (true) empty strings or add them to the array (false)
@return The array of string that have been separated"""

	@staticmethod
	def GetCharacterAsNumber(SourceString: str, Index: int = ...) -> int: ...
	"""Gets a single character from the string (as an integer)
@param SourceString - The string to convert
@param Index - Location of the character whose value is required
@return The integer value of the character or 0 if index is out of range"""

	@staticmethod
	def Contains(SearchIn: str, Substring: str, bUseCase: bool = ..., bSearchFromEnd: bool = ...) -> bool: ...
	"""Returns whether this string contains the specified substring.

@param SubStr                 Find to search for
@param SearchCase             Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
@param SearchDir                      Indicates whether the search starts at the begining or at the end ( defaults to ESearchDir::FromStart )
@return                                       Returns whether the string contains the substring"""

	@staticmethod
	def FindSubstring(SearchIn: str, Substring: str, bUseCase: bool = ..., bSearchFromEnd: bool = ..., StartPosition: int = ...) -> int: ...
	"""Finds the starting index of a substring in the a specified string
@param SearchIn The string to search within
@param Substring The string to look for in the SearchIn string
@param bUseCase Whether or not to be case-sensitive
@param bSearchFromEnd Whether or not to start the search from the end of the string instead of the beginning
@param StartPosition The position to start the search from
@return The index (starting from 0 if bSearchFromEnd is false) of the first occurence of the substring"""

	@staticmethod
	def GetSubstring(SourceString: str, StartIndex: int = ..., Length: int = ...) -> str: ...
	"""Returns a substring from the string starting at the specified position
@param SourceString - The string to get the substring from
@param StartIndex - The location in SourceString to use as the start of the substring
@param Length The length of the requested substring

@return The requested substring"""

	@staticmethod
	def IsEmpty(InString: str) -> bool: ...
	"""Returns true if the string is empty
@param InString - The string to check
@return Whether or not the string is empty"""

	@staticmethod
	def Len(S: str) -> int: ...
	"""Returns the number of characters in the string
@param SourceString - The string to measure
@return The number of chars in the string"""

	@staticmethod
	def NotEqual_StriStri(A: str, B: str) -> bool: ...
	"""Test if the input string are not equal (A != B), ignoring case differences
@param A - The string to compare against
@param B - The string to compare
@return Returns true if the input strings are not equal, false if they are equal"""

	@staticmethod
	def NotEqual_StrStr(A: str, B: str) -> bool: ...
	"""Test if the input string are not equal (A != B)
@param A - The string to compare against
@param B - The string to compare
@return Returns true if the input strings are not equal, false if they are equal"""

	@staticmethod
	def EqualEqual_StriStri(A: str, B: str) -> bool: ...
	"""Test if the input strings are equal (A == B), ignoring case
@param A - The string to compare against
@param B - The string to compare
@returns True if the strings are equal, false otherwise"""

	@staticmethod
	def EqualEqual_StrStr(A: str, B: str) -> bool: ...
	"""Test if the input strings are equal (A == B)
@param A - The string to compare against
@param B - The string to compare
@returns True if the strings are equal, false otherwise"""

	@staticmethod
	def Concat_StrStr(A: str, B: str) -> str: ...
	"""Concatenates two strings together to make a new string
@param A - The original string
@param B - The string to append to A
@returns A new string which is the concatenation of A+B"""

	@staticmethod
	def BuildString_Name(AppendTo: str, Prefix: str, InName: str, Suffix: str) -> str: ...
	"""Converts a color->string, creating a new string in the form AppendTo+Prefix+InName+Suffix
@param AppendTo - An existing string to use as the start of the conversion string
@param Prefix - A string to use as a prefix, after the AppendTo string
@param InName - The name value to convert
@param Suffix - A suffix to append to the end of the conversion string
@return A new string built from the passed parameters"""

	@staticmethod
	def BuildString_Color(AppendTo: str, Prefix: str, InColor: LinearColor, Suffix: str) -> str: ...
	"""Converts a color->string, creating a new string in the form AppendTo+Prefix+InColor+Suffix
@param AppendTo - An existing string to use as the start of the conversion string
@param Prefix - A string to use as a prefix, after the AppendTo string
@param InColor - The linear color value to convert. Uses the standard ToString conversion
@param Suffix - A suffix to append to the end of the conversion string
@return A new string built from the passed parameters"""

	@staticmethod
	def BuildString_Object(AppendTo: str, Prefix: str, InObj: Object, Suffix: str) -> str: ...
	"""Converts a object->string, creating a new string in the form AppendTo+Prefix+object name+Suffix
@param AppendTo - An existing string to use as the start of the conversion string
@param Prefix - A string to use as a prefix, after the AppendTo string
@param InObj - The object to convert. Will insert the name of the object into the conversion string
@param Suffix - A suffix to append to the end of the conversion string
@return A new string built from the passed parameters"""

	@staticmethod
	def BuildString_Rotator(AppendTo: str, Prefix: str, InRot: Rotator, Suffix: str) -> str: ...
	"""Converts a rotator->string, creating a new string in the form AppendTo+Prefix+InRot+Suffix
@param AppendTo - An existing string to use as the start of the conversion string
@param Prefix - A string to use as a prefix, after the AppendTo string
@param InRot - The rotator value to convert. Uses the standard ToString conversion
@param Suffix - A suffix to append to the end of the conversion string
@return A new string built from the passed parameters"""

	@staticmethod
	def BuildString_Vector2d(AppendTo: str, Prefix: str, InVector2d: Vector2D, Suffix: str) -> str: ...
	"""Converts a vector2d->string, creating a new string in the form AppendTo+Prefix+InVector2d+Suffix
@param AppendTo - An existing string to use as the start of the conversion string
@param Prefix - A string to use as a prefix, after the AppendTo string
@param InVector2d - The vector2d value to convert. Uses the standard FVector2D::ToString conversion
@param Suffix - A suffix to append to the end of the conversion string
@return A new string built from the passed parameters"""

	@staticmethod
	def BuildString_IntVector(AppendTo: str, Prefix: str, InIntVector: IntVector, Suffix: str) -> str: ...
	"""Converts an IntVector->string, creating a new string in the form AppendTo+Prefix+InIntVector+Suffix
@param AppendTo - An existing string to use as the start of the conversion string
@param Prefix - A string to use as a prefix, after the AppendTo string
@param InIntVector - The intVector value to convert. Uses the standard FVector::ToString conversion
@param Suffix - A suffix to append to the end of the conversion string
@return A new string built from the passed parameters"""

	@staticmethod
	def BuildString_Vector(AppendTo: str, Prefix: str, InVector: Vector, Suffix: str) -> str: ...
	"""Converts a vector->string, creating a new string in the form AppendTo+Prefix+InVector+Suffix
@param AppendTo - An existing string to use as the start of the conversion string
@param Prefix - A string to use as a prefix, after the AppendTo string
@param InVector - The vector value to convert. Uses the standard FVector::ToString conversion
@param Suffix - A suffix to append to the end of the conversion string
@return A new string built from the passed parameters"""

	@staticmethod
	def BuildString_Bool(AppendTo: str, Prefix: str, InBool: bool, Suffix: str) -> str: ...
	"""Converts a boolean->string, creating a new string in the form AppendTo+Prefix+InBool+Suffix
@param AppendTo - An existing string to use as the start of the conversion string
@param Prefix - A string to use as a prefix, after the AppendTo string
@param InBool - The bool value to convert. Will add 'true' or 'false' to the conversion string
@param Suffix - A suffix to append to the end of the conversion string
@return A new string built from the passed parameters"""

	@staticmethod
	def BuildString_Int(AppendTo: str, Prefix: str, InInt: int, Suffix: str) -> str: ...
	"""Converts a int->string, creating a new string in the form AppendTo+Prefix+InInt+Suffix
@param AppendTo - An existing string to use as the start of the conversion string
@param Prefix - A string to use as a prefix, after the AppendTo string
@param InInt - The int value to convert
@param Suffix - A suffix to append to the end of the conversion string
@return A new string built from the passed parameters"""

	@staticmethod
	def BuildString_Float(AppendTo: str, Prefix: str, InFloat: float, Suffix: str) -> str: ...
	"""Converts a float->string, create a new string in the form AppendTo+Prefix+InFloat+Suffix
@param AppendTo - An existing string to use as the start of the conversion string
@param Prefix - A string to use as a prefix, after the AppendTo string
@param InFloat - The float value to convert
@param Suffix - A suffix to append to the end of the conversion string
@return A new string built from the passed parameters"""

	@staticmethod
	def Conv_StringToColor(InString: str) -> typing.Tuple[LinearColor, bool]: ...
	"""Convert String Back To Color. IsValid indicates whether or not the string could be successfully converted."""

	@staticmethod
	def Conv_StringToRotator(InString: str) -> typing.Tuple[Rotator, bool]: ...
	"""Convert String Back To Rotator. IsValid indicates whether or not the string could be successfully converted."""

	@staticmethod
	def Conv_StringToVector2D(InString: str) -> typing.Tuple[Vector2D, bool]: ...
	"""Convert String Back To Vector2D. IsValid indicates whether or not the string could be successfully converted."""

	@staticmethod
	def Conv_StringToVector(InString: str) -> typing.Tuple[Vector, bool]: ...
	"""Convert String Back To Vector. IsValid indicates whether or not the string could be successfully converted."""

	@staticmethod
	def Conv_StringToFloat(InString: str) -> float: ...
	"""Converts a string to a float value"""

	@staticmethod
	def Conv_StringToInt(InString: str) -> int: ...
	"""Converts a string to a int value"""

	@staticmethod
	def Conv_StringToName(InString: str) -> str: ...
	"""Converts a string to a name value"""

	@staticmethod
	def Conv_MatrixToString(InMatrix: Matrix) -> str: ...
	"""Converts a name value to a string"""

	@staticmethod
	def Conv_NameToString(InName: str) -> str: ...
	"""Converts a name value to a string"""

	@staticmethod
	def Conv_ColorToString(InColor: LinearColor) -> str: ...
	"""Converts a linear color value to a string, in the form '(R=,G=,B=,A=)'"""

	@staticmethod
	def Conv_ObjectToString(InObj: Object) -> str: ...
	"""Converts a UObject value to a string by calling the object's GetName method"""

	@staticmethod
	def Conv_TransformToString(InTrans: Transform) -> str: ...
	"""Converts a transform value to a string, in the form 'Translation: X= Y= Z= Rotation: P= Y= R= Scale: X= Y= Z='"""

	@staticmethod
	def Conv_RotatorToString(InRot: Rotator) -> str: ...
	"""Converts a rotator value to a string, in the form 'P= Y= R='"""

	@staticmethod
	def Conv_Vector2dToString(InVec: Vector2D) -> str: ...
	"""Converts a vector2d value to a string, in the form 'X= Y='"""

	@staticmethod
	def Conv_IntPointToString(InIntPoint: IntPoint) -> str: ...
	"""Converts an IntPoint value to a string, in the form 'X= Y='"""

	@staticmethod
	def Conv_IntVectorToString(InIntVec: IntVector) -> str: ...
	"""Converts an IntVector value to a string, in the form 'X= Y= Z='"""

	@staticmethod
	def Conv_VectorToString(InVec: Vector) -> str: ...
	"""Converts a vector value to a string, in the form 'X= Y= Z='"""

	@staticmethod
	def Conv_BoolToString(InBool: bool) -> str: ...
	"""Converts a boolean value to a string, either 'true' or 'false'"""

	@staticmethod
	def Conv_ByteToString(InByte: int) -> str: ...
	"""Converts a byte value to a string"""

	@staticmethod
	def Conv_IntToString(InInt: int) -> str: ...
	"""Converts an integer value to a string"""

	@staticmethod
	def Conv_FloatToString(InFloat: float) -> str: ...
	"""Converts a float value to a string"""

	pass

class KismetStringTableLibrary(BlueprintFunctionLibrary):
	"""Kismet String Table Library"""

	@staticmethod
	def GetMetaDataIdsFromStringTableEntry(TableId: str, Key: str) -> typing.List[str]: ...
	"""Returns an array of all meta-data IDs within the given string table entry"""

	@staticmethod
	def GetKeysFromStringTable(TableId: str) -> typing.List[str]: ...
	"""Returns an array of all keys within the given string table"""

	@staticmethod
	def GetRegisteredStringTables() -> typing.List[str]: ...
	"""Returns an array of all registered string table IDs"""

	@staticmethod
	def GetTableEntryMetaData(TableId: str, Key: str, MetaDataId: str) -> str: ...
	"""Returns the specified meta-data of the given string table entry (or an empty string)."""

	@staticmethod
	def GetTableEntrySourceString(TableId: str, Key: str) -> str: ...
	"""Returns the source string of the given string table entry (or an empty string)."""

	@staticmethod
	def GetTableNamespace(TableId: str) -> str: ...
	"""Returns the namespace of the given string table."""

	@staticmethod
	def IsRegisteredTableEntry(TableId: str, Key: str) -> bool: ...
	"""Returns true if the given table ID corresponds to a registered string table, and that table has."""

	@staticmethod
	def IsRegisteredTableId(TableId: str) -> bool: ...
	"""Returns true if the given table ID corresponds to a registered string table."""

	pass

class KismetSystemLibrary(BlueprintFunctionLibrary):
	"""Kismet System Library"""

	@staticmethod
	def GetPrimaryAssetsWithBundleState(RequiredBundles: typing.List[str], ExcludedBundles: typing.List[str], ValidTypes: typing.List[PrimaryAssetType], bForceCurrentState: bool) -> typing.List[PrimaryAssetId]: ...
	"""Returns the list of assets that are in a given bundle state. Required Bundles must be specified
If ExcludedBundles is not empty, it will not return any assets in those bundle states
If ValidTypes is not empty, it will only return assets of those types
If ForceCurrentState is true it will use the current state even if a load is in process"""

	@staticmethod
	def GetCurrentBundleState(PrimaryAssetId: PrimaryAssetId, bForceCurrentState: bool) -> typing.Tuple[bool, typing.List[str]]: ...
	"""Returns the list of loaded bundles for a given Primary Asset. This will return false if the asset is not loaded at all.
If ForceCurrentState is true it will return the current state even if a load is in process"""

	@staticmethod
	def UnloadPrimaryAssetList(PrimaryAssetIdList: typing.List[PrimaryAssetId]): ...
	"""Unloads a primary asset, which allows it to be garbage collected if nothing else is referencing it"""

	@staticmethod
	def UnloadPrimaryAsset(PrimaryAssetId: PrimaryAssetId): ...
	"""Unloads a primary asset, which allows it to be garbage collected if nothing else is referencing it"""

	@staticmethod
	def NotEqual_PrimaryAssetType(A: PrimaryAssetType, B: PrimaryAssetType) -> bool: ...
	"""Returns true if the values are not equal (A != B)"""

	@staticmethod
	def EqualEqual_PrimaryAssetType(A: PrimaryAssetType, B: PrimaryAssetType) -> bool: ...
	"""Returns true if the values are equal (A == B)"""

	@staticmethod
	def Conv_PrimaryAssetTypeToString(PrimaryAssetType: PrimaryAssetType) -> str: ...
	"""Converts a Primary Asset Type to a string. The other direction is not provided because it cannot be validated"""

	@staticmethod
	def IsValidPrimaryAssetType(PrimaryAssetType: PrimaryAssetType) -> bool: ...
	"""Returns list of Primary Asset Ids for a PrimaryAssetType"""

	@staticmethod
	def NotEqual_PrimaryAssetId(A: PrimaryAssetId, B: PrimaryAssetId) -> bool: ...
	"""Returns true if the values are not equal (A != B)"""

	@staticmethod
	def EqualEqual_PrimaryAssetId(A: PrimaryAssetId, B: PrimaryAssetId) -> bool: ...
	"""Returns true if the values are equal (A == B)"""

	@staticmethod
	def Conv_PrimaryAssetIdToString(PrimaryAssetId: PrimaryAssetId) -> str: ...
	"""Converts a Primary Asset Id to a string. The other direction is not provided because it cannot be validated"""

	@staticmethod
	def IsValidPrimaryAssetId(PrimaryAssetId: PrimaryAssetId) -> bool: ...
	"""Returns true if the Primary Asset Id is valid"""

	@staticmethod
	def GetPrimaryAssetIdList(PrimaryAssetType: PrimaryAssetType) -> typing.List[PrimaryAssetId]: ...
	"""Returns list of PrimaryAssetIds for a PrimaryAssetType"""

	@staticmethod
	def GetPrimaryAssetIdFromSoftClassReference(SoftClassReference) -> PrimaryAssetId: ...
	"""Returns the Primary Asset Id for a Soft Class Reference, this can return an invalid one if not registered"""

	@staticmethod
	def GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference) -> PrimaryAssetId: ...
	"""Returns the Primary Asset Id for a Soft Object Reference, this can return an invalid one if not registered"""

	@staticmethod
	def GetPrimaryAssetIdFromClass(Class: Object) -> PrimaryAssetId: ...
	"""Returns the Primary Asset Id for a Class, this can return an invalid one if not registered"""

	@staticmethod
	def GetPrimaryAssetIdFromObject(Object: Object) -> PrimaryAssetId: ...
	"""Returns the Primary Asset Id for an Object, this can return an invalid one if not registered"""

	@staticmethod
	def GetSoftClassReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId) -> typing.Any: ...
	"""Returns the Blueprint Class Id associated with a Primary Asset Id, this works even if the asset is not loaded"""

	@staticmethod
	def GetSoftObjectReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId) -> typing.Any: ...
	"""Returns the Object Id associated with a Primary Asset Id, this works even if the asset is not loaded"""

	@staticmethod
	def GetClassFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId) -> Object: ...
	"""Returns the Blueprint Class associated with a Primary Asset Id, this will only return a valid object if it is in memory, it will not load it"""

	@staticmethod
	def GetObjectFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId) -> Object: ...
	"""Returns the Object associated with a Primary Asset Id, this will only return a valid object if it is in memory, it will not load it"""

	@staticmethod
	def SnapshotObject(Object: Object): ...
	"""Notify the current transaction (if any) that this object is about to be modified and should be snapshot for intermediate update.
@note Internally this calls SnapshotTransactionBuffer on the given object.
@note Only available in the editor.

@param       Object          The object that is about to be modified."""

	@staticmethod
	def TransactObject(Object: Object): ...
	"""Notify the current transaction (if any) that this object is about to be modified and should be placed into the undo buffer.
@note Internally this calls Modify on the given object, so will also mark the owner package dirty.
@note Only available in the editor.

@param       Object          The object that is about to be modified."""

	@staticmethod
	def CancelTransaction(Index: int): ...
	"""Cancel the current transaction, and no longer capture actions to be placed in the undo buffer.
@note Only available in the editor.

@param       Index           The action counter to cancel transactions from (as returned by a call to BeginTransaction)."""

	@staticmethod
	def EndTransaction() -> int: ...
	"""Attempt to end the current undo transaction. Only successful if the transaction's action counter is 1.
@note Only available in the editor.

@return      The number of active actions when EndTransaction was called (a value of 1 indicates that the transaction was successfully closed), or -1 on failure."""

	@staticmethod
	def BeginTransaction(Context: str, Description: str, PrimaryObject: Object) -> int: ...
	"""Begin a new undo transaction. An undo transaction is defined as all actions which take place when the user selects 'undo' a single time.
@note If there is already an active transaction in progress, then this increments that transaction's action counter instead of beginning a new transaction.
@note You must call TransactObject before modifying each object that should be included in this undo transaction.
@note Only available in the editor.

@param       Context                 The context for the undo session. Typically the tool/editor that caused the undo operation.
@param       Description             The description for the undo session. This is the text that will appear in the 'Edit' menu next to the Undo item.
@param       PrimaryObject   The primary object that the undo session operators on (can be null, and mostly is).

@return      The number of active actions when BeginTransaction was called (values greater than 0 indicate that there was already an existing undo transaction in progress), or -1 on failure."""

	@staticmethod
	def IsUnattended() -> bool: ...
	"""Returns true if running unattended (-unattended is on the command line)

@return      Unattended state"""

	@staticmethod
	def ParseParamValue(InString: str, InParam: str) -> typing.Tuple[bool, str]: ...
	"""Returns 'value' if -option=value is in the string"""

	@staticmethod
	def ParseParam(InString: str, InParam: str) -> bool: ...
	"""Returns true if the string has -param in it (do not specify the leading -)"""

	@staticmethod
	def ParseCommandLine(InCmdLine: str) -> typing.Tuple[typing.List[str], typing.List[str], typing.Dict[str, str]]: ...
	"""* Parses the given string into loose tokens, switches (arguments that begin with - or /) and parameters (-mySwitch=myVar)
*
* @param        InCmdLine                       The the string to parse (ie '-foo -bar=/game/baz testtoken' )
* @param        OutTokens[out]          Filled with all loose tokens found in the string (ie: testToken in above example)
* @param        OutSwitches[out]        Filled with all switches found in the string (ie -foo)
* @param        OutParams[out]          Filled with all switches found in the string with the format key = value (ie: -bar, /game/baz)"""

	@staticmethod
	def GetCommandLine() -> str: ...
	"""Returns the command line that the process was launched with."""

	@staticmethod
	def SetUserActivity(UserActivity: UserActivity): ...
	"""Tells the engine what the user is doing for debug, analytics, etc."""

	@staticmethod
	def UnregisterForRemoteNotifications(): ...
	"""Requests Requests unregistering from receiving remote notifications to the user's device.
(Android only)"""

	@staticmethod
	def RegisterForRemoteNotifications(): ...
	"""Requests permission to send remote notifications to the user's device.
(Android and iOS only)"""

	@staticmethod
	def GetLocalCurrencySymbol() -> str: ...
	"""Returns the currency symbol associated with the device's locale
@return the currency symbol associated with the device's locale"""

	@staticmethod
	def GetLocalCurrencyCode() -> str: ...
	"""Returns the currency code associated with the device's locale
@return the currency code associated with the device's locale"""

	@staticmethod
	def GetDefaultLocale() -> str: ...
	"""Get the default locale (for internationalization) used by this platform
@note This should be returned in IETF language tag form:
 - A two-letter ISO 639-1 language code (eg, 'zh')
 - An optional four-letter ISO 15924 script code (eg, 'Hans')
 - An optional two-letter ISO 3166-1 country code (eg, 'CN')
@return The locale as an IETF language tag (eg, 'zh-Hans-CN')"""

	@staticmethod
	def GetDefaultLanguage() -> str: ...
	"""Get the default language (for localization) used by this platform
@note This is typically the same as GetDefaultLocale unless the platform distinguishes between the two
@note This should be returned in IETF language tag form:
 - A two-letter ISO 639-1 language code (eg, 'zh')
 - An optional four-letter ISO 15924 script code (eg, 'Hans')
 - An optional two-letter ISO 3166-1 country code (eg, 'CN')
@return The language as an IETF language tag (eg, 'zh-Hans-CN')"""

	@staticmethod
	def GetPreferredLanguages() -> typing.List[str]: ...
	"""Returns an array of the user's preferred languages in order of preference
@return An array of language IDs ordered from most preferred to least"""

	@staticmethod
	def SetSuppressViewportTransitionMessage(WorldContextObject: Object, bState: bool): ...
	"""Sets the state of the transition message rendered by the viewport. (The blue text displayed when the game is paused and so forth.)

@param WorldContextObject    World context
@param State                                 set true to suppress transition message"""

	@staticmethod
	def GetGamepadButtonGlyph(ButtonKey: str, ControllerIndex: int) -> Texture2D: ...
	"""Returns glyph assigned to a gamepad button (or a null ptr if not assigned) (iOS and tvOS only)"""

	@staticmethod
	def GetGamepadControllerName(ControllerId: int) -> str: ...
	"""Returns name of controller if assigned to a gamepad (or None if not assigned) (Android and iOS only)"""

	@staticmethod
	def IsControllerAssignedToGamepad(ControllerId: int) -> bool: ...
	"""Returns true if controller id assigned to a gamepad (Android and iOS only)"""

	@staticmethod
	def ResetGamepadAssignmentToController(ControllerId: int): ...
	"""* Resets the gamepad assignment to player controller id (Android and iOS only)"""

	@staticmethod
	def ResetGamepadAssignments(): ...
	"""Resets the gamepad to player controller id assignments (Android and iOS only)"""

	@staticmethod
	def SetGamepadsBlockDeviceFeedback(bBlock: bool): ...
	"""Sets whether attached gamepads will block feedback from the device itself (Mobile only)."""

	@staticmethod
	def GetVolumeButtonsHandledBySystem() -> bool: ...
	"""Returns true if system default handling of volume up and volume down buttons enabled (Android only)"""

	@staticmethod
	def SetVolumeButtonsHandledBySystem(bEnabled: bool): ...
	"""Allows or inhibits system default handling of volume up and volume down buttons (Android only)
@param       bEnabled                                If true, allow Android to handle volume up and down events"""

	@staticmethod
	def ControlScreensaver(bAllowScreenSaver: bool): ...
	"""Allows or inhibits screensaver
@param       bAllowScreenSaver               If false, don't allow screensaver if possible, otherwise allow default behavior"""

	@staticmethod
	def IsScreensaverEnabled() -> bool: ...
	"""Returns true if screen saver is enabled."""

	@staticmethod
	def IsLoggedIn(SpecificPlayer: PlayerController) -> bool: ...
	"""Returns whether the player is logged in to the currently active online subsystem.

@param Player Specific player's login status to get. May not be supported on all platforms. If null, defaults to the player with ControllerId 0."""

	@staticmethod
	def ShowPlatformSpecificAchievementsScreen(SpecificPlayer: PlayerController): ...
	"""Displays the built-in achievements GUI (iOS and Android only; this function may be renamed or moved in a future release)

@param SpecificPlayer Specific player's achievements to show. May not be supported on all platforms. If null, defaults to the player with ControllerId 0"""

	@staticmethod
	def ShowPlatformSpecificLeaderboardScreen(CategoryName: str): ...
	"""Displays the built-in leaderboard GUI (iOS and Android only; this function may be renamed or moved in a future release)"""

	@staticmethod
	def ShowInterstitialAd(): ...
	"""Shows the loaded interstitial ad (loaded with LoadInterstitialAd)
(Android only)"""

	@staticmethod
	def IsInterstitialAdRequested() -> bool: ...
	"""Returns true if the requested interstitial ad has been successfully requested (false if load request fails)
(Android only)"""

	@staticmethod
	def IsInterstitialAdAvailable() -> bool: ...
	"""Returns true if the requested interstitial ad is loaded and ready
(Android only)"""

	@staticmethod
	def LoadInterstitialAd(AdIdIndex: int): ...
	"""Will load a fullscreen interstitial AdMob ad. Call this before using ShowInterstitialAd
(Android only)

@param AdIdIndex The index of the ID to select for the ad to show"""

	@staticmethod
	def ForceCloseAdBanner(): ...
	"""Forces closed any displayed ad. Can lead to loss of revenue
(iOS and Android only)"""

	@staticmethod
	def HideAdBanner(): ...
	"""Hides the ad banner (iAd on iOS, or AdMob on Android). Will force close the ad if it's open
(iOS and Android only)"""

	@staticmethod
	def GetAdIDCount() -> int: ...
	"""Retrieves the total number of Ad IDs that can be selected between"""

	@staticmethod
	def ShowAdBanner(AdIdIndex: int, bShowOnBottomOfScreen: bool): ...
	"""Will show an ad banner (iAd on iOS, or AdMob on Android) on the top or bottom of screen, on top of the GL view (doesn't resize the view)
(iOS and Android only)

@param AdIdIndex The index of the ID to select for the ad to show
@param bShowOnBottomOfScreen If true, the iAd will be shown at the bottom of the screen, top otherwise"""

	@staticmethod
	def CollectGarbage(): ...
	"""Deletes all unreferenced objects, keeping only referenced objects (this command will be queued and happen at the end of the frame)
Note: This can be a slow operation, and should only be performed where a hitch would be acceptable"""

	@staticmethod
	def CanLaunchURL(URL: str) -> bool: ...
	"""Can Launch URL"""

	@staticmethod
	def LaunchURL(URL: str): ...
	"""Opens the specified URL in the platform's web browser of choice"""

	@staticmethod
	def GetMinYResolutionFor3DView() -> int: ...
	"""Gets the smallest Y resolution we want to support in the 3D view, clamped within reasons
@return value in pixels"""

	@staticmethod
	def GetMinYResolutionForUI() -> int: ...
	"""Gets the smallest Y resolution we want to support in the UI, clamped within reasons
@return value in pixels"""

	@staticmethod
	def GetConvenientWindowedResolutions() -> typing.Tuple[bool, typing.List[IntPoint]]: ...
	"""Gets the list of windowed resolutions which are convenient for the current primary display size.
@return true if successfully queried the device for available resolutions."""

	@staticmethod
	def GetSupportedFullscreenResolutions() -> typing.Tuple[bool, typing.List[IntPoint]]: ...
	"""Gets the list of support fullscreen resolutions.
@return true if successfully queried the device for available resolutions."""

	@staticmethod
	def GetRenderingMaterialQualityLevel() -> int: ...
	"""Get the clamped state of r.MaterialQualityLevel, see console variable help (allows for scalability, cannot be used in construction scripts)
0: low
1: high
2: medium"""

	@staticmethod
	def GetRenderingDetailMode() -> int: ...
	"""Get the clamped state of r.DetailMode, see console variable help (allows for scalability, cannot be used in construction scripts)
0: low, show only object with DetailMode low or higher
1: medium, show all object with DetailMode medium or higher
2: high, show all objects"""

	@staticmethod
	def GetComponentBounds(Component: SceneComponent) -> typing.Tuple[Vector, Vector, float]: ...
	"""Get bounds"""

	@staticmethod
	def CreateCopyForUndoBuffer(ObjectToModify: Object): ...
	"""Mark as modified."""

	@staticmethod
	def AddFloatHistorySample(Value: float, FloatHistory: DebugFloatHistory) -> DebugFloatHistory: ...
	"""Add Float History Sample"""

	@staticmethod
	def DrawDebugFloatHistoryLocation(WorldContextObject: Object, FloatHistory: DebugFloatHistory, DrawLocation: Vector, DrawSize: Vector2D, DrawColor: LinearColor = ..., Duration: float = ...): ...
	"""Draws a 2D Histogram of size 'DrawSize' based FDebugFloatHistory struct, using DrawLocation for the location in the world, rotation will face camera of first player."""

	@staticmethod
	def DrawDebugFloatHistoryTransform(WorldContextObject: Object, FloatHistory: DebugFloatHistory, DrawTransform: Transform, DrawSize: Vector2D, DrawColor: LinearColor = ..., Duration: float = ...): ...
	"""Draws a 2D Histogram of size 'DrawSize' based FDebugFloatHistory struct, using DrawTransform for the position in the world."""

	@staticmethod
	def DrawDebugCamera(CameraActor: CameraActor, CameraColor: LinearColor = ..., Duration: float = ...): ...
	"""Draw a debug camera shape."""

	@staticmethod
	def DrawDebugFrustum(WorldContextObject: Object, FrustumTransform: Transform, FrustumColor: LinearColor = ..., Duration: float = ..., Thickness: float = ...): ...
	"""Draws a debug frustum."""

	@staticmethod
	def FlushPersistentDebugLines(WorldContextObject: Object): ...
	"""Flush all persistent debug lines and shapes.

@param WorldContext  World context"""

	@staticmethod
	def DrawDebugPlane(WorldContextObject: Object, PlaneCoordinates: Plane, Location: Vector, Size: float, PlaneColor: LinearColor = ..., Duration: float = ...): ...
	"""Draws a debug plane."""

	@staticmethod
	def FlushDebugStrings(WorldContextObject: Object): ...
	"""Removes all debug strings.

@param WorldContext  World context"""

	@staticmethod
	def DrawDebugString(WorldContextObject: Object, TextLocation: Vector, Text: str, TestBaseActor: Actor = ..., TextColor: LinearColor = ..., Duration: float = ...): ...
	"""Draw a debug string at a 3d world location."""

	@staticmethod
	def DrawDebugCapsule(WorldContextObject: Object, Center: Vector, HalfHeight: float, Radius: float, Rotation: Rotator, LineColor: LinearColor = ..., Duration: float = ..., Thickness: float = ...): ...
	"""Draw a debug capsule"""

	@staticmethod
	def DrawDebugConeInDegrees(WorldContextObject: Object, Origin: Vector, Direction: Vector, Length: float = ..., AngleWidth: float = ..., AngleHeight: float = ..., NumSides: int = ..., LineColor: LinearColor = ..., Duration: float = ..., Thickness: float = ...): ...
	"""Draw a debug cone
Angles are specified in degrees"""

	@staticmethod
	def DrawDebugCylinder(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float = ..., Segments: int = ..., LineColor: LinearColor = ..., Duration: float = ..., Thickness: float = ...): ...
	"""Draw a debug cylinder"""

	@staticmethod
	def DrawDebugSphere(WorldContextObject: Object, Center: Vector, Radius: float = ..., Segments: int = ..., LineColor: LinearColor = ..., Duration: float = ..., Thickness: float = ...): ...
	"""Draw a debug sphere"""

	@staticmethod
	def DrawDebugCoordinateSystem(WorldContextObject: Object, AxisLoc: Vector, AxisRot: Rotator, Scale: float = ..., Duration: float = ..., Thickness: float = ...): ...
	"""Draw a debug coordinate system."""

	@staticmethod
	def DrawDebugBox(WorldContextObject: Object, Center: Vector, Extent: Vector, LineColor: LinearColor, Rotation: Rotator = ..., Duration: float = ..., Thickness: float = ...): ...
	"""Draw a debug box"""

	@staticmethod
	def DrawDebugArrow(WorldContextObject: Object, LineStart: Vector, LineEnd: Vector, ArrowSize: float, LineColor: LinearColor, Duration: float = ..., Thickness: float = ...): ...
	"""Draw directional arrow, pointing from LineStart to LineEnd."""

	@staticmethod
	def DrawDebugPoint(WorldContextObject: Object, Position: Vector, Size: float, PointColor: LinearColor, Duration: float = ...): ...
	"""Draw a debug point"""

	@staticmethod
	def DrawDebugCircle(WorldContextObject: Object, Center: Vector, Radius: float, NumSegments: int = ..., LineColor: LinearColor = ..., Duration: float = ..., Thickness: float = ..., YAxis: Vector = ..., ZAxis: Vector = ..., bDrawAxis: bool = ...): ...
	"""Draw a debug circle!"""

	@staticmethod
	def DrawDebugLine(WorldContextObject: Object, LineStart: Vector, LineEnd: Vector, LineColor: LinearColor, Duration: float = ..., Thickness: float = ...): ...
	"""Draw a debug line"""

	@staticmethod
	def GetActorListFromComponentList(ComponentList: typing.List[PrimitiveComponent], ActorClassFilter: Object) -> typing.List[Actor]: ...
	"""Returns an array of unique actors represented by the given list of components.
@param ComponentList         List of components.
@param ClassFilter           If set, will only return results of this class or subclasses of it.
@param OutActorList          Start of line segment."""

	@staticmethod
	def CapsuleTraceMultiByProfile(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, HalfHeight: float, ProfileName: str, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Sweep a capsule against the world and return all initial overlaps using a specific profile, then overlapping hits and then first blocking hit
Results are sorted, so a blocking hit (if found) will be the last element of the array
Only the single closest blocking result will be generated, no tests will be done after that

@param WorldContext   World context
@param Start                  Start of line segment.
@param End                    End of line segment.
@param Radius                 Radius of the capsule to sweep
@param HalfHeight             Distance from center of capsule to tip of hemisphere endcap.
@param ProfileName    The 'profile' used to determine which components to hit
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
@return                               True if there was a blocking hit, false otherwise."""

	@staticmethod
	def CapsuleTraceSingleByProfile(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, HalfHeight: float, ProfileName: str, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Sweep a capsule against the world and return the first blocking hit using a specific profile

@param WorldContext   World context
@param Start                  Start of line segment.
@param End                    End of line segment.
@param Radius                 Radius of the capsule to sweep
@param HalfHeight             Distance from center of capsule to tip of hemisphere endcap.
@param ProfileName    The 'profile' used to determine which components to hit
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHit                 Properties of the trace hit.
@return                               True if there was a hit, false otherwise."""

	@staticmethod
	def BoxTraceMultiByProfile(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ProfileName: str, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Sweep a box against the world and return all initial overlaps using a specific profile, then overlapping hits and then first blocking hit
Results are sorted, so a blocking hit (if found) will be the last element of the array
Only the single closest blocking result will be generated, no tests will be done after that

@param Start                  Start of line segment.
@param End                    End of line segment.
@param HalfSize           Distance from the center of box along each axis
@param Orientation    Orientation of the box
@param ProfileName    The 'profile' used to determine which components to hit
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHits                A list of hits, sorted along the trace from start to finish. The blocking hit will be the last hit, if there was one.
@return                               True if there was a blocking hit, false otherwise."""

	@staticmethod
	def BoxTraceSingleByProfile(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ProfileName: str, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Sweep a box against the world and return the first blocking hit using a specific profile

@param Start                  Start of line segment.
@param End                    End of line segment.
@param HalfSize           Distance from the center of box along each axis
@param Orientation    Orientation of the box
@param ProfileName    The 'profile' used to determine which components to hit
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHit                 Properties of the trace hit.
@return                               True if there was a hit, false otherwise."""

	@staticmethod
	def SphereTraceMultiByProfile(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, ProfileName: str, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Sweep a sphere against the world and return all initial overlaps using a specific profile, then overlapping hits and then first blocking hit
Results are sorted, so a blocking hit (if found) will be the last element of the array
Only the single closest blocking result will be generated, no tests will be done after that

@param WorldContext   World context
@param Start                  Start of line segment.
@param End                    End of line segment.
@param Radius         Radius of the sphere to sweep
@param ProfileName    The 'profile' used to determine which components to hit
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
@return                               True if there was a blocking hit, false otherwise."""

	@staticmethod
	def SphereTraceSingleByProfile(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, ProfileName: str, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Sweep a sphere against the world and return the first blocking hit using a specific profile

@param Start                  Start of line segment.
@param End                    End of line segment.
@param Radius                 Radius of the sphere to sweep
@param ProfileName    The 'profile' used to determine which components to hit
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHit                 Properties of the trace hit.
@return                               True if there was a hit, false otherwise."""

	@staticmethod
	def LineTraceMultiByProfile(WorldContextObject: Object, Start: Vector, End: Vector, ProfileName: str, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Trace a ray against the world using a specific profile and return overlapping hits and then first blocking hit
Results are sorted, so a blocking hit (if found) will be the last element of the array
Only the single closest blocking result will be generated, no tests will be done after that

@param WorldContext   World context
@param Start                  Start of line segment.
@param End                    End of line segment.
@param ProfileName    The 'profile' used to determine which components to hit
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHit         Properties of the trace hit.
@return                               True if there was a blocking hit, false otherwise."""

	@staticmethod
	def LineTraceSingleByProfile(WorldContextObject: Object, Start: Vector, End: Vector, ProfileName: str, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Trace a ray against the world using a specific profile and return the first blocking hit

@param WorldContext   World context
@param Start                  Start of line segment.
@param End                    End of line segment.
@param ProfileName    The 'profile' used to determine which components to hit
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHit                 Properties of the trace hit.
@return                               True if there was a hit, false otherwise."""

	@staticmethod
	def CapsuleTraceMultiForObjects(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, HalfHeight: float, ObjectTypes: typing.List[int], bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Sweeps a capsule along the given line and returns all hits encountered.
This only finds objects that are of a type specified by ObjectTypes.

@param WorldContext  World context
@param Start                 Start of line segment.
@param End                   End of line segment.
@param Radius                Radius of the capsule to sweep
@param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.
@param ObjectTypes   Array of Object Types to trace
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
@return                              True if there was a hit, false otherwise."""

	@staticmethod
	def CapsuleTraceSingleForObjects(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, HalfHeight: float, ObjectTypes: typing.List[int], bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Sweeps a capsule along the given line and returns the first hit encountered.
This only finds objects that are of a type specified by ObjectTypes.

@param WorldContext  World context
@param Start                 Start of line segment.
@param End                   End of line segment.
@param Radius                Radius of the capsule to sweep
@param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.
@param ObjectTypes   Array of Object Types to trace
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHit                Properties of the trace hit.
@return                              True if there was a hit, false otherwise."""

	@staticmethod
	def BoxTraceMultiForObjects(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ObjectTypes: typing.List[int], bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Sweeps a box along the given line and returns all hits encountered.
This only finds objects that are of a type specified by ObjectTypes.

@param Start                  Start of line segment.
@param End                    End of line segment.
@param Orientation
@param HalfSize               Radius of the sphere to sweep
@param ObjectTypes    Array of Object Types to trace
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
@return                               True if there was a hit, false otherwise."""

	@staticmethod
	def BoxTraceSingleForObjects(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ObjectTypes: typing.List[int], bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Sweeps a box along the given line and returns the first hit encountered.
This only finds objects that are of a type specified by ObjectTypes.

@param Start                  Start of line segment.
@param End                    End of line segment.
@param Orientation
@param HalfSize               Radius of the sphere to sweep
@param ObjectTypes    Array of Object Types to trace
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHit                 Properties of the trace hit.
@return                               True if there was a hit, false otherwise."""

	@staticmethod
	def SphereTraceMultiForObjects(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, ObjectTypes: typing.List[int], bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Sweeps a sphere along the given line and returns all hits encountered.
This only finds objects that are of a type specified by ObjectTypes.

@param WorldContext  World context
@param Start                 Start of line segment.
@param End                   End of line segment.
@param Radius                Radius of the sphere to sweep
@param ObjectTypes   Array of Object Types to trace
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
@return                              True if there was a hit, false otherwise."""

	@staticmethod
	def SphereTraceSingleForObjects(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, ObjectTypes: typing.List[int], bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Sweeps a sphere along the given line and returns the first hit encountered.
This only finds objects that are of a type specified by ObjectTypes.

@param Start                 Start of line segment.
@param End                   End of line segment.
@param Radius                Radius of the sphere to sweep
@param ObjectTypes   Array of Object Types to trace
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHit                Properties of the trace hit.
@return                              True if there was a hit, false otherwise."""

	@staticmethod
	def LineTraceMultiForObjects(WorldContextObject: Object, Start: Vector, End: Vector, ObjectTypes: typing.List[int], bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Does a collision trace along the given line and returns all hits encountered.
This only finds objects that are of a type specified by ObjectTypes.

@param WorldContext  World context
@param Start                 Start of line segment.
@param End                   End of line segment.
@param ObjectTypes   Array of Object Types to trace
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHit                Properties of the trace hit.
@return                              True if there was a hit, false otherwise."""

	@staticmethod
	def LineTraceSingleForObjects(WorldContextObject: Object, Start: Vector, End: Vector, ObjectTypes: typing.List[int], bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Does a collision trace along the given line and returns the first hit encountered.
This only finds objects that are of a type specified by ObjectTypes.

@param WorldContext  World context
@param Start                 Start of line segment.
@param End                   End of line segment.
@param ObjectTypes   Array of Object Types to trace
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHit                Properties of the trace hit.
@return                              True if there was a hit, false otherwise."""

	@staticmethod
	def CapsuleTraceMulti(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, HalfHeight: float, TraceChannel: int, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Sweeps a capsule along the given line and returns all hits encountered up to and including the first blocking hit.
This trace finds the objects that RESPOND to the given TraceChannel

@param WorldContext  World context
@param Start                 Start of line segment.
@param End                   End of line segment.
@param Radius                Radius of the capsule to sweep
@param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.
@param TraceChannel
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
@return                              True if there was a blocking hit, false otherwise."""

	@staticmethod
	def CapsuleTraceSingle(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, HalfHeight: float, TraceChannel: int, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Sweeps a capsule along the given line and returns the first blocking hit encountered.
This trace finds the objects that RESPOND to the given TraceChannel

@param WorldContext  World context
@param Start                 Start of line segment.
@param End                   End of line segment.
@param Radius                Radius of the capsule to sweep
@param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.
@param TraceChannel
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHit                Properties of the trace hit.
@return                              True if there was a hit, false otherwise."""

	@staticmethod
	def BoxTraceMulti(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, TraceChannel: int, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Sweeps a box along the given line and returns all hits encountered.
This trace finds the objects that RESPONDS to the given TraceChannel

@param Start                  Start of line segment.
@param End                    End of line segment.
@param HalfSize           Distance from the center of box along each axis
@param Orientation    Orientation of the box
@param TraceChannel
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHits                A list of hits, sorted along the trace from start to finish. The blocking hit will be the last hit, if there was one.
@return                               True if there was a blocking hit, false otherwise."""

	@staticmethod
	def BoxTraceSingle(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, TraceChannel: int, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Sweeps a box along the given line and returns the first blocking hit encountered.
This trace finds the objects that RESPONDS to the given TraceChannel

@param Start                  Start of line segment.
@param End                    End of line segment.
@param HalfSize           Distance from the center of box along each axis
@param Orientation    Orientation of the box
@param TraceChannel
@param bTraceComplex  True to test against complex collision, false to test against simplified collision.
@param OutHit                 Properties of the trace hit.
@return                               True if there was a hit, false otherwise."""

	@staticmethod
	def SphereTraceMulti(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, TraceChannel: int, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Sweeps a sphere along the given line and returns all hits encountered up to and including the first blocking hit.
This trace finds the objects that RESPOND to the given TraceChannel

@param WorldContext  World context
@param Start                 Start of line segment.
@param End                   End of line segment.
@param Radius                Radius of the sphere to sweep
@param TraceChannel
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.
@return                              True if there was a blocking hit, false otherwise."""

	@staticmethod
	def SphereTraceSingle(WorldContextObject: Object, Start: Vector, End: Vector, Radius: float, TraceChannel: int, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Sweeps a sphere along the given line and returns the first blocking hit encountered.
This trace finds the objects that RESPONDS to the given TraceChannel

@param Start                 Start of line segment.
@param End                   End of line segment.
@param Radius                Radius of the sphere to sweep
@param TraceChannel
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHit                Properties of the trace hit.
@return                              True if there was a hit, false otherwise."""

	@staticmethod
	def LineTraceMulti(WorldContextObject: Object, Start: Vector, End: Vector, TraceChannel: int, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, typing.List[HitResult]]: ...
	"""Does a collision trace along the given line and returns all hits encountered up to and including the first blocking hit.
This trace finds the objects that RESPOND to the given TraceChannel

@param WorldContext  World context
@param Start                 Start of line segment.
@param End                   End of line segment.
@param TraceChannel  The channel to trace
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHit                Properties of the trace hit.
@return                              True if there was a blocking hit, false otherwise."""

	@staticmethod
	def LineTraceSingle(WorldContextObject: Object, Start: Vector, End: Vector, TraceChannel: int, bTraceComplex: bool, ActorsToIgnore: typing.List[Actor], DrawDebugType: int, bIgnoreSelf: bool, TraceColor: LinearColor = ..., TraceHitColor: LinearColor = ..., DrawTime: float = ...) -> typing.Tuple[bool, HitResult]: ...
	"""Does a collision trace along the given line and returns the first blocking hit encountered.
This trace finds the objects that RESPONDS to the given TraceChannel

@param WorldContext  World context
@param Start                 Start of line segment.
@param End                   End of line segment.
@param TraceChannel
@param bTraceComplex True to test against complex collision, false to test against simplified collision.
@param OutHit                Properties of the trace hit.
@return                              True if there was a hit, false otherwise."""

	@staticmethod
	def ComponentOverlapComponents(Component: PrimitiveComponent, ComponentTransform: Transform, ObjectTypes: typing.List[int], ComponentClassFilter: Object, ActorsToIgnore: typing.List[Actor]) -> typing.Tuple[bool, typing.List[PrimitiveComponent]]: ...
	"""Returns an array of components that overlap the given component.
@param Component                             Component to test with.
@param ComponentTransform    Defines where to place the component for overlap testing.
@param Filter                                Option to restrict results to only static or only dynamic.  For efficiency.
@param ClassFilter                   If set, will only return results of this class or subclasses of it.
@param ActorsToIgnore                Ignore these actors in the list
@param OutActors                             Returned array of actors. Unsorted.
@return                                              true if there was an overlap that passed the filters, false otherwise."""

	@staticmethod
	def ComponentOverlapActors(Component: PrimitiveComponent, ComponentTransform: Transform, ObjectTypes: typing.List[int], ActorClassFilter: Object, ActorsToIgnore: typing.List[Actor]) -> typing.Tuple[bool, typing.List[Actor]]: ...
	"""Returns an array of actors that overlap the given component.
@param Component                             Component to test with.
@param ComponentTransform    Defines where to place the component for overlap testing.
@param Filter                                Option to restrict results to only static or only dynamic.  For efficiency.
@param ClassFilter                   If set, will only return results of this class or subclasses of it.
@param ActorsToIgnore                Ignore these actors in the list
@param OutActors                             Returned array of actors. Unsorted.
@return                                              true if there was an overlap that passed the filters, false otherwise."""

	@staticmethod
	def CapsuleOverlapComponents(WorldContextObject: Object, CapsulePos: Vector, Radius: float, HalfHeight: float, ObjectTypes: typing.List[int], ComponentClassFilter: Object, ActorsToIgnore: typing.List[Actor]) -> typing.Tuple[bool, typing.List[PrimitiveComponent]]: ...
	"""Returns an array of components that overlap the given capsule.
@param WorldContext  World context
@param CapsulePos    Center of the capsule.
@param Radius                Radius of capsule hemispheres and radius of center cylinder portion.
@param HalfHeight    Half-height of the capsule (from center of capsule to tip of hemisphere.
@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.
@param ClassFilter   If set, will only return results of this class or subclasses of it.
@param ActorsToIgnore                Ignore these actors in the list
@param OutActors             Returned array of actors. Unsorted.
@return                              true if there was an overlap that passed the filters, false otherwise."""

	@staticmethod
	def CapsuleOverlapActors(WorldContextObject: Object, CapsulePos: Vector, Radius: float, HalfHeight: float, ObjectTypes: typing.List[int], ActorClassFilter: Object, ActorsToIgnore: typing.List[Actor]) -> typing.Tuple[bool, typing.List[Actor]]: ...
	"""Returns an array of actors that overlap the given capsule.
@param WorldContext  World context
@param CapsulePos    Center of the capsule.
@param Radius                Radius of capsule hemispheres and radius of center cylinder portion.
@param HalfHeight    Half-height of the capsule (from center of capsule to tip of hemisphere.
@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.
@param ClassFilter   If set, will only return results of this class or subclasses of it.
@param ActorsToIgnore                Ignore these actors in the list
@param OutActors             Returned array of actors. Unsorted.
@return                              true if there was an overlap that passed the filters, false otherwise."""

	@staticmethod
	def BoxOverlapComponents(WorldContextObject: Object, BoxPos: Vector, Extent: Vector, ObjectTypes: typing.List[int], ComponentClassFilter: Object, ActorsToIgnore: typing.List[Actor]) -> typing.Tuple[bool, typing.List[PrimitiveComponent]]: ...
	"""Returns an array of components that overlap the given axis-aligned box.
@param WorldContext  World context
@param BoxPos                Center of box.
@param BoxExtent             Extents of box.
@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.
@param ClassFilter   If set, will only return results of this class or subclasses of it.
@param ActorsToIgnore                Ignore these actors in the list
@param OutActors             Returned array of actors. Unsorted.
@return                              true if there was an overlap that passed the filters, false otherwise."""

	@staticmethod
	def BoxOverlapActors(WorldContextObject: Object, BoxPos: Vector, BoxExtent: Vector, ObjectTypes: typing.List[int], ActorClassFilter: Object, ActorsToIgnore: typing.List[Actor]) -> typing.Tuple[bool, typing.List[Actor]]: ...
	"""Returns an array of actors that overlap the given axis-aligned box.
@param WorldContext  World context
@param BoxPos                Center of box.
@param BoxExtent             Extents of box.
@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.
@param ClassFilter   If set, will only return results of this class or subclasses of it.
@param ActorsToIgnore                Ignore these actors in the list
@param OutActors             Returned array of actors. Unsorted.
@return                              true if there was an overlap that passed the filters, false otherwise."""

	@staticmethod
	def SphereOverlapComponents(WorldContextObject: Object, SpherePos: Vector, SphereRadius: float, ObjectTypes: typing.List[int], ComponentClassFilter: Object, ActorsToIgnore: typing.List[Actor]) -> typing.Tuple[bool, typing.List[PrimitiveComponent]]: ...
	"""Returns an array of components that overlap the given sphere.
@param WorldContext  World context
@param SpherePos             Center of sphere.
@param SphereRadius  Size of sphere.
@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.
@param ClassFilter   If set, will only return results of this class or subclasses of it.
@param ActorsToIgnore                Ignore these actors in the list
@param OutActors             Returned array of actors. Unsorted.
@return                              true if there was an overlap that passed the filters, false otherwise."""

	@staticmethod
	def SphereOverlapActors(WorldContextObject: Object, SpherePos: Vector, SphereRadius: float, ObjectTypes: typing.List[int], ActorClassFilter: Object, ActorsToIgnore: typing.List[Actor]) -> typing.Tuple[bool, typing.List[Actor]]: ...
	"""Returns an array of actors that overlap the given sphere.
@param WorldContext  World context
@param SpherePos             Center of sphere.
@param SphereRadius  Size of sphere.
@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.
@param ClassFilter   If set, will only return results of this class or subclasses of it.
@param ActorsToIgnore                Ignore these actors in the list
@param OutActors             Returned array of actors. Unsorted.
@return                              true if there was an overlap that passed the filters, false otherwise."""

	@staticmethod
	def SetStructurePropertyByName(Object: Object, PropertyName: str, Value: GenericStruct): ...
	"""Set a custom structure property by name"""

	@staticmethod
	def SetFieldPathPropertyByName(Object: Object, PropertyName: str, Value): ...
	"""Set a SOFTOBJECT property by name"""

	@staticmethod
	def SetCollisionProfileNameProperty(Object: Object, PropertyName: str, Value: CollisionProfileName): ...
	"""Set a CollisionProfileName property by name"""

	@staticmethod
	def SetTransformPropertyByName(Object: Object, PropertyName: str, Value: Transform): ...
	"""Set a TRANSFORM property by name"""

	@staticmethod
	def SetColorPropertyByName(Object: Object, PropertyName: str, Value: Color): ...
	"""Set a COLOR property by name"""

	@staticmethod
	def SetLinearColorPropertyByName(Object: Object, PropertyName: str, Value: LinearColor): ...
	"""Set a LINEAR COLOR property by name"""

	@staticmethod
	def SetRotatorPropertyByName(Object: Object, PropertyName: str, Value: Rotator): ...
	"""Set a ROTATOR property by name"""

	@staticmethod
	def SetVectorPropertyByName(Object: Object, PropertyName: str, Value: Vector): ...
	"""Set a VECTOR property by name"""

	@staticmethod
	def SetTextPropertyByName(Object: Object, PropertyName: str, Value: str): ...
	"""Set a TEXT property by name"""

	@staticmethod
	def SetStringPropertyByName(Object: Object, PropertyName: str, Value: str): ...
	"""Set a STRING property by name"""

	@staticmethod
	def SetSoftClassPropertyByName(Object: Object, PropertyName: str, Value): ...
	"""Set a SOFTCLASS property by name"""

	@staticmethod
	def SetSoftObjectPropertyByName(Object: Object, PropertyName: str, Value): ...
	"""Set a SOFTOBJECT property by name"""

	@staticmethod
	def SetNamePropertyByName(Object: Object, PropertyName: str, Value: str): ...
	"""Set a NAME property by name"""

	@staticmethod
	def SetInterfacePropertyByName(Object: Object, PropertyName: str, Value): ...
	"""Set an INTERFACE property by name"""

	@staticmethod
	def SetClassPropertyByName(Object: Object, PropertyName: str, Value: Object): ...
	"""Set a CLASS property by name"""

	@staticmethod
	def SetObjectPropertyByName(Object: Object, PropertyName: str, Value: Object): ...
	"""Set an OBJECT property by name"""

	@staticmethod
	def SetBoolPropertyByName(Object: Object, PropertyName: str, Value: bool): ...
	"""Set a bool property by name"""

	@staticmethod
	def SetFloatPropertyByName(Object: Object, PropertyName: str, Value: float): ...
	"""Set a float property by name"""

	@staticmethod
	def SetBytePropertyByName(Object: Object, PropertyName: str, Value: int): ...
	"""Set an uint8 or enum property by name"""

	@staticmethod
	def SetInt64PropertyByName(Object: Object, PropertyName: str, Value: long): ...
	"""Set an int64 property by name"""

	@staticmethod
	def SetIntPropertyByName(Object: Object, PropertyName: str, Value: int): ...
	"""Set an int32 property by name"""

	@staticmethod
	def GetTimerRemainingTime(Object: Object, FunctionName: str) -> float: ...
	"""Returns time until the timer will next execute its delegate.
@param Object                Object that implements the delegate function. Defaults to self (this blueprint)
@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.
@return                              How long is remaining in the current iteration of the timer."""

	@staticmethod
	def GetTimerElapsedTime(Object: Object, FunctionName: str) -> float: ...
	"""Returns elapsed time for the given delegate (time since current countdown iteration began).
@param Object                Object that implements the delegate function. Defaults to self (this blueprint)
@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.
@return                              How long has elapsed since the current iteration of the timer began."""

	@staticmethod
	def TimerExists(Object: Object, FunctionName: str) -> bool: ...
	"""Returns true is a timer for the given delegate exists, false otherwise.
@param Object         Object that implements the delegate function. Defaults to self (this blueprint)
@param FunctionName   Delegate function name. Can be a K2 function or a Custom Event.
@return                               True if the timer exists."""

	@staticmethod
	def IsTimerPaused(Object: Object, FunctionName: str) -> bool: ...
	"""Returns true if a timer exists and is paused for the given delegate, false otherwise.
@param Object         Object that implements the delegate function. Defaults to self (this blueprint)
@param FunctionName   Delegate function name. Can be a K2 function or a Custom Event.
@return                               True if the timer exists and is paused."""

	@staticmethod
	def IsTimerActive(Object: Object, FunctionName: str) -> bool: ...
	"""Returns true if a timer exists and is active for the given delegate, false otherwise.
@param Object                Object that implements the delegate function. Defaults to self (this blueprint)
@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.
@return                              True if the timer exists and is active."""

	@staticmethod
	def UnPauseTimer(Object: Object, FunctionName: str): ...
	"""Resumes a paused timer from its current elapsed time.
@param Object                Object that implements the delegate function. Defaults to self (this blueprint)
@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event."""

	@staticmethod
	def PauseTimer(Object: Object, FunctionName: str): ...
	"""Pauses a set timer at its current elapsed time.
@param Object                Object that implements the delegate function. Defaults to self (this blueprint)
@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event."""

	@staticmethod
	def ClearTimer(Object: Object, FunctionName: str): ...
	"""Clears a set timer.
@param Object                Object that implements the delegate function. Defaults to self (this blueprint)
@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event."""

	@staticmethod
	def SetTimer(Object: Object, FunctionName: str, Time: float, bLooping: bool, InitialStartDelay: float = ..., InitialStartDelayVariance: float = ...) -> typing.Any: ...
	"""Set a timer to execute delegate. Setting an existing timer will reset that timer with updated parameters.
@param Object                                        Object that implements the delegate function. Defaults to self (this blueprint)
@param FunctionName                          Delegate function name. Can be a K2 function or a Custom Event.
@param Time                                          How long to wait before executing the delegate, in seconds. Setting a timer to <= 0 seconds will clear it if it is set.
@param bLooping                                      true to keep executing the delegate every Time seconds, false to execute delegate only once.
@param InitialStartDelay                     Initial delay passed to the timer manager to allow some variance in when the timer starts, in seconds.
@param InitialStartDelayVariance     Use this to add some variance to when the timer starts in lieu of doing a random range on the InitialStartDelay input, in seconds.
@return                                                      The timer handle to pass to other timer functions to manipulate this timer."""

	@staticmethod
	def GetTimerRemainingTimeHandle(WorldContextObject: Object, Handle) -> float: ...
	"""Returns time until the timer will next execute its handle.
@param Handle                The handle of the timer to time remaining of.
@return                              How long is remaining in the current iteration of the timer."""

	@staticmethod
	def GetTimerElapsedTimeHandle(WorldContextObject: Object, Handle) -> float: ...
	"""Returns elapsed time for the given handle (time since current countdown iteration began).
@param Handle                The handle of the timer to get the elapsed time of.
@return                              How long has elapsed since the current iteration of the timer began."""

	@staticmethod
	def TimerExistsHandle(WorldContextObject: Object, Handle) -> bool: ...
	"""Returns true is a timer for the given handle exists, false otherwise.
@param Handle                The handle to check whether it exists.
@return                              True if the timer exists."""

	@staticmethod
	def IsTimerPausedHandle(WorldContextObject: Object, Handle) -> bool: ...
	"""Returns true if a timer exists and is paused for the given handle, false otherwise.
@param Handle                The handle of the timer to check whether it is paused.
@return                              True if the timer exists and is paused."""

	@staticmethod
	def IsTimerActiveHandle(WorldContextObject: Object, Handle) -> bool: ...
	"""Returns true if a timer exists and is active for the given handle, false otherwise.
@param Handle                The handle of the timer to check whether it is active.
@return                              True if the timer exists and is active."""

	@staticmethod
	def UnPauseTimerHandle(WorldContextObject: Object, Handle): ...
	"""Resumes a paused timer from its current elapsed time.
@param Handle                The handle of the timer to unpause."""

	@staticmethod
	def PauseTimerHandle(WorldContextObject: Object, Handle): ...
	"""Pauses a set timer at its current elapsed time.
@param Handle                The handle of the timer to pause."""

	@staticmethod
	def ClearAndInvalidateTimerHandle(WorldContextObject: Object, Handle): ...
	"""Clears a set timer.
@param Handle                The handle of the timer to clear."""

	@staticmethod
	def InvalidateTimerHandle(Handle) -> typing.Any: ...
	"""Invalidate the supplied TimerHandle and return it.
@param Handle                The handle of the timer to invalidate.
@return                              Return the invalidated timer handle for convenience."""

	@staticmethod
	def IsValidTimerHandle(Handle) -> bool: ...
	"""Returns whether the timer handle is valid. This does not indicate that there is an active timer that this handle references, but rather that it once referenced a valid timer.
@param Handle                The handle of the timer to check validity of.
@return                              Whether the timer handle is valid."""

	@staticmethod
	def SetTimerDelegate(Delegate, Time: float, bLooping: bool, InitialStartDelay: float = ..., InitialStartDelayVariance: float = ...) -> typing.Any: ...
	"""Set a timer to execute delegate. Setting an existing timer will reset that timer with updated parameters.
@param Event                                         Event. Can be a K2 function or a Custom Event.
@param Time                                          How long to wait before executing the delegate, in seconds. Setting a timer to <= 0 seconds will clear it if it is set.
@param bLooping                                      True to keep executing the delegate every Time seconds, false to execute delegate only once.
@param InitialStartDelay                     Initial delay passed to the timer manager, in seconds.
@param InitialStartDelayVariance     Use this to add some variance to when the timer starts in lieu of doing a random range on the InitialStartDelay input, in seconds.
@return                                                      The timer handle to pass to other timer functions to manipulate this timer."""

	@staticmethod
	def MoveComponentTo(Component: SceneComponent, TargetRelativeLocation: Vector, TargetRelativeRotation: Rotator, bEaseOut: bool, bEaseIn: bool, OverTime: float, bForceShortestRotationPath: bool, MoveAction: int, LatentInfo: LatentActionInfo): ...
	"""* Interpolate a component to the specified relative location and rotation over the course of OverTime seconds.
* @param Component                                             Component to interpolate
* @param TargetRelativeLocation                Relative target location
* @param TargetRelativeRotation                Relative target rotation
* @param bEaseOut                                              if true we will ease out (ie end slowly) during interpolation
* @param bEaseIn                                               if true we will ease in (ie start slowly) during interpolation
* @param OverTime                                              duration of interpolation
* @param bForceShortestRotationPath    if true we will always use the shortest path for rotation
* @param MoveAction                                    required movement behavior @see EMoveComponentAction
* @param LatentInfo                                    The latent action"""

	@staticmethod
	def RetriggerableDelay(WorldContextObject: Object, Duration: float, LatentInfo: LatentActionInfo): ...
	"""Perform a latent action with a retriggerable delay (specified in seconds).  Calling again while it is counting down will reset the countdown to Duration.

@param WorldContext  World context.
@param Duration              length of delay (in seconds).
@param LatentInfo    The latent action."""

	@staticmethod
	def Delay(WorldContextObject: Object, Duration: float, LatentInfo: LatentActionInfo): ...
	"""Perform a latent action with a delay (specified in seconds).  Calling again while it is counting down will be ignored.

@param WorldContext  World context.
@param Duration              length of delay (in seconds).
@param LatentInfo    The latent action."""

	@staticmethod
	def QuitGame(WorldContextObject: Object, SpecificPlayer: PlayerController, QuitPreference: int, bIgnorePlatformRestrictions: bool): ...
	"""Exit the current game
@param       SpecificPlayer  The specific player to quit the game. If not specified, player 0 will quit.
@param       QuitPreference  Form of quitting.
@param       bIgnorePlatformRestrictions     Ignores and best-practices based on platform (e.g PS4 games should never quit). Non-shipping only"""

	@staticmethod
	def GetConsoleVariableBoolValue(VariableName: str) -> bool: ...
	"""Evaluates, if it exists, whether the specified integer console variable has a non-zero value (true) or not (false).

@param       VariableName    Name of the console variable to find.
@return      True if found and has a non-zero value, false otherwise."""

	@staticmethod
	def GetConsoleVariableIntValue(VariableName: str) -> int: ...
	"""Attempts to retrieve the value of the specified integer console variable, if it exists.

@param       VariableName    Name of the console variable to find.
@return      The value if found, 0 otherwise."""

	@staticmethod
	def GetConsoleVariableFloatValue(VariableName: str) -> float: ...
	"""Attempts to retrieve the value of the specified float console variable, if it exists.

@param       VariableName    Name of the console variable to find.
@return      The value if found, 0 otherwise."""

	@staticmethod
	def ExecuteConsoleCommand(WorldContextObject: Object, Command: str, SpecificPlayer: PlayerController = ...): ...
	"""Executes a console command, optionally on a specific controller

@param       Command                 Command to send to the console
@param       SpecificPlayer  If specified, the console command will be routed through the specified player"""

	@staticmethod
	def SetWindowTitle(Title: str): ...
	"""Sets the game window title"""

	@staticmethod
	def PrintWarning(InString: str): ...
	"""Prints a warning string to the log and the screen. Meant to be used as a way to inform the user that they misused the node.

WARNING!! Don't change the signature of this function without fixing up all nodes using it in the compiler

@param       InString                The string to log out"""

	@staticmethod
	def PrintText(WorldContextObject: Object, InText: str = ..., bPrintToScreen: bool = ..., bPrintToLog: bool = ..., TextColor: LinearColor = ..., Duration: float = ...): ...
	"""Prints text to the log, and optionally, to the screen
If Print To Log is true, it will be visible in the Output Log window.  Otherwise it will be logged only as 'Verbose', so it generally won't show up.

@param       InText                  The text to log out
@param       bPrintToScreen  Whether or not to print the output to the screen
@param       bPrintToLog             Whether or not to print the output to the log
@param       bPrintToConsole Whether or not to print the output to the console
@param       TextColor               Whether or not to print the output to the console
@param       Duration                The display duration (if Print to Screen is True). Using negative number will result in loading the duration time from the config."""

	@staticmethod
	def PrintString(WorldContextObject: Object, InString: str = ..., bPrintToScreen: bool = ..., bPrintToLog: bool = ..., TextColor: LinearColor = ..., Duration: float = ...): ...
	"""Prints a string to the log, and optionally, to the screen
If Print To Log is true, it will be visible in the Output Log window.  Otherwise it will be logged only as 'Verbose', so it generally won't show up.

@param       InString                The string to log out
@param       bPrintToScreen  Whether or not to print the output to the screen
@param       bPrintToLog             Whether or not to print the output to the log
@param       bPrintToConsole Whether or not to print the output to the console
@param       TextColor               Whether or not to print the output to the console
@param       Duration                The display duration (if Print to Screen is True). Using negative number will result in loading the duration time from the config."""

	@staticmethod
	def MakeLiteralText(Value: str) -> str: ...
	"""Creates a literal FText
@param       Value   value to set the FText to
@return      The literal FText"""

	@staticmethod
	def MakeLiteralString(Value: str) -> str: ...
	"""Creates a literal string
@param       Value   value to set the string to
@return      The literal string"""

	@staticmethod
	def MakeLiteralByte(Value: int) -> int: ...
	"""Creates a literal byte
@param       Value   value to set the byte to
@return      The literal byte"""

	@staticmethod
	def MakeLiteralName(Value: str) -> str: ...
	"""Creates a literal name
@param       Value   value to set the name to
@return      The literal name"""

	@staticmethod
	def MakeLiteralBool(Value: bool) -> bool: ...
	"""Creates a literal bool
@param       Value   value to set the bool to
@return      The literal bool"""

	@staticmethod
	def MakeLiteralFloat(Value: float) -> float: ...
	"""Creates a literal float
@param       Value   value to set the float to
@return      The literal float"""

	@staticmethod
	def MakeLiteralInt(Value: int) -> int: ...
	"""Creates a literal integer
@param       Value   value to set the integer to
@return      The literal integer"""

	@staticmethod
	def LoadAssetClass(WorldContextObject: Object, AssetClass, OnLoaded, LatentInfo: LatentActionInfo): ...
	"""Load Asset Class"""

	@staticmethod
	def LoadAsset(WorldContextObject: Object, Asset, OnLoaded, LatentInfo: LatentActionInfo): ...
	"""Load Asset"""

	@staticmethod
	def Conv_ClassToSoftClassReference(Class: Object) -> typing.Any: ...
	"""Conv Class to Soft Class Reference"""

	@staticmethod
	def Conv_ObjectToSoftObjectReference(Object: Object) -> typing.Any: ...
	"""Conv Object to Soft Object Reference"""

	@staticmethod
	def Conv_SoftClassReferenceToClass(SoftClass) -> Object: ...
	"""Conv Soft Class Reference to Class"""

	@staticmethod
	def Conv_SoftObjectReferenceToObject(SoftObject) -> Object: ...
	"""Internal functions used by K2Node_LoadAsset and K2Node_ConvertAsset"""

	@staticmethod
	def LoadClassAsset_Blocking(AssetClass) -> Object: ...
	"""Resolves or loads a Soft Class Reference immediately, this will cause hitches and Async Load Class Asset should be used if possible"""

	@staticmethod
	def NotEqual_SoftClassReference(A, B) -> bool: ...
	"""Returns true if the values are not equal (A != B)"""

	@staticmethod
	def EqualEqual_SoftClassReference(A, B) -> bool: ...
	"""Returns true if the values are equal (A == B)"""

	@staticmethod
	def Conv_SoftClassReferenceToString(SoftClassReference) -> str: ...
	"""Converts a Soft Class Reference to a string. The other direction is not provided because it cannot be validated"""

	@staticmethod
	def IsValidSoftClassReference(SoftClassReference) -> bool: ...
	"""Returns true if the Soft Class Reference is not null"""

	@staticmethod
	def LoadAsset_Blocking(Asset) -> Object: ...
	"""Resolves or loads a Soft Object Reference immediately, this will cause hitches and Async Load Asset should be used if possible"""

	@staticmethod
	def NotEqual_SoftObjectReference(A, B) -> bool: ...
	"""Returns true if the values are not equal (A != B)"""

	@staticmethod
	def EqualEqual_SoftObjectReference(A, B) -> bool: ...
	"""Returns true if the values are equal (A == B)"""

	@staticmethod
	def Conv_SoftObjectReferenceToString(SoftObjectReference) -> str: ...
	"""Converts a Soft Object Reference to a string. The other direction is not provided because it cannot be validated"""

	@staticmethod
	def IsValidSoftObjectReference(SoftObjectReference) -> bool: ...
	"""Returns true if the Soft Object Reference is not null"""

	@staticmethod
	def Conv_SoftClassPathToSoftClassRef(SoftClassPath: SoftClassPath) -> typing.Any: ...
	"""Converts a Soft Class Path into a base Soft Class Reference, this is not guaranteed to be resolvable"""

	@staticmethod
	def BreakSoftClassPath(InSoftClassPath: SoftClassPath) -> str: ...
	"""Gets the path string out of a Soft Class Path"""

	@staticmethod
	def MakeSoftClassPath(PathString: str) -> SoftClassPath: ...
	"""Builds a SoftClassPath struct. Generally you should be using Soft Class References/Ptr types instead"""

	@staticmethod
	def Conv_SoftObjPathToSoftObjRef(SoftObjectPath: SoftObjectPath) -> typing.Any: ...
	"""Converts a Soft Object Path into a base Soft Object Reference, this is not guaranteed to be resolvable"""

	@staticmethod
	def BreakSoftObjectPath(InSoftObjectPath: SoftObjectPath) -> str: ...
	"""Gets the path string out of a Soft Object Path"""

	@staticmethod
	def MakeSoftObjectPath(PathString: str) -> SoftObjectPath: ...
	"""Builds a SoftObjectPath struct. Generally you should be using Soft Object References/Ptr types instead"""

	@staticmethod
	def Conv_InterfaceToObject(Interface) -> Object: ...
	"""Converts an interfance into an object"""

	@staticmethod
	def GetDeviceId() -> str: ...
	"""Returns the platform specific unique device id"""

	@staticmethod
	def IsPackagedForDistribution() -> bool: ...
	"""Returns whether this is a build that is packaged for distribution"""

	@staticmethod
	def IsSplitScreen(WorldContextObject: Object) -> bool: ...
	"""Returns whether we're currently running in split screen (more than one local player)."""

	@staticmethod
	def IsStandalone(WorldContextObject: Object) -> bool: ...
	"""Returns whether this game instance is stand alone (no networking)."""

	@staticmethod
	def IsDedicatedServer(WorldContextObject: Object) -> bool: ...
	"""Returns whether this is running on a dedicated server"""

	@staticmethod
	def IsServer(WorldContextObject: Object) -> bool: ...
	"""Returns whether the world this object is in is the host or not"""

	@staticmethod
	def GetFrameCount() -> long: ...
	"""Returns the value of GFrameCounter, a running count of the number of frames that have occurred."""

	@staticmethod
	def GetGameTimeInSeconds(WorldContextObject: Object) -> float: ...
	"""Get the current game time, in seconds. This stops when the game is paused and is affected by slomo.

@param WorldContextObject    World context"""

	@staticmethod
	def DoesImplementInterface(TestObject: Object, Interface) -> bool: ...
	"""Does Implement Interface"""

	@staticmethod
	def GetPlatformUserDir() -> str: ...
	"""Get the current user dir from the OS"""

	@staticmethod
	def GetPlatformUserName() -> str: ...
	"""Get the current user name from the OS"""

	@staticmethod
	def GetGameBundleId() -> str: ...
	"""Retrieves the game's platform-specific bundle identifier or package name of the game

@return The game's bundle identifier or package name."""

	@staticmethod
	def NormalizeFilename(InFilename: str) -> str: ...
	"""Convert all / and / to TEXT('/')"""

	@staticmethod
	def ConvertToAbsolutePath(FileName: str) -> str: ...
	"""Converts passed in filename to use a absolute path"""

	@staticmethod
	def ConvertToRelativePath(FileName: str) -> str: ...
	"""Converts passed in filename to use a relative path"""

	@staticmethod
	def GetProjectSavedDirectory() -> str: ...
	"""Get the saved directory of the current project"""

	@staticmethod
	def GetProjectContentDirectory() -> str: ...
	"""Get the content directory of the current project"""

	@staticmethod
	def GetProjectDirectory() -> str: ...
	"""Get the directory of the current project"""

	@staticmethod
	def GetGameName() -> str: ...
	"""Get the name of the current game"""

	@staticmethod
	def GetEngineVersion() -> str: ...
	"""Engine build number, for displaying to end users."""

	@staticmethod
	def GetOuterObject(Object: Object) -> Object: ...
	"""Returns the outer object of an object."""

	@staticmethod
	def GetClassDisplayName(Class: Object) -> str: ...
	"""Returns the display name of a class"""

	@staticmethod
	def GetDisplayName(Object: Object) -> str: ...
	"""Returns the display name (or actor label), for displaying as a debugging aid.
Note: In editor builds, this is the actor label.  In non-editor builds, this is the actual object name.  This function should not be used to uniquely identify actors!
It is not localized and should not be used for display to an end user of a game."""

	@staticmethod
	def GetSystemPath(Object: Object) -> str: ...
	"""Returns the full system path to a UObject
If given a non-asset UObject, it will return an empty string"""

	@staticmethod
	def GetPathName(Object: Object) -> str: ...
	"""Returns the full path to the specified object."""

	@staticmethod
	def GetObjectName(Object: Object) -> str: ...
	"""Returns the actual object name."""

	@staticmethod
	def IsValidClass(Class: Object) -> bool: ...
	"""Return true if the class is usable : non-null and not pending kill"""

	@staticmethod
	def IsValid(Object: Object) -> bool: ...
	"""Return true if the object is usable : non-null and not pending kill"""

	pass

class KismetTextLibrary(BlueprintFunctionLibrary):
	"""Kismet Text Library"""

	@staticmethod
	def PolyglotDataToText(PolyglotData) -> str: ...
	"""Get the text instance created from this polyglot data.
@return The text instance, or an empty text if the data is invalid."""

	@staticmethod
	def IsPolyglotDataValid(PolyglotData) -> typing.Tuple[bool, str]: ...
	"""Check whether the given polyglot data is valid.
@return True if the polyglot data is valid, false otherwise. ErrorMessage will be filled in if the the data is invalid."""

	@staticmethod
	def StringTableIdAndKeyFromText(Text: str) -> typing.Tuple[bool, str, str]: ...
	"""Attempts to find the String Table ID and key used by the given text.
@return True if the String Table ID and key were found, false otherwise."""

	@staticmethod
	def TextFromStringTable(TableId: str, Key: str) -> str: ...
	"""Attempts to create a text instance from a string table ID and key.
@note This exists to allow programmatic ‎look-up of a string table entry from dynamic content - you should favor setting your string table reference on a text property or pin wherever possible as it is significantly more robust (see 'Make Literal Text').
@return The found text, or a dummy text if the entry could not be found."""

	@staticmethod
	def TextIsFromStringTable(Text: str) -> bool: ...
	"""Returns true if the given text is referencing a string table."""

	@staticmethod
	def Format(InPattern: str, InArgs: typing.List[FormatArgumentData]) -> str: ...
	"""Used for formatting text using the FText::Format function and utilized by the UK2Node_FormatText"""

	@staticmethod
	def AsTimespan_Timespan(InTimespan: Timespan) -> str: ...
	"""Converts a passed in time span to a text, formatted as a time span"""

	@staticmethod
	def AsTimeZoneTime_DateTime(InDateTime: DateTime, InTimeZone: str = ...) -> str: ...
	"""Converts a passed in date & time to a text, formatted as a time using the given timezone (default is the local timezone). This will convert the given date & time from UTC to the given timezone (taking into account DST)."""

	@staticmethod
	def AsTime_DateTime(In: DateTime) -> str: ...
	"""Converts a passed in date & time to a text, formatted as a time using an invariant timezone. This will use the given date & time as-is, so it's assumed to already be in the correct timezone."""

	@staticmethod
	def AsTimeZoneDateTime_DateTime(InDateTime: DateTime, InTimeZone: str = ...) -> str: ...
	"""Converts a passed in date & time to a text, formatted as a date & time using the given timezone (default is the local timezone). This will convert the given date & time from UTC to the given timezone (taking into account DST)."""

	@staticmethod
	def AsDateTime_DateTime(In: DateTime) -> str: ...
	"""Converts a passed in date & time to a text, formatted as a date & time using an invariant timezone. This will use the given date & time as-is, so it's assumed to already be in the correct timezone."""

	@staticmethod
	def AsTimeZoneDate_DateTime(InDateTime: DateTime, InTimeZone: str = ...) -> str: ...
	"""Converts a passed in date & time to a text, formatted as a date using the given timezone (default is the local timezone). This will convert the given date & time from UTC to the given timezone (taking into account DST)."""

	@staticmethod
	def AsDate_DateTime(InDateTime: DateTime) -> str: ...
	"""Converts a passed in date & time to a text, formatted as a date using an invariant timezone. This will use the given date & time as-is, so it's assumed to already be in the correct timezone."""

	@staticmethod
	def AsPercent_Float(Value: float, RoundingMode: int, bAlwaysSign: bool = ..., bUseGrouping: bool = ..., MinimumIntegralDigits: int = ..., MaximumIntegralDigits: int = ..., MinimumFractionalDigits: int = ..., MaximumFractionalDigits: int = ...) -> str: ...
	"""Converts a passed in float to a text, formatted as a percent"""

	@staticmethod
	def AsCurrency_Float(Value: float, RoundingMode: int, bAlwaysSign: bool = ..., bUseGrouping: bool = ..., MinimumIntegralDigits: int = ..., MaximumIntegralDigits: int = ..., MinimumFractionalDigits: int = ..., MaximumFractionalDigits: int = ..., CurrencyCode: str = ...) -> str: ...
	"""Converts a passed in float to a text formatted as a currency"""

	@staticmethod
	def AsCurrency_Integer(Value: int, RoundingMode: int, bAlwaysSign: bool = ..., bUseGrouping: bool = ..., MinimumIntegralDigits: int = ..., MaximumIntegralDigits: int = ..., MinimumFractionalDigits: int = ..., MaximumFractionalDigits: int = ..., CurrencyCode: str = ...) -> str: ...
	"""Converts a passed in integer to a text formatted as a currency"""

	@staticmethod
	def AsCurrencyBase(BaseValue: int, CurrencyCode: str) -> str: ...
	"""Generate an FText that represents the passed number as currency in the current culture.
BaseVal is specified in the smallest fractional value of the currency and will be converted for formatting according to the selected culture.
Keep in mind the CurrencyCode is completely independent of the culture it's displayed in (and they do not imply one another).
For example: FText::AsCurrencyBase(650, TEXT('EUR')); would return an FText of '<EUR>6.50' in most English cultures (en_US/en_UK) and '6,50<EUR>' in Spanish (es_ES) (where <EUR> is U+20AC)"""

	@staticmethod
	def Conv_FloatToText(Value: float, RoundingMode: int, bAlwaysSign: bool = ..., bUseGrouping: bool = ..., MinimumIntegralDigits: int = ..., MaximumIntegralDigits: int = ..., MinimumFractionalDigits: int = ..., MaximumFractionalDigits: int = ...) -> str: ...
	"""Converts a passed in float to text based on formatting options"""

	@staticmethod
	def Conv_Int64ToText(Value: long, bAlwaysSign: bool = ..., bUseGrouping: bool = ..., MinimumIntegralDigits: int = ..., MaximumIntegralDigits: int = ...) -> str: ...
	"""Converts a passed in integer to text based on formatting options"""

	@staticmethod
	def Conv_IntToText(Value: int, bAlwaysSign: bool = ..., bUseGrouping: bool = ..., MinimumIntegralDigits: int = ..., MaximumIntegralDigits: int = ...) -> str: ...
	"""Converts a passed in integer to text based on formatting options"""

	@staticmethod
	def Conv_ByteToText(Value: int) -> str: ...
	"""Converts a byte value to formatted text"""

	@staticmethod
	def Conv_BoolToText(InBool: bool) -> str: ...
	"""Converts a boolean value to formatted text, either 'true' or 'false'"""

	@staticmethod
	def NotEqual_IgnoreCase_TextText(A: str, B: str) -> bool: ...
	"""Returns true if A and B are linguistically not equal (A != B), ignoring case."""

	@staticmethod
	def NotEqual_TextText(A: str, B: str) -> bool: ...
	"""Returns true if A and B are linguistically not equal (A != B)."""

	@staticmethod
	def EqualEqual_IgnoreCase_TextText(A: str, B: str) -> bool: ...
	"""Returns true if A and B are linguistically equal (A == B), ignoring case."""

	@staticmethod
	def EqualEqual_TextText(A: str, B: str) -> bool: ...
	"""Returns true if A and B are linguistically equal (A == B)."""

	@staticmethod
	def FindTextInLocalizationTable(Namespace: str, Key: str) -> typing.Tuple[bool, str]: ...
	"""Attempts to find existing Text using the representation found in the loc tables for the specified namespace and key."""

	@staticmethod
	def GetEmptyText() -> str: ...
	"""Returns an empty piece of text."""

	@staticmethod
	def TextTrimPrecedingAndTrailing(InText: str) -> str: ...
	"""Removes whitespace characters from the front and end of the text."""

	@staticmethod
	def TextTrimTrailing(InText: str) -> str: ...
	"""Removes trailing whitespace characters."""

	@staticmethod
	def TextTrimPreceding(InText: str) -> str: ...
	"""Removes whitespace characters from the front of the text."""

	@staticmethod
	def TextToUpper(InText: str) -> str: ...
	"""Transforms the text to uppercase in a culture correct way.
@note The returned instance is linked to the original and will be rebuilt if the active culture is changed."""

	@staticmethod
	def TextToLower(InText: str) -> str: ...
	"""Transforms the text to lowercase in a culture correct way.
@note The returned instance is linked to the original and will be rebuilt if the active culture is changed."""

	@staticmethod
	def TextIsCultureInvariant(InText: str) -> bool: ...
	"""Returns true if text is culture invariant."""

	@staticmethod
	def TextIsTransient(InText: str) -> bool: ...
	"""Returns true if text is transient."""

	@staticmethod
	def TextIsEmpty(InText: str) -> bool: ...
	"""Returns true if text is empty."""

	@staticmethod
	def Conv_NameToText(InName: str) -> str: ...
	"""Converts Name to culture invariant text"""

	@staticmethod
	def Conv_StringToText(InString: str) -> str: ...
	"""Converts string to culture invariant text. Use Format or Make Literal Text to create localizable text"""

	@staticmethod
	def Conv_TextToString(InText: str) -> str: ...
	"""Converts localizable text to the string"""

	@staticmethod
	def Conv_ColorToText(InColor: LinearColor) -> str: ...
	"""Converts a linear color value to localized formatted text, in the form '(R=,G=,B=,A=)'"""

	@staticmethod
	def Conv_ObjectToText(InObj: Object) -> str: ...
	"""Converts a UObject value to culture invariant text by calling the object's GetName method"""

	@staticmethod
	def Conv_TransformToText(InTrans: Transform) -> str: ...
	"""Converts a transform value to localized formatted text, in the form 'Translation: X= Y= Z= Rotation: P= Y= R= Scale: X= Y= Z='"""

	@staticmethod
	def Conv_RotatorToText(InRot: Rotator) -> str: ...
	"""Converts a rotator value to localized formatted text, in the form 'P= Y= R='"""

	@staticmethod
	def Conv_Vector2dToText(InVec: Vector2D) -> str: ...
	"""Converts a vector2d value to localized formatted text, in the form 'X= Y='"""

	@staticmethod
	def Conv_VectorToText(InVec: Vector) -> str: ...
	"""Converts a vector value to localized formatted text, in the form 'X= Y= Z='"""

	pass

class StereoLayerFunctionLibrary(BlueprintFunctionLibrary):
	"""StereoLayer Extensions Function Library"""

	@staticmethod
	def EnableAutoLoadingSplashScreen(InAutoShowEnabled: bool): ...
	"""Enables/disables splash screen to be automatically shown when LoadMap is called.

@param       bAutoShowEnabled        (in)    True, if automatic showing of splash screens is enabled when map is being loaded."""

	pass

class LightmassCharacterIndirectDetailVolume(Volume):
	"""Lightmass Character Indirect Detail Volume"""

	pass

class LightmassImportanceVolume(Volume):
	"""Lightmass Importance Volume"""

	pass

class LightmassPortal(Actor):
	"""Lightmass Portal"""

	pass

class PrecomputedVisibilityOverrideVolume(Volume):
	"""Precomputed Visibility Override Volume"""

	@property
	def OverrideVisibleActors(self) -> typing.List[Actor]: ...
	"""Array of actors that will always be considered visible by Precomputed Visibility when viewed from inside this volume."""

	@property
	def OverrideInvisibleActors(self) -> typing.List[Actor]: ...
	"""Array of actors that will always be considered invisible by Precomputed Visibility when viewed from inside this volume."""

	@property
	def OverrideInvisibleLevels(self) -> typing.List[str]: ...
	"""Array of level names whose actors will always be considered invisible by Precomputed Visibility when viewed from inside this volume."""

	pass

class PrecomputedVisibilityVolume(Volume):
	"""Precomputed Visibility Volume"""

	pass

class VolumetricLightmapDensityVolume(Volume):
	"""Provides local control over volumetric lightmap density.  Only convex shapes supported."""

	@property
	def AllowedMipLevelRange(self) -> typing.Any: ...
	"""The Volumetric Lightmap has 3 mipmaps, where the highest density mipmap (mip0) corresponds to VolumetricLightmapDetailCellSize.
mip0: DetailCellSize
mip1: DetailCellSize * 4
mip2: DetailCellSize * 16

By default, highest density will be placed around static geometry and static lights, but AllowedMipLevelRange can be used to override this behavior.
Examples:
[0, 3] = Volume does nothing
[1, 3] = Volume removes highest density mip, even near static geometry, which can be useful to save memory ('stat MapBuildData')
[0, 0] = Volume forces highest density.  Warning: using this on a large area can greatly increase memory and build times!
When multiple volumes overlap, the smallest (highest density) values will be used."""

	pass

class MaterialInterface(Object):
	"""Material Interface"""

	@property
	def SubsurfaceProfile(self) -> typing.Any: ...
	"""SubsurfaceProfile, for Screen Space Subsurface Scattering"""

	def SetForceMipLevelsToBeResident(self, OverrideForceMiplevelsToBeResident: bool, bForceMiplevelsToBeResidentValue: bool, ForceDuration: float, CinematicTextureGroups: int = ..., bFastResponse: bool = ...): ...
	"""Force the streaming system to disregard the normal logic for the specified duration and
instead always load all mip-levels for all textures used by this material.

@param OverrideForceMiplevelsToBeResident    - Whether to use (true) or ignore (false) the bForceMiplevelsToBeResidentValue parameter.
@param bForceMiplevelsToBeResidentValue              - true forces all mips to stream in. false lets other factors decide what to do with the mips.
@param ForceDuration                                                 - Number of seconds to keep all mip-levels in memory, disregarding the normal priority logic. Negative value turns it off.
@param CinematicTextureGroups                                - Bitfield indicating texture groups that should use extra high-resolution mips
@param bFastResponse                                                 - USE WITH EXTREME CAUTION! Fast response textures incur sizable GT overhead and disturb streaming metric calculation. Avoid whenever possible."""

	def GetParameterInfo(self, Association: int, ParameterName: str, LayerFunction: MaterialFunctionInterface) -> MaterialParameterInfo: ...
	"""Get Parameter Info"""

	def GetPhysicalMaterialFromMap(self, Index: int) -> PhysicalMaterial: ...
	"""Return a pointer to the physical material from mask map at given index.
@return The physical material."""

	def GetPhysicalMaterialMask(self) -> PhysicalMaterialMask: ...
	"""Return a pointer to the physical material mask used by this material instance.
@return The physical material."""

	def GetPhysicalMaterial(self) -> PhysicalMaterial: ...
	"""Return a pointer to the physical material used by this material instance.
@return The physical material."""

	def GetBaseMaterial(self) -> Material: ...
	"""Walks up parent chain and finds the base Material that this is an instance of. Just calls the virtual GetMaterial()"""

	pass

class Material(MaterialInterface):
	"""A Material is an asset which can be applied to a mesh to control the visual look of the scene.
When light from the scene hits the surface, the shading model of the material is used to calculate how that light interacts with the surface.

Warning: Creating new materials directly increases shader compile times!  Consider creating a Material Instance off of an existing material instead."""

	@property
	def PhysMaterial(self) -> PhysicalMaterial: ...
	"""Physical material to use for this graphics material. Used for sounds, effects etc."""

	@property
	def PhysMaterialMask(self) -> PhysicalMaterialMask: ...
	"""Physical material mask to use for this graphics material. Used for sounds, effects etc."""

	@property
	def PhysicalMaterialMap(self) -> typing.List[PhysicalMaterial]: ...
	"""Physical material mask map to use for this graphics material. Used for sounds, effects etc."""

	@property
	def Metallic(self) -> typing.Any: ...
	"""Metallic"""

	@property
	def Specular(self) -> typing.Any: ...
	"""Specular"""

	@property
	def Anisotropy(self) -> typing.Any: ...
	"""Anisotropy"""

	@property
	def Normal(self) -> typing.Any: ...
	"""Normal"""

	@property
	def Tangent(self) -> typing.Any: ...
	"""Tangent"""

	@property
	def EmissiveColor(self) -> typing.Any: ...
	"""Emission."""

	@property
	def MaterialDomain(self) -> int: ...
	"""The domain that the material's attributes will be evaluated in.
Certain pieces of material functionality are only valid in certain domains, for example vertex normal is only valid on a surface."""

	@property
	def BlendMode(self) -> int: ...
	"""Determines how the material's color is blended with background colors."""

	@property
	def DecalBlendMode(self) -> int: ...
	"""Defines how the GBuffer chanels are getting manipulated by a decal material pass. (only with MaterialDomain == MD_DeferredDecal)"""

	@property
	def MaterialDecalResponse(self) -> int: ...
	"""Defines how the material reacts on DBuffer decals (Affects look, performance and texture/sample usage).
Non DBuffer Decals can be disabled on the primitive (e.g. static mesh)"""

	@property
	def bCastDynamicShadowAsMasked(self) -> bool: ...
	"""Whether the material should cast shadows as masked even though it has a translucent blend mode."""

	@property
	def OpacityMaskClipValue(self) -> float: ...
	"""If BlendMode is BLEND_Masked, the surface is not rendered where OpacityMask < OpacityMaskClipValue.
If BlendMode is BLEND_Translucent, BLEND_Additive, or BLEND_Modulate, and 'Output Velocity' is enabled,
the object velocity is not rendered where Opacity < OpacityMaskClipValue."""

	@property
	def WorldPositionOffset(self) -> typing.Any: ...
	"""Adds to world position in the vertex shader."""

	@property
	def Refraction(self) -> typing.Any: ...
	"""output refraction index for translucent rendering
Air:1.0 Water:1.333 Ice:1.3 Glass:~1.6 Diamond:2.42"""

	@property
	def MaterialAttributes(self) -> typing.Any: ...
	"""Material Attributes"""

	@property
	def PixelDepthOffset(self) -> typing.Any: ...
	"""Pixel Depth Offset"""

	@property
	def ShadingModelFromMaterialExpression(self) -> typing.Any: ...
	"""Shading Model from Material Expression"""

	@property
	def bEnableSeparateTranslucency(self) -> bool: ...
	"""Indicates that the material should be rendered in the SeparateTranslucency Pass (not affected by DOF, requires bAllowSeparateTranslucency to be set in .ini)."""

	@property
	def bEnableResponsiveAA(self) -> bool: ...
	"""Indicates that the material should be rendered using responsive anti-aliasing. Improves sharpness of small moving particles such as sparks.
Only use for small moving features because it will cause aliasing of the background."""

	@property
	def bScreenSpaceReflections(self) -> bool: ...
	"""SSR on translucency"""

	@property
	def bContactShadows(self) -> bool: ...
	"""Contact shadows on translucency"""

	@property
	def TwoSided(self) -> bool: ...
	"""Indicates that the material should be rendered without backface culling and the normal should be flipped for backfaces."""

	@property
	def DitheredLODTransition(self) -> bool: ...
	"""Whether meshes rendered with the material should support dithered LOD transitions."""

	@property
	def DitherOpacityMask(self) -> bool: ...
	"""Dither opacity mask. When combined with Temporal AA this can be used as a form of limited translucency which supports all lighting features."""

	@property
	def bAllowNegativeEmissiveColor(self) -> bool: ...
	"""Whether the material should allow outputting negative emissive color values.  Only allowed on unlit materials."""

	@property
	def TranslucencyLightingMode(self) -> int: ...
	"""Sets the lighting mode that will be used on this material if it is translucent."""

	@property
	def bEnableMobileSeparateTranslucency(self) -> bool: ...
	"""Indicates that the translucent material should not be affected by bloom or DOF. (Note: Depth testing is not available)"""

	@property
	def NumCustomizedUVs(self) -> int: ...
	"""Number of customized UV inputs to display.  Unconnected customized UV inputs will just pass through the vertex UVs."""

	@property
	def TranslucencyDirectionalLightingIntensity(self) -> float: ...
	"""Useful for artificially increasing the influence of the normal on the lighting result for translucency.
A value larger than 1 increases the influence of the normal, a value smaller than 1 makes the lighting more ambient."""

	@property
	def TranslucentShadowDensityScale(self) -> float: ...
	"""Scale used to make translucent shadows more or less opaque than the material's actual opacity."""

	@property
	def TranslucentSelfShadowDensityScale(self) -> float: ...
	"""Scale used to make translucent self-shadowing more or less opaque than the material's shadow on other objects.
This is only used when the object is casting a volumetric translucent shadow."""

	@property
	def TranslucentSelfShadowSecondDensityScale(self) -> float: ...
	"""Used to make a second self shadow gradient, to add interesting shading in the shadow of the first."""

	@property
	def TranslucentSelfShadowSecondOpacity(self) -> float: ...
	"""Controls the strength of the second self shadow gradient."""

	@property
	def TranslucentBackscatteringExponent(self) -> float: ...
	"""Controls how diffuse the material's backscattering is when using the MSM_Subsurface shading model.
Larger exponents give a less diffuse look (smaller, brighter backscattering highlight).
This is only used when the object is casting a volumetric translucent shadow from a directional light."""

	@property
	def TranslucentMultipleScatteringExtinction(self) -> LinearColor: ...
	"""Colored extinction factor used to approximate multiple scattering in dense volumes.
This is only used when the object is casting a volumetric translucent shadow."""

	@property
	def TranslucentShadowStartOffset(self) -> float: ...
	"""Local space distance to bias the translucent shadow.  Positive values move the shadow away from the light."""

	@property
	def bDisableDepthTest(self) -> bool: ...
	"""Whether to draw on top of opaque pixels even if behind them. This only has meaning for translucency."""

	@property
	def bWriteOnlyAlpha(self) -> bool: ...
	"""Whether the transluency pass should write its alpha, and only the alpha, into the framebuffer"""

	@property
	def bGenerateSphericalParticleNormals(self) -> bool: ...
	"""Whether to generate spherical normals for particles that use this material."""

	@property
	def bTangentSpaceNormal(self) -> bool: ...
	"""Whether the material takes a tangent space normal or a world space normal as input.
(TangentSpace requires extra instructions but is often more convenient)."""

	@property
	def bUseEmissiveForDynamicAreaLighting(self) -> bool: ...
	"""If enabled, the material's emissive colour is injected into the LightPropagationVolume"""

	@property
	def bBlockGI(self) -> bool: ...
	"""If enabled, the material's opacity defines how much GI is blocked when using the LightPropagationVolume feature"""

	@property
	def bUsedAsSpecialEngineMaterial(self) -> bool: ...
	"""This is a special usage flag that allows a material to be assignable to any primitive type.
This is useful for materials used by code to implement certain viewmodes, for example the default material or lighting only material.
The cost is that nearly 20x more shaders will be compiled for the material than the average material, which will greatly increase shader compile time and memory usage.
This flag should only be enabled when absolutely necessary, and is purposefully not exposed to the UI to prevent abuse."""

	@property
	def bUsedWithSkeletalMesh(self) -> bool: ...
	"""Indicates that the material and its instances can be used with skeletal meshes.
This will result in the shaders required to support skeletal meshes being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithEditorCompositing(self) -> bool: ...
	"""Indicates that the material and its instances can be used with editor compositing
This will result in the shaders required to support editor compositing being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithParticleSprites(self) -> bool: ...
	"""Indicates that the material and its instances can be used with particle sprites
This will result in the shaders required to support particle sprites being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithBeamTrails(self) -> bool: ...
	"""Indicates that the material and its instances can be used with beam trails
This will result in the shaders required to support beam trails being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithMeshParticles(self) -> bool: ...
	"""Indicates that the material and its instances can be used with mesh particles
This will result in the shaders required to support mesh particles being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithNiagaraSprites(self) -> bool: ...
	"""Indicates that the material and its instances can be used with Niagara sprites (meshes and ribbons, respectively)
This will result in the shaders required to support Niagara sprites being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithNiagaraRibbons(self) -> bool: ...
	"""Used with Niagara Ribbons"""

	@property
	def bUsedWithNiagaraMeshParticles(self) -> bool: ...
	"""Used with Niagara Mesh Particles"""

	@property
	def bUsedWithGeometryCache(self) -> bool: ...
	"""Used with Geometry Cache"""

	@property
	def bUsedWithStaticLighting(self) -> bool: ...
	"""Indicates that the material and its instances can be used with static lighting
This will result in the shaders required to support static lighting being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithMorphTargets(self) -> bool: ...
	"""Indicates that the material and its instances can be used with morph targets
This will result in the shaders required to support morph targets being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithSplineMeshes(self) -> bool: ...
	"""Indicates that the material and its instances can be used with spline meshes
This will result in the shaders required to support spline meshes being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithInstancedStaticMeshes(self) -> bool: ...
	"""Indicates that the material and its instances can be used with instanced static meshes
This will result in the shaders required to support instanced static meshes being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithGeometryCollections(self) -> bool: ...
	"""Indicates that the material and its instances can be use with geometry collections
This will result in the shaders required to support geometry collections being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsesDistortion(self) -> bool: ...
	"""Indicates that the material and its instances can be used with distortion
This will result in the shaders required to support distortion being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithClothing(self) -> bool: ...
	"""Indicates that the material and its instances can be used with clothing
This will result in the shaders required to support clothing being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithWater(self) -> bool: ...
	"""Indicates that the material and its instances can be use with water
This will result in the shaders required to support water meshes being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithHairStrands(self) -> bool: ...
	"""Indicates that the material and its instances can be use with hair strands
This will result in the shaders required to support hair strands geometries being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithLidarPointCloud(self) -> bool: ...
	"""Indicates that the material and its instances can be use with LiDAR Point Clouds
This will result in the shaders required to support LiDAR Point Cloud geometries being compiled which will increase shader compile time and memory usage."""

	@property
	def bUsedWithVirtualHeightfieldMesh(self) -> bool: ...
	"""Indicates that the material and its instances can be used with Virtual Heightfield Mesh.
This will result in the shaders required to support Virtual Heightfield Mesh geometries being compiled which will increase shader compile time and memory usage."""

	@property
	def bAutomaticallySetUsageInEditor(self) -> bool: ...
	"""Whether to automatically set usage flags based on what the material is applied to in the editor.
It can be useful to disable this on a base material with many instances, where adding another usage flag accidentally (eg bUsedWithSkeletalMeshes) can add a lot of shader permutations."""

	@property
	def bFullyRough(self) -> bool: ...
	"""Forces the material to be completely rough. Saves a number of instructions and one sampler."""

	@property
	def bUseFullPrecision(self) -> bool: ...
	"""Forces this material to use full (highp) precision in the pixel shader.
This is slower than the default (mediump) but can be used to work around precision-related rendering errors.
This setting has no effect on older mobile devices that do not support high precision."""

	@property
	def bUseLightmapDirectionality(self) -> bool: ...
	"""Use lightmap directionality and per pixel normals. If disabled, lighting from lightmaps will be flat but cheaper."""

	@property
	def bUseAlphaToCoverage(self) -> bool: ...
	"""Use alpha to coverage for masked material on mobile, make sure MSAA is enabled as well."""

	@property
	def bForwardRenderUsePreintegratedGFForSimpleIBL(self) -> bool: ...
	"""Forward (including mobile) renderer: use preintegrated GF lut for simple IBL, but will use one more sampler."""

	@property
	def bUseHQForwardReflections(self) -> bool: ...
	"""* Forward renderer: enables multiple parallax-corrected reflection captures that blend together.
* Mobile renderer: blend between nearest 3 reflection captures, but reduces the number of samplers available to the material as two more samplers will be used for reflection cubemaps."""

	@property
	def bUsePlanarForwardReflections(self) -> bool: ...
	"""Enables planar reflection when using the forward renderer or mobile. Enabling this setting reduces the number of samplers available to the material as one more sampler will be used for the planar reflection."""

	@property
	def bNormalCurvatureToRoughness(self) -> bool: ...
	"""Reduce roughness based on screen space normal changes."""

	@property
	def D3D11TessellationMode(self) -> int: ...
	"""D3D11Tessellation Mode"""

	@property
	def bEnableCrackFreeDisplacement(self) -> bool: ...
	"""Enable Crack Free Displacement"""

	@property
	def bEnableAdaptiveTessellation(self) -> bool: ...
	"""Enable Adaptive Tessellation"""

	@property
	def AllowTranslucentCustomDepthWrites(self) -> bool: ...
	"""Allows a translucent material to be used with custom depth writing by compiling additional shaders."""

	@property
	def Wireframe(self) -> bool: ...
	"""Enables a wireframe view of the mesh the material is applied to."""

	@property
	def ShadingRate(self) -> int: ...
	"""Select what shading rate to apply for platforms that have variable rate shading"""

	@property
	def bCanMaskedBeAssumedOpaque(self) -> bool: ...
	"""true if this Material can be assumed Opaque when set to masked."""

	@property
	def bIsPreviewMaterial(self) -> bool: ...
	"""true if Material is the preview material used in the material editor."""

	@property
	def bIsFunctionPreviewMaterial(self) -> bool: ...
	"""true if Material is the function preview material used in the material instance editor."""

	@property
	def bUseMaterialAttributes(self) -> bool: ...
	"""when true, the material attributes pin is used instead of the regular pins."""

	@property
	def bCastRayTracedShadows(self) -> bool: ...
	"""when true, the material casts ray tracing shadows."""

	@property
	def bUseTranslucencyVertexFog(self) -> bool: ...
	"""When true, translucent materials are fogged. Defaults to true."""

	@property
	def bApplyCloudFogging(self) -> bool: ...
	"""When true, translucent materials receive cloud contribution as part of the fog evaluation, per vertex or per pixel according to the other selected options. This is a rough approximation but can help in some cases. Defaults to false. Fog is applied on clouds, so Apply Fogging must be true to use this feature."""

	@property
	def bIsSky(self) -> bool: ...
	"""Unlit and Opaque materials can be used as sky material on a sky dome mesh. When IsSky is true, these meshes will not receive any contribution from the aerial perspective. Height and Volumetric fog effects will still be applied."""

	@property
	def bComputeFogPerPixel(self) -> bool: ...
	"""When true, translucent materials have fog computed for every pixel, which costs more but fixes artifacts due to low tessellation."""

	@property
	def bOutputTranslucentVelocity(self) -> bool: ...
	"""When true, translucent materials will output motion vectors in velocity pass."""

	@property
	def bAllowDevelopmentShaderCompile(self) -> bool: ...
	"""If true the compilation environment will be changed to remove the global COMPILE_SHADERS_FOR_DEVELOPMENT flag."""

	@property
	def bIsMaterialEditorStatsMaterial(self) -> bool: ...
	"""true if this is a special material used for stats by the material editor."""

	@property
	def BlendableLocation(self) -> int: ...
	"""Where the node is inserted in the (post processing) graph, only used if domain is PostProcess"""

	@property
	def BlendableOutputAlpha(self) -> bool: ...
	"""If this is enabled, the blendable will output alpha"""

	@property
	def bEnableStencilTest(self) -> bool: ...
	"""Selectively execute post process material only for pixels that pass the stencil test against the Custom Depth/Stencil buffer.
Pixels that fail the stencil test are filled with the previous post process material output or scene color."""

	@property
	def StencilCompare(self) -> int: ...
	"""Stencil Compare"""

	@property
	def StencilRefValue(self) -> int: ...
	"""Stencil Ref Value"""

	@property
	def RefractionMode(self) -> int: ...
	"""Controls how the Refraction input is interpreted and how the refraction offset into scene color is computed for this material."""

	@property
	def BlendablePriority(self) -> int: ...
	"""If multiple nodes with the same  type are inserted at the same point, this defined order and if they get combined, only used if domain is PostProcess"""

	@property
	def bIsBlendable(self) -> bool: ...
	"""Allows blendability to be turned off, only used if domain is PostProcess"""

	@property
	def UsageFlagWarnings(self) -> int: ...
	"""true if we have printed a warning about material usage for a given usage flag."""

	@property
	def RefractionDepthBias(self) -> float: ...
	"""This is the refraction depth bias, larger values offset distortion to prevent closer objects from rendering into the distorted surface at acute viewing angles but increases the disconnect between surface and where the refraction starts."""

	@property
	def StateId(self) -> Guid: ...
	"""Guid that uniquely identifies this material.
Any changes to the state of the material that do not appear separately in the shadermap DDC keys must cause this guid to be regenerated!
For example, a modification to the Expressions array.
Code changes that cause the guid to be regenerated on load should be avoided, as that requires a resave of the content to stop recompiling every load."""

	@property
	def MaxDisplacement(self) -> float: ...
	"""Max Displacement"""

	pass

class MaterialFunctionInterface(Object):
	"""A Material Function is a collection of material expressions that can be reused in different materials"""

	@property
	def StateId(self) -> Guid: ...
	"""Used by materials using this function to know when to recompile."""

	pass

class MaterialFunction(MaterialFunctionInterface):
	"""A Material Function is a collection of material expressions that can be reused in different materials"""

	@property
	def Description(self) -> str: ...
	"""Description of the function which will be displayed as a tooltip wherever the function is used."""

	@property
	def bExposeToLibrary(self) -> bool: ...
	"""Whether to list this function in the material function library, which is a window in the material editor that lists categorized functions."""

	@property
	def bPrefixParameterNames(self) -> bool: ...
	"""If true, parameters in this function will have a prefix added to their group name."""

	pass

class MaterialFunctionInstance(MaterialFunctionInterface):
	"""A material function instance defines parameter overrides for a parent material function."""

	@property
	def Parent(self) -> MaterialFunctionInterface: ...
	"""Parent function."""

	@property
	def Base(self) -> MaterialFunctionInterface: ...
	"""Base function."""

	@property
	def ScalarParameterValues(self) -> typing.List[ScalarParameterValue]: ...
	"""Scalar parameters."""

	@property
	def VectorParameterValues(self) -> typing.List[VectorParameterValue]: ...
	"""Vector parameters."""

	@property
	def TextureParameterValues(self) -> typing.List[TextureParameterValue]: ...
	"""Texture parameters."""

	@property
	def FontParameterValues(self) -> typing.List[FontParameterValue]: ...
	"""Font parameters."""

	@property
	def StaticSwitchParameterValues(self) -> typing.List[unsupported]: ...
	"""Static switch parameters."""

	@property
	def StaticComponentMaskParameterValues(self) -> typing.List[unsupported]: ...
	"""Static component mask parameters."""

	@property
	def RuntimeVirtualTextureParameterValues(self) -> typing.List[RuntimeVirtualTextureParameterValue]: ...
	"""Runtime virtual texture parameters."""

	pass

class MaterialFunctionMaterialLayer(MaterialFunction):
	"""Specialized Material Function that acts as a layer"""

	pass

class MaterialFunctionMaterialLayerInstance(MaterialFunctionInstance):
	"""Specialized Material Function Instance that instances a layer"""

	pass

class MaterialFunctionMaterialLayerBlend(MaterialFunction):
	"""Specialized Material Function that acts as a blend"""

	pass

class MaterialFunctionMaterialLayerBlendInstance(MaterialFunctionInstance):
	"""Specialized Material Function Instance that instances a blend"""

	pass

class MaterialInstance(MaterialInterface):
	"""Material Instance"""

	@property
	def PhysMaterial(self) -> PhysicalMaterial: ...
	"""Physical material to use for this graphics material. Used for sounds, effects etc."""

	@property
	def PhysicalMaterialMap(self) -> typing.List[PhysicalMaterial]: ...
	"""Physical material map used with physical material mask, when it exists."""

	@property
	def Parent(self) -> MaterialInterface: ...
	"""Parent material."""

	@property
	def bHasStaticPermutationResource(self) -> bool: ...
	"""Indicates whether the instance has static permutation resources (which are required when static parameters are present)
Read directly from the rendering thread, can only be modified with the use of a FMaterialUpdateContext.
When true, StaticPermutationMaterialResources will always be valid and non-null."""

	@property
	def bOverrideSubsurfaceProfile(self) -> bool: ...
	"""Defines if SubsurfaceProfile from this instance is used or it uses the parent one."""

	@property
	def ScalarParameterValues(self) -> typing.List[ScalarParameterValue]: ...
	"""Scalar parameters."""

	@property
	def VectorParameterValues(self) -> typing.List[VectorParameterValue]: ...
	"""Vector parameters."""

	@property
	def TextureParameterValues(self) -> typing.List[TextureParameterValue]: ...
	"""Texture parameters."""

	@property
	def RuntimeVirtualTextureParameterValues(self) -> typing.List[RuntimeVirtualTextureParameterValue]: ...
	"""RuntimeVirtualTexture parameters."""

	@property
	def FontParameterValues(self) -> typing.List[FontParameterValue]: ...
	"""Font parameters."""

	@property
	def BasePropertyOverrides(self) -> typing.Any: ...
	"""Base Property Overrides"""

	def GetScalarParameterValue(self, ParamName: str) -> float: ...

	def GetVectorParameterValue(self, ParamName: str) -> LinearColor: ...

	def GetTextureParameterValue(self, ParamName: str) -> Texture: ...

	pass

class MaterialInstanceActor(Actor):
	"""Material Instance Actor"""

	@property
	def TargetActors(self) -> typing.List[Actor]: ...
	"""Pointer to actors that we want to control paramters of using Matinee."""

	pass

class MaterialInstanceConstant(MaterialInstance):
	"""Material Instances may be used to change the appearance of a material without incurring an expensive recompilation of the material.
General modification of the material cannot be supported without recompilation, so the instances are limited to changing the values of
predefined material parameters. The parameters are statically defined in the compiled material by a unique name, type and default value."""

	@property
	def PhysMaterialMask(self) -> PhysicalMaterialMask: ...
	"""Physical material mask to use for this graphics material. Used for sounds, effects etc."""

	pass

class MaterialInstanceDynamic(MaterialInstance):
	"""Material Instance Dynamic"""

	def CopyParameterOverrides(self, MaterialInstance: MaterialInstance): ...
	"""Copy parameter values from another material instance. This will copy only
parameters explicitly overridden in that material instance!!"""

	def CopyInterpParameters(self, Source: MaterialInstance): ...
	"""Copies over parameters given a material instance (only copy from the instance, not following the hierarchy)
much faster than K2_CopyMaterialInstanceParameters(),
The output is the object itself (this).
@param Source ignores the call if 0"""

	def CopyMaterialInstanceParameters(self, Source: MaterialInterface, bQuickParametersOnly: bool = ...): ...
	"""Copies over parameters given a material interface (copy each instance following the hierarchy)
Very slow implementation, avoid using at runtime. Hopefully we can replace it later with something like CopyInterpParameters()
The output is the object itself (this). Copying 'quick parameters only' will result in a much
faster copy process but will only copy dynamic scalar, vector and texture parameters on clients.
@param bQuickParametersOnly Copy scalar, vector and texture parameters only. Much faster but may not include required data"""

	def InterpolateMaterialInstanceParameters(self, SourceA: MaterialInstance, SourceB: MaterialInstance, Alpha: float): ...
	"""Interpolates the scalar and vector parameters of this material instance based on two other material instances, and an alpha blending factor
The output is the object itself (this).
Supports the case SourceA==this || SourceB==this
Both material have to be from the same base material
@param SourceA value that is used for Alpha=0, silently ignores the case if 0
@param SourceB value that is used for Alpha=1, silently ignores the case if 0
@param Alpha usually in the range 0..1, values outside the range extrapolate"""

	def GetVectorParameterValueByInfo(self, ParameterInfo: MaterialParameterInfo) -> LinearColor: ...
	"""Get the current MID vector parameter value, using MPI (to allow access to layer parameters)"""

	def GetVectorParameterValue(self, ParameterName: str) -> LinearColor: ...
	"""Get the current MID vector parameter value"""

	def SetVectorParameterValueByInfo(self, ParameterInfo: MaterialParameterInfo, Value: LinearColor): ...
	"""Set an MID vector parameter value, using MPI (to allow access to layer parameters)"""

	def SetVectorParameterValue(self, ParameterName: str, Value: LinearColor): ...
	"""Set an MID vector parameter value"""

	def GetTextureParameterValueByInfo(self, ParameterInfo: MaterialParameterInfo) -> Texture: ...
	"""Get the current MID texture parameter value, using MPI (to allow access to layer parameters)"""

	def GetTextureParameterValue(self, ParameterName: str) -> Texture: ...
	"""Get the current MID texture parameter value"""

	def SetTextureParameterValueByInfo(self, ParameterInfo: MaterialParameterInfo, Value: Texture): ...
	"""Set an MID texture parameter value using MPI (to allow access to layer parameters)"""

	def SetTextureParameterValue(self, ParameterName: str, Value: Texture): ...
	"""Set an MID texture parameter value"""

	def GetScalarParameterValueByInfo(self, ParameterInfo: MaterialParameterInfo) -> float: ...
	"""Get the current scalar (float) parameter value from an MID, using MPI (to allow access to layer parameters)"""

	def GetScalarParameterValue(self, ParameterName: str) -> float: ...
	"""Get the current scalar (float) parameter value from an MID"""

	def SetScalarParameterValueByInfo(self, ParameterInfo: MaterialParameterInfo, Value: float): ...
	"""Set a MID scalar (float) parameter value using MPI (to allow access to layer parameters)"""

	def SetScalarParameterValue(self, ParameterName: str, Value: float): ...
	"""Set a MID scalar (float) parameter value"""

	pass

class MaterialParameterCollection(Object):
	"""Asset class that contains a list of parameter names and their default values.
Any number of materials can reference these parameters and get new values when the parameter values are changed."""

	@property
	def StateId(self) -> Guid: ...
	"""Used by materials using this collection to know when to recompile."""

	@property
	def ScalarParameters(self) -> typing.List[unsupported]: ...
	"""Scalar Parameters"""

	@property
	def VectorParameters(self) -> typing.List[unsupported]: ...
	"""Vector Parameters"""

	pass

class InterpData(Object):
	"""Interpolation data, containing keyframe tracks, event tracks etc.
This does not contain any  AActor  references or state, so can safely be stored in
packages, shared between multiple MatineeActors etc."""

	@property
	def InterpLength(self) -> float: ...
	"""Duration of interpolation sequence - in seconds."""

	@property
	def PathBuildTime(self) -> float: ...
	"""Position in Interp to move things to for path-building in editor."""

	@property
	def InterpGroups(self) -> typing.List[InterpGroup]: ...
	"""Actual interpolation data. Groups of InterpTracks."""

	@property
	def CurveEdSetup(self) -> typing.Any: ...
	"""Used for curve editor to remember curve-editing setup. Only loaded in editor."""

	@property
	def EdSectionStart(self) -> float: ...
	"""Used in editor for defining sections to loop, stretch etc."""

	@property
	def EdSectionEnd(self) -> float: ...
	"""Used in editor for defining sections to loop, stretch etc."""

	@property
	def bShouldBakeAndPrune(self) -> bool: ...
	"""If true, then the matinee should be baked and pruned at cook time."""

	@property
	def CachedDirectorGroup(self) -> InterpGroupDirector: ...
	"""Cached version of the director group, if any, for easy access while in game"""

	@property
	def AllEventNames(self) -> typing.List[str]: ...
	"""Unique names of all events contained across all event tracks"""

	pass

class InterpGroup(Object):
	"""Interp Group"""

	@property
	def InterpTracks(self) -> typing.List[InterpTrack]: ...
	"""Interp Tracks"""

	@property
	def GroupName(self) -> str: ...
	"""Within an InterpData, all GroupNames must be unique.
Used for naming Variable connectors on the Action in Kismet and finding each groups object."""

	@property
	def GroupColor(self) -> Color: ...
	"""Colour used for drawing tracks etc. related to this group."""

	@property
	def bCollapsed(self) -> bool: ...
	"""Whether or not this group is folded away in the editor."""

	@property
	def bVisible(self) -> bool: ...
	"""Whether or not this group is visible in the editor."""

	@property
	def bIsFolder(self) -> bool: ...
	"""When enabled, this group is treated like a folder in the editor, which should only be used for organization.  Folders are never associated with actors and don't have a presence in the Kismet graph."""

	@property
	def bIsParented(self) -> bool: ...
	"""When true, this group is considered a 'visual child' of another group.  This doesn't at all affect the behavior of the group, it's only for visual organization.  Also, it's implied that the parent is the next prior group in the array that doesn't have a parent."""

	pass

class InterpGroupCamera(InterpGroup):
	"""Interp Group Camera"""

	@property
	def CameraAnimInst(self) -> CameraAnim: ...
	"""Camera Anim Inst"""

	@property
	def CompressTolerance(self) -> float: ...
	"""When compress, tolerance option *"""

	pass

class InterpGroupDirector(InterpGroup):
	"""Interp Group Director"""

	pass

class InterpTrack(Object):
	"""Interp Track"""

	@property
	def SubTracks(self) -> typing.List[InterpTrack]: ...
	"""A list of subtracks that belong to this track"""

	@property
	def TrackInstClass(self) -> typing.Any: ...
	"""Track Inst Class"""

	@property
	def ActiveCondition(self) -> int: ...
	"""Sets the condition that must be met for this track to be enabled"""

	@property
	def TrackTitle(self) -> str: ...
	"""Title of track type."""

	@property
	def bOnePerGroup(self) -> bool: ...
	"""Whether there may only be one of this track in an UInterpGroup."""

	@property
	def bDirGroupOnly(self) -> bool: ...
	"""If this track can only exist inside the Director group."""

	@property
	def bIsAnimControlTrack(self) -> bool: ...
	"""If true, the  AActor  this track is working on will have BeginAnimControl/FinishAnimControl called on it."""

	@property
	def bSubTrackOnly(self) -> bool: ...
	"""If this track can only exist as a sub track."""

	@property
	def bVisible(self) -> bool: ...
	"""Whether or not this track is visible in the editor."""

	@property
	def bIsRecording(self) -> bool: ...
	"""Whether or not this track is recording in the editor."""

	pass

class InterpTrackFloatBase(InterpTrack):
	"""Interp Track Float Base"""

	@property
	def FloatTrack(self) -> InterpCurveFloat: ...
	"""Actually track data containing keyframes of float as it varies over time."""

	@property
	def CurveTension(self) -> float: ...
	"""Tension of curve, used for keypoints using automatic tangents."""

	pass

class InterpTrackAnimControl(InterpTrackFloatBase):
	"""Interp Track Anim Control"""

	@property
	def SlotName(self) -> str: ...
	"""Name of slot to use when playing animation. Passed to Actor.
When multiple tracks use the same slot name, they are each given a different ChannelIndex when SetAnimPosition is called."""

	@property
	def AnimSeqs(self) -> typing.List[unsupported]: ...
	"""Track of different animations to play and when to start playing them."""

	@property
	def bSkipAnimNotifiers(self) -> bool: ...
	"""Skip all anim notifiers *"""

	pass

class InterpTrackVectorBase(InterpTrack):
	"""Interp Track Vector Base"""

	@property
	def VectorTrack(self) -> InterpCurveVector: ...
	"""Actually track data containing keyframes of a FVector as it varies over time."""

	@property
	def CurveTension(self) -> float: ...
	"""Tension of curve, used for keypoints using automatic tangents."""

	pass

class InterpTrackAudioMaster(InterpTrackVectorBase):
	"""Interp Track Audio Master"""

	pass

class InterpTrackBoolProp(InterpTrack):
	"""Interp Track Bool Prop"""

	@property
	def BoolTrack(self) -> typing.List[unsupported]: ...
	"""Array of booleans to set."""

	@property
	def PropertyName(self) -> str: ...
	"""Name of property in Group  AActor  which this track will modify over time."""

	pass

class InterpTrackColorProp(InterpTrackVectorBase):
	"""Interp Track Color Prop"""

	@property
	def PropertyName(self) -> str: ...
	"""Name of property in Group  AActor  which this track mill modify over time."""

	pass

class InterpTrackDirector(InterpTrack):
	"""Interp Track Director"""

	@property
	def CutTrack(self) -> typing.List[unsupported]: ...
	"""Array of cuts between cameras."""

	pass

class InterpTrackEvent(InterpTrack):
	"""Interp Track Event"""

	@property
	def EventTrack(self) -> typing.List[unsupported]: ...
	"""Array of events to fire off."""

	@property
	def bFireEventsWhenForwards(self) -> bool: ...
	"""If events should be fired when passed playing the sequence forwards."""

	@property
	def bFireEventsWhenBackwards(self) -> bool: ...
	"""If events should be fired when passed playing the sequence backwards."""

	@property
	def bFireEventsWhenJumpingForwards(self) -> bool: ...
	"""If true, events on this track are fired even when jumping forwads through a sequence - for example, skipping a cinematic."""

	@property
	def bUseCustomEventName(self) -> bool: ...
	"""If checked each key's event name is the exact name of the custom event function in level script that will be called"""

	pass

class InterpTrackFloatMaterialParam(InterpTrackFloatBase):
	"""Interp Track Float Material Param"""

	@property
	def TargetMaterials(self) -> typing.List[MaterialInterface]: ...
	"""Materials whose parameters we want to change and the references to those materials."""

	@property
	def ParamName(self) -> str: ...
	"""Name of parameter in the MaterialInstance which this track will modify over time."""

	pass

class InterpTrackFloatProp(InterpTrackFloatBase):
	"""Interp Track Float Prop"""

	@property
	def PropertyName(self) -> str: ...
	"""Name of property in Group  AActor  which this track mill modify over time."""

	pass

class InterpTrackLinearColorBase(InterpTrack):
	"""Interp Track Linear Color Base"""

	@property
	def LinearColorTrack(self) -> InterpCurveLinearColor: ...
	"""Actually track data containing keyframes of a FVector as it varies over time."""

	@property
	def CurveTension(self) -> float: ...
	"""Tension of curve, used for keypoints using automatic tangents."""

	pass

class InterpTrackLinearColorProp(InterpTrackLinearColorBase):
	"""Interp Track Linear Color Prop"""

	@property
	def PropertyName(self) -> str: ...
	"""Name of property in Group  AActor  which this track mill modify over time."""

	pass

class InterpTrackMove(InterpTrack):
	"""Track containing data for moving an actor around over time."""

	@property
	def PosTrack(self) -> InterpCurveVector: ...
	"""Actual position keyframe data."""

	@property
	def EulerTrack(self) -> InterpCurveVector: ...
	"""Actual rotation keyframe data, stored as Euler angles in degrees, for easy editing on curve."""

	@property
	def LookupTrack(self) -> typing.Any: ...
	"""Lookup Track"""

	@property
	def LookAtGroupName(self) -> str: ...
	"""When using IMR_LookAtGroup, specifies the Group which this track should always point its actor at."""

	@property
	def LinCurveTension(self) -> float: ...
	"""Controls the tightness of the curve for the translation path."""

	@property
	def AngCurveTension(self) -> float: ...
	"""Controls the tightness of the curve for the rotation path."""

	@property
	def bUseQuatInterpolation(self) -> bool: ...
	"""Use a Quaternion linear interpolation between keys.
This is robust and will find the 'shortest' distance between keys, but does not support ease in/out."""

	@property
	def bShowArrowAtKeys(self) -> bool: ...
	"""In the editor, show a small arrow at each keyframe indicating the rotation at that key."""

	@property
	def bDisableMovement(self) -> bool: ...
	"""Disable previewing of this track - will always position  AActor  at Time=0.0. Useful when keyframing an object relative to this group."""

	@property
	def bShowTranslationOnCurveEd(self) -> bool: ...
	"""If false, when this track is displayed on the Curve Editor in Matinee, do not show the Translation tracks."""

	@property
	def bShowRotationOnCurveEd(self) -> bool: ...
	"""If false, when this track is displayed on the Curve Editor in Matinee, do not show the Rotation tracks."""

	@property
	def bHide3DTrack(self) -> bool: ...
	"""If true, 3D representation of this track in the 3D viewport is disabled."""

	@property
	def RotMode(self) -> int: ...
	"""Rot Mode"""

	pass

class InterpTrackMoveAxis(InterpTrackFloatBase):
	"""Interp Track Move Axis"""

	@property
	def MoveAxis(self) -> int: ...
	"""The axis which this track will use when transforming an actor"""

	@property
	def LookupTrack(self) -> typing.Any: ...
	"""Lookup track to use when looking at different groups for transform information"""

	pass

class InterpTrackParticleReplay(InterpTrack):
	"""Interp Track Particle Replay"""

	@property
	def TrackKeys(self) -> typing.List[unsupported]: ...
	"""Array of keys"""

	pass

class InterpTrackSound(InterpTrackVectorBase):
	"""Interp Track Sound"""

	@property
	def Sounds(self) -> typing.List[unsupported]: ...
	"""Array of sounds to play at specific times."""

	@property
	def bPlayOnReverse(self) -> bool: ...
	"""if set, sound plays only when playing the matinee in reverse instead of when the matinee plays forward"""

	@property
	def bContinueSoundOnMatineeEnd(self) -> bool: ...
	"""If true, sounds on this track will not be forced to finish when the matinee sequence finishes."""

	@property
	def bSuppressSubtitles(self) -> bool: ...
	"""If true, don't show subtitles for sounds played by this track."""

	@property
	def bTreatAsDialogue(self) -> bool: ...
	"""If true and track is controlling a pawn, makes the pawn 'speak' the given audio."""

	@property
	def bAttach(self) -> bool: ...
	"""Attach"""

	pass

class InterpTrackToggle(InterpTrack):
	"""Interp Track Toggle"""

	@property
	def ToggleTrack(self) -> typing.List[unsupported]: ...
	"""Array of events to fire off."""

	@property
	def bActivateSystemEachUpdate(self) -> bool: ...
	"""If true, the track will call ActivateSystem on the emitter each update (the old 'incorrect' behavior).
If false (the default), the System will only be activated if it was previously inactive."""

	@property
	def bActivateWithJustAttachedFlag(self) -> bool: ...
	"""If true, the track will activate the system w/ the 'Just Attached' flag."""

	@property
	def bFireEventsWhenForwards(self) -> bool: ...
	"""If events should be fired when passed playing the sequence forwards."""

	@property
	def bFireEventsWhenBackwards(self) -> bool: ...
	"""If events should be fired when passed playing the sequence backwards."""

	@property
	def bFireEventsWhenJumpingForwards(self) -> bool: ...
	"""If true, events on this track are fired even when jumping forwads through a sequence - for example, skipping a cinematic."""

	pass

class InterpTrackVectorMaterialParam(InterpTrackVectorBase):
	"""Interp Track Vector Material Param"""

	@property
	def TargetMaterials(self) -> typing.List[MaterialInterface]: ...
	"""Materials whose parameters we want to change and the references to those materials."""

	@property
	def ParamName(self) -> str: ...
	"""Name of parameter in the MaterialInstance which this track will modify over time."""

	pass

class InterpTrackVectorProp(InterpTrackVectorBase):
	"""Interp Track Vector Prop"""

	@property
	def PropertyName(self) -> str: ...
	"""Name of property in Group  AActor  which this track mill modify over time."""

	pass

class InterpTrackVisibility(InterpTrack):
	"""Interp Track Visibility"""

	@property
	def VisibilityTrack(self) -> typing.List[unsupported]: ...
	"""Array of events to fire off."""

	@property
	def bFireEventsWhenForwards(self) -> bool: ...
	"""If events should be fired when passed playing the sequence forwards."""

	@property
	def bFireEventsWhenBackwards(self) -> bool: ...
	"""If events should be fired when passed playing the sequence backwards."""

	@property
	def bFireEventsWhenJumpingForwards(self) -> bool: ...
	"""If true, events on this track are fired even when jumping forwads through a sequence - for example, skipping a cinematic."""

	pass

class MatineeActor(Actor):
	"""Matinee Actor"""

	@property
	def MatineeData(self) -> InterpData: ...
	"""The matinee data used by this actor"""

	@property
	def MatineeControllerName(self) -> str: ...
	"""Name of controller node in level script, used to know what function to try and find for events"""

	@property
	def PlayRate(self) -> float: ...
	"""Time multiplier for playback."""

	@property
	def bPlayOnLevelLoad(self) -> bool: ...
	"""If true, the matinee will play when the level is loaded."""

	@property
	def bForceStartPos(self) -> bool: ...
	"""Lets you force the sequence to always start at ForceStartPosition"""

	@property
	def ForceStartPosition(self) -> float: ...
	"""Time position to always start at if bForceStartPos is set to true."""

	@property
	def bLooping(self) -> bool: ...
	"""If sequence should pop back to beginning when finished.
Note, if true, will never get Completed/Reversed events - sequence must be explicitly Stopped."""

	@property
	def bRewindOnPlay(self) -> bool: ...
	"""If true, sequence will rewind itself back to the start each time the Play input is activated."""

	@property
	def bNoResetOnRewind(self) -> bool: ...
	"""If true, when rewinding this interpolation, reset the 'initial positions' of any RelateToInitial movements to the current location.
This allows the next loop of movement to proceed from the current locations."""

	@property
	def bRewindIfAlreadyPlaying(self) -> bool: ...
	"""Only used if bRewindOnPlay if true. Defines what should happen if the Play input is activated while currently playing.
If true, hitting Play while currently playing will pop the position back to the start and begin playback over again.
If false, hitting Play while currently playing will do nothing."""

	@property
	def bDisableRadioFilter(self) -> bool: ...
	"""If true, disables the realtime radio effect"""

	@property
	def bClientSideOnly(self) -> bool: ...
	"""Indicates that this interpolation does not affect gameplay. This means that:
-it is not replicated via MatineeActor
-it is not ticked if no affected Actors are visible
-on dedicated servers, it is completely ignored"""

	@property
	def bSkipUpdateIfNotVisible(self) -> bool: ...
	"""if bClientSideOnly is true, whether this matinee should be completely skipped if none of the affected Actors are visible"""

	@property
	def bIsSkippable(self) -> bool: ...
	"""Lets you skip the matinee with the CANCELMATINEE exec command. Triggers all events to the end along the way."""

	@property
	def PreferredSplitScreenNum(self) -> int: ...
	"""Preferred local viewport number (when split screen is active) the director track should associate with, or zero for 'all'."""

	@property
	def bDisableMovementInput(self) -> bool: ...
	"""Disable Input from player during play"""

	@property
	def bDisableLookAtInput(self) -> bool: ...
	"""Disable LookAt Input from player during play"""

	@property
	def bHidePlayer(self) -> bool: ...
	"""Hide Player Pawn during play"""

	@property
	def bHideHud(self) -> bool: ...
	"""Hide HUD during play"""

	@property
	def GroupActorInfos(self) -> typing.List[unsupported]: ...
	"""@todo UE4 matinee - shouldnt be directly editable.  Needs a nice interface in matinee"""

	@property
	def bShouldShowGore(self) -> bool: ...
	"""Cached value that indicates whether or not gore was enabled when the sequence was started"""

	@property
	def GroupInst(self) -> typing.List[unsupported]: ...
	"""Instance data for interp groups. One for each variable/group combination."""

	@property
	def CameraCuts(self) -> typing.List[unsupported]: ...
	"""Contains the camera world-position for each camera cut in the cinematic."""

	@property
	def bIsPlaying(self) -> bool: ...
	"""properties that may change on InterpAction that we need to notify clients about, since the object's properties will not be replicated"""

	@property
	def bReversePlayback(self) -> bool: ...
	"""Reverse Playback"""

	@property
	def bPaused(self) -> bool: ...
	"""Paused"""

	@property
	def bPendingStop(self) -> bool: ...
	"""The below property is deprecated and will be removed in 4.9."""

	@property
	def InterpPosition(self) -> float: ...
	"""Interp Position"""

	@property
	def OnPlay(self) -> typing.Any: ...
	"""Event triggered when the matinee is played for whatever reason"""

	@property
	def OnStop(self) -> typing.Any: ...
	"""Event triggered when the matinee is stopped for whatever reason"""

	@property
	def OnPause(self) -> typing.Any: ...
	"""Event triggered when the matinee is paused for whatever reason"""

	def EnableGroupByName(self, GroupName: str, bEnable: bool): ...
	"""Enable Group by Name"""

	def SetLoopingState(self, bNewLooping: bool): ...
	"""Change the looping behaviour of this matinee"""

	def ChangePlaybackDirection(self): ...
	"""Changes the direction of playback (go in reverse if it was going forward, or vice versa)"""

	def SetPosition(self, NewPosition: float, bJump: bool = ...): ...
	"""Set the position of the interpolation.
@note if the interpolation is not currently active, this function doesn't send any Kismet events
@param NewPosition the new position to set the interpolation to
@param bJump if true, teleport to the new position (don't trigger any events between the old and new positions, etc)"""

	def Pause(self): ...
	"""Hold playback at its current position. Calling Pause again will continue playback in its current direction."""

	def Reverse(self): ...
	"""Similar to play, but the playback will go backwards until the beginning of the sequence is reached."""

	def Stop(self): ...
	"""Stops playback at the current position"""

	def Play(self): ...
	"""Begin playback of the matinee. Only called in game.
Will then advance Position by (PlayRate * Deltatime) each time the matinee is ticked."""

	pass

class MatineeActorCameraAnim(MatineeActor):
	"""Actor used to control temporary matinees for camera anims that only exist in the editor"""

	@property
	def CameraAnim(self) -> CameraAnim: ...
	"""The camera anim we are editing"""

	pass

class Emitter(Actor):
	"""Emitter"""

	@property
	def bDestroyOnSystemFinish(self) -> bool: ...
	"""Destroy on System Finish"""

	@property
	def bPostUpdateTickGroup(self) -> bool: ...
	"""Post Update Tick Group"""

	@property
	def bCurrentlyActive(self) -> bool: ...
	"""used to update status of toggleable level placed emitters on clients"""

	@property
	def OnParticleSpawn(self) -> typing.Any: ...
	"""On Particle Spawn"""

	@property
	def OnParticleBurst(self) -> typing.Any: ...
	"""On Particle Burst"""

	@property
	def OnParticleDeath(self) -> typing.Any: ...
	"""On Particle Death"""

	@property
	def OnParticleCollide(self) -> typing.Any: ...
	"""On Particle Collide"""

	def OnRep_bCurrentlyActive(self): ...
	"""Replication Notification Callbacks"""

	def OnParticleSystemFinished(self, FinishedComponent: ParticleSystemComponent): ...
	"""On Particle System Finished"""

	pass

class EmitterCameraLensEffectBase(Emitter):
	"""Emitter Camera Lens Effect Base"""

	@property
	def BaseFOV(self) -> float: ...
	"""This is the assumed FOV for which the effect was authored. The code will make automatic adjustments to make it look the same at different FOVs"""

	@property
	def bAllowMultipleInstances(self) -> bool: ...
	"""true if multiple instances of this emitter can exist simultaneously, false otherwise."""

	@property
	def bResetWhenRetriggered(self) -> bool: ...
	"""If bAllowMultipleInstances is true and this effect is retriggered, the particle system will be reset if this is true"""

	@property
	def EmittersToTreatAsSame(self) -> typing.List[EmitterCameraLensEffectBase]: ...
	"""If an emitter class in this array is currently playing, do not play this effect.
Useful for preventing multiple similar or expensive camera effects from playing simultaneously."""

	pass

class ParticleModule(Object):
	"""Particle Module"""

	@property
	def bSpawnModule(self) -> bool: ...
	"""If true, the module performs operations on particles during Spawning"""

	@property
	def bUpdateModule(self) -> bool: ...
	"""If true, the module performs operations on particles during Updating"""

	@property
	def bFinalUpdateModule(self) -> bool: ...
	"""If true, the module performs operations on particles during final update"""

	@property
	def bUpdateForGPUEmitter(self) -> bool: ...
	"""If true, the module performs operations on particles during update and/or final update for GPU emitters"""

	@property
	def bCurvesAsColor(self) -> bool: ...
	"""If true, the module displays FVector curves as colors"""

	@property
	def b3DDrawMode(self) -> bool: ...
	"""If true, the module should render its 3D visualization helper"""

	@property
	def bSupported3DDrawMode(self) -> bool: ...
	"""If true, the module supports rendering a 3D visualization helper"""

	@property
	def bEnabled(self) -> bool: ...
	"""If true, the module is enabled"""

	@property
	def bEditable(self) -> bool: ...
	"""If true, the module has had editing enabled on it"""

	@property
	def LODDuplicate(self) -> bool: ...
	"""If true, this flag indicates that auto-generation for LOD will result in
an exact duplicate of the module, regardless of the percentage.
If false, it will result in a module with different settings."""

	@property
	def bSupportsRandomSeed(self) -> bool: ...
	"""If true, the module supports RandomSeed setting"""

	@property
	def bRequiresLoopingNotification(self) -> bool: ...
	"""If true, the module should be told when looping"""

	@property
	def LODValidity(self) -> int: ...
	"""The LOD levels this module is present in.
Bit-flags are used to indicate validity for a given LOD level.
For example, if
        ((1 << Level) & LODValidity) != 0
then the module is used in that LOD."""

	pass

class ParticleModuleLight(ParticleModuleLightBase):
	"""Particle Module Light"""

	@property
	def bUseInverseSquaredFalloff(self) -> bool: ...
	"""Whether to use physically based inverse squared falloff from the light.  If unchecked, the LightExponent distribution will be used instead."""

	@property
	def bAffectsTranslucency(self) -> bool: ...
	"""Whether lights from this module should affect translucency.
Use with caution.  Modules enabling this should only make a few particle lights at most, and the smaller they are, the less they will cost."""

	@property
	def bPreviewLightRadius(self) -> bool: ...
	"""Will draw wireframe spheres to preview the light radius if enabled.
Note: this is intended for previewing and the value will not be saved, it will always revert to disabled."""

	@property
	def SpawnFraction(self) -> float: ...
	"""Fraction of particles in this emitter to create lights on."""

	@property
	def ColorScaleOverLife(self) -> typing.Any: ...
	"""Scale that is applied to the particle's color to calculate the light's color, and can be setup as a curve over the particle's lifetime."""

	@property
	def BrightnessOverLife(self) -> typing.Any: ...
	"""Brightness scale for the light, which can be setup as a curve over the particle's lifetime."""

	@property
	def RadiusScale(self) -> typing.Any: ...
	"""Scales the particle's radius, to calculate the light's radius."""

	@property
	def LightExponent(self) -> typing.Any: ...
	"""Provides the light's exponent when inverse squared falloff is disabled."""

	@property
	def LightingChannels(self) -> LightingChannels: ...
	"""Channels that this light should affect.
Only affect high quality lights
These channels only apply to opaque materials, direct lighting, and dynamic lighting and shadowing."""

	@property
	def VolumetricScatteringIntensity(self) -> float: ...
	"""Intensity of the volumetric scattering from this light.  This scales Intensity and LightColor."""

	@property
	def bHighQualityLights(self) -> bool: ...
	"""Converts the particle lights into high quality lights as if they came from a PointLightComponent.  High quality lights cost significantly more on both CPU and GPU."""

	@property
	def bShadowCastingLights(self) -> bool: ...
	"""Whether to cast shadows from the particle lights.  Requires High Quality Lights to be enabled.
Warning: This can be incredibly expensive on the GPU - use with caution."""

	pass

class ParticleModuleLight_Seeded(ParticleModuleLight):
	"""Particle Module Light Seeded"""

	@property
	def RandomSeedInfo(self) -> typing.Any: ...
	"""The random seed(s) to use for looking up values in StartLocation"""

	pass

class FXSystemAsset(Object):
	"""FXSystem Asset"""

	@property
	def MaxPoolSize(self) -> int: ...
	"""Max number of components of this system to keep resident in the world component pool."""

	@property
	def PoolPrimeSize(self) -> int: ...
	"""How many instances we should use to initially prime the pool.
This can amortize runtime activation cost by moving it to load time.
Use with care as this could cause large hitches for systems loaded/unloaded during play rather than at level load."""

	pass

class ParticleSystem(FXSystemAsset):
	"""A ParticleSystem is a complete particle effect that contains any number of ParticleEmitters. By allowing multiple emitters
in a system, the designer can create elaborate particle effects that are held in a single system. Once created using
Cascade, a ParticleSystem can then be inserted into a level or created in script."""

	@property
	def UpdateTime_FPS(self) -> float: ...
	"""UpdateTime_FPS - the frame per second to update at in FixedTime mode"""

	@property
	def UpdateTime_Delta(self) -> float: ...
	"""UpdateTime_Delta       - internal"""

	@property
	def WarmupTime(self) -> float: ...
	"""WarmupTime - the time to warm-up the particle system when first rendered
Warning: WarmupTime is implemented by simulating the particle system for the time requested upon activation.
This is extremely prone to cause hitches, especially with large particle counts - use with caution."""

	@property
	def WarmupTickRate(self) -> float: ...
	"""WarmupTickRate - the time step for each tick during warm up.
       Increasing this improves performance. Decreasing, improves accuracy.
       Set to 0 to use the default tick time."""

	@property
	def Emitters(self) -> typing.List[unsupported]: ...
	"""Emitters       - internal - the array of emitters in the system"""

	@property
	def PreviewComponent(self) -> ParticleSystemComponent: ...
	"""The component used to preview the particle system in Cascade"""

	@property
	def CurveEdSetup(self) -> typing.Any: ...
	"""Used for curve editor to remember curve-editing setup."""

	@property
	def LODDistanceCheckTime(self) -> float: ...
	"""How often (in seconds) the system should perform the LOD distance check."""

	@property
	def MacroUVRadius(self) -> float: ...
	"""World space radius that UVs generated with the ParticleMacroUV material node will tile based on."""

	@property
	def LODDistances(self) -> typing.List[float]: ...
	"""The array of distances for each LOD level in the system.
Used when LODMethod is set to PARTICLESYSTEMLODMETHOD_Automatic.

Example: System with 3 LOD levels
        LODDistances(0) = 0.0
        LODDistances(1) = 2500.0
        LODDistances(2) = 5000.0

        In this case, when the system is [   0.0 ..   2499.9] from the camera, LOD level 0 will be used.
                                                                         [2500.0 ..   4999.9] from the camera, LOD level 1 will be used.
                                                                         [5000.0 .. INFINITY] from the camera, LOD level 2 will be used."""

	@property
	def LODSettings(self) -> typing.List[unsupported]: ...
	"""LODSettings"""

	@property
	def FixedRelativeBoundingBox(self) -> Box: ...
	"""Fixed relative bounding box for particle system."""

	@property
	def SecondsBeforeInactive(self) -> float: ...
	"""Number of seconds of emitter not being rendered that need to pass before it
no longer gets ticked/ becomes inactive."""

	@property
	def Delay(self) -> float: ...
	"""How long this Particle system should delay when ActivateSystem is called on it."""

	@property
	def DelayLow(self) -> float: ...
	"""The low end of the emitter delay if using a range."""

	@property
	def bOrientZAxisTowardCamera(self) -> bool: ...
	"""If true, the system's Z axis will be oriented toward the camera"""

	@property
	def bUseFixedRelativeBoundingBox(self) -> bool: ...
	"""Whether to use the fixed relative bounding box or calculate it every frame."""

	@property
	def bShouldResetPeakCounts(self) -> bool: ...
	"""EDITOR ONLY: Indicates that Cascade would like to have the PeakActiveParticles count reset"""

	@property
	def bHasPhysics(self) -> bool: ...
	"""Set during load time to indicate that physics is used..."""

	@property
	def bUseRealtimeThumbnail(self) -> bool: ...
	"""Inidicates the old 'real-time' thumbnail rendering should be used"""

	@property
	def ThumbnailImageOutOfDate(self) -> bool: ...
	"""Internal: Indicates the PSys thumbnail image is out of date"""

	@property
	def bUseDelayRange(self) -> bool: ...
	"""If true, select the emitter delay from the range
        [DelayLow..Delay]"""

	@property
	def bAllowManagedTicking(self) -> bool: ...
	"""Whether or not to allow instances of this system to have their ticks managed."""

	@property
	def bAutoDeactivate(self) -> bool: ...
	"""Auto-deactivate system if all emitters are determined to not spawn particles again, regardless of lifetime."""

	@property
	def bRegenerateLODDuplicate(self) -> bool: ...
	"""Internal value that tracks the regenerate LOD levels preference.
If true, when autoregenerating LOD levels in code, the low level will
be a duplicate of the high."""

	@property
	def SystemUpdateMode(self) -> int: ...
	"""System Update Mode"""

	@property
	def LODMethod(self) -> int: ...
	"""The method of LOD level determination to utilize for this particle system
  PARTICLESYSTEMLODMETHOD_Automatic - Automatically set the LOD level, checking every LODDistanceCheckTime seconds.
PARTICLESYSTEMLODMETHOD_DirectSet - LOD level is directly set by the game code.
PARTICLESYSTEMLODMETHOD_ActivateAutomatic - LOD level is determined at Activation time, then left alone unless directly set by game code."""

	@property
	def InsignificantReaction(self) -> int: ...
	"""The reaction this system takes when all emitters are insignificant."""

	@property
	def OcclusionBoundsMethod(self) -> int: ...
	"""Which occlusion bounds method to use for this particle system.
EPSOBM_None - Don't determine occlusion for this system.
EPSOBM_ParticleBounds - Use the bounds of the component when determining occlusion."""

	@property
	def MaxSignificanceLevel(self) -> int: ...
	"""The maximum level of significance for emitters in this system. Any emitters with a higher significance will be capped at this significance level."""

	@property
	def MinTimeBetweenTicks(self) -> int: ...
	"""Minimum duration between ticks; 33=tick at max. 30FPS, 16=60FPS, 8=120FPS"""

	@property
	def InsignificanceDelay(self) -> float: ...
	"""Time delay between all emitters becoming insignificant and the systems insignificant reaction."""

	@property
	def MacroUVPosition(self) -> Vector: ...
	"""Local space position that UVs generated with the ParticleMacroUV material node will be centered on."""

	@property
	def CustomOcclusionBounds(self) -> Box: ...
	"""The occlusion bounds to use if OcclusionBoundsMethod is set to EPSOBM_CustomBounds"""

	@property
	def SoloTracking(self) -> typing.List[unsupported]: ...
	"""Solo Tracking"""

	@property
	def NamedMaterialSlots(self) -> typing.List[unsupported]: ...
	"""Array of named material slots for use by emitters of this system.
Emitters can use these instead of their own materials by providing the name to the NamedMaterialOverrides property of their required module.
These materials can be overridden using CreateNamedDynamicMaterialInstance() on a ParticleSystemComponent."""

	pass

class FXSystemComponent(PrimitiveComponent):
	"""FXSystem Component"""

	def ReleaseToPool(self): ...
	"""Deactivates this system and releases it to the pool on completion.
Usage of this PSC reference after this call is unsafe.
You should clear out your references to it."""

	def SetUseAutoManageAttachment(self, bAutoManage: bool): ...
	"""Sets whether we should automatically attach to AutoAttachParent when activated, and detach from our parent when completed.
This overrides any current attachment that may be present at the time of activation (deferring initial attachment until activation, if AutoAttachParent is null).
When enabled, detachment occurs regardless of whether AutoAttachParent is assigned, and the relative transform from the time of activation is restored.
This also disables attachment on dedicated servers, where we don't actually activate even if bAutoActivate is true.
@see SetAutoAttachmentParameters()"""

	def SetAutoAttachmentParameters(self, Parent: SceneComponent, SocketName: str, LocationRule: int, RotationRule: int, ScaleRule: int): ...
	"""Set AutoAttachParent, AutoAttachSocketName, AutoAttachLocationRule, AutoAttachRotationRule, AutoAttachScaleRule to the specified parameters. Does not change bAutoManageAttachment; that must be set separately.
@param  Parent                       Component to attach to.
@param  SocketName           Socket on Parent to attach to.
@param  LocationRule         Option for how we handle our location when we attach to Parent.
@param  RotationRule         Option for how we handle our rotation when we attach to Parent.
@param  ScaleRule            Option for how we handle our scale when we attach to Parent.
@see bAutoManageAttachment, AutoAttachParent, AutoAttachSocketName, AutoAttachLocationRule, AutoAttachRotationRule, AutoAttachScaleRule"""

	def SetEmitterEnable(self, EmitterName: str, bNewEnableState: bool): ...
	"""Enables/Disables a sub-emitter

@param  EmitterName                     The name of the sub-emitter to set it on
@param  bNewEnableState         The value to set it to"""

	def GetFXSystemAsset(self) -> FXSystemAsset: ...
	"""Get the referenced FXSystem asset."""

	def SetActorParameter(self, ParameterName: str, Param: Actor): ...
	"""Set a named actor instance parameter on this ParticleSystemComponent.
Updates the parameter if it already exists, or creates a new entry if not."""

	def SetColorParameter(self, ParameterName: str, Param: LinearColor): ...
	"""Set a named color instance parameter on this ParticleSystemComponent.
Updates the parameter if it already exists, or creates a new entry if not."""

	def SetVectorParameter(self, ParameterName: str, Param: Vector): ...
	"""Set a named vector instance parameter on this ParticleSystemComponent.
Updates the parameter if it already exists, or creates a new entry if not."""

	def SetFloatParameter(self, ParameterName: str, Param: float): ...
	"""Change a named float parameter"""

	def SetIntParameter(self, ParameterName: str, Param: int): ...
	"""Change a named int parameter"""

	def SetBoolParameter(self, ParameterName: str, Param: bool): ...
	"""Change a named boolean parameter, ParticleSystemComponent converts to float."""

	pass

class ParticleSystemComponent(FXSystemComponent):
	"""A particle emitter."""

	@property
	def Template(self) -> ParticleSystem: ...
	"""Template"""

	@property
	def EmitterMaterials(self) -> typing.List[MaterialInterface]: ...
	"""Emitter Materials"""

	@property
	def SkelMeshComponents(self) -> typing.List[SkeletalMeshComponent]: ...
	"""The skeletal mesh components used with the socket location module.
This is to prevent them from being garbage collected."""

	@property
	def bResetOnDetach(self) -> bool: ...
	"""Reset on Detach"""

	@property
	def bUpdateOnDedicatedServer(self) -> bool: ...
	"""whether to update the particle system on dedicated servers"""

	@property
	def bAllowRecycling(self) -> bool: ...
	"""If true, this Particle System will be available for recycling after it has completed. Auto-destroyed systems cannot be recycled.
Some systems (currently particle trail effects) can recycle components to avoid respawning them to play new effects.
This is only an optimization and does not change particle system behavior, aside from not triggering normal component initialization events more than once."""

	@property
	def bAutoManageAttachment(self) -> bool: ...
	"""True if we should automatically attach to AutoAttachParent when activated, and detach from our parent when completed.
This overrides any current attachment that may be present at the time of activation (deferring initial attachment until activation, if AutoAttachParent is null).
When enabled, detachment occurs regardless of whether AutoAttachParent is assigned, and the relative transform from the time of activation is restored.
This also disables attachment on dedicated servers, where we don't actually activate even if bAutoActivate is true.
See: AutoAttachParent, AutoAttachSocketName, AutoAttachLocationType"""

	@property
	def bAutoAttachWeldSimulatedBodies(self) -> bool: ...
	"""Option for how we handle bWeldSimulatedBodies when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
See: bAutoManageAttachment"""

	@property
	def bWarmingUp(self) -> bool: ...
	"""Warming Up"""

	@property
	def bOverrideLODMethod(self) -> bool: ...
	"""indicates that the component's LODMethod overrides the Template's"""

	@property
	def bSkipUpdateDynamicDataDuringTick(self) -> bool: ...
	"""Flag indicating that dynamic updating of render data should NOT occur during Tick.
This is used primarily to allow for warming up and simulated effects to a certain state."""

	@property
	def LODMethod(self) -> int: ...
	"""The method of LOD level determination to utilize for this particle system"""

	@property
	def RequiredSignificance(self) -> int: ...
	"""The significance this component requires of it's emitters for them to be enabled."""

	@property
	def InstanceParameters(self) -> typing.List[ParticleSysParam]: ...
	"""Array holding name instance parameters for this ParticleSystemComponent.
Parameters can be used in Cascade using DistributionFloat/VectorParticleParameters."""

	@property
	def OnParticleSpawn(self) -> typing.Any: ...
	"""On Particle Spawn"""

	@property
	def OnParticleBurst(self) -> typing.Any: ...
	"""On Particle Burst"""

	@property
	def OnParticleDeath(self) -> typing.Any: ...
	"""On Particle Death"""

	@property
	def OnParticleCollide(self) -> typing.Any: ...
	"""On Particle Collide"""

	@property
	def bOldPositionValid(self) -> bool: ...
	"""Old Position Valid"""

	@property
	def OldPosition(self) -> Vector: ...
	"""Old Position"""

	@property
	def PartSysVelocity(self) -> Vector: ...
	"""Part Sys Velocity"""

	@property
	def WarmupTime(self) -> float: ...
	"""Warmup Time"""

	@property
	def WarmupTickRate(self) -> float: ...
	"""Warmup Tick Rate"""

	@property
	def SecondsBeforeInactive(self) -> float: ...
	"""Number of seconds of emitter not being rendered that need to pass before it
no longer gets ticked/ becomes inactive."""

	@property
	def MaxTimeBeforeForceUpdateTransform(self) -> float: ...
	"""Time between forced UpdateTransforms for systems that use dynamically calculated bounds,
Which is effectively how often the bounds are shrunk."""

	@property
	def ReplayClips(self) -> typing.List[unsupported]: ...
	"""Array of replay clips for this particle system component.  These are serialized to disk.  You really should never add anything to this in the editor.  It's exposed so that you can delete clips if you need to, but be careful when doing so!"""

	@property
	def CustomTimeDilation(self) -> float: ...
	"""Scales DeltaTime in UParticleSystemComponent::Tick(...)"""

	@property
	def AutoAttachParent(self) -> SceneComponent: ...
	"""Component we automatically attach to when activated, if bAutoManageAttachment is true.
If null during registration, we assign the existing AttachParent and defer attachment until we activate.
See: bAutoManageAttachment"""

	@property
	def AutoAttachSocketName(self) -> str: ...
	"""Socket we automatically attach to on the AutoAttachParent, if bAutoManageAttachment is true.
If no auto attach socket name is set during registration, the current attach socket will be
assigned to AutoAttachSocketName and used when activated.
See: bAutoManageAttachment"""

	@property
	def AutoAttachLocationRule(self) -> int: ...
	"""Options for how we handle our location when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
See: bAutoManageAttachment, EAttachmentRule"""

	@property
	def AutoAttachRotationRule(self) -> int: ...
	"""Options for how we handle our rotation when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
See: bAutoManageAttachment, EAttachmentRule"""

	@property
	def AutoAttachScaleRule(self) -> int: ...
	"""Options for how we handle our scale when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
See: bAutoManageAttachment, EAttachmentRule"""

	@property
	def OnSystemFinished(self) -> typing.Any: ...
	"""Called when the particle system is done"""

	def GenerateParticleEvent(self, InEventName: str, InEmitterTime: float, InLocation: Vector, InDirection: Vector, InVelocity: Vector): ...
	"""Record a kismet event.

@param  InEventName                             The name of the event that fired.
@param  InEmitterTime                   The emitter time when the event fired.
@param  InLocation                              The location of the particle when the event fired.
@param  InVelocity                              The velocity of the particle when the event fired.
@param  InNormal                                Normal vector of the collision in coordinate system of the returner. Zero=none."""

	def GetNamedMaterial(self, InName: str) -> MaterialInterface: ...
	"""Returns a named material. If this named material is not found, returns NULL."""

	def CreateNamedDynamicMaterialInstance(self, InName: str, SourceMaterial: MaterialInterface = ...) -> MaterialInstanceDynamic: ...
	"""Creates a Dynamic Material Instance for the specified named material override, optionally from the supplied material.
@param Name - The slot name of the material to replace.  If invalid, the material is unchanged and NULL is returned."""

	def SetTrailSourceData(self, InFirstSocketName: str, InSecondSocketName: str, InWidthMode: int, InWidth: float): ...
	"""Sets the defining data for all trails in this component.

@param        InFirstSocketName       The name of the first socket for the trail.
@param        InSecondSocketName      The name of the second socket for the trail.
@param        InWidthMode                     How the width value is applied to the trail.
@param        InWidth                         The width of the trail."""

	def EndTrails(self): ...
	"""Ends all trail emitters in this component."""

	def BeginTrails(self, InFirstSocketName: str, InSecondSocketName: str, InWidthMode: int, InWidth: float): ...
	"""Begins all trail emitters in this component.

@param        InFirstSocketName       The name of the first socket for the trail.
@param        InSecondSocketName      The name of the second socket for the trail.
@param        InWidthMode                     How the width value is applied to the trail.
@param        InWidth                         The width of the trail."""

	def GetNumActiveParticles(self) -> int: ...
	"""Get the current number of active particles in this system"""

	def SetTemplate(self, NewTemplate: ParticleSystem): ...
	"""Change the ParticleSystem used by this ParticleSystemComponent"""

	def SetMaterialParameter(self, ParameterName: str, Param: MaterialInterface): ...
	"""Set a named material instance parameter on this ParticleSystemComponent.
Updates the parameter if it already exists, or creates a new entry if not."""

	def GetBeamTargetStrength(self, EmitterIndex: int, TargetIndex: int) -> typing.Tuple[bool, float]: ...
	"""Get the beam target strength

@param  EmitterIndex            The index of the emitter to get
@param  TargetIndex                     Which beam within the emitter to get
@param  OutTargetStrength       Value of target tangent

@return true            EmitterIndex and TargetIndex are valid - OutTargetStrength is valid
                false           EmitterIndex or TargetIndex is invalid - OutTargetStrength is invalid"""

	def GetBeamTargetTangent(self, EmitterIndex: int, TargetIndex: int) -> typing.Tuple[bool, Vector]: ...
	"""Get the beam target tangent

@param  EmitterIndex            The index of the emitter to get
@param  TargetIndex                     Which beam within the emitter to get
@param  OutTangentPoint         Value of target tangent

@return true            EmitterIndex and TargetIndex are valid - OutTangentPoint is valid
                false           EmitterIndex or TargetIndex is invalid - OutTangentPoint is invalid"""

	def GetBeamTargetPoint(self, EmitterIndex: int, TargetIndex: int) -> typing.Tuple[bool, Vector]: ...
	"""Get the beam target point

@param  EmitterIndex            The index of the emitter to get
@param  TargetIndex                     Which beam within the emitter to get
@param  OutTargetPoint          Value of target point

@return true            EmitterIndex and TargetIndex are valid - OutTargetPoint is valid
                false           EmitterIndex or TargetIndex is invalid - OutTargetPoint is invalid"""

	def GetBeamSourceStrength(self, EmitterIndex: int, SourceIndex: int) -> typing.Tuple[bool, float]: ...
	"""Get the beam source strength

@param  EmitterIndex            The index of the emitter to get
@param  SourceIndex                     Which beam within the emitter to get
@param  OutSourceStrength               Value of source tangent

@return true            EmitterIndex and SourceIndex are valid - OutSourceStrength is valid
                false           EmitterIndex or SourceIndex is invalid - OutSourceStrength is invalid"""

	def GetBeamSourceTangent(self, EmitterIndex: int, SourceIndex: int) -> typing.Tuple[bool, Vector]: ...
	"""Get the beam source tangent

@param  EmitterIndex            The index of the emitter to get
@param  SourceIndex                     Which beam within the emitter to get
@param  OutTangentPoint         Value of source tangent

@return true            EmitterIndex and SourceIndex are valid - OutTangentPoint is valid
                false           EmitterIndex or SourceIndex is invalid - OutTangentPoint is invalid"""

	def GetBeamSourcePoint(self, EmitterIndex: int, SourceIndex: int) -> typing.Tuple[bool, Vector]: ...
	"""Get the beam source point

@param  EmitterIndex            The index of the emitter to get
@param  SourceIndex                     Which beam within the emitter to get
@param  OutSourcePoint          Value of source point

@return true            EmitterIndex and SourceIndex are valid - OutSourcePoint is valid
                false           EmitterIndex or SourceIndex is invalid - OutSourcePoint is invalid"""

	def GetBeamEndPoint(self, EmitterIndex: int) -> typing.Tuple[bool, Vector]: ...
	"""Get the beam end point

@param  EmitterIndex            The index of the emitter to get the value of

@return true            EmitterIndex is valid and End point is set - OutEndPoint is valid
                false           EmitterIndex invalid or End point is not set - OutEndPoint is invalid"""

	def SetBeamTargetStrength(self, EmitterIndex: int, NewTargetStrength: float, TargetIndex: int): ...
	"""Set the beam target strength

@param  EmitterIndex            The index of the emitter to set it on
@param  NewTargetStrength       The value to set it to
@param  TargetIndex                     Which beam within the emitter to set it on"""

	def SetBeamTargetTangent(self, EmitterIndex: int, NewTangentPoint: Vector, TargetIndex: int): ...
	"""Set the beam target tangent

@param  EmitterIndex            The index of the emitter to set it on
@param  NewTangentPoint         The value to set it to
@param  TargetIndex                     Which beam within the emitter to set it on"""

	def SetBeamTargetPoint(self, EmitterIndex: int, NewTargetPoint: Vector, TargetIndex: int): ...
	"""Set the beam target point

@param  EmitterIndex            The index of the emitter to set it on
@param  NewTargetPoint          The value to set it to
@param  TargetIndex                     Which beam within the emitter to set it on"""

	def SetBeamSourceStrength(self, EmitterIndex: int, NewSourceStrength: float, SourceIndex: int): ...
	"""Set the beam source strength

@param  EmitterIndex            The index of the emitter to set it on
@param  NewSourceStrength       The value to set it to
@param  SourceIndex                     Which beam within the emitter to set it on"""

	def SetBeamSourceTangent(self, EmitterIndex: int, NewTangentPoint: Vector, SourceIndex: int): ...
	"""Set the beam source tangent

@param  EmitterIndex            The index of the emitter to set it on
@param  NewTangentPoint         The value to set it to
@param  SourceIndex                     Which beam within the emitter to set it on"""

	def SetBeamSourcePoint(self, EmitterIndex: int, NewSourcePoint: Vector, SourceIndex: int): ...
	"""Set the beam source point

@param  EmitterIndex            The index of the emitter to set it on
@param  NewSourcePoint          The value to set it to
@param  SourceIndex                     Which beam within the emitter to set it on"""

	def SetBeamEndPoint(self, EmitterIndex: int, NewEndPoint: Vector): ...
	"""Set the beam end point

@param  EmitterIndex            The index of the emitter to set it on
@param  NewEndPoint                     The value to set it to"""

	pass

class PhysicalMaterialMask(Object):
	"""Physical material masks are used to map multiple physical materials to a single rendering material"""

	@property
	def UVChannelIndex(self) -> int: ...
	"""StaticMesh UV channel index to use when performing lookups with this mask."""

	@property
	def AddressX(self) -> int: ...
	"""The addressing mode to use for the X axis."""

	@property
	def AddressY(self) -> int: ...
	"""The addressing mode to use for the Y axis."""

	pass

class PhysicalAnimationComponent(ActorComponent):
	"""Physical Animation Component"""

	@property
	def StrengthMultiplyer(self) -> float: ...
	"""Multiplies the strength of any active motors. (can blend from 0-1 for example)"""

	def GetBodyTargetTransform(self, BodyName: str) -> Transform: ...
	"""Returns the target transform for the given body. If physical animation component is not controlling this body, returns its current transform."""

	def ApplyPhysicalAnimationProfileBelow(self, BodyName: str, ProfileName: str, bIncludeSelf: bool = ..., bClearNotFound: bool = ...): ...
	"""Applies the physical animation profile to the body given and all bodies below.
@param  BodyName                     The body from which we'd like to start applying the physical animation profile. Finds all bodies below in the skeleton hierarchy. None implies all bodies
@param  ProfileName          The physical animation profile we'd like to apply. For each body in the physics asset we search for physical animation settings with this name.
@param  bIncludeSelf         Whether to include the provided body name in the list of bodies we act on (useful to ignore for cases where a root has multiple children)
@param  bClearNotFound       If true, bodies without the given profile name will have any existing physical animation settings cleared. If false, bodies without the given profile name are left untouched."""

	def SetStrengthMultiplyer(self, InStrengthMultiplyer: float): ...
	"""Updates strength multiplyer and any active motors"""

	def ApplyPhysicalAnimationSettingsBelow(self, BodyName: str, PhysicalAnimationData: PhysicalAnimationData, bIncludeSelf: bool = ...): ...
	"""Applies the physical animation settings to the body given and all bodies below."""

	def ApplyPhysicalAnimationSettings(self, BodyName: str, PhysicalAnimationData: PhysicalAnimationData): ...
	"""Applies the physical animation settings to the body given."""

	def SetSkeletalMeshComponent(self, InSkeletalMeshComponent: SkeletalMeshComponent): ...
	"""Sets the skeletal mesh we are driving through physical animation. Will erase any existing physical animation data."""

	pass

class PhysicsAsset(Object):
	"""PhysicsAsset contains a set of rigid bodies and constraints that make up a single ragdoll.
The asset is not limited to human ragdolls, and can be used for any physical simulation using bodies and constraints.
A SkeletalMesh has a single PhysicsAsset, which allows for easily turning ragdoll physics on or off for many SkeletalMeshComponents
The asset can be configured inside the Physics Asset Editor.

See: https://docs.unrealengine.com/latest/INT/Engine/Physics/PhAT/Reference/index.html
See: USkeletalMesh"""

	@property
	def BoundsBodies(self) -> typing.List[int]: ...
	"""Index of bodies that are marked bConsiderForBounds"""

	@property
	def SkeletalBodySetups(self) -> typing.List[unsupported]: ...
	"""Array of SkeletalBodySetup objects. Stores information about collision shape etc. for each body.
Does not include body position - those are taken from mesh."""

	@property
	def ConstraintSetup(self) -> typing.List[unsupported]: ...
	"""Array of RB_ConstraintSetup objects.
Stores information about a joint between two bodies, such as position relative to each body, joint limits etc."""

	@property
	def SolverIterations(self) -> SolverIterations: ...
	"""[Chaos Only] Recommended solver settings."""

	@property
	def bNotForDedicatedServer(self) -> bool: ...
	"""If true, we skip instancing bodies for this PhysicsAsset on dedicated servers"""

	@property
	def ThumbnailInfo(self) -> typing.Any: ...
	"""Information for thumbnail rendering"""

	pass

class PhysicsCollisionHandler(Object):
	"""Physics Collision Handler"""

	@property
	def ImpactThreshold(self) -> float: ...
	"""How hard an impact must be to trigger effect/sound"""

	@property
	def ImpactReFireDelay(self) -> float: ...
	"""Min time between effect/sound being triggered"""

	@property
	def DefaultImpactSound(self) -> SoundBase: ...
	"""Sound to play"""

	@property
	def LastImpactSoundTime(self) -> float: ...
	"""Time since last impact sound"""

	pass

class RigidBodyBase(Actor):
	"""Rigid Body Base"""

	pass

class PhysicsConstraintActor(RigidBodyBase):
	"""Physics Constraint Actor"""

	pass

class PhysicsConstraintComponent(SceneComponent):
	"""This is effectively a joint that allows you to connect 2 rigid bodies together. You can create different types of joints using the various parameters of this component."""

	@property
	def ConstraintActor1(self) -> Actor: ...
	"""Pointer to first Actor to constrain."""

	@property
	def ComponentName1(self) -> typing.Any: ...
	"""Name of first component property to constrain. If Actor1 is NULL, will look within Owner.
If this is NULL, will use RootComponent of Actor1"""

	@property
	def ConstraintActor2(self) -> Actor: ...
	"""Pointer to second Actor to constrain."""

	@property
	def ComponentName2(self) -> typing.Any: ...
	"""Name of second component property to constrain. If Actor2 is NULL, will look within Owner.
If this is NULL, will use RootComponent of Actor2"""

	@property
	def OnConstraintBroken(self) -> typing.Any: ...
	"""Notification when constraint is broken."""

	@property
	def ConstraintInstance(self) -> typing.Any: ...
	"""All constraint settings"""

	def IsBroken(self) -> bool: ...
	"""Retrieve the status of constraint being broken."""

	def GetConstraintForce(self) -> typing.Tuple[Vector, Vector]: ...
	"""Retrieve the constraint force most recently applied to maintain this constraint. Returns 0 forces if the constraint is not initialized or broken."""

	def SetDisableCollision(self, bDisableCollision: bool): ...
	"""If true, the collision between the two rigid bodies of the constraint will be disabled."""

	def SetConstraintReferenceOrientation(self, Frame: int, PriAxis: Vector, SecAxis: Vector): ...
	"""Pass in reference orientation in (maintains reference position). If the constraint is currently active, this will set its active local pose. Otherwise the change will take affect in InitConstraint."""

	def SetConstraintReferencePosition(self, Frame: int, RefPosition: Vector): ...
	"""Pass in reference position in (maintains reference orientation). If the constraint is currently active, this will set its active local pose. Otherwise the change will take affect in InitConstraint."""

	def SetConstraintReferenceFrame(self, Frame: int, RefFrame: Transform): ...
	"""Pass in reference frame in. If the constraint is currently active, this will set its active local pose. Otherwise the change will take affect in InitConstraint."""

	def GetCurrentSwing2(self) -> float: ...
	"""Gets the current Swing2 of the constraint"""

	def GetCurrentSwing1(self) -> float: ...
	"""Gets the current Swing1 of the constraint"""

	def GetCurrentTwist(self) -> float: ...
	"""Gets the current Angular Twist of the constraint"""

	def SetAngularBreakable(self, bAngularBreakable: bool, AngularBreakThreshold: float): ...
	"""Sets the Angular Breakable properties
     @param bAngularBreakable                Whether it is possible to break the joint with angular force
     @param AngularBreakThreshold    Torque needed to break the joint"""

	def SetLinearBreakable(self, bLinearBreakable: bool, LinearBreakThreshold: float): ...
	"""Sets the Linear Breakable properties
     @param bLinearBreakable         Whether it is possible to break the joint with linear force
     @param LinearBreakThreshold     Force needed to break the joint"""

	def SetAngularTwistLimit(self, ConstraintType: int, TwistLimitAngle: float): ...
	"""Sets the Angular Twist Motion Type
     @param ConstraintType   New Constraint Type
     @param TwistLimitAngle  Size of limit in degrees"""

	def SetAngularSwing2Limit(self, MotionType: int, Swing2LimitAngle: float): ...
	"""Sets the Angular Swing2 Motion Type
     @param ConstraintType   New Constraint Type
     @param Swing2LimitAngle Size of limit in degrees"""

	def SetAngularSwing1Limit(self, MotionType: int, Swing1LimitAngle: float): ...
	"""Sets the Angular Swing1 Motion Type
     @param ConstraintType   New Constraint Type
     @param Swing1LimitAngle Size of limit in degrees"""

	def SetLinearZLimit(self, ConstraintType: int, LimitSize: float): ...
	"""Sets the LinearZ Motion Type
     @param ConstraintType   New Constraint Type
     @param LimitSize                Size of limit"""

	def SetLinearYLimit(self, ConstraintType: int, LimitSize: float): ...
	"""Sets the LinearY Motion Type
     @param ConstraintType   New Constraint Type
     @param LimitSize                Size of limit"""

	def SetLinearXLimit(self, ConstraintType: int, LimitSize: float): ...
	"""Sets the LinearX Motion Type
     @param ConstraintType   New Constraint Type
     @param LimitSize                Size of limit"""

	def SetAngularDriveParams(self, PositionStrength: float, VelocityStrength: float, InForceLimit: float): ...
	"""Sets the drive params for the angular drive.
    @param PositionStrength         Positional strength for the drive (stiffness)
    @param VelocityStrength         Velocity strength of the drive (damping)
    @param InForceLimit     Max force applied by the drive"""

	def SetAngularVelocityTarget(self, InVelTarget: Vector): ...
	"""Sets the target velocity for the angular drive.
    @param InVelTarget              Target velocity"""

	def SetAngularOrientationTarget(self, InPosTarget: Rotator): ...
	"""Sets the target orientation for the angular drive.
    @param InPosTarget              Target orientation"""

	def SetLinearDriveParams(self, PositionStrength: float, VelocityStrength: float, InForceLimit: float): ...
	"""Sets the drive params for the linear drive.
    @param PositionStrength         Positional strength for the drive (stiffness)
    @param VelocityStrength         Velocity strength of the drive (damping)
    @param InForceLimit     Max force applied by the drive"""

	def SetLinearVelocityTarget(self, InVelTarget: Vector): ...
	"""Sets the target velocity for the linear drive.
    @param InVelTarget              Target velocity"""

	def SetLinearPositionTarget(self, InPosTarget: Vector): ...
	"""Sets the target position for the linear drive.
    @param InPosTarget              Target position"""

	def SetAngularDriveMode(self, DriveMode: int): ...
	"""Switches the angular drive mode between SLERP and Twist And Swing

     @param DriveMode        The angular drive mode to use. SLERP uses shortest spherical path, but will not work if any angular constraints are locked. Twist and Swing decomposes the path into the different angular degrees of freedom but may experience gimbal lock"""

	def SetAngularVelocityDriveSLERP(self, bEnableSLERP: bool): ...
	"""Enables/Disables the angular velocity slerp drive. Only relevant if the AngularDriveMode is set to SLERP

     @param bEnableSLERP             Indicates whether the SLERP drive should be enabled. Only relevant if the AngularDriveMode is set to SLERP"""

	def SetAngularVelocityDriveTwistAndSwing(self, bEnableTwistDrive: bool, bEnableSwingDrive: bool): ...
	"""Enables/Disables angular velocity twist and swing drive. Only relevant if the AngularDriveMode is set to Twist and Swing

     @param bEnableSwingDrive        Indicates whether the drive for the swing axis should be enabled. Only relevant if the AngularDriveMode is set to Twist and Swing
     @param bEnableTwistDrive        Indicates whether the drive for the twist axis should be enabled. Only relevant if the AngularDriveMode is set to Twist and Swing"""

	def SetOrientationDriveSLERP(self, bEnableSLERP: bool): ...
	"""Enables/Disables the angular orientation slerp drive. Only relevant if the AngularDriveMode is set to SLERP

     @param bEnableSLERP             Indicates whether the SLERP drive should be enabled. Only relevant if the AngularDriveMode is set to SLERP"""

	def SetOrientationDriveTwistAndSwing(self, bEnableTwistDrive: bool, bEnableSwingDrive: bool): ...
	"""Enables/Disables angular orientation drive. Only relevant if the AngularDriveMode is set to Twist and Swing

     @param bEnableSwingDrive        Indicates whether the drive for the swing axis should be enabled. Only relevant if the AngularDriveMode is set to Twist and Swing
     @param bEnableTwistDrive        Indicates whether the drive for the twist axis should be enabled. Only relevant if the AngularDriveMode is set to Twist and Swing"""

	def SetLinearVelocityDrive(self, bEnableDriveX: bool, bEnableDriveY: bool, bEnableDriveZ: bool): ...
	"""Enables/Disables linear position drive

    @param bEnableDriveX    Indicates whether the drive for the X-Axis should be enabled
    @param bEnableDriveY    Indicates whether the drive for the Y-Axis should be enabled
    @param bEnableDriveZ    Indicates whether the drive for the Z-Axis should be enabled"""

	def SetLinearPositionDrive(self, bEnableDriveX: bool, bEnableDriveY: bool, bEnableDriveZ: bool): ...
	"""Enables/Disables linear position drive

    @param bEnableDriveX    Indicates whether the drive for the X-Axis should be enabled
    @param bEnableDriveY    Indicates whether the drive for the Y-Axis should be enabled
    @param bEnableDriveZ    Indicates whether the drive for the Z-Axis should be enabled"""

	def BreakConstraint(self): ...
	"""Break this constraint"""

	def SetConstrainedComponents(self, Component1: PrimitiveComponent, BoneName1: str, Component2: PrimitiveComponent, BoneName2: str): ...
	"""Directly specify component to connect. Will update frames based on current position."""

	pass

class PhysicsHandleComponent(ActorComponent):
	"""Utility object for moving physics objects around."""

	@property
	def GrabbedComponent(self) -> PrimitiveComponent: ...
	"""Component we are currently holding"""

	@property
	def bSoftAngularConstraint(self) -> bool: ...
	"""Soft Angular Constraint"""

	@property
	def bSoftLinearConstraint(self) -> bool: ...
	"""Soft Linear Constraint"""

	@property
	def bInterpolateTarget(self) -> bool: ...
	"""Interpolate Target"""

	@property
	def LinearDamping(self) -> float: ...
	"""Linear damping of the handle spring."""

	@property
	def LinearStiffness(self) -> float: ...
	"""Linear stiffness of the handle spring"""

	@property
	def AngularDamping(self) -> float: ...
	"""Angular damping of the handle spring"""

	@property
	def AngularStiffness(self) -> float: ...
	"""Angular stiffness of the handle spring"""

	@property
	def InterpolationSpeed(self) -> float: ...
	"""How quickly we interpolate the physics target transform"""

	def SetInterpolationSpeed(self, NewInterpolationSpeed: float): ...
	"""Set interpolation speed"""

	def SetAngularStiffness(self, NewAngularStiffness: float): ...
	"""Set angular stiffness"""

	def SetAngularDamping(self, NewAngularDamping: float): ...
	"""Set angular damping"""

	def SetLinearStiffness(self, NewLinearStiffness: float): ...
	"""Set linear stiffness"""

	def SetLinearDamping(self, NewLinearDamping: float): ...
	"""Set linear damping"""

	def GetTargetLocationAndRotation(self) -> typing.Tuple[Vector, Rotator]: ...
	"""Get the current location and rotation"""

	def SetTargetLocationAndRotation(self, NewLocation: Vector, NewRotation: Rotator): ...
	"""Set target location and rotation"""

	def SetTargetRotation(self, NewRotation: Rotator): ...
	"""Set the target rotation"""

	def SetTargetLocation(self, NewLocation: Vector): ...
	"""Set the target location"""

	def GetGrabbedComponent(self) -> PrimitiveComponent: ...
	"""Returns the currently grabbed component, or null if nothing is grabbed."""

	def ReleaseComponent(self): ...
	"""Release the currently held component"""

	def GrabComponentAtLocationWithRotation(self, Component: PrimitiveComponent, InBoneName: str, Location: Vector, Rotation: Rotator): ...
	"""Grab the specified component at a given location and rotation. Constrains rotation."""

	def GrabComponentAtLocation(self, Component: PrimitiveComponent, InBoneName: str, GrabLocation: Vector): ...
	"""Grab the specified component at a given location. Does NOT constraint rotation which means the handle will pivot about GrabLocation."""

	pass

class PhysicsSpringComponent(SceneComponent):
	"""Note: this component is still work in progress. Uses raycast springs for simple vehicle forces
   Used with objects that have physics to create a spring down the X direction
   ie. point X in the direction you want generate spring."""

	@property
	def SpringStiffness(self) -> float: ...
	"""Specifies how much strength the spring has. The higher the SpringStiffness the more force the spring can push on a body with."""

	@property
	def SpringDamping(self) -> float: ...
	"""Specifies how quickly the spring can absorb energy of a body. The higher the damping the less oscillation"""

	@property
	def SpringLengthAtRest(self) -> float: ...
	"""Determines how long the spring will be along the X-axis at rest. The spring will apply 0 force on a body when it's at rest."""

	@property
	def SpringRadius(self) -> float: ...
	"""Determines the radius of the spring."""

	@property
	def SpringChannel(self) -> int: ...
	"""Strength of thrust force applied to the base object."""

	@property
	def bIgnoreSelf(self) -> bool: ...
	"""If true, the spring will ignore all components in its own actor"""

	@property
	def SpringCompression(self) -> float: ...
	"""The current compression of the spring. A spring at rest will have SpringCompression 0."""

	def GetSpringDirection(self) -> Vector: ...
	"""Returns the spring direction from start to resting point"""

	def GetSpringCurrentEndPoint(self) -> Vector: ...
	"""Returns the spring current end point in world space."""

	def GetSpringRestingPoint(self) -> Vector: ...
	"""Returns the spring resting point in world space."""

	def GetNormalizedCompressionScalar(self) -> float: ...
	"""Returns the spring compression as a normalized scalar along spring direction.
0 implies spring is at rest
1 implies fully compressed"""

	pass

class PhysicsThrusterComponent(SceneComponent):
	"""Used with objects that have physics to apply a force down the negative-X direction
ie. point X in the direction you want the thrust in."""

	@property
	def ThrustStrength(self) -> float: ...
	"""Strength of thrust force applied to the base object."""

	pass

class RadialForceActor(RigidBodyBase):
	"""Radial Force Actor"""

	pass

class RadialForceComponent(SceneComponent):
	"""Used to emit a radial force or impulse that can affect physics objects and or destructible objects."""

	@property
	def Radius(self) -> float: ...
	"""The radius to apply the force or impulse in"""

	@property
	def Falloff(self) -> int: ...
	"""How the force or impulse should fall off as object are further away from the center"""

	@property
	def ImpulseStrength(self) -> float: ...
	"""How strong the impulse should be"""

	@property
	def bImpulseVelChange(self) -> bool: ...
	"""If true, the impulse will ignore mass of objects and will always result in a fixed velocity change"""

	@property
	def bIgnoreOwningActor(self) -> bool: ...
	"""If true, do not apply force/impulse to any physics objects that are part of the Actor that owns this component."""

	@property
	def ForceStrength(self) -> float: ...
	"""How strong the force should be"""

	@property
	def DestructibleDamage(self) -> float: ...
	"""If > 0.f, will cause damage to destructible meshes as well"""

	def RemoveObjectTypeToAffect(self, ObjectType: int): ...
	"""Remove an object type that is affected by this radial force"""

	def AddObjectTypeToAffect(self, ObjectType: int): ...
	"""Add an object type for this radial force to affect"""

	def FireImpulse(self): ...
	"""Fire a single impulse"""

	pass

class SlateBrushAsset(Object):
	"""An asset describing how a texture can exist in slate's DPI-aware environment
and how this texture responds to resizing. e.g. Scale9-stretching? Tiling?"""

	@property
	def Brush(self) -> SlateBrush: ...
	"""The slate brush resource describing the texture's behavior."""

	pass

class AmbientSound(Actor):
	"""A sound actor that can be placed in a level"""

	pass

class AudioBus(Object):
	"""An audio bus is an object which represents an audio patch chord. Audio can be sent to it. It can be sonified using USoundSourceBuses.
Instances of the audio bus are created in the audio engine."""

	@property
	def AudioBusChannels(self) -> int: ...
	"""How many channels to use for the source bus."""

	@property
	def bIsAutomatic(self) -> bool: ...
	"""If the audio bus can be instantiated and destroyed automatically when sources send audio to it. If this audio bus is manually started, it will override this value to be false, meaning you will need to stop the audio bus manually."""

	pass

class AudioVolume(Volume):
	"""Audio Volume"""

	def SetSubmixOverrideSettings(self, NewSubmixOverrideSettings: typing.List[AudioVolumeSubmixOverrideSettings]): ...
	"""Set Submix Override Settings"""

	def SetSubmixSendSettings(self, NewSubmixSendSettings: typing.List[AudioVolumeSubmixSendSettings]): ...
	"""Set Submix Send Settings"""

	def SetInteriorSettings(self, NewInteriorSettings): ...
	"""Set Interior Settings"""

	def SetReverbSettings(self, NewReverbSettings: ReverbSettings): ...
	"""Set Reverb Settings"""

	def SetEnabled(self, bNewEnabled: bool): ...
	"""Set Enabled"""

	def SetPriority(self, NewPriority: float): ...
	"""Set Priority"""

	pass

class SoundBase(Object):
	"""Sound Base"""

	@property
	def SoundClassObject(self) -> SoundClass: ...
	"""Sound class this sound belongs to"""

	@property
	def bDebug(self) -> bool: ...
	"""When 'au.debug.Sounds -debug' has been specified, draw this sound's attenuation shape when the sound is audible. For debugging purpose only."""

	@property
	def bOverrideConcurrency(self) -> bool: ...
	"""Whether or not to override the sound concurrency object with local concurrency settings."""

	@property
	def bOutputToBusOnly(self) -> bool: ...
	"""Whether or not to only send this audio's output to a bus. If true, will not be this sound won't be audible except through bus sends."""

	@property
	def bHasDelayNode(self) -> bool: ...
	"""Whether or not to only send this audio's output to a bus. If true, will not be this sound won't be audible except through bus sends."""

	@property
	def bHasConcatenatorNode(self) -> bool: ...
	"""Whether or not this sound has a concatenator node. If it does, we have to allow the sound to persist even though it may not have generate audible audio in a given audio thread frame."""

	@property
	def bBypassVolumeScaleForPriority(self) -> bool: ...
	"""Bypass volume weighting priority upon evaluating whether sound should remain active when max channel count is met (See platform Audio Settings)."""

	@property
	def VirtualizationMode(self) -> int: ...
	"""Virtualization behavior, determining if a sound may revive and how it continues playing when culled or evicted (limited to looping sounds)."""

	@property
	def ConcurrencySet(self) -> typing.Set[SoundConcurrency]: ...
	"""Set of concurrency settings to observe (if override is set to false).  Sound must pass all concurrency settings to play."""

	@property
	def ConcurrencyOverrides(self) -> typing.Any: ...
	"""If Override Concurrency is true, concurrency settings to use."""

	@property
	def Duration(self) -> float: ...
	"""Duration of sound in seconds."""

	@property
	def MaxDistance(self) -> float: ...
	"""The max distance of the asset, as determined by attenuation settings."""

	@property
	def TotalSamples(self) -> float: ...
	"""Total number of samples (in the thousands). Useful as a metric to analyze the relative size of a given sound asset in content browser."""

	@property
	def Priority(self) -> float: ...
	"""Used to determine whether sound can play or remain active if channel limit is met, where higher value is higher priority
(see platform's Audio Settings 'Max Channels' property). Unless bypassed, value is weighted with the final volume of the
sound to produce final runtime priority value."""

	@property
	def AttenuationSettings(self) -> SoundAttenuation: ...
	"""Attenuation settings package for the sound"""

	@property
	def ModulationSettings(self) -> SoundModulationDefaultRoutingSettings: ...
	"""Modulation Settings"""

	@property
	def SoundSubmixObject(self) -> SoundSubmixBase: ...
	"""Submix to route sound output to. If unset, falls back to referenced SoundClass submix.
If SoundClass submix is unset, sends to the 'Master Submix' as set in the 'Audio' category of Project Settings'."""

	@property
	def SoundSubmixSends(self) -> typing.List[SoundSubmixSendInfo]: ...
	"""Array of submix sends to which a prescribed amount (see 'Send Level') of this sound is sent."""

	@property
	def SourceEffectChain(self) -> SoundEffectSourcePresetChain: ...
	"""The source effect chain to use for this sound."""

	@property
	def BusSends(self) -> typing.List[SoundSourceBusSendInfo]: ...
	"""This sound will send its audio output to this list of buses if there are bus instances playing after source effects are processed."""

	@property
	def PreEffectBusSends(self) -> typing.List[SoundSourceBusSendInfo]: ...
	"""This sound will send its audio output to this list of buses if there are bus instances playing before source effects are processed."""

	@property
	def AssetUserData(self) -> typing.List[AssetUserData]: ...
	"""Array of user data stored with the asset"""

	pass

class DialogueVoice(Object):
	"""Dialogue Voice"""

	@property
	def Gender(self) -> int: ...
	"""Gender"""

	@property
	def Plurality(self) -> int: ...
	"""Plurality"""

	@property
	def LocalizationGUID(self) -> Guid: ...
	"""Localization GUID"""

	pass

class DialogueWave(Object):
	"""Dialogue Wave"""

	@property
	def bMature(self) -> bool: ...
	"""true if this dialogue is considered to contain mature/adult content."""

	@property
	def bOverride_SubtitleOverride(self) -> bool: ...
	"""Override Subtitle Override"""

	@property
	def SpokenText(self) -> str: ...
	"""A localized version of the text that is actually spoken phonetically in the audio."""

	@property
	def SubtitleOverride(self) -> str: ...
	"""A localized version of the subtitle text that should be displayed for this audio. By default this will be the same as the Spoken Text."""

	@property
	def ContextMappings(self) -> typing.List[unsupported]: ...
	"""Mappings between dialogue contexts and associated soundwaves."""

	@property
	def LocalizationGUID(self) -> Guid: ...
	"""Localization GUID"""

	pass

class ReverbEffect(Object):
	"""Reverb Effect"""

	@property
	def bBypassEarlyReflections(self) -> bool: ...
	"""Bypasses early reflections"""

	@property
	def ReflectionsDelay(self) -> float: ...
	"""Reflections Delay - 0.0 < 0.007 < 0.3 Seconds - the time between the listener receiving the direct path sound and the first reflection"""

	@property
	def GainHF(self) -> float: ...
	"""Reverb Gain High Frequency - 0.0 < 0.89 < 1.0 - attenuates the high frequency reflected sound"""

	@property
	def ReflectionsGain(self) -> float: ...
	"""Reflections Gain - 0.0 < 0.05 < 3.16 - controls the amount of initial reflections"""

	@property
	def bBypassLateReflections(self) -> bool: ...
	"""Bypasses late reflections."""

	@property
	def LateDelay(self) -> float: ...
	"""Late Reverb Delay - 0.0 < 0.011 < 0.1 Seconds - time difference between late reverb and first reflections"""

	@property
	def DecayTime(self) -> float: ...
	"""Decay Time - 0.1 < 1.49 < 20.0 Seconds - larger is more reverb"""

	@property
	def Density(self) -> float: ...
	"""Density - 0.0 < 1.0 < 1.0 - Coloration of the late reverb - lower value is more grainy"""

	@property
	def Diffusion(self) -> float: ...
	"""Diffusion - 0.0 < 1.0 < 1.0 - Echo density in the reverberation decay - lower is more grainy"""

	@property
	def AirAbsorptionGainHF(self) -> float: ...
	"""Air Absorption - 0.0 < 0.994 < 1.0 - lower value means more absorption"""

	@property
	def DecayHFRatio(self) -> float: ...
	"""Decay High Frequency Ratio - 0.1 < 0.83 < 2.0 - how much the quicker or slower the high frequencies decay relative to the lower frequencies."""

	@property
	def LateGain(self) -> float: ...
	"""Late Reverb Gain - 0.0 < 1.26 < 10.0 - gain of the late reverb"""

	@property
	def Gain(self) -> float: ...
	"""Reverb Gain - 0.0 < 0.32 < 1.0 - overall reverb gain - master volume control"""

	@property
	def RoomRolloffFactor(self) -> float: ...
	"""Room Rolloff Factor"""

	pass

class SoundAttenuation(Object):
	"""Defines how a sound changes volume with distance to the listener"""

	@property
	def Attenuation(self) -> SoundAttenuationSettings: ...
	"""Attenuation"""

	pass

class SoundClass(Object):
	"""Sound Class"""

	@property
	def Properties(self) -> typing.Any: ...
	"""Configurable properties like volume and priority."""

	@property
	def ChildClasses(self) -> typing.List[SoundClass]: ...
	"""Child Classes"""

	@property
	def PassiveSoundMixModifiers(self) -> typing.List[PassiveSoundMixModifier]: ...
	"""SoundMix Modifiers to activate automatically when a sound of this class is playing."""

	@property
	def ParentClass(self) -> SoundClass: ...
	"""Parent Class"""

	pass

class SoundConcurrency(Object):
	"""Sound Concurrency"""

	@property
	def Concurrency(self) -> typing.Any: ...
	"""Concurrency"""

	pass

class SoundCue(SoundBase):
	"""The behavior of audio playback is defined within Sound Cues."""

	@property
	def bPrimeOnLoad(self) -> bool: ...
	"""Makes this sound cue automatically load any sound waves it can play into the cache when it is loaded."""

	@property
	def FirstNode(self) -> typing.Any: ...
	"""First Node"""

	@property
	def VolumeMultiplier(self) -> float: ...
	"""Base volume multiplier"""

	@property
	def PitchMultiplier(self) -> float: ...
	"""Base pitch multiplier"""

	@property
	def AttenuationOverrides(self) -> SoundAttenuationSettings: ...
	"""Attenuation settings to use if Override Attenuation is set to true"""

	@property
	def bOverrideAttenuation(self) -> bool: ...
	"""Indicates whether attenuation should use the Attenuation Overrides or the Attenuation Settings asset"""

	@property
	def bExcludeFromRandomNodeBranchCulling(self) -> bool: ...
	"""Ignore per-platform random node culling for memory purposes"""

	pass

class SoundEffectPreset(Object):
	"""Sound Effect Preset"""

	pass

class SoundEffectSourcePreset(SoundEffectPreset):
	"""Preset of a source effect that can be shared between chains."""

	pass

class SoundEffectSourcePresetChain(Object):
	"""Chain of source effect presets that can be shared between referencing sounds."""

	@property
	def Chain(self) -> typing.List[SourceEffectChainEntry]: ...
	"""Chain of source effects to use for this sound source."""

	@property
	def bPlayEffectChainTails(self) -> bool: ...
	"""Whether to keep the source alive for the duration of the effect chain tails."""

	pass

class SoundEffectSubmixPreset(SoundEffectPreset):
	"""Preset of a submix effect that can be shared between sounds."""

	pass

class SoundMix(Object):
	"""Sound Mix"""

	@property
	def bApplyEQ(self) -> bool: ...
	"""Whether to apply the EQ effect"""

	@property
	def EQPriority(self) -> float: ...
	"""EQPriority"""

	@property
	def EQSettings(self) -> typing.Any: ...
	"""EQSettings"""

	@property
	def SoundClassEffects(self) -> typing.List[SoundClassAdjuster]: ...
	"""Array of changes to be applied to groups."""

	@property
	def InitialDelay(self) -> float: ...
	"""Initial delay in seconds before the mix is applied."""

	@property
	def FadeInTime(self) -> float: ...
	"""Time taken in seconds for the mix to fade in."""

	@property
	def Duration(self) -> float: ...
	"""Duration of mix, negative means it will be applied until another mix is set."""

	@property
	def FadeOutTime(self) -> float: ...
	"""Time taken in seconds for the mix to fade out."""

	pass

class SoundWave(SoundBase):
	"""Sound Wave"""

	@property
	def CompressionQuality(self) -> int: ...
	"""Platform agnostic compression quality. 1..100 with 1 being best compression and 100 being best quality."""

	@property
	def StreamingPriority(self) -> int: ...
	"""Priority of this sound when streaming (lower priority streams may not always play)"""

	@property
	def SampleRateQuality(self) -> int: ...
	"""Quality of sample rate conversion for platforms that opt into resampling during cook. The sample rate for each enumeration is definable per platform in platform target settings."""

	@property
	def SoundGroup(self) -> int: ...
	"""Sound Group"""

	@property
	def bLooping(self) -> bool: ...
	"""If set, when played directly (not through a sound cue) the wave will be played looping."""

	@property
	def bStreaming(self) -> bool: ...
	"""Whether this sound can be streamed to avoid increased memory usage. If using Stream Caching, use Loading Behavior instead to control memory usage."""

	@property
	def bSeekableStreaming(self) -> bool: ...
	"""Whether this sound supports seeking. This requires recooking with a codec which supports seekability and streaming."""

	@property
	def LoadingBehavior(self) -> int: ...
	"""Specifies how and when compressed audio data is loaded for asset if stream caching is enabled."""

	@property
	def bMature(self) -> bool: ...
	"""If set to true if this sound is considered to contain mature/adult content."""

	@property
	def bManualWordWrap(self) -> bool: ...
	"""If set to true will disable automatic generation of line breaks - use if the subtitles have been split manually."""

	@property
	def bSingleLine(self) -> bool: ...
	"""If set to true the subtitles display as a sequence of single lines as opposed to multiline."""

	@property
	def bIsAmbisonics(self) -> bool: ...
	"""Whether or not this source is ambisonics file format. If set, sound always uses the
'Master Ambisonics Submix' as set in the 'Audio' category of Project Settings'
and ignores submix if provided locally or in the referenced SoundClass."""

	@property
	def FrequenciesToAnalyze(self) -> typing.List[float]: ...
	"""The frequencies (in hz) to analyze when doing baked FFT analysis."""

	@property
	def CookedSpectralTimeData(self) -> typing.List[unsupported]: ...
	"""The cooked spectral time data."""

	@property
	def CookedEnvelopeTimeData(self) -> typing.List[unsupported]: ...
	"""The cooked cooked envelope data."""

	@property
	def InitialChunkSize(self) -> int: ...
	"""Use this to override how much audio data is loaded when this USoundWave is loaded."""

	@property
	def SpokenText(self) -> str: ...
	"""A localized version of the text that is actually spoken phonetically in the audio."""

	@property
	def SubtitlePriority(self) -> float: ...
	"""The priority of the subtitle."""

	@property
	def Volume(self) -> float: ...
	"""Playback volume of sound 0 to 1 - Default is 1.0."""

	@property
	def Pitch(self) -> float: ...
	"""Playback pitch for sound."""

	@property
	def NumChannels(self) -> int: ...
	"""Number of channels of multichannel data; 1 or 2 for regular mono and stereo files"""

	@property
	def Subtitles(self) -> typing.List[SubtitleCue]: ...
	"""Subtitle cues.  If empty, use SpokenText as the subtitle.  Will often be empty,
as the contents of the subtitle is commonly identical to what is spoken."""

	def GetRawData(self) -> bytes: ...

	def SetRawData(self Buffer: buffer) -> None: ...

	pass

class SoundSourceBus(SoundWave):
	"""A source bus is a type of USoundBase and can be 'played' like any sound."""

	@property
	def SourceBusChannels(self) -> int: ...
	"""How many channels to use for the source bus if the audio bus is not specified, otherwise it will use the audio bus object's channel count."""

	@property
	def SourceBusDuration(self) -> float: ...
	"""The duration (in seconds) to use for the source bus. A duration of 0.0 indicates to play the source bus indefinitely."""

	@property
	def AudioBus(self) -> AudioBus: ...
	"""Audio bus to use to use as audio for this source bus. This source bus will sonify the audio from the audio bus."""

	pass

class SoundSubmixBase(Object):
	"""Sound Submix Base"""

	@property
	def ChildSubmixes(self) -> typing.List[SoundSubmixBase]: ...
	"""Child submixes to this sound mix"""

	pass

class SoundSubmixWithParentBase(SoundSubmixBase):
	"""This submix class can be derived from for submixes that output to a parent submix."""

	@property
	def ParentSubmix(self) -> SoundSubmixBase: ...
	"""Parent Submix"""

	pass

class SoundSubmix(SoundSubmixWithParentBase):
	"""Sound Submix class meant for applying an effect to the downmixed sum of multiple audio sources."""

	@property
	def bMuteWhenBackgrounded(self) -> bool: ...
	"""Mute this submix when the application is muted or in the background. Used to prevent submix effect tails from continuing when tabbing out of application or if application is muted."""

	@property
	def SubmixEffectChain(self) -> typing.List[SoundEffectSubmixPreset]: ...
	"""Submix Effect Chain"""

	@property
	def AmbisonicsPluginSettings(self) -> typing.Any: ...
	"""Optional settings used by plugins which support ambisonics file playback."""

	@property
	def EnvelopeFollowerAttackTime(self) -> int: ...
	"""The attack time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the envelope value of sounds played with this submix."""

	@property
	def EnvelopeFollowerReleaseTime(self) -> int: ...
	"""The release time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the envelope value of sounds played with this submix."""

	@property
	def GainMode(self) -> int: ...
	"""Whether to treat submix gain levels as linear or decibel values."""

	@property
	def OutputVolume(self) -> float: ...
	"""The output volume of the submix. Applied after submix effects and analysis are performed."""

	@property
	def WetLevel(self) -> float: ...
	"""The wet level of the submix. Applied after submix effects and analysis are performed."""

	@property
	def DryLevel(self) -> float: ...
	"""The dry level of the submix. Applied before submix effects and analysis are performed."""

	@property
	def OnSubmixRecordedFileDone(self) -> typing.Any: ...
	"""Blueprint delegate for when a recorded file is finished exporting."""

	def SetSubmixOutputVolume(self, WorldContextObject: Object, InOutputVolume: float): ...
	"""Sets the output volume of the submix. This dynamic volume scales with the OutputVolume property of this submix."""

	def StopSpectralAnalysis(self, WorldContextObject: Object): ...
	"""Start spectrum analysis of the audio output."""

	def StartSpectralAnalysis(self, WorldContextObject: Object, FFTSize: int = ..., InterpolationMethod: int = ..., WindowType: int = ..., HopSize: float = ..., SpectrumType: int = ...): ...
	"""Start spectrum analysis of the audio output."""

	def RemoveSpectralAnalysisDelegate(self, WorldContextObject: Object, OnSubmixSpectralAnalysisBP): ...
	"""Remove a spectral analysis delegate.
@param  OnSubmixSpectralAnalysisBP          The event delegate to remove."""

	def AddSpectralAnalysisDelegate(self, WorldContextObject: Object, InBandSettings: typing.List[SoundSubmixSpectralAnalysisBandSettings], OnSubmixSpectralAnalysisBP, UpdateRate: float = ..., DecibelNoiseFloor: float = ..., bDoNormalize: bool = ..., bDoAutoRange: bool = ..., AutoRangeAttackTime: float = ..., AutoRangeReleaseTime: float = ...): ...
	"""Adds a spectral analysis delegate to receive notifications when this submix has spectrum analysis enabled.
@param  InBandsettings                                  The frequency bands to analyze and their envelope-following settings.
@param  OnSubmixSpectralAnalysisBP          Event to fire when new spectral data is available.
@param  UpdateRate                                              How often to retrieve the data from the spectral analyzer and broadcast the event. Max is 30 times per second.
@param  InterpMethod                    Method to used for band peak calculation.
@param  SpectrumType                    Metric to use when returning spectrum values.
@param  DecibelNoiseFloor               Decibel Noise Floor to consider as silence silence when using a Decibel Spectrum Type.
@param  bDoNormalize                    If true, output band values will be normalized between zero and one.
@param  bDoAutoRange                    If true, output band values will have their ranges automatically adjusted to the minimum and maximum values in the audio. Output band values will be normalized between zero and one.
@param  AutoRangeAttackTime             The time (in seconds) it takes for the range to expand to 90% of a larger range.
@param  AutoRangeReleaseTime            The time (in seconds) it takes for the range to shrink to 90% of a smaller range."""

	def AddEnvelopeFollowerDelegate(self, WorldContextObject: Object, OnSubmixEnvelopeBP): ...
	"""Adds an envelope follower delegate to the submix when envelope following is enabled on this submix.
@param  OnSubmixEnvelopeBP      Event to fire when new envelope data is available."""

	def StopEnvelopeFollowing(self, WorldContextObject: Object): ...
	"""Start envelope following the submix output. Register with OnSubmixEnvelope to receive envelope follower data in BP."""

	def StartEnvelopeFollowing(self, WorldContextObject: Object): ...
	"""Start envelope following the submix output. Register with OnSubmixEnvelope to receive envelope follower data in BP."""

	def StopRecordingOutput(self, WorldContextObject: Object, ExportType: int, Name: str, Path: str, ExistingSoundWaveToOverwrite: SoundWave = ...): ...
	"""Finish recording the audio from this submix and export it as a wav file or a USoundWave."""

	def StartRecordingOutput(self, WorldContextObject: Object, ExpectedDuration: float): ...
	"""Start recording the audio from this submix."""

	pass

class SoundfieldSubmix(SoundSubmixWithParentBase):
	"""Sound Submix class meant for use with soundfield formats, such as Ambisonics."""

	@property
	def SoundfieldEncodingFormat(self) -> str: ...
	"""Currently used format."""

	@property
	def EncodingSettings(self) -> typing.Any: ...
	"""TODO: Make this editable only if SoundfieldEncodingFormat is non-default,
 and filter classes based on ISoundfieldFactory::GetCustomSettingsClass()."""

	@property
	def SoundfieldEffectChain(self) -> typing.List[unsupported]: ...
	"""TODO: make this editable only if SoundfieldEncodingFormat is non-default
and filter classes based on USoundfieldProcessorBase::SupportsFormat."""

	@property
	def EncodingSettingsClass(self) -> typing.Any: ...
	"""Encoding Settings Class"""

	pass

class EndpointSubmix(SoundSubmixBase):
	"""Sound Submix class meant for sending audio to an external endpoint, such as controller haptics or an additional audio device."""

	@property
	def EndpointType(self) -> str: ...
	"""Currently used format."""

	@property
	def EndpointSettingsClass(self) -> typing.Any: ...
	"""Endpoint Settings Class"""

	@property
	def EndpointSettings(self) -> typing.Any: ...
	"""TODO: Make this editable only if EndpointType is non-default,
 and filter classes based on ISoundfieldFactory::GetCustomSettingsClass()."""

	pass

class SoundfieldEndpointSubmix(SoundSubmixBase):
	"""Sound Submix class meant for sending soundfield-encoded audio to an external endpoint, such as a hardware binaural renderer that supports ambisonics."""

	@property
	def SoundfieldEndpointType(self) -> str: ...
	"""Currently used format."""

	@property
	def EndpointSettingsClass(self) -> typing.Any: ...
	"""Endpoint Settings Class"""

	@property
	def EndpointSettings(self) -> typing.Any: ...
	"""TODO: Make this editable only if EndpointType is non-default,
 and filter classes based on ISoundfieldFactory::GetCustomSettingsClass()."""

	@property
	def EncodingSettingsClass(self) -> typing.Any: ...
	"""Encoding Settings Class"""

	@property
	def EncodingSettings(self) -> typing.Any: ...
	"""Encoding Settings"""

	@property
	def SoundfieldEffectChain(self) -> typing.List[unsupported]: ...
	"""Soundfield Effect Chain"""

	pass

class SoundWaveProcedural(SoundWave):
	"""Sound Wave Procedural"""

	def QueueAudio(self Buffer: buffer) -> None: ...

	def GetAvailableAudioByteCount(self) -> int: ...

	def ResetAudio(self) -> None: ...

	pass

class VectorFieldVolume(Actor):
	"""Vector Field Volume"""

	pass

class LightMapVirtualTexture2D(Texture2D):
	"""Light Map Virtual Texture 2D"""

	@property
	def TypeToLayer(self) -> typing.List[int]: ...
	"""Type to Layer"""

	pass

class RuntimeVirtualTexture(Object):
	"""Runtime virtual texture UObject"""

	def GetPageTableSize(self) -> int: ...
	"""Public getter for virtual texture page table size. This is only different from GetTileCount() when using an adaptive page table."""

	def GetSize(self) -> int: ...
	"""Public getter for virtual texture size. This is derived from the TileCount and TileSize."""

	def GetTileBorderSize(self) -> int: ...
	"""Public getter for virtual texture tile border size"""

	def GetTileSize(self) -> int: ...
	"""Public getter for virtual texture tile size"""

	def GetTileCount(self) -> int: ...
	"""Public getter for virtual texture tile count"""

	pass

class RuntimeVirtualTextureVolume(Actor):
	"""Actor used to place a URuntimeVirtualTexture in the world."""

	@property
	def VirtualTextureComponent(self) -> RuntimeVirtualTextureComponent: ...
	"""Component that owns the runtime virtual texture."""

	pass

class VirtualTextureBuilder(Object):
	"""Container for a UVirtualTexture2D that can be built from a FVirtualTextureBuildDesc description.
This has a simple BuildTexture() interface but we may want to extend in the future to support partial builds
or other more blueprint driven approaches for data generation."""

	@property
	def Texture(self) -> typing.Any: ...
	"""The UTexture object."""

	@property
	def BuildHash(self) -> long: ...
	"""Some client defined hash of that defines how the Texture was built."""

	pass

class NodeMappingContainer(Object):
	"""Node Mapping Container Class
* This saves source items, and target items, and mapping between
* Used by Retargeting, Control Rig mapping. Will need to improve interface better"""

	pass

class AssetExportTask(Object):
	"""Contains data for a group of assets to import"""

	@property
	def Object(self) -> Object: ...
	"""Asset to export"""

	@property
	def Exporter(self) -> Exporter: ...
	"""Optional exporter, otherwise it will be determined automatically"""

	@property
	def bSelected(self) -> bool: ...
	"""Export selected only"""

	@property
	def bReplaceIdentical(self) -> bool: ...
	"""Replace identical files"""

	@property
	def bPrompt(self) -> bool: ...
	"""Allow dialog prompts"""

	@property
	def bAutomated(self) -> bool: ...
	"""Unattended export"""

	@property
	def bUseFileArchive(self) -> bool: ...
	"""Save to a file archive"""

	@property
	def bWriteEmptyFiles(self) -> bool: ...
	"""Write even if file empty"""

	@property
	def IgnoreObjectList(self) -> typing.List[Object]: ...
	"""Array of objects to ignore exporting"""

	@property
	def Options(self) -> Object: ...
	"""Exporter specific options"""

	@property
	def Errors(self) -> typing.List[str]: ...
	"""Array of error messages encountered during exporter"""

	pass

class NetPushModelHelpers(BlueprintFunctionLibrary):
	"""Net Push Model Helpers"""

	@staticmethod
	def MarkPropertyDirtyFromRepIndex(Object: Object, RepIndex: int, PropertyName: str): ...
	"""Mark Property Dirty from Rep Index"""

	@staticmethod
	def MarkPropertyDirty(Object: Object, PropertyName: str): ...
	"""Mark Property Dirty"""

	pass

class HealthSnapshotBlueprintLibrary(BlueprintFunctionLibrary):
	"""Health Snapshot Blueprint Library"""

	@staticmethod
	def LogPerformanceSnapshot(SnapshotTitle: str, bResetStats: bool = ...): ...
	"""Writes a snapshot to the log. Captures memory stats by default. Also captures performance stats if called after StartHealthSnapshotChart and before SopHealthSnapshotChart.

@param        SnapshotTitle                   The name to be given to the new HealthSnapshot."""

	@staticmethod
	def StopPerformanceSnapshots(): ...
	"""Stops capturing FPS charts only if StartHealthSnapshotChart has first been called. Does nothing if FPS charts are not running. HealthSnapshots captured after this is called will not include performance stats."""

	@staticmethod
	def StartPerformanceSnapshots(): ...
	"""Begins capturing FPS charts that can be used to include performance data in a HealthSnapshot. If snapshots are already running clears all accumulated performance data"""

	pass

class NavAreaBase(Object):
	"""a stub class. Actual implementation in NavigationSystem module."""

	pass

class NavigationSystemBase(Object):
	"""Navigation System Base"""

	pass

class DynamicSubsystem(Subsystem):
	"""Dynamic Subsystems auto populate/depopulate existing collections when modules are loaded and unloaded

Only UEngineSubsystems and UEditorSubsystems allow for dynamic loading.

If instances of your subsystem aren't being created it maybe that the module they are in isn't being explicitly loaded,
make sure there is a LoadModule('ModuleName') to load the module."""

	pass

class EdGraphNode(Object):
	"""Ed Graph Node"""

	@property
	def DeprecatedPins(self) -> typing.List[unsupported]: ...
	"""List of connector pins"""

	@property
	def NodePosX(self) -> int: ...
	"""X position of node in the editor"""

	@property
	def NodePosY(self) -> int: ...
	"""Y position of node in the editor"""

	@property
	def NodeWidth(self) -> int: ...
	"""Width of node in the editor; only used when the node can be resized"""

	@property
	def NodeHeight(self) -> int: ...
	"""Height of node in the editor; only used when the node can be resized"""

	@property
	def AdvancedPinDisplay(self) -> int: ...
	"""Enum to indicate if a node has advanced-display-pins, and if they are shown"""

	@property
	def bHasCompilerMessage(self) -> bool: ...
	"""Flag to check for compile error/warning"""

	@property
	def NodeComment(self) -> str: ...
	"""Comment string that is drawn on the node"""

	@property
	def ErrorType(self) -> int: ...
	"""Flag to store node specific compile error/warning"""

	@property
	def ErrorMsg(self) -> str: ...
	"""Error/Warning description"""

	@property
	def NodeGuid(self) -> Guid: ...
	"""GUID to uniquely identify this node, to facilitate diffing versions of this graph"""

	pass

class AssetUserData(Object):
	"""Object that can be subclassed to store custom data on Unreal asset objects."""

	pass

class OnlineBlueprintCallProxyBase(BlueprintAsyncActionBase):
	"""Online Blueprint Call Proxy Base"""

	pass

class EngineSubsystem(DynamicSubsystem):
	"""UEngineSubsystem
Base class for auto instanced and initialized systems that share the lifetime of the Engine

UEngineSubsystems are dynamic and will be initialized when the module is loaded if necessary.
This means that after StartupModule() is called on the module containing a subsystem,
the subsystem collection with instantiate and initialize the subsystem automatically.
If the subsystem collection is created post module load then the instances will be created at
collection initialization time."""

	pass

class EInputEvent(Enum):
	"""EInputEvent"""

	# 
	IE_Pressed = 0
	# 
	IE_Released = 1
	# 
	IE_Repeat = 2
	# 
	IE_DoubleClick = 3
	# 
	IE_Axis = 4
	# 
	IE_MAX = 5

class EMouseCaptureMode(Enum):
	"""EMouse Capture Mode"""

	# Do not capture the mouse at all
	NoCapture = 0
	# Capture the mouse permanently when the viewport is clicked, and consume the initial mouse down that caused the capture so it isn't processed by player input
	CapturePermanently = 1
	# Capture the mouse permanently when the viewport is clicked, and allow player input to process the mouse down that caused the capture
	CapturePermanently_IncludingInitialMouseDown = 2
	# Capture the mouse during a mouse down, releases on mouse up
	CaptureDuringMouseDown = 3
	# Capture only when the right mouse button is down, not any of the other mouse buttons
	CaptureDuringRightMouseDown = 4

class EMouseLockMode(Enum):
	"""EMouse Lock Mode"""

	# Do not lock the mouse cursor to the viewport
	DoNotLock = 0
	# Only lock the mouse cursor to the viewport when the mouse is captured
	LockOnCapture = 1
	# Always lock the mouse cursor to the viewport
	LockAlways = 2
	# Lock the cursor if we're in fullscreen
	LockInFullscreen = 3

class ETickingGroup(Enum):
	"""Determines which ticking group a tick function belongs to."""

	# Any item that needs to be executed before physics simulation starts.
	TG_PrePhysics = 0
	# Special tick group that starts physics simulation.
	TG_StartPhysics = 1
	# Any item that can be run in parallel with our physics simulation work.
	TG_DuringPhysics = 2
	# Special tick group that ends physics simulation.
	TG_EndPhysics = 3
	# Any item that needs rigid body and cloth simulation to be complete before being executed.
	TG_PostPhysics = 4
	# Any item that needs the update work to be done before being ticked.
	TG_PostUpdateWork = 5
	# Catchall for anything demoted to the end.
	TG_LastDemotable = 6
	# Special tick group that is not actually a tick group. After every tick group this is repeatedly re-run until there are no more newly spawned items to run.
	TG_NewlySpawned = 7
	# 
	TG_MAX = 8

class ENetworkFailure(Enum):
	"""Types of network failures broadcast from the engine"""

	# A relevant net driver has already been created for this service
	NetDriverAlreadyExists = 0
	# The net driver creation failed
	NetDriverCreateFailure = 1
	# The net driver failed its Listen() call
	NetDriverListenFailure = 2
	# A connection to the net driver has been lost
	ConnectionLost = 3
	# A connection to the net driver has timed out
	ConnectionTimeout = 4
	# The net driver received an NMT_Failure message
	FailureReceived = 5
	# The client needs to upgrade their game
	OutdatedClient = 6
	# The server needs to upgrade their game
	OutdatedServer = 7
	# There was an error during connection to the game
	PendingConnectionFailure = 8
	# NetGuid mismatch
	NetGuidMismatch = 9
	# Network checksum mismatch
	NetChecksumMismatch = 10

class ENetworkLagState(Enum):
	"""ENetwork Lag State"""

	# The net driver is operating normally or it is not possible to tell if it is lagging
	NotLagging = 0
	# The net driver is in the process of timing out all of the client connections
	Lagging = 1

class ETravelFailure(Enum):
	"""Types of server travel failures broadcast by the engine"""

	# No level found in the loaded package
	NoLevel = 0
	# LoadMap failed on travel (about to Browse to default map)
	LoadMapFailure = 1
	# Invalid URL specified
	InvalidURL = 2
	# A package is missing on the client
	PackageMissing = 3
	# A package version mismatch has occurred between client and server
	PackageVersion = 4
	# A package is missing and the client is unable to download the file
	NoDownload = 5
	# General travel failure
	TravelFailure = 6
	# Cheat commands have been used disabling travel
	CheatCommands = 7
	# Failed to create the pending net game for travel
	PendingNetGameCreateFailure = 8
	# Failed to save before travel
	CloudSaveFailure = 9
	# There was an error during a server travel to a new map
	ServerTravelFailure = 10
	# There was an error during a client travel to a new map
	ClientTravelFailure = 11

class ETravelType(Enum):
	"""Traveling from server to server."""

	# Absolute URL.
	TRAVEL_Absolute = 0
	# Partial (carry name, reset server).
	TRAVEL_Partial = 1
	# Relative URL.
	TRAVEL_Relative = 2
	# 
	TRAVEL_MAX = 3

class EDemoPlayFailure(Enum):
	"""Types of demo play failures broadcast from the engine"""

	# A Generic failure.
	Generic = 0
	# Demo was not found.
	DemoNotFound = 1
	# Demo is corrupt.
	Corrupt = 2
	# Invalid version.
	InvalidVersion = 3
	# InitBase failed.
	InitBase = 4
	# Failed to process game specific header.
	GameSpecificHeader = 5
	# Replay streamer had an internal error.
	ReplayStreamerInternal = 6
	# LoadMap failed.
	LoadMap = 7
	# Error serializing data stream.
	Serialization = 8

class EViewModeIndex(Enum):
	"""Define view modes to get specific show flag settings (some on, some off and some are not altered)
Don't change the order, the ID is serialized with the editor"""

	# Wireframe w/ brushes.
	VMI_BrushWireframe = 0
	# Wireframe w/ BSP.
	VMI_Wireframe = 1
	# Unlit.
	VMI_Unlit = 2
	# Lit.
	VMI_Lit = 3
	# 
	VMI_Lit_DetailLighting = 4
	# Lit wo/ materials.
	VMI_LightingOnly = 5
	# Colored according to light count.
	VMI_LightComplexity = 6
	# Colored according to shader complexity.
	VMI_ShaderComplexity = 8
	# Colored according to world-space LightMap texture density.
	VMI_LightmapDensity = 9
	# Colored according to light count - showing lightmap texel density on texture mapped objects.
	VMI_LitLightmapDensity = 10
	# 
	VMI_ReflectionOverride = 11
	# 
	VMI_VisualizeBuffer = 12
	# Colored according to stationary light overlap.
	VMI_StationaryLightOverlap = 14
	# 
	VMI_CollisionPawn = 15
	# 
	VMI_CollisionVisibility = 16
	# Colored according to the current LOD index.
	VMI_LODColoration = 18
	# Colored according to the quad coverage.
	VMI_QuadOverdraw = 19
	# Visualize the accuracy of the primitive distance computed for texture streaming.
	VMI_PrimitiveDistanceAccuracy = 20
	# Visualize the accuracy of the mesh UV densities computed for texture streaming.
	VMI_MeshUVDensityAccuracy = 21
	# Colored according to shader complexity, including quad overdraw.
	VMI_ShaderComplexityWithQuadOverdraw = 22
	# Colored according to the current HLOD index.
	VMI_HLODColoration = 23
	# Group item for LOD and HLOD coloration
	VMI_GroupLODColoration = 24
	# Visualize the accuracy of the material texture scales used for texture streaming.
	VMI_MaterialTextureScaleAccuracy = 25
	# Compare the required texture resolution to the actual resolution.
	VMI_RequiredTextureResolution = 26
	# Run path tracing pipeline
	VMI_PathTracing = 27
	# Run ray tracing debug pipeline
	VMI_RayTracingDebug = 28
	# 
	VMI_Max = 29
	# VMI_Unknown - The value assigned to VMI_Unknown must be the highest possible of any member of EViewModeIndex, or GetViewModeName might seg-fault
	VMI_Unknown = 255

class EFastArraySerializerDeltaFlags(Enum):
	"""EFast Array Serializer Delta Flags"""

	# 
	None = 0
	# ! No flags.
	HasBeenSerialized = -1
	# ! Set when serialization at least once (i.e., this struct has been written or read).
	HasDeltaBeenRequested = -1
	# ! Set if users requested Delta Serialization for this struct.
	IsUsingDeltaSerialization = -1

class EAspectRatioAxisConstraint(Enum):
	"""Enum describing how to constrain perspective view port FOV"""

	# 
	AspectRatio_MaintainYFOV = 0
	# 
	AspectRatio_MaintainXFOV = 1
	# 
	AspectRatio_MajorAxisFOV = 2
	# 
	AspectRatio_MAX = 3

class EAttachmentRule(Enum):
	"""Rules for attaching components - needs to be kept synced to EDetachmentRule"""

	# Keeps current relative transform as the relative transform to the new parent.
	KeepRelative = 0
	# Automatically calculates the relative transform such that the attached component maintains the same world transform.
	KeepWorld = 1
	# Snaps transform to the attach point
	SnapToTarget = 2

class EDetachmentRule(Enum):
	"""Rules for detaching components - needs to be kept synced to EAttachmentRule"""

	# Keeps current relative transform.
	KeepRelative = 0
	# Automatically calculates the relative transform such that the detached component maintains the same world transform.
	KeepWorld = 1

class EAttachLocation(Enum):
	"""Deprecated rules for setting transform on attachment, new functions should use FAttachmentTransformRules isntead"""

	# Keeps current relative transform as the relative transform to the new parent.
	KeepRelativeOffset = 0
	# Automatically calculates the relative transform such that the attached component maintains the same world transform.
	KeepWorldPosition = 1
	# Snaps location and rotation to the attach point. Calculates the relative scale so that the final world scale of the component remains the same.
	SnapToTarget = 2
	# Snaps entire transform to target, including scale.
	SnapToTargetIncludingScale = 3

class ESceneDepthPriorityGroup(Enum):
	"""A priority for sorting scene elements by depth.
Elements with higher priority occlude elements with lower priority, disregarding distance."""

	# World scene DPG.
	SDPG_World = 0
	# Foreground scene DPG.
	SDPG_Foreground = 1
	# 
	SDPG_MAX = 2

class EIndirectLightingCacheQuality(Enum):
	"""Quality of indirect lighting for Movable primitives. This has a large effect on Indirect Lighting Cache update time."""

	# The indirect lighting cache will be disabled for this object, so no GI from stationary lights on movable objects.
	ILCQ_Off = 0
	# A single indirect lighting sample computed at the bounds origin will be interpolated which fades over time to newer results.
	ILCQ_Point = 1
	# The object will get a 5x5x5 stable volume of interpolated indirect lighting, which allows gradients of lighting intensity across the receiving object.
	ILCQ_Volume = 2

class ELightmapType(Enum):
	"""Type of lightmap that is used for primitive components"""

	# Use the default based on Mobility: Surface Lightmap for Static components, Volumetric Lightmap for Movable components.
	Default = 0
	# Force Surface Lightmap, even if the component moves, which should otherwise change the lighting.  This is only supported on components which support surface lightmaps, like static meshes.
	ForceSurface = 1
	# Force Volumetric Lightmaps, even if the component is static and could have supported surface lightmaps.
	# Volumetric Lightmaps have better directionality and no Lightmap UV seams, but are much lower resolution than Surface Lightmaps and frequently have self-occlusion and leaking problems.
	# Note: Lightmass currently requires valid lightmap UVs and sufficient lightmap resolution to compute bounce lighting, even though the Volumetric Lightmap will be used at runtime.
	ForceVolumetric = 2

class EOcclusionCombineMode(Enum):
	"""Controls how occlusion from Distance Field Ambient Occlusion is combined with Screen Space Ambient Occlusion."""

	# Take the minimum occlusion value.  This is effective for avoiding over-occlusion from multiple methods, but can result in indoors looking too flat.
	OCM_Minimum = 0
	# Multiply together occlusion values from Distance Field Ambient Occlusion and Screen Space Ambient Occlusion.
	# This gives a good sense of depth everywhere, but can cause over-occlusion.
	# SSAO should be tweaked to be less strong compared to Minimum.
	OCM_Multiply = 1
	# 
	OCM_MAX = 2

class EBlendMode(Enum):
	"""The blending mode for materials
@warning This is mirrored in Lightmass, be sure to update the blend mode structure and logic there if this changes.
@warning Check UMaterialInstance::Serialize if changed!!"""

	# 
	BLEND_Opaque = 0
	# 
	BLEND_Masked = 1
	# 
	BLEND_Translucent = 2
	# 
	BLEND_Additive = 3
	# 
	BLEND_Modulate = 4
	# 
	BLEND_AlphaComposite = 5
	# 
	BLEND_AlphaHoldout = 6
	# 
	BLEND_MAX = 7

class ESamplerSourceMode(Enum):
	"""Controls where the sampler for different texture lookups comes from"""

	# Get the sampler from the texture.  Every unique texture will consume a sampler slot, which are limited in number.
	SSM_FromTextureAsset = 0
	# Shared sampler source that does not consume a sampler slot.  Uses wrap addressing and gets filter mode from the world texture group.
	SSM_Wrap_WorldGroupSettings = 1
	# Shared sampler source that does not consume a sampler slot.  Uses clamp addressing and gets filter mode from the world texture group.
	SSM_Clamp_WorldGroupSettings = 2

class ETranslucencyLightingMode(Enum):
	"""Describes how to handle lighting of translucent objets"""

	# Lighting will be calculated for a volume, without directionality.  Use this on particle effects like smoke and dust.
	# This is the cheapest per-pixel lighting method, however the material normal is not taken into account.
	TLM_VolumetricNonDirectional = 0
	# Lighting will be calculated for a volume, with directionality so that the normal of the material is taken into account.
	# Note that the default particle tangent space is facing the camera, so enable bGenerateSphericalParticleNormals to get a more useful tangent space.
	TLM_VolumetricDirectional = 1
	# Same as Volumetric Non Directional, but lighting is only evaluated at vertices so the pixel shader cost is significantly less.
	# Note that lighting still comes from a volume texture, so it is limited in range.  Directional lights become unshadowed in the distance.
	TLM_VolumetricPerVertexNonDirectional = 2
	# Same as Volumetric Directional, but lighting is only evaluated at vertices so the pixel shader cost is significantly less.
	# Note that lighting still comes from a volume texture, so it is limited in range.  Directional lights become unshadowed in the distance.
	TLM_VolumetricPerVertexDirectional = 3
	# Lighting will be calculated for a surface. The light is accumulated in a volume so the result is blurry,
	# limited distance but the per pixel cost is very low. Use this on translucent surfaces like glass and water.
	# Only diffuse lighting is supported.
	TLM_Surface = 4
	# Lighting will be calculated for a surface. Use this on translucent surfaces like glass and water.
	# This is implemented with forward shading so specular highlights from local lights are supported, however many deferred-only features are not.
	# This is the most expensive translucency lighting method as each light's contribution is computed per-pixel.
	TLM_SurfacePerPixelLighting = 5
	# 
	TLM_MAX = 6

class ERefractionMode(Enum):
	"""Determines how the refraction offset should be computed for the material."""

	# Refraction is computed based on the camera vector entering a medium whose index of refraction is defined by the Refraction material input.
	# The new medium's surface is defined by the material's normal.  With this mode, a flat plane seen from the side will have a constant refraction offset.
	# This is a physical model of refraction but causes reading outside the scene color texture so is a poor fit for large refractive surfaces like water.
	RM_IndexOfRefraction = 0
	# The refraction offset into Scene Color is computed based on the difference between the per-pixel normal and the per-vertex normal.
	# With this mode, a material whose normal is the default (0, 0, 1) will never cause any refraction.  This mode is only valid with tangent space normals.
	# The refraction material input scales the offset, although a value of 1.0 maps to no refraction, and a value of 2 maps to a scale of 1.0 on the offset.
	# This is a non-physical model of refraction but is useful on large refractive surfaces like water, since offsets have to stay small to avoid reading outside scene color.
	RM_PixelNormalOffset = 1

class ETranslucentSortPolicy(Enum):
	"""Enumerates available options for the translucency sort policy."""

	# Sort based on distance from camera centerpoint to bounding sphere centerpoint. (Default, best for 3D games.)
	SortByDistance = 0
	# Sort based on the post-projection Z distance to the camera.
	SortByProjectedZ = 1
	# Sort based on the projection onto a fixed axis. (Best for 2D games.)
	SortAlongAxis = 2

class ESceneCaptureSource(Enum):
	"""Specifies which component of the scene rendering should be output to the final render target."""

	# 
	SCS_SceneColorHDR = 0
	# 
	SCS_SceneColorHDRNoAlpha = 1
	# 
	SCS_FinalColorLDR = 2
	# 
	SCS_SceneColorSceneDepth = 3
	# 
	SCS_SceneDepth = 4
	# 
	SCS_DeviceDepth = 5
	# 
	SCS_Normal = 6
	# 
	SCS_BaseColor = 7
	# 
	SCS_FinalColorHDR = 8
	# 
	SCS_FinalToneCurveHDR = 9

class ESceneCaptureCompositeMode(Enum):
	"""Specifies how scene captures are composited into render buffers"""

	# 
	SCCM_Overwrite = 0
	# 
	SCCM_Additive = 1
	# 
	SCCM_Composite = 2

class EGBufferFormat(Enum):
	"""Enumerates available GBufferFormats.
@warning When this enum is updated please update CVarGBufferFormat comments"""

	# Forces all GBuffers to 8 bits per channel. Intended as profiling for best performance.
	Force8BitsPerChannel = 0
	# See GBuffer allocation function for layout details.
	Default = 1
	# Same as Default except normals are encoded at 16 bits per channel.
	HighPrecisionNormals = 3
	# Forces all GBuffers to 16 bits per channel. Intended as profiling for best quality.
	Force16BitsPerChannel = 5

class ETrailWidthMode(Enum):
	"""Controls the way that the width scale property affects animation trails."""

	# 
	ETrailWidthMode_FromCentre = 0
	# 
	ETrailWidthMode_FromFirst = 1
	# 
	ETrailWidthMode_FromSecond = 2

class EParticleCollisionMode(Enum):
	"""Specifies how particle collision is computed for GPU particles"""

	# 
	SceneDepth = 0
	# 
	DistanceField = 1

class EMaterialShadingModel(Enum):
	"""Specifies the overal rendering/shading model for a material
@warning Check UMaterialInstance::Serialize if changed!"""

	# 
	MSM_Unlit = 0
	# 
	MSM_DefaultLit = 1
	# 
	MSM_Subsurface = 2
	# 
	MSM_PreintegratedSkin = 3
	# 
	MSM_ClearCoat = 4
	# 
	MSM_SubsurfaceProfile = 5
	# 
	MSM_TwoSidedFoliage = 6
	# 
	MSM_Hair = 7
	# 
	MSM_Cloth = 8
	# 
	MSM_Eye = 9
	# 
	MSM_SingleLayerWater = 10
	# 
	MSM_ThinTranslucent = 11
	# Number of unique shading models.
	MSM_NUM = 12
	# Shading model will be determined by the Material Expression Graph,
	#               by utilizing the 'Shading Model' MaterialAttribute output pin.
	MSM_FromMaterialExpression = 13
	# 
	MSM_MAX = 14

class EMaterialTessellationMode(Enum):
	"""This is used by the drawing passes to determine tessellation policy, so changes here need to be supported in native code."""

	# Tessellation disabled.
	MTM_NoTessellation = 0
	# Simple tessellation.
	MTM_FlatTessellation = 1
	# Simple spline based tessellation.
	MTM_PNTriangles = 2
	# 
	MTM_MAX = 3

class EMaterialSamplerType(Enum):
	"""Describes how textures are sampled for materials"""

	# 
	SAMPLERTYPE_Color = 0
	# 
	SAMPLERTYPE_Grayscale = 1
	# 
	SAMPLERTYPE_Alpha = 2
	# 
	SAMPLERTYPE_Normal = 3
	# 
	SAMPLERTYPE_Masks = 4
	# 
	SAMPLERTYPE_DistanceFieldFont = 5
	# 
	SAMPLERTYPE_LinearColor = 6
	# 
	SAMPLERTYPE_LinearGrayscale = 7
	# 
	SAMPLERTYPE_Data = 8
	# 
	SAMPLERTYPE_External = 9
	# 
	SAMPLERTYPE_VirtualColor = 10
	# 
	SAMPLERTYPE_VirtualGrayscale = 11
	# 
	SAMPLERTYPE_VirtualAlpha = 12
	# 
	SAMPLERTYPE_VirtualNormal = 13
	# 
	SAMPLERTYPE_VirtualMasks = 14
	# No DistanceFiledFont Virtual
	SAMPLERTYPE_VirtualLinearColor = 15
	# 
	SAMPLERTYPE_VirtualLinearGrayscale = 16
	# No External Virtual
	SAMPLERTYPE_MAX = 17

class EMaterialStencilCompare(Enum):
	"""EMaterial Stencil Compare"""

	# 
	MSC_Less = 0
	# 
	MSC_LessEqual = 1
	# 
	MSC_Greater = 2
	# 
	MSC_GreaterEqual = 3
	# 
	MSC_Equal = 4
	# 
	MSC_NotEqual = 5
	# 
	MSC_Never = 6
	# 
	MSC_Always = 7
	# 
	MSC_Count = 8

class EMaterialShadingRate(Enum):
	"""EMaterial Shading Rate"""

	# 
	MSR_1x1 = 0
	# 
	MSR_2x1 = 1
	# 
	MSR_1x2 = 2
	# 
	MSR_2x2 = 3
	# 
	MSR_4x2 = 4
	# 
	MSR_2x4 = 5
	# 
	MSR_4x4 = 6
	# 
	MSR_Count = 7

class ELightingBuildQuality(Enum):
	"""Lighting build quality enumeration"""

	# 
	Quality_Preview = 0
	# 
	Quality_Medium = 1
	# 
	Quality_High = 2
	# 
	Quality_Production = 3
	# 
	Quality_MAX = 4

class EMovementMode(Enum):
	"""Movement modes for Characters."""

	# None (movement is disabled).
	MOVE_None = 0
	# Walking on a surface.
	MOVE_Walking = 1
	# Simplified walking on navigation data (e.g. navmesh).
	# If GetGenerateOverlapEvents() is true, then we will perform sweeps with each navmesh move.
	# If GetGenerateOverlapEvents() is false then movement is cheaper but characters can overlap other objects without some extra process to repel/resolve their collisions.
	MOVE_NavWalking = 2
	# Falling under the effects of gravity, such as after jumping or walking off the edge of a surface.
	MOVE_Falling = 3
	# Swimming through a fluid volume, under the effects of gravity and buoyancy.
	MOVE_Swimming = 4
	# Flying, ignoring the effects of gravity. Affected by the current physics volume's fluid friction.
	MOVE_Flying = 5
	# User-defined custom movement mode, including many possible sub-modes.
	MOVE_Custom = 6
	# 
	MOVE_MAX = 7

class ENetworkSmoothingMode(Enum):
	"""Smoothing approach used by network interpolation for Characters."""

	# No smoothing, only change position as network position updates are received.
	Disabled = 0
	# Linear interpolation from source to target.
	Linear = 1
	# Exponential. Faster as you are further from target.
	Exponential = 2
	# Special linear interpolation designed specifically for replays. Not intended as a selectable mode in-editor.
	Replay = 3

class ECollisionChannel(Enum):
	"""Enum indicating different type of objects for rigid-body collision purposes."""

	# 
	ECC_WorldStatic = 0
	# 
	ECC_WorldDynamic = 1
	# 
	ECC_Pawn = 2
	# 
	ECC_Visibility = 3
	# 
	ECC_Camera = 4
	# 
	ECC_PhysicsBody = 5
	# 
	ECC_Vehicle = 6
	# 
	ECC_Destructible = 7
	# Reserved for gizmo collision
	ECC_EngineTraceChannel1 = 8
	# 
	ECC_EngineTraceChannel2 = 9
	# 
	ECC_EngineTraceChannel3 = 10
	# 
	ECC_EngineTraceChannel4 = 11
	# 
	ECC_EngineTraceChannel5 = 12
	# 
	ECC_EngineTraceChannel6 = 13
	# 
	ECC_GameTraceChannel1 = 14
	# 
	ECC_GameTraceChannel2 = 15
	# 
	ECC_GameTraceChannel3 = 16
	# 
	ECC_GameTraceChannel4 = 17
	# 
	ECC_GameTraceChannel5 = 18
	# 
	ECC_GameTraceChannel6 = 19
	# 
	ECC_GameTraceChannel7 = 20
	# 
	ECC_GameTraceChannel8 = 21
	# 
	ECC_GameTraceChannel9 = 22
	# 
	ECC_GameTraceChannel10 = 23
	# 
	ECC_GameTraceChannel11 = 24
	# 
	ECC_GameTraceChannel12 = 25
	# 
	ECC_GameTraceChannel13 = 26
	# 
	ECC_GameTraceChannel14 = 27
	# 
	ECC_GameTraceChannel15 = 28
	# 
	ECC_GameTraceChannel16 = 29
	# 
	ECC_GameTraceChannel17 = 30
	# 
	ECC_GameTraceChannel18 = 31
	# Add only nonserialized/transient flags below // NOTE!!!! THESE ARE BEING DEPRECATED BUT STILL THERE FOR BLUEPRINT. PLEASE DO NOT USE THEM IN CODE
	ECC_OverlapAll_Deprecated = 32
	# 
	ECC_MAX = 33

class EOverlapFilterOption(Enum):
	"""Specifies what types of objects to return from an overlap physics query
@warning If you change this, change GetCollisionChannelFromOverlapFilter() to match"""

	# Returns both overlaps with both dynamic and static components
	OverlapFilter_All = 0
	# returns only overlaps with dynamic actors (far fewer results in practice, much more efficient)
	OverlapFilter_DynamicOnly = 1
	# returns only overlaps with static actors (fewer results, more efficient)
	OverlapFilter_StaticOnly = 2

class EObjectTypeQuery(Enum):
	"""Specifies custom collision object types, overridable per game"""

	# 
	ObjectTypeQuery1 = 0
	# 
	ObjectTypeQuery2 = 1
	# 
	ObjectTypeQuery3 = 2
	# 
	ObjectTypeQuery4 = 3
	# 
	ObjectTypeQuery5 = 4
	# 
	ObjectTypeQuery6 = 5
	# 
	ObjectTypeQuery7 = 6
	# 
	ObjectTypeQuery8 = 7
	# 
	ObjectTypeQuery9 = 8
	# 
	ObjectTypeQuery10 = 9
	# 
	ObjectTypeQuery11 = 10
	# 
	ObjectTypeQuery12 = 11
	# 
	ObjectTypeQuery13 = 12
	# 
	ObjectTypeQuery14 = 13
	# 
	ObjectTypeQuery15 = 14
	# 
	ObjectTypeQuery16 = 15
	# 
	ObjectTypeQuery17 = 16
	# 
	ObjectTypeQuery18 = 17
	# 
	ObjectTypeQuery19 = 18
	# 
	ObjectTypeQuery20 = 19
	# 
	ObjectTypeQuery21 = 20
	# 
	ObjectTypeQuery22 = 21
	# 
	ObjectTypeQuery23 = 22
	# 
	ObjectTypeQuery24 = 23
	# 
	ObjectTypeQuery25 = 24
	# 
	ObjectTypeQuery26 = 25
	# 
	ObjectTypeQuery27 = 26
	# 
	ObjectTypeQuery28 = 27
	# 
	ObjectTypeQuery29 = 28
	# 
	ObjectTypeQuery30 = 29
	# 
	ObjectTypeQuery31 = 30
	# 
	ObjectTypeQuery32 = 31
	# 
	ObjectTypeQuery_MAX = 32

class ETraceTypeQuery(Enum):
	"""Specifies custom collision trace types, overridable per game"""

	# 
	TraceTypeQuery1 = 0
	# 
	TraceTypeQuery2 = 1
	# 
	TraceTypeQuery3 = 2
	# 
	TraceTypeQuery4 = 3
	# 
	TraceTypeQuery5 = 4
	# 
	TraceTypeQuery6 = 5
	# 
	TraceTypeQuery7 = 6
	# 
	TraceTypeQuery8 = 7
	# 
	TraceTypeQuery9 = 8
	# 
	TraceTypeQuery10 = 9
	# 
	TraceTypeQuery11 = 10
	# 
	TraceTypeQuery12 = 11
	# 
	TraceTypeQuery13 = 12
	# 
	TraceTypeQuery14 = 13
	# 
	TraceTypeQuery15 = 14
	# 
	TraceTypeQuery16 = 15
	# 
	TraceTypeQuery17 = 16
	# 
	TraceTypeQuery18 = 17
	# 
	TraceTypeQuery19 = 18
	# 
	TraceTypeQuery20 = 19
	# 
	TraceTypeQuery21 = 20
	# 
	TraceTypeQuery22 = 21
	# 
	TraceTypeQuery23 = 22
	# 
	TraceTypeQuery24 = 23
	# 
	TraceTypeQuery25 = 24
	# 
	TraceTypeQuery26 = 25
	# 
	TraceTypeQuery27 = 26
	# 
	TraceTypeQuery28 = 27
	# 
	TraceTypeQuery29 = 28
	# 
	TraceTypeQuery30 = 29
	# 
	TraceTypeQuery31 = 30
	# 
	TraceTypeQuery32 = 31
	# 
	TraceTypeQuery_MAX = 32

class ECollisionResponse(Enum):
	"""Enum indicating how each type should respond"""

	# 
	ECR_Ignore = 0
	# 
	ECR_Overlap = 1
	# 
	ECR_Block = 2
	# 
	ECR_MAX = 3

class EFilterInterpolationType(Enum):
	"""Interpolation method used by animation blending"""

	# 
	BSIT_Average = 0
	# 
	BSIT_Linear = 1
	# 
	BSIT_Cubic = 2
	# 
	BSIT_MAX = 3

class ETimelineSigType(Enum):
	"""Enum used to indicate what type of timeline signature a function matches."""

	# 
	ETS_EventSignature = 0
	# 
	ETS_FloatSignature = 1
	# 
	ETS_VectorSignature = 2
	# 
	ETS_LinearColorSignature = 3
	# 
	ETS_InvalidSignature = 4
	# 
	ETS_MAX = 5

class ECollisionEnabled(Enum):
	"""Enum used to describe what type of collision is enabled on a body."""

	# Will not create any representation in the physics engine. Cannot be used for spatial queries (raycasts, sweeps, overlaps) or simulation (rigid body, constraints). Best performance possible (especially for moving objects)
	NoCollision = 0
	# Only used for spatial queries (raycasts, sweeps, and overlaps). Cannot be used for simulation (rigid body, constraints). Useful for character movement and things that do not need physical simulation. Performance gains by keeping data out of simulation tree.
	QueryOnly = 1
	# Only used only for physics simulation (rigid body, constraints). Cannot be used for spatial queries (raycasts, sweeps, overlaps). Useful for jiggly bits on characters that do not need per bone detection. Performance gains by keeping data out of query tree
	PhysicsOnly = 2
	# Can be used for both spatial queries (raycasts, sweeps, overlaps) and simulation (rigid body, constraints).
	QueryAndPhysics = 3

class ELightMapPaddingType(Enum):
	"""Method for padding a light map in memory"""

	# 
	LMPT_NormalPadding = 0
	# 
	LMPT_PrePadding = 1
	# 
	LMPT_NoPadding = 2

class EShadowMapFlags(Enum):
	"""Bit-field flags that affects storage (e.g. packing, streaming) and other info about a shadowmap."""

	# No flags.
	SMF_None = 0
	# Shadowmap should be placed in a streaming texture.
	SMF_Streamed = 1

class ETeleportType(Enum):
	"""Whether to teleport physics body or not"""

	# Do not teleport physics body. This means velocity will reflect the movement between initial and final position, and collisions along the way will occur
	None = 0
	# Teleport physics body so that velocity remains the same and no collision occurs
	TeleportPhysics = 1
	# Teleport physics body and reset physics state completely
	ResetPhysics = 2

class EUpdateRateShiftBucket(Enum):
	"""Enum for controlling buckets for update rate optimizations if we need to stagger
Multiple actor populations separately."""

	# 
	ShiftBucket0 = 0
	# 
	ShiftBucket1 = 1
	# 
	ShiftBucket2 = 2
	# 
	ShiftBucket3 = 3
	# 
	ShiftBucket4 = 4
	# 
	ShiftBucket5 = 5
	# 
	ShiftBucketMax = 6

class ENetRole(Enum):
	"""The network role of an actor on a local/remote network context"""

	# No role at all.
	ROLE_None = 0
	# Locally simulated proxy of this actor.
	ROLE_SimulatedProxy = 1
	# Locally autonomous proxy of this actor.
	ROLE_AutonomousProxy = 2
	# Authoritative control over the actor.
	ROLE_Authority = 3
	# 
	ROLE_MAX = 4

class ENetDormancy(Enum):
	"""Describes if an actor can enter a low network bandwidth dormant mode"""

	# This actor can never go network dormant.
	DORM_Never = 0
	# This actor can go dormant, but is not currently dormant. Game code will tell it when it go dormant.
	DORM_Awake = 1
	# This actor wants to go fully dormant for all connections.
	DORM_DormantAll = 2
	# This actor may want to go dormant for some connections, GetNetDormancy() will be called to find out which.
	DORM_DormantPartial = 3
	# This actor is initially dormant for all connection if it was placed in map.
	DORM_Initial = 4
	# 
	DORM_MAX = 5

class EAutoReceiveInput(Enum):
	"""Specifies which player index will pass input to this actor/component"""

	# 
	Disabled = 0
	# 
	Player0 = 1
	# 
	Player1 = 2
	# 
	Player2 = 3
	# 
	Player3 = 4
	# 
	Player4 = 5
	# 
	Player5 = 6
	# 
	Player6 = 7
	# 
	Player7 = 8

class EAutoPossessAI(Enum):
	"""Specifies if an AI pawn will automatically be possed by an AI controller"""

	# Feature is disabled (do not automatically possess AI).
	Disabled = 0
	# Only possess by an AI Controller if Pawn is placed in the world.
	PlacedInWorld = 1
	# Only possess by an AI Controller if Pawn is spawned after the world has loaded.
	Spawned = 2
	# Pawn is automatically possessed by an AI Controller whenever it is created.
	PlacedInWorldOrSpawned = 3

class EEndPlayReason(Enum):
	"""Specifies why an actor is being deleted/removed from a level"""

	# When the Actor or Component is explicitly destroyed.
	Destroyed = 0
	# When the world is being unloaded for a level transition.
	LevelTransition = 1
	# When the world is being unloaded because PIE is ending.
	EndPlayInEditor = 2
	# When the level it is a member of is streamed out.
	RemovedFromWorld = 3
	# When the application is being exited.
	Quit = 4

class EVectorQuantization(Enum):
	"""Describes rules for network replicating a vector efficiently"""

	# Each vector component will be rounded to the nearest whole number.
	RoundWholeNumber = 0
	# Each vector component will be rounded, preserving one decimal place.
	RoundOneDecimal = 1
	# Each vector component will be rounded, preserving two decimal places.
	RoundTwoDecimals = 2

class ERotatorQuantization(Enum):
	"""Describes rules for network replicating a vector efficiently"""

	# The rotator will be compressed to 8 bits per component.
	ByteComponents = 0
	# The rotator will be compressed to 16 bits per component.
	ShortComponents = 1

class EWalkableSlopeBehavior(Enum):
	"""Controls behavior of WalkableSlopeOverride, determining how to affect walkability of surfaces for Characters.
@see FWalkableSlopeOverride
@see UCharacterMovementComponent::GetWalkableFloorAngle(), UCharacterMovementComponent::SetWalkableFloorAngle()"""

	# Don't affect the walkable slope. Walkable slope angle will be ignored.
	WalkableSlope_Default = 0
	# Increase walkable slope.
	# Makes it easier to walk up a surface, by allowing traversal over higher-than-usual angles.
	# @see FWalkableSlopeOverride::WalkableSlopeAngle
	WalkableSlope_Increase = 1
	# Decrease walkable slope.
	# Makes it harder to walk up a surface, by restricting traversal to lower-than-usual angles.
	# @see FWalkableSlopeOverride::WalkableSlopeAngle
	WalkableSlope_Decrease = 2
	# Make surface unwalkable.
	# Note: WalkableSlopeAngle will be ignored.
	WalkableSlope_Unwalkable = 3
	# 
	WalkableSlope_Max = 4

class EPhysicalMaterialMaskColor(Enum):
	"""Types of valid physical material mask colors which may be associated with a physical material"""

	# 
	Red = 0
	# 
	Green = 1
	# 
	Blue = 2
	# 
	Cyan = 3
	# 
	Magenta = 4
	# 
	Yellow = 5
	# 
	White = 6
	# 
	Black = 7
	# 
	MAX = 8

class EComponentMobility(Enum):
	"""Describes how often this component is allowed to move."""

	# Static objects cannot be moved or changed in game.
	# - Allows baked lighting
	# - Fastest rendering
	Static = 0
	# A stationary light will only have its shadowing and bounced lighting from static geometry baked by Lightmass, all other lighting will be dynamic.
	# - It can change color and intensity in game.
	# - Can't move
	# - Allows partial baked lighting
	# - Dynamic shadows
	Stationary = 1
	# Movable objects can be moved and changed in game.
	# - Totally dynamic
	# - Can cast dynamic shadows
	# - Slowest rendering
	Movable = 2

class EComponentSocketType(Enum):
	"""Type of a socket on a scene component."""

	# Not a valid socket or bone name.
	Invalid = 0
	# Skeletal bone.
	Bone = 1
	# Socket.
	Socket = 2

class ESpawnActorCollisionHandlingMethod(Enum):
	"""Defines available strategies for handling the case where an actor is spawned in such a way that it penetrates blocking collision."""

	# Fall back to default settings.
	Undefined = 0
	# Actor will spawn in desired location, regardless of collisions.
	AlwaysSpawn = 1
	# Actor will try to find a nearby non-colliding location (based on shape components), but will always spawn even if one cannot be found.
	AdjustIfPossibleButAlwaysSpawn = 2
	# Actor will try to find a nearby non-colliding location (based on shape components), but will NOT spawn unless one is found.
	AdjustIfPossibleButDontSpawnIfColliding = 3
	# Actor will fail to spawn.
	DontSpawnIfColliding = 4

class EMeshBufferAccess(Enum):
	"""Which processors will have access to Mesh Vertex Buffers."""

	# Access will be determined based on the assets used in the mesh and hardware / software capability.
	Default = 0
	# Force access on both CPU and GPU.
	ForceCPUAndGPU = 1

class EComponentCreationMethod(Enum):
	"""EComponent Creation Method"""

	# A component that is part of a native class.
	Native = 0
	# A component that is created from a template defined in the Components section of the Blueprint.
	SimpleConstructionScript = 1
	# A dynamically created component, either from the UserConstructionScript or from a Add Component node in a Blueprint event graph.
	UserConstructionScript = 2
	# A component added to a single Actor instance via the Component section of the Actor's details panel.
	Instance = 3

class EEdGraphPinDirection(Enum):
	"""Enum used to define which way data flows into or out of this pin."""

	# 
	EGPD_Input = 0
	# 
	EGPD_Output = 1
	# 
	EGPD_MAX = 2

class EPinContainerType(Enum):
	"""Enum used to define what container type a pin represents."""

	# 
	None = 0
	# 
	Array = 1
	# 
	Set = 2
	# 
	Map = 3

class ENodeTitleType(Enum):
	"""Enum to indicate what sort of title we want."""

	# The full title, may be multiple lines.
	FullTitle = 0
	# More concise, single line title.
	ListView = 1
	# Returns the editable title (which might not be a title at all).
	EditableTitle = 2
	# Menu Title for context menus to be displayed in context menus referencing the node.
	MenuTitle = 3
	# 
	MAX_TitleTypes = 4

class ENodeAdvancedPins(Enum):
	"""Enum to indicate if a node has advanced-display-pins, and whether they are shown."""

	# No advanced pins.
	NoPins = 0
	# There are some advanced pins, and they are shown.
	Shown = 1
	# There are some advanced pins, and they are hidden.
	Hidden = 2

class ENodeEnabledState(Enum):
	"""Enum to indicate a node's enabled state."""

	# Node is enabled.
	Enabled = 0
	# Node is disabled.
	Disabled = 1
	# Node is enabled for development only.
	DevelopmentOnly = 2

class EBlueprintPinStyleType(Enum):
	"""EBlueprint Pin Style Type"""

	# 
	BPST_Original = 0
	# 
	BPST_VariantA = 1

class EDetailMode(Enum):
	"""Detail mode for scene component rendering, corresponds with the integer value of UWorld::GetDetailMode()"""

	# 
	DM_Low = 0
	# 
	DM_Medium = 1
	# 
	DM_High = 2
	# 
	DM_MAX = 3

class ERelativeTransformSpace(Enum):
	"""The space for the transform"""

	# World space transform.
	RTS_World = 0
	# Actor space transform.
	RTS_Actor = 1
	# Component space transform.
	RTS_Component = 2
	# Parent bone space transform
	RTS_ParentBoneSpace = 3

class EChildActorComponentTreeViewVisualizationMode(Enum):
	"""EChild Actor Component Tree View Visualization Mode"""

	# Use the editor's default setting.
	UseDefault = 0
	# Show only the outer component as a single component node.
	ComponentOnly = 1
	# Include the child actor hierarchy attached to the outer component as the root node.
	ComponentWithChildActor = 2
	# Show only as a child actor hierarchy (i.e. do not show the outer component node as the root).
	ChildActorOnly = 3

class ETextureSizingType(Enum):
	"""ETexture Sizing Type"""

	# 
	TextureSizingType_UseSingleTextureSize = 0
	# 
	TextureSizingType_UseAutomaticBiasedSizes = 1
	# 
	TextureSizingType_UseManualOverrideTextureSize = 2
	# 
	TextureSizingType_UseSimplygonAutomaticSizing = 3
	# 
	TextureSizingType_MAX = 4

class EMaterialMergeType(Enum):
	"""EMaterial Merge Type"""

	# 
	MaterialMergeType_Default = 0
	# 
	MaterialMergeType_Simplygon = 1

class EActorUpdateOverlapsMethod(Enum):
	"""Chooses a method for actors to update overlap state (objects it is touching) on initialization, currently only used during level streaming."""

	# 
	UseConfigDefault = 0
	# Use the default value specified by the native class or config value.
	AlwaysUpdate = 1
	# Always update overlap state on initialization.
	OnlyUpdateMovable = 2
	# Only update if root component has Movable mobility.
	NeverUpdate = 3

class ENavigationOptionFlag(Enum):
	"""ENavigation Option Flag"""

	# 
	Default = 0
	# 
	Enable = 1
	# UHT was complaining when tried to use True as value instead of Enable
	Disable = 2
	# 
	MAX = 3

class ENavDataGatheringMode(Enum):
	"""ENav Data Gathering Mode"""

	# 
	Default = 0
	# 
	Instant = 1
	# 
	Lazy = 2

class ENavDataGatheringModeConfig(Enum):
	"""ENav Data Gathering Mode Config"""

	# 
	Invalid = 0
	# 
	Instant = 1
	# 
	Lazy = 2

class ENavPathEvent(Enum):
	"""ENav Path Event"""

	# 
	Cleared = 0
	# 
	NewPath = 1
	# 
	UpdatedDueToGoalMoved = 2
	# 
	UpdatedDueToNavigationChanged = 3
	# 
	Invalidated = 4
	# 
	RePathFailed = 5
	# 
	MetaPathUpdate = 6
	# 
	Custom = 7

class ENavigationQueryResult(Enum):
	"""ENavigation Query Result"""

	# 
	Invalid = 0
	# 
	Error = 1
	# 
	Fail = 2
	# 
	Success = 3

class ENavLinkDirection(Enum):
	"""ENav Link Direction"""

	# 
	BothWays = 0
	# 
	LeftToRight = 1
	# 
	RightToLeft = 2

class EBlueprintStatus(Enum):
	"""Enumerates states a blueprint can be in."""

	# Blueprint is in an unknown state.
	BS_Unknown = 0
	# Blueprint has been modified but not recompiled.
	BS_Dirty = 1
	# Blueprint tried but failed to be compiled.
	BS_Error = 2
	# Blueprint has been compiled since it was last modified.
	BS_UpToDate = 3
	# Blueprint is in the process of being created for the first time.
	BS_BeingCreated = 4
	# Blueprint has been compiled since it was last modified. There are warnings.
	BS_UpToDateWithWarnings = 5
	# 
	BS_MAX = 6

class EBlueprintType(Enum):
	"""Enumerates types of blueprints."""

	# Normal blueprint.
	BPTYPE_Normal = 0
	# Blueprint that is const during execution (no state graph and methods cannot modify member variables).
	BPTYPE_Const = 1
	# Blueprint that serves as a container for macros to be used in other blueprints.
	BPTYPE_MacroLibrary = 2
	# Blueprint that serves as an interface to be implemented by other blueprints.
	BPTYPE_Interface = 3
	# Blueprint that handles level scripting.
	BPTYPE_LevelScript = 4
	# Blueprint that serves as a container for functions to be used in other blueprints.
	BPTYPE_FunctionLibrary = 5
	# 
	BPTYPE_MAX = 6

class EBlueprintCompileMode(Enum):
	"""Compile modes."""

	# Use the default setting.
	Default = 0
	# Always compile in development mode (even when cooking).
	Development = 1
	# Always compile in final release mode.
	FinalRelease = 2

class EBlueprintNativizationFlag(Enum):
	"""EBlueprint Nativization Flag"""

	# 
	Disabled = 0
	# 
	Dependency = 1
	# conditionally enabled (set from sub-class as a dependency)
	ExplicitlyEnabled = 2

class EPSCPoolMethod(Enum):
	"""EPSCPool Method"""

	# PSC is will be created fresh and not allocated from the pool.
	None = 0
	# PSC is allocated from the pool and will be automatically released back to it.
	# User need not handle this any more that other PSCs but interaction with the PSC after the tick it's spawned in are unsafe.
	# This method is useful for one-shot fx that you don't need to keep a reference to and can fire and forget.
	AutoRelease = 1
	# PSC is allocated from the pool but will NOT be automatically released back to it. User has ownership of the PSC and must call ReleaseToPool when finished with it otherwise the PSC will leak.
	# Interaction with the PSC after it has been released are unsafe.
	# This method is useful for persistent FX that you need to modify parameters upon etc over it's lifetime.
	ManualRelease = 2
	# Special entry allowing manual release PSCs to be manually released but wait until completion to be returned to the pool.
	ManualRelease_OnComplete = 3
	# Special entry that marks a PSC as having been returned to the pool. All PSCs currently in the pool are marked this way.
	FreeInPool = 4

class FNavigationSystemRunMode(Enum):
	"""FNavigation System Run Mode"""

	# 
	InvalidMode = 0
	# 
	GameMode = 1
	# 
	EditorMode = 2
	# 
	SimulationMode = 3
	# 
	PIEMode = 4
	# 
	InferFromWorldMode = 5

class EAnimLinkMethod(Enum):
	"""Supported types of time for a linked element"""

	# Element stays at a specific time without moving.
	Absolute = 0
	# Element moves with its segment, but not when the segment changes size.
	Relative = 1
	# Element moves with its segment and will stay at a certain proportion through the segment.
	Proportional = 2

class ERootMotionRootLock(Enum):
	"""Root Bone Lock options when extracting Root Motion."""

	# Use reference pose root bone position.
	RefPose = 0
	# Use root bone position on first frame of animation.
	AnimFirstFrame = 1
	# FTransform::Identity.
	Zero = 2

class ERootMotionMode(Enum):
	"""ERoot Motion Mode"""

	# Leave root motion in animation.
	NoRootMotionExtraction = 0
	# Extract root motion but do not apply it.
	IgnoreRootMotion = 1
	# Root motion is taken from all animations contributing to the final pose, not suitable for network multiplayer setups.
	RootMotionFromEverything = 2
	# Root motion is only taken from montages, suitable for network multiplayer setups.
	RootMotionFromMontagesOnly = 3

class EAdditiveBasePoseType(Enum):
	"""For an additive animation, indicates what the animation is relative to."""

	# Will be deprecated.
	ABPT_None = 0
	# Use the Skeleton's ref pose as base.
	ABPT_RefPose = 1
	# Use a whole animation as a base pose. BasePoseSeq must be set.
	ABPT_AnimScaled = 2
	# Use one frame of an animation as a base pose. BasePoseSeq and RefFrameIndex must be set (RefFrameIndex will be clamped).
	ABPT_AnimFrame = 3
	# 
	ABPT_MAX = 4

class AnimationCompressionFormat(Enum):
	"""Indicates animation data compression format."""

	# 
	ACF_None = 0
	# 
	ACF_Float96NoW = 1
	# 
	ACF_Fixed48NoW = 2
	# 
	ACF_IntervalFixed32NoW = 3
	# 
	ACF_Fixed32NoW = 4
	# 
	ACF_Float32NoW = 5
	# 
	ACF_Identity = 6
	# 
	ACF_MAX = 7

class EBoneAxis(Enum):
	"""Enum for specifying a specific axis of a bone"""

	# 
	BA_X = 0
	# 
	BA_Y = 1
	# 
	BA_Z = 2

class EBoneControlSpace(Enum):
	"""Enum for controlling which reference frame a controller is applied in."""

	# Set absolute position of bone in world space.
	BCS_WorldSpace = 0
	# Set position of bone in SkeletalMeshComponent's reference frame.
	BCS_ComponentSpace = 1
	# Set position of bone relative to parent bone.
	BCS_ParentBoneSpace = 2
	# Set position of bone in its own reference frame.
	BCS_BoneSpace = 3
	# 
	BCS_MAX = 4

class EBoneRotationSource(Enum):
	"""Enum for specifying the source of a bone's rotation."""

	# Don't change rotation at all.
	BRS_KeepComponentSpaceRotation = 0
	# Keep forward direction vector relative to the parent bone.
	BRS_KeepLocalSpaceRotation = 1
	# Copy rotation of target to bone.
	BRS_CopyFromTarget = 2

class EMontageNotifyTickType(Enum):
	"""Ticking method for AnimNotifies in AnimMontages."""

	# Queue notifies, and trigger them at the end of the evaluation phase (faster). Not suitable for changing sections or montage position.
	Queued = 0
	# Trigger notifies as they are encountered (Slower). Suitable for changing sections or montage position.
	BranchingPoint = 1

class ENotifyFilterType(Enum):
	"""Filtering method for deciding whether to trigger a notify."""

	# No filtering.
	NoFiltering = 0
	# Filter By Skeletal Mesh LOD.
	LOD = 1

class EAdditiveAnimationType(Enum):
	"""Indicates whether an animation is additive, and what kind."""

	# No additive.
	AAT_None = 0
	# Create Additive from LocalSpace Base.
	AAT_LocalSpaceBase = 1
	# Create Additive from MeshSpace Rotation Only, Translation still will be LocalSpace.
	AAT_RotationOffsetMeshSpace = 2
	# 
	AAT_MAX = 3

class ECurveBlendOption(Enum):
	"""ECurve Blend Option"""

	# Last pose that contains valid curve value override it.
	Override = 0
	# Only set the value if the previous pose doesn't have the curve value.
	DoNotOverride = 1
	# Normalize By Sum of Weight and use it to blend.
	NormalizeByWeight = 2
	# Blend By Weight without normalizing
	BlendByWeight = 3
	# Use Base Pose for all curve values. Do not blend
	UseBasePose = 4
	# Find the highest curve value from multiple poses and use that.
	UseMaxValue = 5
	# Find the lowest curve value from multiple poses and use that.
	UseMinValue = 6

class EAnimInterpolationType(Enum):
	"""Indicates how animation should be evaluated between keys."""

	# Linear interpolation when looking up values between keys.
	Linear = 0
	# Step interpolation when looking up values between keys.
	Step = 1

class EAxisOption(Enum):
	"""EAxis Option"""

	# 
	X = 0
	# 
	Y = 1
	# 
	Z = 2
	# 
	X_Neg = 3
	# 
	Y_Neg = 4
	# 
	Z_Neg = 5
	# 
	Custom = 6

class EComponentType(Enum):
	"""The transform component (attribute) to read from"""

	# 
	None = 0
	# 
	TranslationX = 1
	# 
	TranslationY = 2
	# 
	TranslationZ = 3
	# 
	RotationX = 4
	# 
	RotationY = 5
	# 
	RotationZ = 6
	# 
	Scale = 7
	# 
	ScaleX = 8
	# 
	ScaleY = 9
	# 
	ScaleZ = 10

class EFullyLoadPackageType(Enum):
	"""Enumerates types of fully loaded packages."""

	# Load the packages when the map in Tag is loaded.
	FULLYLOAD_Map = 0
	# Load the packages before the game class in Tag is loaded. The Game name MUST be specified in the URL (game=Package.GameName). Useful for loading packages needed to load the game type (a DLC game type, for instance).
	FULLYLOAD_Game_PreLoadClass = 1
	# Load the packages after the game class in Tag is loaded. Will work no matter how game is specified in UWorld::SetGameMode. Useful for modifying shipping gametypes by loading more packages (mutators, for instance).
	FULLYLOAD_Game_PostLoadClass = 2
	# Fully load the package as long as the DLC is loaded.
	FULLYLOAD_Always = 3
	# Load the package for a mutator that is active.
	FULLYLOAD_Mutator = 4
	# 
	FULLYLOAD_MAX = 5

class ETransitionType(Enum):
	"""Enumerates transition types."""

	# 
	None = 0
	# 
	Paused = 1
	# 
	Loading = 2
	# 
	Saving = 3
	# 
	Connecting = 4
	# 
	Precaching = 5
	# 
	WaitingToConnect = 6
	# 
	MAX = 7

class SkeletalMeshTerminationCriterion(Enum):
	"""Enum specifying the reduction type to use when simplifying skeletal meshes with internal tool"""

	# Triangle count criterion will be used for simplification.
	SMTC_NumOfTriangles = 0
	# Vertex cont criterion will be used for simplification.
	SMTC_NumOfVerts = 1
	# Simplification will continue until either Triangle or Vertex count criteria is met.
	SMTC_TriangleOrVert = 2
	# Triangle count criterion will be used for simplification.
	SMTC_AbsNumOfTriangles = 3
	# Vertex cont criterion will be used for simplification.
	SMTC_AbsNumOfVerts = 4
	# Simplification will continue until either Triangle or Vertex count criteria is met.
	SMTC_AbsTriangleOrVert = 5
	# 
	SMTC_MAX = 6

class SkeletalMeshOptimizationType(Enum):
	"""Enum specifying the reduction type to use when simplifying skeletal meshes with Simmplygon"""

	# Triangle requirement will be used for simplification.
	SMOT_NumOfTriangles = 0
	# Accuracy requirement will be used for simplification.
	SMOT_MaxDeviation = 1
	# Simplification will continue until either Triangle or Accuracy requirement is met.
	SMOT_TriangleOrDeviation = 2
	# 
	SMOT_MAX = 3

class SkeletalMeshOptimizationImportance(Enum):
	"""Enum specifying the importance of properties when simplifying skeletal meshes."""

	# 
	SMOI_Off = 0
	# 
	SMOI_Lowest = 1
	# 
	SMOI_Low = 2
	# 
	SMOI_Normal = 3
	# 
	SMOI_High = 4
	# 
	SMOI_Highest = 5
	# 
	SMOI_MAX = 6

class EBoneFilterActionOption(Enum):
	"""EBone Filter Action Option"""

	# Remove list of joints specified and children. All the other joints will be kept.
	Remove = 0
	# Only keep the joints specified and parents. All the other joints will be removed.
	Keep = 1
	# Invalid
	Invalid = 2

class EMaterialProperty(Enum):
	"""EMaterialProperty"""

	# 
	MP_EmissiveColor = 0
	# 
	MP_Opacity = 1
	# 
	MP_OpacityMask = 2
	# 
	MP_DiffuseColor = 3
	# used in Lightmass, not exposed to user, computed from: BaseColor, Metallic
	MP_SpecularColor = 4
	# used in Lightmass, not exposed to user, derived from: SpecularColor, Metallic, Specular
	MP_BaseColor = 5
	# 
	MP_Metallic = 6
	# 
	MP_Specular = 7
	# 
	MP_Roughness = 8
	# 
	MP_Anisotropy = 9
	# 
	MP_Normal = 10
	# 
	MP_Tangent = 11
	# 
	MP_WorldPositionOffset = 12
	# 
	MP_WorldDisplacement = 13
	# 
	MP_TessellationMultiplier = 14
	# 
	MP_SubsurfaceColor = 15
	# 
	MP_CustomData0 = 16
	# 
	MP_CustomData1 = 17
	# 
	MP_AmbientOcclusion = 18
	# 
	MP_Refraction = 19
	# 
	MP_CustomizedUVs0 = 20
	# 
	MP_CustomizedUVs1 = 21
	# 
	MP_CustomizedUVs2 = 22
	# 
	MP_CustomizedUVs3 = 23
	# 
	MP_CustomizedUVs4 = 24
	# 
	MP_CustomizedUVs5 = 25
	# 
	MP_CustomizedUVs6 = 26
	# 
	MP_CustomizedUVs7 = 27
	# 
	MP_PixelDepthOffset = 28
	# 
	MP_ShadingModel = 29
	# ^^^ New material properties go above here ^^^^
	MP_MaterialAttributes = 30
	# 
	MP_CustomOutput = 31
	# 
	MP_MAX = 32

class ESkinCacheUsage(Enum):
	"""ESkin Cache Usage"""

	# Auto will defer to child or global behavior based on context. If Ray Tracing is enabled, will imply Enabled
	Auto = 0
	# Mesh will not use the skin cache. If Ray Tracing is enabled, will imply Enabled
	Disabled = -1
	# Mesh will use the skin cache
	Enabled = 1

class ESkinCacheDefaultBehavior(Enum):
	"""ESkin Cache Default Behavior"""

	# All skeletal meshes are excluded from the skin cache. Each must opt in individually. If Ray Tracing is enabled, will imply Inclusive
	Exclusive = 0
	# All skeletal meshes are included into the skin cache. Each must opt out individually
	Inclusive = 1

class EAnimGroupRole(Enum):
	"""EAnim Group Role"""

	# This node can be the leader, as long as it has a higher blend weight than the previous best leader.
	CanBeLeader = 0
	# This node will always be a follower (unless there are only followers, in which case the first one ticked wins).
	AlwaysFollower = 1
	# This node will always be a leader (if more than one node is AlwaysLeader, the last one ticked wins).
	AlwaysLeader = 2
	# This node will be excluded from the sync group while blending in. Once blended in it will be the sync group leader until blended out
	TransitionLeader = 3
	# This node will be excluded from the sync group while blending in. Once blended in it will be a follower until blended out
	TransitionFollower = 4

class EAnimSyncGroupScope(Enum):
	"""EAnim Sync Group Scope"""

	# Sync only with animations in the current instance (either main or linked instance)
	Local = 0
	# Sync with all animations in the main and linked instances of this skeletal mesh component
	Component = 1

class EBlendSpaceAxis(Enum):
	"""Interpolation data types."""

	# 
	BSA_None = 0
	# 
	BSA_X = 1
	# 
	BSA_Y = 2
	# 
	BSA_Max = 3

class ENotifyTriggerMode(Enum):
	"""ENotify Trigger Mode"""

	# 
	AllAnimations = 0
	# 
	HighestWeightedAnimation = 1
	# 
	None = 2

class ERichCurveInterpMode(Enum):
	"""Method of interpolation between this key and the next."""

	# Use linear interpolation between values.
	RCIM_Linear = 0
	# Use a constant value. Represents stepped values.
	RCIM_Constant = 1
	# Cubic interpolation. See TangentMode for different cubic interpolation options.
	RCIM_Cubic = 2
	# No interpolation.
	RCIM_None = 3

class ERichCurveExtrapolation(Enum):
	"""Enumerates extrapolation options."""

	# Repeat the curve without an offset.
	RCCE_Cycle = 0
	# Repeat the curve with an offset relative to the first or last key's value.
	RCCE_CycleWithOffset = 1
	# Sinusoidally extrapolate.
	RCCE_Oscillate = 2
	# Use a linearly increasing value for extrapolation.
	RCCE_Linear = 3
	# Use a constant value for extrapolation
	RCCE_Constant = 4
	# No Extrapolation
	RCCE_None = 5

class ERichCurveTangentMode(Enum):
	"""If using RCIM_Cubic, this enum describes how the tangents should be controlled in editor."""

	# Automatically calculates tangents to create smooth curves between values.
	RCTM_Auto = 0
	# User specifies the tangent as a unified tangent where the two tangents are locked to each other, presenting a consistent curve before and after.
	RCTM_User = 1
	# User specifies the tangent as two separate broken tangents on each side of the key which can allow a sharp change in evaluation before or after.
	RCTM_Break = 2
	# No tangents.
	RCTM_None = 3

class ERichCurveTangentWeightMode(Enum):
	"""Enumerates tangent weight modes."""

	# Don't take tangent weights into account.
	RCTWM_WeightedNone = 0
	# Only take the arrival tangent weight into account for evaluation.
	RCTWM_WeightedArrive = 1
	# Only take the leaving tangent weight into account for evaluation.
	RCTWM_WeightedLeave = 2
	# Take both the arrival and leaving tangent weights into account for evaluation.
	RCTWM_WeightedBoth = 3

class ERichCurveCompressionFormat(Enum):
	"""Enumerates curve compression options."""

	# No keys are present
	RCCF_Empty = 0
	# All keys use constant interpolation
	RCCF_Constant = 1
	# All keys use linear interpolation
	RCCF_Linear = 2
	# All keys use cubic interpolation
	RCCF_Cubic = 3
	# Keys use mixed interpolation modes
	RCCF_Mixed = 4
	# Keys use weighted interpolation modes
	RCCF_Weighted = 5

class ERichCurveKeyTimeCompressionFormat(Enum):
	"""Enumerates key time compression options."""

	# Key time is quantized to 16 bits
	RCKTCF_uint16 = 0
	# Key time uses full precision
	RCKTCF_float32 = 1

class EBoneTranslationRetargetingMode(Enum):
	"""Bone translation retargeting mode."""

	# Use translation from animation data.
	Animation = 0
	# Use fixed translation from Skeleton.
	Skeleton = 1
	# Use Translation from animation, but scale length by Skeleton's proportions.
	AnimationScaled = 2
	# Use Translation from animation, but also play the difference from retargeting pose as an additive.
	AnimationRelative = 3
	# Apply delta orientation and scale from ref pose
	OrientAndScale = 4

class EAnimAssetCurveFlags(Enum):
	"""This is curve flags that are saved in asset and *"""

	# 
	AACF_NONE = 0
	# Used as morph target curve
	AACF_DriveMorphTarget_DEPRECATED = 1
	# This has moved to FAnimCurveType:bMorphTarget. Set per skeleton. DO NOT REMOVE UNTIL FrameworkObjectVersion.MoveCurveTypesToSkeleton expires.
	# Used as triggering event
	AACF_DriveAttribute_DEPRECATED = 2
	# Set per skeleton. DO NOT REMOVE UNTIL FrameworkObjectVersion.MoveCurveTypesToSkeleton expires.
	# Is editable in Sequence Editor
	AACF_Editable = 4
	# per asset
	# Used as a material curve
	AACF_DriveMaterial_DEPRECATED = 8
	# This has moved to FAnimCurveType:bMaterial. Set per skeleton. DO NOT REMOVE UNTIL FrameworkObjectVersion.MoveCurveTypesToSkeleton expires.
	# Is a metadata 'curve'
	AACF_Metadata = 16
	# per asset
	# motifies bone track
	AACF_DriveTrack = 32
	# @Todo: remove?
	# disabled, right now it's used by track
	AACF_Disabled = 64

class ERawCurveTrackTypes(Enum):
	"""ERaw Curve Track Types"""

	# 
	RCT_Float = 0
	# 
	RCT_Vector = 1
	# 
	RCT_Transform = 2
	# 
	RCT_MAX = 3

class ETypeAdvanceAnim(Enum):
	"""EType Advance Anim"""

	# 
	ETAA_Default = 0
	# 
	ETAA_Finished = 1
	# 
	ETAA_Looped = 2

class AnimationKeyFormat(Enum):
	"""Indicates animation data key format."""

	# 
	AKF_ConstantKeyLerp = 0
	# 
	AKF_VariableKeyLerp = 1
	# 
	AKF_PerTrackCompression = 2
	# 
	AKF_MAX = 3

class ECustomAttributeBlendType(Enum):
	"""ECustom Attribute Blend Type"""

	# Overrides Custom attributes according to highest weighted pose
	Override = 0
	# Blends Custom attributes according to weights per pose
	Blend = 1

class EPreviewAnimationBlueprintApplicationMethod(Enum):
	"""The method by which a preview animation blueprint is applied"""

	# Apply the preview animation blueprint using LinkAnimClassLayers
	LinkedLayers = 0
	# Apply the preview animation blueprint using SetLinkedAnimGraphByTag
	LinkedAnimGraph = 1

class EAlphaBlendOption(Enum):
	"""EAlpha Blend Option"""

	# Linear interpolation
	Linear = 0
	# Cubic-in interpolation
	Cubic = 1
	# Hermite-Cubic
	HermiteCubic = 2
	# Sinusoidal interpolation
	Sinusoidal = 3
	# Quadratic in-out interpolation
	QuadraticInOut = 4
	# Cubic in-out interpolation
	CubicInOut = 5
	# Quartic in-out interpolation
	QuarticInOut = 6
	# Quintic in-out interpolation
	QuinticInOut = 7
	# Circular-in interpolation
	CircularIn = 8
	# Circular-out interpolation
	CircularOut = 9
	# Circular in-out interpolation
	CircularInOut = 10
	# Exponential-in interpolation
	ExpIn = 11
	# Exponential-Out interpolation
	ExpOut = 12
	# Exponential in-out interpolation
	ExpInOut = 13
	# Custom interpolation, will use custom curve inside an FAlphaBlend or linear if none has been set
	Custom = 14

class ETransitionBlendMode(Enum):
	"""@TODO: Document"""

	# 
	TBM_Linear = 0
	# 
	TBM_Cubic = 1

class ETransitionLogicType(Enum):
	"""@TODO: Document"""

	# 
	TLT_StandardBlend = 0
	# 
	TLT_Inertialization = 1
	# 
	TLT_Custom = 2

class EPinHidingMode(Enum):
	"""The display mode of editable values on an animation node."""

	# Never show this property as a pin, it is only editable in the details panel (default for everything but FPoseLink properties).
	NeverAsPin = 0
	# Hide this property by default, but allow the user to expose it as a pin via the details panel.
	PinHiddenByDefault = 1
	# Show this property as a pin by default, but allow the user to hide it via the details panel.
	PinShownByDefault = 2
	# Always show this property as a pin; it never makes sense to edit it in the details panel (default for FPoseLink properties).
	AlwaysAsPin = 3

class EPostCopyOperation(Enum):
	"""EPost Copy Operation"""

	# 
	None = 0
	# 
	LogicalNegateBool = 1

class ETimeStretchCurveMapping(Enum):
	"""ETime Stretch Curve Mapping"""

	# 
	T_Original = 0
	# 
	T_TargetMin = 1
	# 
	T_TargetMax = 2
	# 
	MAX = 3

class EAnimNotifyEventType(Enum):
	"""EAnim Notify Event Type"""

	# 
	Begin = 0
	# 
	End = 1

class EMontageSubStepResult(Enum):
	"""EMontage Sub Step Result"""

	# 
	Moved = 0
	# 
	NotMoved = 1
	# 
	InvalidSection = 2
	# 
	InvalidMontage = 3

class EDOFMode(Enum):
	"""EDOFMode"""

	# Inherits the degrees of freedom from the project settings.
	Default = 0
	# Specifies which axis to freeze rotation and movement along.
	SixDOF = 1
	# Allows 2D movement along the Y-Z plane.
	YZPlane = 2
	# Allows 2D movement along the X-Z plane.
	XZPlane = 3
	# Allows 2D movement along the X-Y plane.
	XYPlane = 4
	# Allows 2D movement along the plane of a given normal
	CustomPlane = 5
	# No constraints.
	None = 6

class ERuntimeVirtualTextureMaterialType(Enum):
	"""Enumeration of virtual texture stack layouts to support.
Extend this enumeration with other layouts as required. For example we will probably want to add a displacement texture option.
This 'fixed function' approach will probably break down if we end up needing to support some complex set of attribute combinations but it is OK to begin with."""

	# 
	BaseColor = 0
	# 
	BaseColor_Normal_DEPRECATED = 1
	# 
	BaseColor_Normal_Specular = 2
	# Base Color is stored in YCoCg space. This requires more memory but may provide better quality.
	BaseColor_Normal_Specular_YCoCg = 3
	# Base Color is stored in YCoCg space. This requires more memory but may provide better quality.
	BaseColor_Normal_Specular_Mask_YCoCg = 4
	# 
	WorldHeight = 5
	# 
	Count = 6

class ERuntimeVirtualTextureMainPassType(Enum):
	"""Enumeration of main pass behaviors when rendering to a runtime virtual texture."""

	# Never render to the main pass.
	# Use this for primitives that only render to Runtime Virtual Texture and can be missing if there is no virtual texture support.
	Never = 0
	# Render to the main pass if no associated Runtime Virtual Texture Volumes are set to 'Hide Primitives'.
	# This will render to the main pass if there is no matching Runtime Virtual Texture Volume placed in the scene.
	Exclusive = 1
	# Always render to the main pass.
	# Use this for items that both read from and write to a Runtime Virtual Texture.
	Always = 2

class EHitProxyPriority(Enum):
	"""The priority a hit proxy has when choosing between several hit proxies near the point the user clicked.
HPP_World - this is the default priority
HPP_Wireframe - the priority of items that are drawn in wireframe, such as volumes
HPP_UI - the priority of the UI components such as the translation widget"""

	# 
	HPP_World = 0
	# 
	HPP_Wireframe = 1
	# 
	HPP_Foreground = 2
	# 
	HPP_UI = 3

class ECanBeCharacterBase(Enum):
	"""Determines whether a Character can attempt to step up onto a component when they walk in to it."""

	# Character cannot step up onto this Component.
	ECB_No = 0
	# Character can step up onto this Component.
	ECB_Yes = 1
	# Owning actor determines whether character can step up onto this Component (default true unless overridden in code).
	# @see AActor::CanBeBaseForCharacter()
	ECB_Owner = 2
	# 
	ECB_MAX = 3

class EHasCustomNavigableGeometry(Enum):
	"""Determines if a primitive component contains custom collision for navigation/AI"""

	# Primitive doesn't have custom navigation geometry, if collision is enabled then its convex/trimesh collision will be used for generating the navmesh
	No = 0
	# If primitive would normally affect navmesh, DoCustomNavigableGeometryExport() should be called to export this primitive's navigable geometry
	Yes = 1
	# DoCustomNavigableGeometryExport() should be called even if the mesh is non-collidable and wouldn't normally affect the navmesh
	EvenIfNotCollidable = 2
	# Don't export navigable geometry even if primitive is relevant for navigation (can still add modifiers)
	DontExport = 3

class ERendererStencilMask(Enum):
	"""Exposed enum to parallel RHI's EStencilMask and show up in the editor. Has a paired struct to convert between the two."""

	# 
	ERSM_Default = 0
	# 
	ERSM_255 = 1
	# 
	ERSM_1 = 2
	# 
	ERSM_2 = 3
	# 
	ERSM_4 = 4
	# 
	ERSM_8 = 5
	# 
	ERSM_16 = 6
	# 
	ERSM_32 = 7
	# 
	ERSM_64 = 8
	# 
	ERSM_128 = 9

class EBlendableLocation(Enum):
	"""Where to place a material node in the post processing graph."""

	# Input0:former pass color, Input1:SeparateTranslucency.
	BL_AfterTonemapping = 0
	# Input0:former pass color, Input1:SeparateTranslucency.
	BL_BeforeTonemapping = 1
	# Input0:former pass color, Input1:SeparateTranslucency.
	BL_BeforeTranslucency = 2
	# Input0:former pass color, Input1:SeparateTranslucency, Input2: BloomOutput
	# vector parameters: Engine.FilmWhitePoint
	# scalar parameters: Engine.FilmSaturation, Engine.FilmContrast
	BL_ReplacingTonemapper = 3
	# Input0:former pass color.
	BL_SSRInput = 4
	# 
	BL_MAX = 5

class EMaterialParameterAssociation(Enum):
	"""EMaterial Parameter Association"""

	# 
	LayerParameter = 0
	# 
	BlendParameter = 1
	# 
	GlobalParameter = 2

class EMaterialLayerLinkState(Enum):
	"""EMaterial Layer Link State"""

	# 
	Uninitialized = -1
	# Saved with previous engine version
	LinkedToParent = -1
	# Layer should mirror changes from parent material
	UnlinkedFromParent = -1
	# Layer is based on parent material, but should not mirror changes
	NotFromParent = -1

class ESceneTextureId(Enum):
	"""like EPassInputId but can expose more e.g. GBuffer"""

	# Scene color, normal post process passes should use PostProcessInput0
	PPI_SceneColor = 0
	# Scene depth, single channel, contains the linear depth of the opaque objects
	PPI_SceneDepth = 1
	# Material diffuse, RGB color (computed from GBuffer)
	PPI_DiffuseColor = 2
	# Material specular, RGB color (computed from GBuffer)
	PPI_SpecularColor = 3
	# Material subsurface, RGB color (GBuffer, only for some ShadingModels)
	PPI_SubsurfaceColor = 4
	# Material base, RGB color (GBuffer), can be modified on read by the ShadingModel, consider StoredBasedColor
	PPI_BaseColor = 5
	# Material specular, single channel (GBuffer), can be modified on read by the ShadingModel, consider StoredSpecular
	PPI_Specular = 6
	# Material metallic, single channel (GBuffer)
	PPI_Metallic = 7
	# Normal, RGB in -1..1 range, not normalized (GBuffer)
	PPI_WorldNormal = 8
	# Not yet supported
	PPI_SeparateTranslucency = 9
	# Material opacity, single channel (GBuffer)
	PPI_Opacity = 10
	# Material roughness, single channel (GBuffer)
	PPI_Roughness = 11
	# Material ambient occlusion, single channel (GBuffer)
	PPI_MaterialAO = 12
	# Scene depth, single channel, contains the linear depth of the opaque objects rendered with CustomDepth (mesh property)
	PPI_CustomDepth = 13
	# Input #0 of this postprocess pass, usually the only one hooked up
	PPI_PostProcessInput0 = 14
	# Input #1 of this postprocess pass, usually not used
	PPI_PostProcessInput1 = 15
	# Input #2 of this postprocess pass, usually not used
	PPI_PostProcessInput2 = 16
	# Input #3 of this postprocess pass, usually not used
	PPI_PostProcessInput3 = 17
	# Input #4 of this postprocess pass, usually not used
	PPI_PostProcessInput4 = 18
	# Input #5 of this postprocess pass, usually not used
	PPI_PostProcessInput5 = 19
	# Input #6 of this postprocess pass, usually not used
	PPI_PostProcessInput6 = 20
	# Decal Mask, single bit (was moved to stencil for better performance, not accessible at the moment)
	PPI_DecalMask = 21
	# Shading model
	PPI_ShadingModelColor = 22
	# Shading model ID
	PPI_ShadingModelID = 23
	# Ambient Occlusion, single channel
	PPI_AmbientOcclusion = 24
	# Scene stencil, contains CustomStencil mesh property of the opaque objects rendered with CustomDepth
	PPI_CustomStencil = 25
	# Material base, RGB color (GBuffer)
	PPI_StoredBaseColor = 26
	# Material specular, single channel (GBuffer)
	PPI_StoredSpecular = 27
	# Scene Velocity
	PPI_Velocity = 28
	# Tangent, RGB in -1..1 range, not normalized (GBuffer)
	PPI_WorldTangent = 29
	# Material anisotropy, single channel (GBuffer)
	PPI_Anisotropy = 30

class EMaterialUsage(Enum):
	"""EMaterial Usage"""

	# 
	MATUSAGE_SkeletalMesh = 0
	# 
	MATUSAGE_ParticleSprites = 1
	# 
	MATUSAGE_BeamTrails = 2
	# 
	MATUSAGE_MeshParticles = 3
	# 
	MATUSAGE_StaticLighting = 4
	# 
	MATUSAGE_MorphTargets = 5
	# 
	MATUSAGE_SplineMesh = 6
	# 
	MATUSAGE_InstancedStaticMeshes = 7
	# 
	MATUSAGE_GeometryCollections = 8
	# 
	MATUSAGE_Clothing = 9
	# 
	MATUSAGE_NiagaraSprites = 10
	# 
	MATUSAGE_NiagaraRibbons = 11
	# 
	MATUSAGE_NiagaraMeshParticles = 12
	# 
	MATUSAGE_GeometryCache = 13
	# 
	MATUSAGE_Water = 14
	# 
	MATUSAGE_HairStrands = 15
	# 
	MATUSAGE_LidarPointCloud = 16
	# 
	MATUSAGE_VirtualHeightfieldMesh = 17
	# 
	MATUSAGE_MAX = 18

class EBoneVisibilityStatus(Enum):
	"""The valid BoneVisibilityStates values; A bone is only visible if it is *exactly* 1"""

	# Bone is hidden because it's parent is hidden.
	BVS_HiddenByParent = 0
	# Bone is visible.
	BVS_Visible = 1
	# Bone is hidden directly.
	BVS_ExplicitlyHidden = 2
	# 
	BVS_MAX = 3

class EPhysBodyOp(Enum):
	"""PhysicsBody options when bone is hidden"""

	# Don't do anything.
	PBO_None = 0
	# Terminate - if you terminate, you won't be able to re-init when unhidden.
	PBO_Term = 1
	# 
	PBO_MAX = 2

class EVisibilityBasedAnimTickOption(Enum):
	"""Skinned Mesh Animation Tick option based on rendered or not. This dictates 'TickPose and RefreshBoneTransforms'"""

	# Always Tick and Refresh BoneTransforms whether rendered or not.
	AlwaysTickPoseAndRefreshBones = 0
	# Always Tick, but Refresh BoneTransforms only when rendered.
	AlwaysTickPose = 1
	# When rendered Tick Pose and Refresh Bone Transforms,
	# otherwise, just update montages and skip everything else.
	# (AnimBP graph will not be updated).
	OnlyTickMontagesWhenNotRendered = 2
	# Tick only when rendered, and it will only RefreshBoneTransforms when rendered.
	OnlyTickPoseWhenRendered = 3

class EBoneSpaces(Enum):
	"""Values for specifying bone space."""

	# Set absolute position of bone in world space.
	WorldSpace = 0
	# Set position of bone in components reference frame.
	ComponentSpace = 1

class EVertexOffsetUsageType(Enum):
	"""EVertex Offset Usage Type"""

	# 
	None = 0
	# 
	PreSkinningOffset = -1
	# 
	PostSkinningOffset = -1

class EAngularDriveMode(Enum):
	"""EAngular Drive Mode"""

	# Spherical lerp between the current orientation/velocity and the target orientation/velocity. NOTE: This will NOT work if any angular constraints are set to Locked.
	SLERP = 0
	# Path is decomposed into twist (roll constraint) and swing (cone constraint). Doesn't follow shortest arc and may experience gimbal lock. Does work with locked angular constraints.
	TwistAndSwing = 1

class EAnimCurveType(Enum):
	"""EAnim Curve Type"""

	# 
	AttributeCurve = 0
	# 
	MaterialCurve = 1
	# 
	MorphTargetCurve = 2
	# make sure to update MaxCurve
	MaxAnimCurveType = 3

class EClothMassMode(Enum):
	"""ECloth Mass Mode"""

	# 
	UniformMass = 0
	# 
	TotalMass = 1
	# 
	Density = 2
	# 
	MaxClothMassMode = 3

class ECustomBoneAttributeLookup(Enum):
	"""Method used when retrieving a Custom Attribute value"""

	# Only look for the attribute using the provided bone (name)
	BoneOnly = 0
	# Look for the attribute using the provided bone (name) and its direct parent bone
	ImmediateParent = 1
	# Look for the attribute using the provided bone (name) and its direct bone parent hierarchy up and until the root bone
	ParentHierarchy = 2

class EKinematicBonesUpdateToPhysics(Enum):
	"""This enum defines how you'd like to update bones to physics world.
      If bone is simulating, you don't have to waste time on updating bone transform from kinematic.
      But also sometimes you don't like fixed bones to be updated by animation data."""

	# Update any bones that are not simulating.
	SkipSimulatingBones = 0
	# Skip physics update from kinematic changes.
	SkipAllBones = 1

class EAnimationMode(Enum):
	"""EAnimation Mode"""

	# 
	AnimationBlueprint = 0
	# 
	AnimationSingleNode = 1
	# This is custom type, engine leaves AnimInstance as it is
	AnimationCustomMode = 2

class EPhysicsTransformUpdateMode(Enum):
	"""EPhysics Transform Update Mode"""

	# 
	SimulationUpatesComponentTransform = 0
	# 
	ComponentTransformIsKinematic = 1

class EMontagePlayReturnType(Enum):
	"""EMontage Play Return Type"""

	# Return value is the length of the montage (in seconds)
	MontageLength = 0
	# Return value is the play duration of the montage (length / play rate, in seconds)
	Duration = 1

class EAnimAlphaInputType(Enum):
	"""AnimNodes using an Alpha can choose how it is driven."""

	# 
	Float = 0
	# 
	Bool = 1
	# 
	Curve = 2

class EInertializationState(Enum):
	"""Inertialization: High-Performance Animation Transitions in 'Gears of War'
David Bollo
Game Developer Conference 2018

https:www.gdcvault.com/play/1025165/Inertialization
https:www.gdcvault.com/play/1025331/Inertialization"""

	# 
	Inactive = 0
	# Inertialization inactive
	Pending = 1
	# Inertialization request pending... prepare to capture the pose difference and then switch to active
	Active = 2

class EInertializationBoneState(Enum):
	"""EInertialization Bone State"""

	# 
	Invalid = 0
	# Invalid bone (ie: bone was present in the skeleton but was not present in the pose when it was captured)
	Valid = 1
	# Valid bone
	Excluded = 2

class EInertializationSpace(Enum):
	"""EInertialization Space"""

	# 
	Default = 0
	# Inertialize in local space (default)
	WorldSpace = 1
	# Inertialize translation and rotation in world space (to conceal discontinuities in actor transform such snapping to a new attach parent)
	WorldRotation = 2

class EEvaluatorDataSource(Enum):
	"""Indicates which state is being evaluated by this node (source or destination)."""

	# 
	EDS_SourcePose = 0
	# 
	EDS_DestinationPose = 1

class EEvaluatorMode(Enum):
	"""Determines the behavior this node will use when updating and evaluating."""

	# DataSource is ticked and evaluated every frame.
	EM_Standard = 0
	# DataSource is never ticked and only evaluated on the first frame. Every frame after uses the cached pose from the first frame.
	EM_Freeze = 1
	# DataSource is ticked and evaluated for a given number of frames, then freezes after and uses the cached pose for future frames.
	EM_DelayedFreeze = 2

class EControlConstraint(Enum):
	"""Control Constraint Type"""

	# Rotation constraint.
	Orientation = 0
	# Translation constraint.
	Translation = 1
	# Max Number.
	MAX = 2

class EConstraintTransform(Enum):
	"""Constraint Transform Type. - currently unused"""

	# Absolute value.
	Absolute = 0
	# Apply relative transform from ref pose.
	Relative = 1

class EDepthOfFieldMethod(Enum):
	"""Used by FPostProcessSettings Depth of Fields"""

	# 
	DOFM_BokehDOF = 0
	# 
	DOFM_Gaussian = 1
	# 
	DOFM_CircleDOF = 2
	# 
	DOFM_MAX = 3

class EAntiAliasingMethod(Enum):
	"""Used by rendering project settings."""

	# 
	AAM_None = 0
	# 
	AAM_FXAA = 1
	# 
	AAM_SMAA = 2
	# 
	AAM_TemporalAA = 3
	# Only supported with forward shading.  MSAA sample count is controlled by r.MSAACount.
	AAM_MSAA = 4
	# 
	AAM_MAX = 5

class EAutoExposureMethod(Enum):
	"""Used by FPostProcessSettings Auto Exposure"""

	# requires compute shader to construct 64 bin histogram
	AEM_Histogram = 0
	# faster method that computes single value by downsampling
	AEM_Basic = 1
	# Uses camera settings.
	AEM_Manual = 2
	# 
	AEM_MAX = 3

class EBloomMethod(Enum):
	"""EBloom Method"""

	# Sum of Gaussian formulation
	BM_SOG = 0
	# Fast Fourier Transform Image based convolution, intended for cinematics (too expensive for games)
	BM_FFT = 1
	# 
	BM_MAX = 2

class ELightUnits(Enum):
	"""ELight Units"""

	# 
	Unitless = 0
	# 
	Candelas = 1
	# 
	Lumens = 2

class EReflectionsType(Enum):
	"""EReflections Type"""

	# 
	ScreenSpace = 0
	# 
	RayTracing = 1

class ETranslucencyType(Enum):
	"""ETranslucency Type"""

	# 
	Raster = 0
	# 
	RayTracing = 1

class ERayTracingGlobalIlluminationType(Enum):
	"""ERay Tracing Global Illumination Type"""

	# 
	Disabled = 0
	# 
	BruteForce = 1
	# 
	FinalGather = 2

class EReflectedAndRefractedRayTracedShadows(Enum):
	"""EReflected and Refracted Ray Traced Shadows"""

	# 
	Disabled = 0
	# 
	Hard_shadows = 1
	# 
	Area_shadows = 2

class EMobilePlanarReflectionMode(Enum):
	"""EMobile Planar Reflection Mode"""

	# The PlanarReflection actor works as usual on all platforms.
	Usual = 0
	# The PlanarReflection actor is only used for mobile pixel projection reflection, it will not affect PC/Console. MobileMSAA will be disabled as a side effect.
	MobilePPRExclusive = 1
	# The PlanarReflection actor still works as usual on PC/Console platform and is used for mobile pixel projected reflection on mobile platform. MobileMSAA will be disabled as a side effect.
	MobilePPR = 2

class EMobilePixelProjectedReflectionQuality(Enum):
	"""EMobile Pixel Projected Reflection Quality"""

	# Disabled.
	Disabled = 0
	# Best performance but may have some artifacts in some view angles.
	BestPerformance = 1
	# Better quality and reasonable performance and could fix some artifacts, but the PlanarReflection mesh has to render twice.
	BetterQuality = 2
	# Best quality but will be much heavier.
	BestQuality = 3

class ECameraProjectionMode(Enum):
	"""@TODO: Document"""

	# 
	Perspective = 0
	# 
	Orthographic = 1

class ECameraShakePlaySpace(Enum):
	"""ECamera Shake Play Space"""

	# This anim is applied in camera space.
	CameraLocal = 0
	# This anim is applied in world space.
	World = 1
	# This anim is applied in a user-specified space (defined by UserPlaySpaceMatrix).
	UserDefined = 2

class ECameraShakeUpdateResultFlags(Enum):
	"""Flags that camera shakes can return to change base-class behaviour."""

	# Apply the result location, rotation, and field of view as absolute values, instead of additive values.
	ApplyAsAbsolute = -1
	# Do not apply scaling (dynamic scale, blending weight, shake scale), meaning that this will be done in the sub-class. Implied when ApplyAsAbsolute is set.
	SkipAutoScale = -1
	# Do not re-orient the result based on the play-space. Implied when ApplyAsAbsolute is set.
	SkipAutoPlaySpace = -1
	# Default flags: the sub-class is returning local, additive offsets, and lets the base class take care of the rest.
	Default = 0

class ECameraShakeDurationType(Enum):
	"""Camera shake duration type."""

	# Camera shake has a fixed duration
	Fixed = 0
	# Camera shake is playing indefinitely, until explicitly stopped
	Infinite = 1
	# Camera shake has custom/dynamic duration
	Custom = 2

class EOscillatorWaveform(Enum):
	"""Types of waveforms that can be used for camera shake oscillators"""

	# A sinusoidal wave
	SineWave = 0
	# Perlin noise
	PerlinNoise = 1

class EInitialOscillatorOffset(Enum):
	"""Shake start offset parameter"""

	# Start with random offset (default).
	EOO_OffsetRandom = 0
	# Start with zero offset.
	EOO_OffsetZero = 1
	# 
	EOO_MAX = 2

class ECameraShakeAttenuation(Enum):
	"""ECamera Shake Attenuation"""

	# 
	Linear = 0
	# 
	Quadratic = 1

class ECameraAlphaBlendMode(Enum):
	"""@TODO: Document"""

	# 
	CABM_Linear = 0
	# 
	CABM_Cubic = 1

class EViewTargetBlendFunction(Enum):
	"""Options that define how to blend when changing view targets.
@see FViewTargetTransitionParams, SetViewTarget"""

	# Camera does a simple linear interpolation.
	VTBlend_Linear = 0
	# Camera has a slight ease in and ease out, but amount of ease cannot be tweaked.
	VTBlend_Cubic = 1
	# Camera immediately accelerates, but smoothly decelerates into the target.  Ease amount controlled by BlendExp.
	VTBlend_EaseIn = 2
	# Camera smoothly accelerates, but does not decelerate into the target.  Ease amount controlled by BlendExp.
	VTBlend_EaseOut = 3
	# Camera smoothly accelerates and decelerates.  Ease amount controlled by BlendExp.
	VTBlend_EaseInOut = 4
	# 
	VTBlend_MAX = 5

class ETemperatureSeverityType(Enum):
	"""A parallel enum to the temperature change severity enum in CoreDelegates
Note if you change this, then you must change the one in CoreDelegates"""

	# 
	Unknown = 0
	# 
	Good = 1
	# 
	Bad = 2
	# 
	Serious = 3
	# 
	Critical = 4
	# 
	NumSeverities = 5

class EAttenuationDistanceModel(Enum):
	"""EAttenuation Distance Model"""

	# 
	Linear = 0
	# 
	Logarithmic = 1
	# 
	Inverse = 2
	# 
	LogReverse = 3
	# 
	NaturalSound = 4
	# 
	Custom = 5

class EAttenuationShape(Enum):
	"""EAttenuation Shape"""

	# 
	Sphere = 0
	# 
	Capsule = 1
	# 
	Box = 2
	# 
	Cone = 3

class ENaturalSoundFalloffMode(Enum):
	"""ENatural Sound Falloff Mode"""

	# (Default) Continues attenuating pass falloff max using volume value
	# specified at the max falloff distance's bounds
	Continues = 0
	# Sound goes silent upon leaving the shape
	Silent = 1
	# Holds the volume value specified at the shapes falloff bounds
	Hold = 2

class ESoundDistanceCalc(Enum):
	"""This enumeration is deprecated"""

	# 
	SOUNDDISTANCE_Normal = 0
	# 
	SOUNDDISTANCE_InfiniteXYPlane = 1
	# 
	SOUNDDISTANCE_InfiniteXZPlane = 2
	# 
	SOUNDDISTANCE_InfiniteYZPlane = 3
	# 
	SOUNDDISTANCE_MAX = 4

class ESoundSpatializationAlgorithm(Enum):
	"""ESound Spatialization Algorithm"""

	# Standard panning method for spatialization (linear or equal power method defined in project settings)
	SPATIALIZATION_Default = 0
	# Binaural spatialization method if available (requires headphones, enabled by plugins)
	SPATIALIZATION_HRTF = 1

class EAirAbsorptionMethod(Enum):
	"""EAir Absorption Method"""

	# The air absorption conform to a linear distance function
	Linear = 0
	# The air absorption conforms to a custom distance curve.
	CustomCurve = 1

class EReverbSendMethod(Enum):
	"""EReverb Send Method"""

	# A reverb send based on linear interpolation between a distance range and send-level range
	Linear = 0
	# A reverb send based on a supplied curve
	CustomCurve = 1
	# A manual reverb send level (Uses the specified constant send level value. Useful for 2D sounds.)
	Manual = 2

class ESubmixSendMethod(Enum):
	"""ESubmix Send Method"""

	# A submix send based on linear interpolation between a distance range and send-level range
	Linear = 0
	# A submix send based on a supplied curve
	CustomCurve = 1
	# A manual submix send level (Uses the specified constant send level value. Useful for 2D sounds.)
	Manual = 2

class EPriorityAttenuationMethod(Enum):
	"""EPriority Attenuation Method"""

	# A priority attenuation based on linear interpolation between a distance range and priority attenuation range
	Linear = 0
	# A priority attenuation based on a supplied curve
	CustomCurve = 1
	# A manual priority attenuation (Uses the specified constant value. Useful for 2D sounds.)
	Manual = 2

class EMaxConcurrentResolutionRule(Enum):
	"""EMax Concurrent Resolution Rule"""

	# When Max Concurrent sounds are active do not start a new sound.
	PreventNew = 0
	# When Max Concurrent sounds are active stop the oldest and start a new one.
	StopOldest = 1
	# When Max Concurrent sounds are active stop the furthest sound.  If all sounds are the same distance then do not start a new sound.
	StopFarthestThenPreventNew = 2
	# When Max Concurrent sounds are active stop the furthest sound.  If all sounds are the same distance then stop the oldest.
	StopFarthestThenOldest = 3
	# Stop the lowest priority sound in the group. If all sounds are the same priority, then it will stop the oldest sound in the group.
	StopLowestPriority = 4
	# Stop the sound that is quietest in the group.
	StopQuietest = 5
	# Stop the lowest priority sound in the group. If all sounds are the same priority, then it won't play a new sound.
	StopLowestPriorityThenPreventNew = 6
	# 
	Count = 7

class EConcurrencyVolumeScaleMode(Enum):
	"""EConcurrency Volume Scale Mode"""

	# Scales volume of older sounds more than newer sounds (default)
	Default = 0
	# Scales distant sounds by volume scalar more than closer sounds
	Distance = 1
	# Scales lower priority sounds by volume scalar more than closer sounds
	Priority = 2

class EModulationRouting(Enum):
	"""EModulation Routing"""

	# Disables modulation routing
	Disable = 0
	# Inherits modulation routing (AudioComponent inherits from Sound, Sound inherits from SoundClass)
	Inherit = 1
	# Ignores inherited settings and uses modulation settings on this object
	Override = 2

class ESourceBusSendLevelControlMethod(Enum):
	"""ESource Bus Send Level Control Method"""

	# A send based on linear interpolation between a distance range and send-level range
	Linear = 0
	# A send based on a supplied curve
	CustomCurve = 1
	# A manual send level (Uses the specified constant send level value. Useful for 2D sounds.)
	Manual = 2

class EAudioSpectrumBandPresetType(Enum):
	"""EAudio Spectrum Band Preset Type"""

	# Band which contains frequencies generally related to kick drums.
	KickDrum = 0
	# Band which contains frequencies generally related to snare drums.
	SnareDrum = 1
	# Band which contains frequencies generally related to vocals.
	Voice = 2
	# Band which contains frequencies generally related to cymbals.
	Cymbals = 3

class EAudioRecordingExportType(Enum):
	"""EAudio Recording Export Type"""

	# Exports a USoundWave.
	SoundWave = 0
	# Exports a WAV file.
	WavFile = 1

class ESendLevelControlMethod(Enum):
	"""ESend Level Control Method"""

	# A send based on linear interpolation between a distance range and send-level range
	Linear = 0
	# A send based on a supplied curve
	CustomCurve = 1
	# A manual send level (Uses the specified constant send level value. Useful for 2D sounds.)
	Manual = 2

class ESubmixSendStage(Enum):
	"""ESubmix Send Stage"""

	# Whether to do the send pre distance attenuation
	PostDistanceAttenuation = 0
	# Whether to do the send post distance attenuation
	PreDistanceAttenuation = 1

class EVirtualizationMode(Enum):
	"""Method of virtualization when a sound is stopped due to playback constraints
(i.e. by concurrency, priority, and/or MaxChannelCount)
for a given sound."""

	# Virtualization is disabled
	Disabled = 0
	# Sound continues to play when silent and not virtualize, continuing to use a voice. If
	# sound is looping and stopped due to concurrency or channel limit/priority, sound will
	# restart on realization. If any SoundWave referenced in a SoundCue's waveplayer is set
	# to 'PlayWhenSilent', entire SoundCue will be overridden to 'PlayWhenSilent' (to maintain
	# timing over all wave players).
	PlayWhenSilent = 1
	# If sound is looping, sound restarts from beginning upon realization from being virtual
	Restart = 2

class ESoundGroup(Enum):
	"""ESound Group"""

	# 
	SOUNDGROUP_Default = 0
	# 
	SOUNDGROUP_Effects = 1
	# 
	SOUNDGROUP_UI = 2
	# 
	SOUNDGROUP_Music = 3
	# 
	SOUNDGROUP_Voice = 4
	# 
	SOUNDGROUP_GameSoundGroup1 = 5
	# 
	SOUNDGROUP_GameSoundGroup2 = 6
	# 
	SOUNDGROUP_GameSoundGroup3 = 7
	# 
	SOUNDGROUP_GameSoundGroup4 = 8
	# 
	SOUNDGROUP_GameSoundGroup5 = 9
	# 
	SOUNDGROUP_GameSoundGroup6 = 10
	# 
	SOUNDGROUP_GameSoundGroup7 = 11
	# 
	SOUNDGROUP_GameSoundGroup8 = 12
	# 
	SOUNDGROUP_GameSoundGroup9 = 13
	# 
	SOUNDGROUP_GameSoundGroup10 = 14
	# 
	SOUNDGROUP_GameSoundGroup11 = 15
	# 
	SOUNDGROUP_GameSoundGroup12 = 16
	# 
	SOUNDGROUP_GameSoundGroup13 = 17
	# 
	SOUNDGROUP_GameSoundGroup14 = 18
	# 
	SOUNDGROUP_GameSoundGroup15 = 19
	# 
	SOUNDGROUP_GameSoundGroup16 = 20
	# 
	SOUNDGROUP_GameSoundGroup17 = 21
	# 
	SOUNDGROUP_GameSoundGroup18 = 22
	# 
	SOUNDGROUP_GameSoundGroup19 = 23
	# 
	SOUNDGROUP_GameSoundGroup20 = 24

class ESoundWaveLoadingBehavior(Enum):
	"""Only used when stream caching is enabled. Determines how we are going to load or retain a given audio asset.
A USoundWave's loading behavior can be overridden in the USoundWave itself, the sound wave's USoundClass, or by cvars.
The order of priority is defined as:
1) The loading behavior set on the USoundWave
2) The loading behavior set on the USoundWave's USoundClass.
3) The loading behavior set on the nearest parent of a USoundWave's USoundClass.
4) The loading behavior set via the au.streamcache cvars."""

	# If set on a USoundWave, use the setting defined by the USoundClass. If set on the next parent USoundClass, or the default behavior defined via the au.streamcache cvars.
	Inherited = 0
	# the first chunk of audio for this asset will be retained in the audio cache until a given USoundWave is either destroyed or USoundWave::ReleaseCompressedAudioData is called.
	RetainOnLoad = 1
	# the first chunk of audio for this asset will be loaded into the cache from disk when this asset is loaded, but may be evicted to make room for other audio if it isn't played for a while.
	PrimeOnLoad = 2
	# the first chunk of audio for this asset will not be loaded until this asset is played or primed.
	LoadOnDemand = 3
	# Force all audio data for this audio asset to live outside of the cache and use the non-streaming decode pathways. Only usable if set on the USoundWave.
	ForceInline = 4
	# This value is used to delineate when the value of ESoundWaveLoadingBehavior hasn't been cached on a USoundWave yet.
	Uninitialized = 255

class EDecompressionType(Enum):
	"""EDecompression Type"""

	# 
	DTYPE_Setup = 0
	# 
	DTYPE_Invalid = 1
	# 
	DTYPE_Preview = 2
	# 
	DTYPE_Native = 3
	# 
	DTYPE_RealTime = 4
	# 
	DTYPE_Procedural = 5
	# 
	DTYPE_Xenon = 6
	# 
	DTYPE_Streaming = 7
	# 
	DTYPE_MAX = 8

class ESoundWaveFFTSize(Enum):
	"""The FFT size (in audio frames) to use for baked FFT analysis"""

	# 
	VerySmall_64 = 0
	# 
	Small_256 = 1
	# 
	Medium_512 = 2
	# 
	Large_1024 = 3
	# 
	VeryLarge_2048 = 4

class EQuartzCommandQuantization(Enum):
	"""An enumeration for specifying quantization for Quartz commands"""

	# (dependent on time signature)
	Bar = 0
	# (dependent on time signature and Pulse Override)
	Beat = 1
	# 
	ThirtySecondNote = 2
	# 
	SixteenthNote = 3
	# 
	EighthNote = 4
	# 
	QuarterNote = 5
	# 
	HalfNote = 6
	# 
	WholeNote = 7
	# 
	DottedSixteenthNote = 8
	# 
	DottedEighthNote = 9
	# 
	DottedQuarterNote = 10
	# 
	DottedHalfNote = 11
	# 
	DottedWholeNote = 12
	# 
	SixteenthNoteTriplet = 13
	# 
	EighthNoteTriplet = 14
	# 
	QuarterNoteTriplet = 15
	# 
	HalfNoteTriplet = 16
	# (same as 1/32)
	Tick = 17
	# 
	Count = 18

class EQuartzTimeSignatureQuantization(Enum):
	"""An enumeration for specifying the denominator of time signatures"""

	# 
	HalfNote = 0
	# 
	QuarterNote = 1
	# 
	EighthNote = 2
	# 
	SixteenthNote = 3
	# 
	ThirtySecondNote = 4
	# 
	Count = 5

class EQuartzDelegateType(Enum):
	"""An enumeration for specifying different TYPES of delegates"""

	# 
	MetronomeTick = 0
	# uses EAudioMixerCommandQuantization to select subdivision
	CommandEvent = 1
	# 
	Count = 2

class EQuarztQuantizationReference(Enum):
	"""An enumeration for specifying quantization boundary reference frame"""

	# Will occur on the next occurence of this duration from the start of a bar (i.e. On beat 3)
	BarRelative = 0
	# Will occur on the next multiple of this duration since the clock started ticking (i.e. on the next 4 bar boundary)
	TransportRelative = 1
	# Will occur on the next multiple of this duration from the current time (i.e. In three beats)
	CurrentTimeRelative = 2
	# 
	Count = 3

class EQuartzCommandDelegateSubType(Enum):
	"""An enumeration for specifying different TYPES of delegates"""

	# The command will not execute (i.e. Clock doesn't exist or PlayQuantized failed concurrency)
	CommandOnFailedToQueue = 0
	# The command has been passed to the Audio Render Thread
	CommandOnQueued = 1
	# The command was stopped before it could execute
	CommandOnCanceled = 2
	# execute off this to be in sync w/ sound starting
	CommandOnAboutToStart = 3
	# the command was just executed on the Audio Render Thrtead
	CommandOnStarted = 4
	# CommandCompleted                        UMETA(DisplayName = 'Completed', ToolTip = 'same as 'Started' unless command is looping'),
	Count = 5

class EAudioComponentPlayState(Enum):
	"""Enum describing the audio component play state"""

	# If the sound is playing (i.e. not fading in, not fading out, not paused)
	Playing = 0
	# If the sound is not playing
	Stopped = 1
	# If the sound is playing but paused
	Paused = 2
	# If the sound is playing and fading in
	FadingIn = 3
	# If the sound is playing and fading out
	FadingOut = 4
	# 
	Count = 5

class EAudioFaderCurve(Enum):
	"""Type of fade to use when adjusting the audio component's volume."""

	# Linear Fade
	Linear = 0
	# Logarithmic Fade
	Logarithmic = 1
	# S-Curve, Sinusoidal Fade
	SCurve = 2
	# Equal Power, Sinusoidal Fade
	Sin = 3
	# 
	Count = 4

class EReflectionSourceType(Enum):
	"""EReflection Source Type"""

	# Construct the reflection source from the captured scene
	CapturedScene = 0
	# Construct the reflection source from the specified cubemap.
	SpecifiedCubemap = 1

class EMobileReflectionCompression(Enum):
	"""EMobile Reflection Compression"""

	# 
	Default = 0
	# 
	On = 1
	# 
	Off = 2

class EControllerAnalogStick(Enum):
	"""EController Analog Stick"""

	# 
	CAS_LeftStick = 0
	# 
	CAS_RightStick = 1
	# 
	CAS_MAX = 2

class EPlaneConstraintAxisSetting(Enum):
	"""Setting that controls behavior when movement is restricted to a 2D plane defined by a specific axis/normal,
so that movement along the locked axis is not be possible."""

	# Lock movement to a user-defined axis.
	Custom = 0
	# Lock movement in the X axis.
	X = 1
	# Lock movement in the Y axis.
	Y = 2
	# Lock movement in the Z axis.
	Z = 3
	# Use the global physics project setting.
	UseGlobalPhysicsSetting = 4

class EInterpToBehaviourType(Enum):
	"""Controls the movement behaviour"""

	# Move to destination and stop
	OneShot = 0
	# Move to destination, return and stop
	OneShot_Reverse = 1
	# Reset back to start when reaching the end
	Loop_Reset = 2
	# Repeatedly lerp from start to end and back
	PingPong = 3

class ESyncOption(Enum):
	"""ESync Option"""

	# Drive LOD from this component. It will contribute to the change of LOD
	Drive = 0
	# It follows what's currently driven by other components. It doesn't contribute to the change of LOD
	Passive = 1
	# It is disabled, it doesn't do anything
	Disabled = 2

class ESceneCapturePrimitiveRenderMode(Enum):
	"""EScene Capture Primitive Render Mode"""

	# Legacy
	PRM_LegacySceneCapture = 0
	# Render primitives in the scene, minus HiddenActors.
	PRM_RenderScenePrimitives = 1
	# Render only primitives in the ShowOnlyActors list, or components specified with ShowOnlyComponent().
	PRM_UseShowOnlyList = 2

class ESkyAtmosphereTransformMode(Enum):
	"""ESky Atmosphere Transform Mode"""

	# 
	PlanetTopAtAbsoluteWorldOrigin = 0
	# 
	PlanetTopAtComponentTransform = 1
	# 
	PlanetCenterAtComponentTransform = 2

class ESkyLightSourceType(Enum):
	"""ESky Light Source Type"""

	# Construct the sky light from the captured scene, anything further than SkyDistanceThreshold from the sky light position will be included.
	SLS_CapturedScene = 0
	# Construct the sky light from the specified cubemap.
	SLS_SpecifiedCubemap = 1
	# 
	SLS_MAX = 2

class ESplinePointType(Enum):
	"""Permitted spline point types for SplineComponent."""

	# 
	Linear = 0
	# 
	Curve = 1
	# 
	Constant = 2
	# 
	CurveClamped = 3
	# 
	CurveCustomTangent = 4

class ESplineCoordinateSpace(Enum):
	"""Types of coordinate space accepted by the functions."""

	# 
	Local = 0
	# 
	World = 1

class ESplineMeshAxis(Enum):
	"""ESpline Mesh Axis"""

	# 
	X = 0
	# 
	Y = 1
	# 
	Z = 2

class EStereoLayerType(Enum):
	"""Used by IStereoLayer"""

	# Location within the world
	SLT_WorldLocked = 0
	# Location within the HMD tracking space
	SLT_TrackerLocked = 1
	# Location within the view space
	SLT_FaceLocked = 2
	# 
	SLT_MAX = 3

class EStereoLayerShape(Enum):
	"""The shape to use for the stereo layer.  Note that some shapes might not be supported on all platforms!"""

	# Quad layer
	SLSH_QuadLayer = 0
	# Cylinder layer
	SLSH_CylinderLayer = 1
	# Cubemap layer
	SLSH_CubemapLayer = 2
	# Equirect layer
	SLSH_EquirectLayer = 3
	# 
	SLSH_MAX = 4

class EHorizTextAligment(Enum):
	"""EHoriz Text Aligment"""

	# 
	EHTA_Left = 0
	# 
	EHTA_Center = 1
	# 
	EHTA_Right = 2

class EVerticalTextAligment(Enum):
	"""EVertical Text Aligment"""

	# 
	EVRTA_TextTop = 0
	# 
	EVRTA_TextCenter = 1
	# 
	EVRTA_TextBottom = 2
	# 
	EVRTA_QuadTop = 3

class ETimelineLengthMode(Enum):
	"""Whether or not the timeline should be finished after the specified length, or the last keyframe in the tracks"""

	# 
	TL_TimelineLength = 0
	# 
	TL_LastKeyFrame = 1

class ETimelineDirection(Enum):
	"""Does timeline play or reverse ?"""

	# 
	Forward = 0
	# 
	Backward = 1

class EWindSourceType(Enum):
	"""EWind Source Type"""

	# 
	Directional = 0
	# 
	Point = 1

class TextureGroup(Enum):
	"""@warning: if this is changed:
    update BaseEngine.ini [SystemSettings]
    you might have to update the update Game's DefaultEngine.ini [SystemSettings]
    order and actual name can never change (order is important!)

TEXTUREGROUP_Cinematic: should be used for Cinematics which will be baked out
                        and want to have the highest settings"""

	# 
	TEXTUREGROUP_World = 0
	# 
	TEXTUREGROUP_WorldNormalMap = 1
	# 
	TEXTUREGROUP_WorldSpecular = 2
	# 
	TEXTUREGROUP_Character = 3
	# 
	TEXTUREGROUP_CharacterNormalMap = 4
	# 
	TEXTUREGROUP_CharacterSpecular = 5
	# 
	TEXTUREGROUP_Weapon = 6
	# 
	TEXTUREGROUP_WeaponNormalMap = 7
	# 
	TEXTUREGROUP_WeaponSpecular = 8
	# 
	TEXTUREGROUP_Vehicle = 9
	# 
	TEXTUREGROUP_VehicleNormalMap = 10
	# 
	TEXTUREGROUP_VehicleSpecular = 11
	# 
	TEXTUREGROUP_Cinematic = 12
	# 
	TEXTUREGROUP_Effects = 13
	# 
	TEXTUREGROUP_EffectsNotFiltered = 14
	# 
	TEXTUREGROUP_Skybox = 15
	# 
	TEXTUREGROUP_UI = 16
	# 
	TEXTUREGROUP_Lightmap = 17
	# 
	TEXTUREGROUP_RenderTarget = 18
	# 
	TEXTUREGROUP_MobileFlattened = 19
	# Obsolete - kept for backwards compatibility.
	TEXTUREGROUP_ProcBuilding_Face = 20
	# Obsolete - kept for backwards compatibility.
	TEXTUREGROUP_ProcBuilding_LightMap = 21
	# 
	TEXTUREGROUP_Shadowmap = 22
	# No compression, no mips.
	TEXTUREGROUP_ColorLookupTable = 23
	# 
	TEXTUREGROUP_Terrain_Heightmap = 24
	# 
	TEXTUREGROUP_Terrain_Weightmap = 25
	# Using this TextureGroup triggers special mip map generation code only useful for the BokehDOF post process.
	TEXTUREGROUP_Bokeh = 26
	# No compression, created on import of a .IES file.
	TEXTUREGROUP_IESLightProfile = 27
	# Non-filtered, useful for 2D rendering.
	TEXTUREGROUP_Pixels2D = 28
	# Hierarchical LOD generated textures
	TEXTUREGROUP_HierarchicalLOD = 29
	# Impostor Color Textures
	TEXTUREGROUP_Impostor = 30
	# Impostor Normal and Depth, use default compression
	TEXTUREGROUP_ImpostorNormalDepth = 31
	# 8 bit data stored in textures
	TEXTUREGROUP_8BitData = 32
	# 16 bit data stored in textures
	TEXTUREGROUP_16BitData = 33
	# Project specific group, rename in Engine.ini, [EnumRemap] TEXTUREGROUP_Project**.DisplayName=My Fun Group
	TEXTUREGROUP_Project01 = 34
	# 
	TEXTUREGROUP_Project02 = 35
	# 
	TEXTUREGROUP_Project03 = 36
	# 
	TEXTUREGROUP_Project04 = 37
	# 
	TEXTUREGROUP_Project05 = 38
	# 
	TEXTUREGROUP_Project06 = 39
	# 
	TEXTUREGROUP_Project07 = 40
	# 
	TEXTUREGROUP_Project08 = 41
	# 
	TEXTUREGROUP_Project09 = 42
	# 
	TEXTUREGROUP_Project10 = 43
	# 
	TEXTUREGROUP_Project11 = 44
	# 
	TEXTUREGROUP_Project12 = 45
	# 
	TEXTUREGROUP_Project13 = 46
	# 
	TEXTUREGROUP_Project14 = 47
	# 
	TEXTUREGROUP_Project15 = 48
	# 
	TEXTUREGROUP_MAX = 49

class TextureMipGenSettings(Enum):
	"""Texture Mip Gen Settings"""

	# Default for the 'texture'.
	TMGS_FromTextureGroup = 0
	# 2x2 average, default for the 'texture group'.
	TMGS_SimpleAverage = 1
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen0 = 2
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen1 = 3
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen2 = 4
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen3 = 5
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen4 = 6
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen5 = 7
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen6 = 8
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen7 = 9
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen8 = 10
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen9 = 11
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	TMGS_Sharpen10 = 12
	# 
	TMGS_NoMipmaps = 13
	# Do not touch existing mip chain as it contains generated data.
	TMGS_LeaveExistingMips = 14
	# Blur further (useful for image based reflections).
	TMGS_Blur1 = 15
	# 
	TMGS_Blur2 = 16
	# 
	TMGS_Blur3 = 17
	# 
	TMGS_Blur4 = 18
	# 
	TMGS_Blur5 = 19
	# Use the first texel of each 2x2 (or 2x2x2) group.
	TMGS_Unfiltered = 20
	# 
	TMGS_MAX = 21

class ETexturePowerOfTwoSetting(Enum):
	"""Options for texture padding mode."""

	# Do not modify the texture dimensions.
	None = 0
	# Pad the texture to the nearest power of two size.
	PadToPowerOfTwo = 1
	# Pad the texture to the nearest square power of two size.
	PadToSquarePowerOfTwo = 2

class ETextureSamplerFilter(Enum):
	"""Must match enum ESamplerFilter in RHIDefinitions.h"""

	# 
	Point = 0
	# 
	Bilinear = 1
	# 
	Trilinear = 2
	# 
	AnisotropicPoint = 3
	# 
	AnisotropicLinear = 4

class ETextureMipLoadOptions(Enum):
	"""ETexture Mip Load Options"""

	# Fallback to the LODGroup settings
	Default = 0
	# Load all mips.
	AllMips = 1
	# Load only the first mip.
	OnlyFirstMip = 2

class ETextureDownscaleOptions(Enum):
	"""ETexture Downscale Options"""

	# Fallback to the 'texture group' settings
	Default = 0
	# Unfiltered
	Unfiltered = 1
	# Average, default for the 'texture group'
	SimpleAverage = 2
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen0 = 3
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen1 = 4
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen2 = 5
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen3 = 6
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen4 = 7
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen5 = 8
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen6 = 9
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen7 = 10
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen8 = 11
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen9 = 12
	# 8x8 with sharpening: 0=no sharpening but better quality which is softer, 1=little, 5=medium, 10=extreme.
	Sharpen10 = 13

class EMaterialDomain(Enum):
	"""Defines the domain of a material."""

	# The material's attributes describe a 3d surface.
	MD_Surface = 0
	# The material's attributes describe a deferred decal, and will be mapped onto the decal's frustum.
	MD_DeferredDecal = 1
	# The material's attributes describe a light's distribution.
	MD_LightFunction = 2
	# The material's attributes describe a 3d volume.
	MD_Volume = 3
	# The material will be used in a custom post process pass.
	MD_PostProcess = 4
	# The material will be used for UMG or Slate UI
	MD_UI = 5
	# The material will be used for runtime virtual texture (Deprecated).
	MD_RuntimeVirtualTexture = 6
	# 
	MD_MAX = 7

class TextureCompressionSettings(Enum):
	"""This needs to be mirrored in EditorFactories.cpp."""

	# 
	TC_Default = 0
	# 
	TC_Normalmap = 1
	# 
	TC_Masks = 2
	# 
	TC_Grayscale = 3
	# 
	TC_Displacementmap = 4
	# 
	TC_VectorDisplacementmap = 5
	# 
	TC_HDR = 6
	# 
	TC_EditorIcon = 7
	# 
	TC_Alpha = 8
	# 
	TC_DistanceFieldFont = 9
	# 
	TC_HDR_Compressed = 10
	# 
	TC_BC7 = 11
	# 
	TC_HalfFloat = 12
	# 
	TC_ReflectionCapture = 13
	# 
	TC_MAX = 14

class TextureFilter(Enum):
	"""Texture Filter"""

	# 
	TF_Nearest = 0
	# 
	TF_Bilinear = 1
	# 
	TF_Trilinear = 2
	# Use setting from the Texture Group.
	TF_Default = 3
	# 
	TF_MAX = 4

class TextureAddress(Enum):
	"""Texture Address"""

	# 
	TA_Wrap = 0
	# 
	TA_Clamp = 1
	# 
	TA_Mirror = 2
	# 
	TA_MAX = 3

class ECompositeTextureMode(Enum):
	"""EComposite Texture Mode"""

	# 
	CTM_Disabled = 0
	# CompositingTexture needs to be a normal map with the same or larger size.
	CTM_NormalRoughnessToRed = 1
	# CompositingTexture needs to be a normal map with the same or larger size.
	CTM_NormalRoughnessToGreen = 2
	# CompositingTexture needs to be a normal map with the same or larger size.
	CTM_NormalRoughnessToBlue = 3
	# CompositingTexture needs to be a normal map with the same or larger size.
	CTM_NormalRoughnessToAlpha = 4
	# 
	CTM_MAX = 5

class ETextureMipCount(Enum):
	"""ETexture Mip Count"""

	# 
	TMC_ResidentMips = 0
	# 
	TMC_AllMips = 1
	# 
	TMC_AllMipsBiased = 2
	# 
	TMC_MAX = 3

class ETextureSourceArtType(Enum):
	"""ETexture Source Art Type"""

	# FColor Data[SrcWidth * SrcHeight].
	TSAT_Uncompressed = 0
	# PNG compresed version of FColor Data[SrcWidth * SrcHeight].
	TSAT_PNGCompressed = 1
	# DDS file with header.
	TSAT_DDSFile = 2
	# 
	TSAT_MAX = 3

class ETextureSourceFormat(Enum):
	"""ETexture Source Format"""

	# 
	TSF_Invalid = 0
	# 
	TSF_G8 = 1
	# 
	TSF_BGRA8 = 2
	# 
	TSF_BGRE8 = 3
	# 
	TSF_RGBA16 = 4
	# 
	TSF_RGBA16F = 5
	# @todo: Deprecated!
	TSF_RGBA8 = 6
	# @todo: Deprecated!
	TSF_RGBE8 = 7
	# 
	TSF_G16 = 8
	# 
	TSF_MAX = 9

class ETextureCompressionQuality(Enum):
	"""ETexture Compression Quality"""

	# 
	TCQ_Default = 0
	# 
	TCQ_Lowest = 1
	# 
	TCQ_Low = 2
	# 
	TCQ_Medium = 3
	# 
	TCQ_High = 4
	# 
	TCQ_Highest = 5
	# 
	TCQ_MAX = 6

class ETextureLossyCompressionAmount(Enum):
	"""ETexture Lossy Compression Amount"""

	# 
	TLCA_Default = 0
	# 
	TLCA_None = 1
	# 
	TLCA_Lowest = 2
	# 
	TLCA_Low = 3
	# 
	TLCA_Medium = 4
	# 
	TLCA_High = 5
	# 
	TLCA_Highest = 6

class EReporterLineStyle(Enum):
	"""Draw styles for lines."""

	# 
	Line = 0
	# 
	Dash = 1

class EGraphAxisStyle(Enum):
	"""Draw styles for axes."""

	# 
	Lines = 0
	# 
	Notches = 1
	# 
	Grid = 2

class EGraphDataStyle(Enum):
	"""Draw styles for data."""

	# 
	Lines = 0
	# 
	Filled = 1

class ELegendPosition(Enum):
	"""ELegend Position"""

	# 
	Outside = 0
	# 
	Inside = 1

class DistributionParamMode(Enum):
	"""Distribution Param Mode"""

	# 
	DPM_Normal = 0
	# 
	DPM_Abs = 1
	# 
	DPM_Direct = 2
	# 
	DPM_MAX = 3

class EDistributionVectorLockFlags(Enum):
	"""EDistribution Vector Lock Flags"""

	# 
	EDVLF_None = 0
	# 
	EDVLF_XY = 1
	# 
	EDVLF_XZ = 2
	# 
	EDVLF_YZ = 3
	# 
	EDVLF_XYZ = 4
	# 
	EDVLF_MAX = 5

class EDistributionVectorMirrorFlags(Enum):
	"""EDistribution Vector Mirror Flags"""

	# 
	EDVMF_Same = 0
	# 
	EDVMF_Different = 1
	# 
	EDVMF_Mirror = 2
	# 
	EDVMF_MAX = 3

class EGraphType(Enum):
	"""Distinguishes between different graph types. Graphs can have different properties; for example: functions have one entry point, ubergraphs can have multiples."""

	# 
	GT_Function = 0
	# 
	GT_Ubergraph = 1
	# 
	GT_Macro = 2
	# 
	GT_Animation = 3
	# 
	GT_StateMachine = 4
	# 
	GT_MAX = 5

class ECanCreateConnectionResponse(Enum):
	"""This is the type of response the graph editor should take when making a connection"""

	# Make the connection; there are no issues (message string is displayed if not empty).
	CONNECT_RESPONSE_MAKE = 0
	# Cannot make this connection; display the message string as an error.
	CONNECT_RESPONSE_DISALLOW = 1
	# Break all existing connections on A and make the new connection (it's exclusive); display the message string as a warning/notice.
	CONNECT_RESPONSE_BREAK_OTHERS_A = 2
	# Break all existing connections on B and make the new connection (it's exclusive); display the message string as a warning/notice.
	CONNECT_RESPONSE_BREAK_OTHERS_B = 3
	# Break all existing connections on A and B, and make the new connection (it's exclusive); display the message string as a warning/notice.
	CONNECT_RESPONSE_BREAK_OTHERS_AB = 4
	# Make the connection via an intermediate cast node, or some other conversion node.
	CONNECT_RESPONSE_MAKE_WITH_CONVERSION_NODE = 5
	# 
	CONNECT_RESPONSE_MAX = 6

class EPrimaryAssetCookRule(Enum):
	"""Rule about when to cook/ship a primary asset"""

	# Nothing is known about this asset specifically. It will cook if something else depends on it.
	Unknown = 0
	# Asset should never be cooked/shipped in any situation. An error will be generated if something depends on it.
	NeverCook = 1
	# Asset will be cooked in development if something else depends on it, but will never be cooked in a production build.
	DevelopmentCook = 2
	# Asset will always be cooked in development, but should never be cooked in a production build.
	DevelopmentAlwaysCook = 3
	# Asset will always be cooked, in both production and development.
	AlwaysCook = 4

class ECsgOper(Enum):
	"""Variables."""

	# Active brush. (deprecated, do not use.)
	CSG_Active = 0
	# Add to world. (deprecated, do not use.)
	CSG_Add = 1
	# Subtract from world. (deprecated, do not use.)
	CSG_Subtract = 2
	# Form from intersection with world.
	CSG_Intersect = 3
	# Form from negative intersection with world.
	CSG_Deintersect = 4
	# 
	CSG_None = 5
	# 
	CSG_MAX = 6

class EBrushType(Enum):
	"""EBrush Type"""

	# Default/builder brush.
	Brush_Default = 0
	# Add to world.
	Brush_Add = 1
	# Subtract from world.
	Brush_Subtract = 2
	# 
	Brush_MAX = 3

class ETextureRenderTargetFormat(Enum):
	"""Subset of EPixelFormat exposed to UTextureRenderTarget2D"""

	# R channel, 8 bit per channel fixed point, range [0, 1].
	RTF_R8 = 0
	# RG channels, 8 bit per channel fixed point, range [0, 1].
	RTF_RG8 = 1
	# RGBA channels, 8 bit per channel fixed point, range [0, 1].
	RTF_RGBA8 = 2
	# RGBA channels, 8 bit per channel fixed point, range [0, 1]. RGB is encoded with sRGB gamma curve. A is always stored as linear.
	RTF_RGBA8_SRGB = 3
	# R channel, 16 bit per channel floating point, range [-65504, 65504]
	RTF_R16f = 4
	# RG channels, 16 bit per channel floating point, range [-65504, 65504]
	RTF_RG16f = 5
	# RGBA channels, 16 bit per channel floating point, range [-65504, 65504]
	RTF_RGBA16f = 6
	# R channel, 32 bit per channel floating point, range [-3.402823 x 10^38, 3.402823 x 10^38]
	RTF_R32f = 7
	# RG channels, 32 bit per channel floating point, range [-3.402823 x 10^38, 3.402823 x 10^38]
	RTF_RG32f = 8
	# RGBA channels, 32 bit per channel floating point, range [-3.402823 x 10^38, 3.402823 x 10^38]
	RTF_RGBA32f = 9
	# RGBA channels, 10 bit per channel fixed point and 2 bit of alpha
	RTF_RGB10A2 = 10

class EMeshFeatureImportance(Enum):
	"""The importance of a mesh feature when automatically generating mesh LODs."""

	# 
	Off = 0
	# 
	Lowest = 1
	# 
	Low = 2
	# 
	Normal = 3
	# 
	High = 4
	# 
	Highest = 5

class EStaticMeshReductionTerimationCriterion(Enum):
	"""Enum specifying the reduction type to use when simplifying static meshes with the engines internal tool"""

	# 
	Triangles = 0
	# 
	Vertices = 1
	# 
	Any = 2

class ELandscapeCullingPrecision(Enum):
	"""ELandscape Culling Precision"""

	# 
	High = 0
	# 
	Medium = 1
	# 
	Low = 2

class EProxyNormalComputationMethod(Enum):
	"""EProxy Normal Computation Method"""

	# 
	AngleWeighted = 0
	# 
	AreaWeighted = 1
	# 
	EqualWeighted = 2

class EMeshLODSelectionType(Enum):
	"""EMesh LODSelection Type"""

	# Whether or not to export all of the LODs found in the source meshes
	AllLODs = 0
	# Whether or not to export all of the LODs found in the source meshes
	SpecificLOD = 1
	# Whether or not to calculate the appropriate LOD model for the given screen size
	CalculateLOD = 2
	# Whether or not to use the lowest-detail LOD
	LowestDetailLOD = 3

class EMeshMergeType(Enum):
	"""EMesh Merge Type"""

	# 
	MeshMergeType_Default = 0
	# 
	MeshMergeType_MergeActor = 1

class EUVOutput(Enum):
	"""As UHT doesnt allow arrays of bools, we need this binary enum :("""

	# 
	DoNotOutputChannel = 0
	# 
	OutputChannel = 1

class EMeshInstancingReplacementMethod(Enum):
	"""How to replace instanced"""

	# Destructive workflow: remove the original actors when replacing with instanced static meshes
	RemoveOriginalActors = 0
	# Non-destructive workflow: keep the original actors but hide them and set them to be editor-only
	KeepOriginalActorsAsEditorOnly = 1

class ReverbPreset(Enum):
	"""DEPRECATED: Exists for backwards compatibility
Indicates a reverb preset to use."""

	# 
	REVERB_Default = 0
	# 
	REVERB_Bathroom = 1
	# 
	REVERB_StoneRoom = 2
	# 
	REVERB_Auditorium = 3
	# 
	REVERB_ConcertHall = 4
	# 
	REVERB_Cave = 5
	# 
	REVERB_Hallway = 6
	# 
	REVERB_StoneCorridor = 7
	# 
	REVERB_Alley = 8
	# 
	REVERB_Forest = 9
	# 
	REVERB_City = 10
	# 
	REVERB_Mountains = 11
	# 
	REVERB_Quarry = 12
	# 
	REVERB_Plain = 13
	# 
	REVERB_ParkingLot = 14
	# 
	REVERB_SewerPipe = 15
	# 
	REVERB_Underwater = 16
	# 
	REVERB_SmallRoom = 17
	# 
	REVERB_MediumRoom = 18
	# 
	REVERB_LargeRoom = 19
	# 
	REVERB_MediumHall = 20
	# 
	REVERB_LargeHall = 21
	# 
	REVERB_Plate = 22
	# 
	REVERB_MAX = 23

class EAudioVolumeLocationState(Enum):
	"""Enum describing the state of checking audio volume location"""

	# A send based on linear interpolation between a distance range and send-level range
	InsideTheVolume = 0
	# A send based on a supplied curve
	OutsideTheVolume = 1

class EVisibilityAggressiveness(Enum):
	"""EVisibility Aggressiveness"""

	# 
	VIS_LeastAggressive = 0
	# 
	VIS_ModeratelyAggressive = 1
	# 
	VIS_MostAggressive = 2
	# 
	VIS_Max = 3

class EVolumeLightingMethod(Enum):
	"""EVolume Lighting Method"""

	# Lighting samples are computed in an adaptive grid which covers the entire Lightmass Importance Volume.  Higher density grids are used near geometry.
	# The Volumetric Lightmap is interpolated efficiently on the GPU per-pixel, allowing accurate indirect lighting for dynamic objects and volumetric fog.
	# Positions outside of the Importance Volume reuse the border texels of the Volumetric Lightmap (clamp addressing).
	# On mobile, interpolation is done on the CPU at the center of each object's bounds.
	VLM_VolumetricLightmap = 0
	# Volume lighting samples are placed on top of static surfaces at medium density, and everywhere else in the Lightmass Importance Volume at low density.  Positions outside of the Importance Volume will have no indirect lighting.
	# This method requires CPU interpolation so the Indirect Lighting Cache is used to interpolate results for each dynamic object, adding Rendering Thread overhead.
	# Volumetric Fog cannot be affected by precomputed lighting with this method.
	VLM_SparseVolumeLightingSamples = 1

class EPlatformInterfaceDataType(Enum):
	"""An enum for the types of data used in a PlatformInterfaceData struct."""

	# No data type specified.
	PIDT_None = 0
	# 
	PIDT_Int = 1
	# 
	PIDT_Float = 2
	# 
	PIDT_String = 3
	# 
	PIDT_Object = 4
	# A custom type where more than one value may be filled out.
	PIDT_Custom = 5
	# 
	PIDT_MAX = 6

class ECloudStorageDelegate(Enum):
	"""All the types of delegate callbacks that a CloudStorage subclass may receive from C++"""

	# @todo: Fill in the result descriptions for these guys (and the other PI subclasses)
	CSD_KeyValueReadComplete = 0
	# 
	CSD_KeyValueWriteComplete = 1
	# 
	CSD_ValueChanged = 2
	# 
	CSD_DocumentQueryComplete = 3
	# 
	CSD_DocumentReadComplete = 4
	# 
	CSD_DocumentWriteComplete = 5
	# Desc: Called when multiple machines have updated the document, and script needs to determine which one to use, via the Resolve functions.
	CSD_DocumentConflictDetected = 6
	# 
	CSD_MAX = 7

class ECurveTableMode(Enum):
	"""Whether the curve table contains simple, rich, or no curves"""

	# 
	Empty = 0
	# 
	SimpleCurves = 1
	# 
	RichCurves = 2

class EDynamicForceFeedbackAction(Enum):
	"""EDynamic Force Feedback Action"""

	# 
	Start = 0
	# 
	Update = 1
	# 
	Stop = 2

class ECustomTimeStepSynchronizationState(Enum):
	"""Possible states of CustomTimeStep."""

	# CustomTimeStep has not been initialized or has been shutdown.
	Closed = 0
	# CustomTimeStep error occurred during Synchronization.
	Error = 1
	# CustomTimeStep is currently synchronized with the source.
	Synchronized = 2
	# CustomTimeStep is initialized and being prepared for synchronization.
	Synchronizing = 3

class EFontImportCharacterSet(Enum):
	"""Font character set type for importing TrueType fonts."""

	# 
	FontICS_Default = 0
	# 
	FontICS_Ansi = 1
	# 
	FontICS_Symbol = 2
	# 
	FontICS_MAX = 3

class EFontCacheType(Enum):
	"""Enumerates supported font caching types."""

	# The font is using offline caching (this is how UFont traditionally worked).
	Offline = 0
	# The font is using runtime caching (this is how Slate fonts work).
	Runtime = 1

class EAdManagerDelegate(Enum):
	"""EAd Manager Delegate"""

	# 
	AMD_ClickedBanner = 0
	# 
	AMD_UserClosedAd = 1
	# 
	AMD_MAX = 2

class EStreamingVolumeUsage(Enum):
	"""Enum for different usage cases of level streaming volumes."""

	# 
	SVB_Loading = 0
	# 
	SVB_LoadingAndVisibility = 1
	# 
	SVB_VisibilityBlockingOnLoad = 2
	# 
	SVB_BlockingOnLoad = 3
	# 
	SVB_LoadingNotVisible = 4
	# 
	SVB_MAX = 5

class EMicroTransactionDelegate(Enum):
	"""All the types of delegate callbacks that a MicroTransaction subclass may receive from C++."""

	# Data:None
	# Desc:QueryForAvailablePurchases() is complete and AvailableProducts is ready for use.
	MTD_PurchaseQueryComplete = 0
	# Data:Result code, and identifier of the product that completed.
	# Type:Custom
	# Desc:IntValue will have one of the enums in EMicroTransactionResult, and StringValue
	#      will have the Identifier from the PurchaseInfo that was bought with BeginPurchase
	#      If MTR_Failed was returned, then LastError and LastErrorSolution should be filled
	#              out with the most recent localized and possible resolutions.
	MTD_PurchaseComplete = 1
	# 
	MTD_MAX = 2

class EMicroTransactionResult(Enum):
	"""Result of a purchase."""

	# 
	MTR_Succeeded = 0
	# 
	MTR_Failed = 1
	# 
	MTR_Canceled = 2
	# 
	MTR_RestoredFromServer = 3
	# 
	MTR_MAX = 4

class EClearSceneOptions(Enum):
	"""Enumerates ways to clear a scene."""

	# This option is fastest but can cause artifacts unless you render to every pixel. Make sure to use a skybox with this option!
	NoClear = 0
	# Perform a full hardware clear before rendering. Most projects should use this option.
	HardwareClear = 1
	# Draws a quad to perform the clear at the far plane, this is faster than a hardware clear on some GPUs.
	QuadAtMaxZ = 2

class ECompositingSampleCount(Enum):
	"""Enumerates available compositing sample counts."""

	# 
	One = 1
	# 
	Two = 2
	# 
	Four = 4
	# 
	Eight = 8

class EMobileMSAASampleCount(Enum):
	"""Enumerates available mobile MSAA sample counts."""

	# 
	One = 1
	# 
	Two = 2
	# 
	Four = 4
	# 
	Eight = 8

class ECustomDepthStencil(Enum):
	"""Enumerates available options for custom depth."""

	# 
	Disabled = 0
	# Depth buffer created immediately. Stencil disabled.
	Enabled = 1
	# Depth buffer created on first use, can save memory but cause stalls. Stencil disabled.
	EnabledOnDemand = 2
	# Depth buffer created immediately. Stencil available for read/write.
	EnabledWithStencil = 3

class EEarlyZPass(Enum):
	"""Enumerates available options for early Z-passes."""

	# 
	None = 0
	# 
	OpaqueOnly = 1
	# 
	OpaqueAndMasked = 2
	# Let the engine decide what to render in the early Z pass based on the features being used.
	Auto = 3

class EAlphaChannelMode(Enum):
	"""Enumerates available options for alpha channel through post processing. The renderer will always generate premultiplied RGBA
with alpha as translucency (0 = fully opaque; 1 = fully translucent)."""

	# Disabled, reducing GPU cost to the minimum. (default).
	Disabled = 0
	# Maintain alpha channel only within linear color space. Tonemapper won't output alpha channel.
	LinearColorSpaceOnly = 1
	# Maintain alpha channel within linear color space, but also pass it through the tonemapper.
	# 
	# CAUTION: Passing the alpha channel through the tonemapper can unevitably lead to pretty poor compositing quality as
	# opposed to linear color space compositing, especially on purely additive pixels bloom can generate. This settings is
	# exclusively targeting broadcast industry in case of hardware unable to do linear color space compositing and
	# tonemapping.
	AllowThroughTonemapper = 2

class EAutoExposureMethodUI(Enum):
	"""used by FPostProcessSettings AutoExposure"""

	# requires compute shader to construct 64 bin histogram
	AEM_Histogram = 0
	# faster method that computes single value by downsampling
	AEM_Basic = 1
	# Uses camera settings.
	AEM_Manual = 2
	# 
	AEM_MAX = 3

class EDefaultBackBufferPixelFormat(Enum):
	"""used by GetDefaultBackBufferPixelFormat"""

	# 
	DBBPF_B8G8R8A8 = 0
	# 
	DBBPF_A16B16G16R16_DEPRECATED = 1
	# 
	DBBPF_FloatRGB_DEPRECATED = 2
	# 
	DBBPF_FloatRGBA = 3
	# 
	DBBPF_A2B10G10R10 = 4
	# 
	DBBPF_MAX = 5

class ESkeletalMeshGeoImportVersions(Enum):
	"""uenum class cannot be inside a preprocessor like #if WITH_EDITOR"""

	# 
	Before_Versionning = 0
	# 
	SkeletalMeshBuildRefactor = 1
	# -----<new versions can be added above this line>-------------------------------------------------
	VersionPlusOne = 2
	# 
	LatestVersion = -1

class ESkeletalMeshSkinningImportVersions(Enum):
	"""ESkeletal Mesh Skinning Import Versions"""

	# 
	Before_Versionning = 0
	# 
	SkeletalMeshBuildRefactor = 1
	# -----<new versions can be added above this line>-------------------------------------------------
	VersionPlusOne = 2
	# 
	LatestVersion = -1

class ENormalMode(Enum):
	"""Optimization settings used to simplify mesh LODs."""

	# 
	NM_PreserveSmoothingGroups = 0
	# 
	NM_RecalculateNormals = 1
	# 
	NM_RecalculateNormalsSmooth = 2
	# 
	NM_RecalculateNormalsHard = 3
	# 
	TEMP_BROKEN = 4
	# 
	ENormalMode_MAX = 5

class EImportanceLevel(Enum):
	"""EImportance Level"""

	# 
	IL_Off = 0
	# 
	IL_Lowest = 1
	# 
	IL_Low = 2
	# 
	IL_Normal = 3
	# 
	IL_High = 4
	# 
	IL_Highest = 5
	# 
	TEMP_BROKEN2 = 6
	# 
	EImportanceLevel_MAX = 7

class EOptimizationType(Enum):
	"""Enum specifying the reduction type to use when simplifying static meshes."""

	# 
	OT_NumOfTriangles = 0
	# 
	OT_MaxDeviation = 1
	# 
	OT_MAX = 2

class ETimecodeProviderSynchronizationState(Enum):
	"""Possible states of TimecodeProvider."""

	# TimecodeProvider has not been initialized or has been shutdown.
	Closed = 0
	# Unrecoverable error occurred during Synchronization.
	Error = 1
	# TimecodeProvider is currently synchronized with the source.
	Synchronized = 2
	# TimecodeProvider is initialized and being prepared for synchronization.
	Synchronizing = 3

class ETwitterRequestMethod(Enum):
	"""The possible twitter request methods"""

	# 
	TRM_Get = 0
	# 
	TRM_Post = 1
	# 
	TRM_Delete = 2
	# 
	TRM_MAX = 3

class ETwitterIntegrationDelegate(Enum):
	"""ETwitter Integration Delegate"""

	# 
	TID_AuthorizeComplete = 0
	# 
	TID_TweetUIComplete = 1
	# 
	TID_RequestComplete = 2
	# 
	TID_MAX = 3

class EUserDefinedStructureStatus(Enum):
	"""EUser Defined Structure Status"""

	# Struct is in an unknown state.
	UDSS_UpToDate = 0
	# Struct has been modified but not recompiled.
	UDSS_Dirty = 1
	# Struct tried but failed to be compiled.
	UDSS_Error = 2
	# Struct is a duplicate, the original one was changed.
	UDSS_Duplicate = 3
	# 
	UDSS_MAX = 4

class ERenderFocusRule(Enum):
	"""When to render the Focus Brush for widgets that have user focus. Based on the EFocusCause."""

	# Focus Brush will always be rendered for widgets that have user focus.
	Always = 0
	# Focus Brush will be rendered for widgets that have user focus not set based on pointer causes.
	NonPointer = 1
	# Focus Brush will be rendered for widgets that have user focus only if the focus was set by navigation.
	NavigationOnly = 2
	# Focus Brush will not be rendered.
	Never = 3

class EUIScalingRule(Enum):
	"""The Side to use when scaling the UI."""

	# Evaluates the scale curve based on the shortest side of the viewport.
	ShortestSide = 0
	# Evaluates the scale curve based on the longest side of the viewport.
	LongestSide = 1
	# Evaluates the scale curve based on the X axis of the viewport.
	Horizontal = 2
	# Evaluates the scale curve based on the Y axis of the viewport.
	Vertical = 3
	# ScaleToFit - Does not use scale curve. Emulates behavior of scale box by using DesignScreenSize and scaling the content relatively to it.
	ScaleToFit = 4
	# Custom - Allows custom rule interpretation.
	Custom = 5

class ERootMotionAccumulateMode(Enum):
	"""Enumeration for RootMotionSource accumulation mode"""

	# Sets velocity to this value directly
	Override = 0
	# Gets added on top of existing velocity
	Additive = 1

class ERootMotionSourceStatusFlags(Enum):
	"""Enumeration for RootMotionSource status flags"""

	# Source has been Prepared and can contribute to root motion
	Prepared = 1
	# Source has timed out or otherwise reached a state where it is considered 'done'
	Finished = 2
	# Source has been queued for removal, will be removed next PrepareRootMotion() by the SourceGroup
	MarkedForRemoval = 4

class ERootMotionSourceSettingsFlags(Enum):
	"""Enumeration for RootMotionSource settings"""

	# Source will switch character to Falling mode with any 'Z up' velocity added.
	# Use this for jump-like root motion. If not enabled, uses default jump impulse
	# detection (which keeps you stuck on ground in Walking fairly strongly)
	UseSensitiveLiftoffCheck = 1
	# If Duration of Source would end partway through the last tick it is active,
	# do not reduce SimulationTime. Disabling this is useful for sources that
	# are more about providing velocity (like jumps), vs. sources that need
	# the precision of partial ticks for say ending up at an exact location (MoveTo)
	DisablePartialEndTick = 2
	# Whether to ignore impact to Z when accumulating output to Velocity
	# Setting this flag on override sources provides the same behavior as
	# animation root motion
	IgnoreZAccumulate = 4

class ERootMotionFinishVelocityMode(Enum):
	"""ERoot Motion Finish Velocity Mode"""

	# Maintain the last velocity root motion gave to the character
	MaintainLastRootMotionVelocity = 0
	# Set Velocity to the specified value (for example, 0,0,0 to stop the character)
	SetVelocity = 1
	# Clamp velocity magnitude to the specified value. Note that it will not clamp Z if negative (falling). it will clamp Z positive though.
	ClampVelocity = 2

class EStandbyType(Enum):
	"""Describes which standby detection event occured so the game can take appropriate action."""

	# 
	STDBY_Rx = 0
	# 
	STDBY_Tx = 1
	# 
	STDBY_BadPing = 2
	# 
	STDBY_MAX = 3

class EWindowMode(Enum):
	"""Supported windowing modes (mirrored from GenericWindow.h)"""

	# The window is in true fullscreen mode
	Fullscreen = 0
	# The window has no border and takes up the entire area of the screen
	WindowedFullscreen = 1
	# The window has a border and may not take up the entire screen area
	Windowed = 2

class EScreenOrientation(Enum):
	"""The list of possible device/screen orientation for mobile devices"""

	# The orientation is not known
	Unknown = 0
	# The orientation is portrait with the home button at the bottom
	Portrait = 1
	# The orientation is portrait with the home button at the top
	PortraitUpsideDown = 2
	# The orientation is landscape with the home button at the right side
	LandscapeLeft = 3
	# The orientation is landscape with the home button at the left side
	LandscapeRight = 4
	# The orientation is as if place on a desk with the screen upward
	FaceUp = 5
	# The orientation is as if place on a desk with the screen downward
	FaceDown = 6

class EApplicationState(Enum):
	"""application state when the game receives a notification"""

	# The Application was in an unknown state when receiving the notification
	Unknown = 0
	# The Application was inactive when receiving the notification
	Inactive = 1
	# The Application was in the background when receiving the notification
	Background = 2
	# The Application was active when receiving the notification
	Active = 3

class EEvaluateCurveTableResult(Enum):
	"""Enum used to indicate success or failure of EvaluateCurveTableRow."""

	# Found the row successfully.
	RowFound = 0
	# Failed to find the row.
	RowNotFound = 1

class EDrawDebugTrace(Enum):
	"""EDraw Debug Trace"""

	# 
	None = 0
	# 
	ForOneFrame = 1
	# 
	ForDuration = 2
	# 
	Persistent = 3

class EMoveComponentAction(Enum):
	"""Enum used to indicate desired behavior for MoveComponentTo latent function."""

	# Move to target over specified time.
	Move = 0
	# If currently moving, stop.
	Stop = 1
	# If currently moving, return to where you started, over the time elapsed so far.
	Return = 2

class EQuitPreference(Enum):
	"""EQuit Preference"""

	# Exit the game completely.
	Quit = 0
	# Move the application to the background.
	Background = 1

class EGrammaticalGender(Enum):
	"""EGrammatical Gender"""

	# 
	Neuter = 0
	# 
	Masculine = 1
	# 
	Feminine = 2
	# 
	Mixed = 3

class EGrammaticalNumber(Enum):
	"""EGrammatical Number"""

	# 
	Singular = 0
	# 
	Plural = 1

class ESuggestProjVelocityTraceOption(Enum):
	"""Trace option to SuggestProjectileVelocity functions."""

	# 
	DoNotTrace = 0
	# 
	TraceFullPath = 1
	# 
	OnlyTraceWhileAscending = 2

class EImportanceWeight(Enum):
	"""Provides different weighting functions for texture importance sampling"""

	# Importance from color luminance.
	Luminance = 0
	# Importance from red channel of texture.
	Red = 1
	# Importance from green channel of texture.
	Green = 2
	# Importance from blue channel of texture.
	Blue = 3
	# Importance from alpha channel of texture.
	Alpha = 4

class ESlateGesture(Enum):
	"""ESlate Gesture"""

	# 
	None = 0
	# 
	Scroll = 1
	# 
	Magnify = 2
	# 
	Swipe = 3
	# 
	Rotate = 4
	# 
	LongPress = 5

class EMIDCreationFlags(Enum):
	"""EMIDCreation Flags"""

	# 
	None = 0
	# 
	Transient = -1

class EEasingFunc(Enum):
	"""Provides different easing functions that can be used in blueprints"""

	# Simple linear interpolation.
	Linear = 0
	# Simple step interpolation.
	Step = 1
	# Sinusoidal in interpolation.
	SinusoidalIn = 2
	# Sinusoidal out interpolation.
	SinusoidalOut = 3
	# Sinusoidal in/out interpolation.
	SinusoidalInOut = 4
	# Smoothly accelerates, but does not decelerate into the target.  Ease amount controlled by BlendExp.
	EaseIn = 5
	# Immediately accelerates, but smoothly decelerates into the target.  Ease amount controlled by BlendExp.
	EaseOut = 6
	# Smoothly accelerates and decelerates.  Ease amount controlled by BlendExp.
	EaseInOut = 7
	# Easing in using an exponential
	ExpoIn = 8
	# Easing out using an exponential
	ExpoOut = 9
	# Easing in/out using an exponential method
	ExpoInOut = 10
	# Easing is based on a half circle.
	CircularIn = 11
	# Easing is based on an inverted half circle.
	CircularOut = 12
	# Easing is based on two half circles.
	CircularInOut = 13

class ELerpInterpolationMode(Enum):
	"""Different methods for interpolating rotation between transforms"""

	# Shortest Path or Quaternion interpolation for the rotation.
	QuatInterp = 0
	# Rotor or Euler Angle interpolation.
	EulerInterp = 1
	# Dual quaternion interpolation, follows helix or screw-motion path between keyframes.
	DualQuatInterp = 2

class EMatrixColumns(Enum):
	"""Possible columns for an FMatrix"""

	# First Column.
	First = 0
	# Second Column.
	Second = 1
	# Third Column.
	Third = 2
	# Fourth Column.
	Fourth = 3

class ERoundingMode(Enum):
	"""Provides rounding modes for converting numbers into localized text"""

	# Rounds to the nearest place, equidistant ties go to the value which is closest to an even value: 1.5 becomes 2, 0.5 becomes 0
	HalfToEven = 0
	# Rounds to nearest place, equidistant ties go to the value which is further from zero: -0.5 becomes -1.0, 0.5 becomes 1.0
	HalfFromZero = 1
	# Rounds to nearest place, equidistant ties go to the value which is closer to zero: -0.5 becomes 0, 0.5 becomes 0.
	HalfToZero = 2
	# Rounds to the value which is further from zero, 'larger' in absolute value: 0.1 becomes 1, -0.1 becomes -1
	FromZero = 3
	# Rounds to the value which is closer to zero, 'smaller' in absolute value: 0.1 becomes 0, -0.1 becomes 0
	ToZero = 4
	# Rounds to the value which is more negative: 0.1 becomes 0, -0.1 becomes -1
	ToNegativeInfinity = 5
	# Rounds to the value which is more positive: 0.1 becomes 1, -0.1 becomes 0
	ToPositiveInfinity = 6

class ETextGender(Enum):
	"""EText Gender"""

	# 
	Masculine = 0
	# 
	Feminine = 1
	# 
	Neuter = 2

class EFormatArgumentType(Enum):
	"""EFormat Argument Type"""

	# 
	Int = 0
	# 
	UInt = 1
	# 
	Float = 2
	# 
	Double = 3
	# 
	Text = 4
	# 
	Gender = 5

class ETextureMipValueMode(Enum):
	"""defines how MipValue is used"""

	# Use hardware computed sample's mip level with automatic anisotropic filtering support.
	TMVM_None = 0
	# Explicitly compute the sample's mip level. Disables anisotropic filtering.
	TMVM_MipLevel = 1
	# Bias the hardware computed sample's mip level. Disables anisotropic filtering.
	TMVM_MipBias = 2
	# Explicitly compute the sample's DDX and DDY for anisotropic filtering.
	TMVM_Derivative = 3
	# 
	TMVM_MAX = 4

class EMaterialFunctionUsage(Enum):
	"""Usage set on a material function determines feature compatibility and validation."""

	# 
	Default = 0
	# 
	MaterialLayer = 1
	# 
	MaterialLayerBlend = 2

class EDecalBlendMode(Enum):
	"""Defines how the GBuffer channels are getting manipulated by a decal material pass. Actual index is used to control shader parameters so don't change order."""

	# Blend full material, updating the GBuffer, does not work for baked lighting.
	DBM_Translucent = 0
	# Modulate BaseColor, blend rest, updating the GBuffer, does not work for baked lighting. Does not work in DBuffer mode (approximated as Translucent).
	DBM_Stain = 1
	# Only blend normal, updating the GBuffer, does not work for baked lighting.
	DBM_Normal = 2
	# Additive emissive only.
	DBM_Emissive = 3
	# Put into DBuffer to work for baked lighting as well (becomes DBM_TranslucentNormal if normal is not hooked up).
	DBM_DBuffer_ColorNormalRoughness = 4
	# Put into DBuffer to work for baked lighting as well.
	DBM_DBuffer_Color = 5
	# Put into DBuffer to work for baked lighting as well (becomes DBM_DBuffer_Color if normal is not hooked up).
	DBM_DBuffer_ColorNormal = 6
	# Put into DBuffer to work for baked lighting as well.
	DBM_DBuffer_ColorRoughness = 7
	# Put into DBuffer to work for baked lighting as well.
	DBM_DBuffer_Normal = 8
	# Put into DBuffer to work for baked lighting as well (becomes DBM_DBuffer_Roughness if normal is not hooked up).
	DBM_DBuffer_NormalRoughness = 9
	# Put into DBuffer to work for baked lighting as well.
	DBM_DBuffer_Roughness = 10
	# Internal DBffer decal blend modes used for auto-converted decals
	DBM_DBuffer_Emissive = 11
	# 
	DBM_DBuffer_AlphaComposite = 12
	# 
	DBM_DBuffer_EmissiveAlphaComposite = 13
	# Output signed distance in Opacity depending on LightVector. Note: Can be costly, no shadow casting but receiving, no per pixel normal yet, no quality settings yet
	DBM_Volumetric_DistanceFunction = 14
	# Blend with existing scene color. Decal color is already pre-multiplied by alpha.
	DBM_AlphaComposite = 15
	# Ambient occlusion.
	DBM_AmbientOcclusion = 16
	# 
	DBM_MAX = 17

class EMaterialDecalResponse(Enum):
	"""Defines how the material reacts on DBuffer decals, later we can expose more variants between None and Default."""

	# Do not receive decals (Later we still can read the DBuffer channels to customize the effect, this frees up some interpolators).
	MDR_None = 0
	# Receive Decals, applies all DBuffer channels, assumes the decal is non metal and mask the subsurface scattering.
	MDR_ColorNormalRoughness = 1
	# Receive Decals, applies color DBuffer channels, assumes the decal is non metal and mask the subsurface scattering.
	MDR_Color = 2
	# Receive Decals, applies all DBuffer channels, assumes the decal is non metal and mask the subsurface scattering.
	MDR_ColorNormal = 3
	# Receive Decals, applies all DBuffer channels, assumes the decal is non metal and mask the subsurface scattering.
	MDR_ColorRoughness = 4
	# Receive Decals, applies all DBuffer channels, assumes the decal is non metal and mask the subsurface scattering.
	MDR_Normal = 5
	# Receive Decals, applies all DBuffer channels, assumes the decal is non metal and mask the subsurface scattering.
	MDR_NormalRoughness = 6
	# Receive Decals, applies all DBuffer channels, assumes the decal is non metal and mask the subsurface scattering.
	MDR_Roughness = 7
	# 
	MDR_MAX = 8

class ETextureColorChannel(Enum):
	"""ETexture Color Channel"""

	# 
	TCC_Red = 0
	# 
	TCC_Green = 1
	# 
	TCC_Blue = 2
	# 
	TCC_Alpha = 3
	# 
	TCC_MAX = 4

class EMaterialAttributeBlend(Enum):
	"""EMaterial Attribute Blend"""

	# 
	Blend = 0
	# 
	UseA = 1
	# 
	UseB = 2

class EChannelMaskParameterColor(Enum):
	"""EChannel Mask Parameter Color"""

	# 
	Red = 0
	# 
	Green = 1
	# 
	Blue = 2
	# 
	Alpha = 3

class EClampMode(Enum):
	"""EClamp Mode"""

	# 
	CMODE_Clamp = 0
	# 
	CMODE_ClampMin = 1
	# 
	CMODE_ClampMax = 2

class ECustomMaterialOutputType(Enum):
	"""ECustom Material Output Type"""

	# 
	CMOT_Float1 = 0
	# 
	CMOT_Float2 = 1
	# 
	CMOT_Float3 = 2
	# 
	CMOT_Float4 = 3
	# 
	CMOT_MaterialAttributes = 4
	# 
	CMOT_MAX = 5

class EDepthOfFieldFunctionValue(Enum):
	"""Note: The index is used to map the enum to different code in the shader"""

	# 0:in Focus .. 1:Near or Far.
	TDOF_NearAndFarMask = 0
	# 0:in Focus or Far .. 1:Near.
	TDOF_NearMask = 1
	# 0:in Focus or Near .. 1:Far.
	TDOF_FarMask = 2
	# in pixels, only works for CircleDOF, use Abs for the actual radius as the sign of the value indicates near out of focus, positive indicates far out of focus
	TDOF_CircleOfConfusionRadius = 3
	# 
	TDOF_MAX = 4

class EFunctionInputType(Enum):
	"""Supported input types"""

	# 
	FunctionInput_Scalar = 0
	# 
	FunctionInput_Vector2 = 1
	# 
	FunctionInput_Vector3 = 2
	# 
	FunctionInput_Vector4 = 3
	# 
	FunctionInput_Texture2D = 4
	# 
	FunctionInput_TextureCube = 5
	# 
	FunctionInput_Texture2DArray = 6
	# 
	FunctionInput_VolumeTexture = 7
	# 
	FunctionInput_StaticBool = 8
	# 
	FunctionInput_MaterialAttributes = 9
	# 
	FunctionInput_TextureExternal = 10
	# 
	FunctionInput_MAX = 11

class ENoiseFunction(Enum):
	"""ENoise Function"""

	# High quality for direct use and bumps
	# ~77 instructions per level, 4 texture lookups
	# Cannot tile
	NOISEFUNCTION_SimplexTex = 0
	# High quality for direct use and bumps
	# Non-tiled: ~61 instructions per level, 8 texture lookups
	# Tiling: ~74 instructions per level, 8 texture lookups
	# Even 'non-tiled' mode has a repeat of 128. Useful Repeat Size range <= 128
	# Formerly labeled as Perlin noise
	NOISEFUNCTION_GradientTex = 1
	# High quality for direct use, BAD for bumps; doesn't work on Mobile
	# ~16 instructions per level, 1 texture lookup
	# Always tiles with a repeat of 16, 'Tiling' mode is not an option for Fast Gradient noise
	NOISEFUNCTION_GradientTex3D = 2
	# High quality for direct use and bumps
	# Non-tiled: ~80 instructions per level, no textures
	# Tiling: ~143 instructions per level, no textures
	NOISEFUNCTION_GradientALU = 3
	# Low quality, but pure computation
	# Non-tiled: ~53 instructions per level, no textures
	# Tiling: ~118 instructions per level, no textures
	# Formerly mis-labeled as Gradient noise
	NOISEFUNCTION_ValueALU = 4
	# Also known as Worley or Cellular noise
	# Quality=1 searches 8 cells, Quality=2 searches 16 cells
	# Quality=3 searches 27 cells, Quality=4 searches 32 cells
	# All are about 20 instructions per cell searched
	NOISEFUNCTION_VoronoiALU = 5
	# 
	NOISEFUNCTION_MAX = 6

class ERuntimeVirtualTextureMipValueMode(Enum):
	"""Defines how MipValue is used.
Internally we will convert to ETextureMipValueMode which is used by internal APIs.
ETextureMipValueMode has more options then are valid for runtime virtual texture."""

	# Use hardware computed sample's mip level with automatic anisotropic filtering support.
	RVTMVM_None = 0
	# Explicitly compute the sample's mip level. Disables anisotropic filtering.
	RVTMVM_MipLevel = 1
	# Bias the hardware computed sample's mip level. Disables anisotropic filtering.
	RVTMVM_MipBias = 2
	# 
	RVTMVM_MAX = 3

class ERuntimeVirtualTextureTextureAddressMode(Enum):
	"""Defines texture addressing behavior."""

	# Clamp mode.
	RVTTA_Clamp = 0
	# Wrap mode.
	RVTTA_Wrap = 1
	# 
	RVTTA_MAX = 2

class EMaterialSceneAttributeInputMode(Enum):
	"""EMaterial Scene Attribute Input Mode"""

	# 
	Coordinates = 0
	# 
	OffsetFraction = 1

class ESpeedTreeGeometryType(Enum):
	"""ESpeed Tree Geometry Type"""

	# 
	STG_Branch = 0
	# 
	STG_Frond = 1
	# 
	STG_Leaf = 2
	# 
	STG_FacingLeaf = 3
	# 
	STG_Billboard = 4

class ESpeedTreeWindType(Enum):
	"""ESpeed Tree Wind Type"""

	# 
	STW_None = 0
	# 
	STW_Fastest = 1
	# 
	STW_Fast = 2
	# 
	STW_Better = 3
	# 
	STW_Best = 4
	# 
	STW_Palm = 5
	# 
	STW_BestPlus = 6

class ESpeedTreeLODType(Enum):
	"""ESpeed Tree LODType"""

	# 
	STLOD_Pop = 0
	# 
	STLOD_Smooth = 1

class EMaterialExposedTextureProperty(Enum):
	"""Selects the texture property to output"""

	# The texture's size.
	TMTM_TextureSize = 0
	# The texture's texel size in the UV space (1 / Texture Size)
	TMTM_TexelSize = 1
	# 
	TMTM_MAX = 2

class EMaterialVectorCoordTransformSource(Enum):
	"""EMaterial Vector Coord Transform Source"""

	# Tangent space (relative to the surface)
	TRANSFORMSOURCE_Tangent = 0
	# Local space (relative to the rendered object, = object space)
	TRANSFORMSOURCE_Local = 1
	# World space, a unit is 1cm
	TRANSFORMSOURCE_World = 2
	# View space (relative to the camera/eye, = camera space, differs from camera space in the shadow passes)
	TRANSFORMSOURCE_View = 3
	# Camera space
	TRANSFORMSOURCE_Camera = 4
	# Particle space
	TRANSFORMSOURCE_ParticleWorld = 5
	# 
	TRANSFORMSOURCE_MAX = 6

class EMaterialVectorCoordTransform(Enum):
	"""EMaterial Vector Coord Transform"""

	# Tangent space (relative to the surface)
	TRANSFORM_Tangent = 0
	# Local space (relative to the rendered object, = object space)
	TRANSFORM_Local = 1
	# World space, a unit is 1cm
	TRANSFORM_World = 2
	# View space (relative to the camera/eye, = camera space, differs from camera space in the shadow passes)
	TRANSFORM_View = 3
	# Camera space
	TRANSFORM_Camera = 4
	# Particle space
	TRANSFORM_ParticleWorld = 5
	# 
	TRANSFORM_MAX = 6

class EMaterialPositionTransformSource(Enum):
	"""EMaterial Position Transform Source"""

	# Local space
	TRANSFORMPOSSOURCE_Local = 0
	# Absolute world space
	TRANSFORMPOSSOURCE_World = 1
	# Camera relative world space
	TRANSFORMPOSSOURCE_TranslatedWorld = 2
	# View space (differs from camera space in the shadow passes)
	TRANSFORMPOSSOURCE_View = 3
	# Camera space
	TRANSFORMPOSSOURCE_Camera = 4
	# Particle space
	TRANSFORMPOSSOURCE_Particle = 5
	# 
	TRANSFORMPOSSOURCE_MAX = 6

class EVectorNoiseFunction(Enum):
	"""EVector Noise Function"""

	# Random color for each unit cell in 3D space.
	# RGB output range 0 to 1
	# R only = 9 instructions, RGB = 11 instructions
	VNF_CellnoiseALU = 0
	# Perlin-style noise with 3D vector/color output.
	# RGB output range -1 to 1
	# R only = ~83 instructions, RGB = ~125 instructions
	VNF_VectorALU = 1
	# Gradient of Perlin noise, useful for bumps.
	# RGB = Gradient of scalar noise (signed 3D vector)
	# A = Base scalar noise with range -1 to 1
	# A only = ~83 instructions, RGBA = ~106 instructions
	VNF_GradientALU = 2
	# Curl of Perlin noise, useful for 3D flow directions.
	# RGB = signed curl vector
	# ~162 instructions
	VNF_CurlALU = 3
	# Also known as Worley or Cellular noise.
	# RGB = *position* of closest point at center of Voronoi cell
	# A = distance to closest point with range 0 to about 4
	# Quality levels 1-4 search 8, 16, 27 & 32 cells
	# All ~20 instructions per cell searched
	VNF_VoronoiALU = 4
	# 
	VNF_MAX = 5

class EMaterialExposedViewProperty(Enum):
	"""EMaterial Exposed View Property"""

	# Horizontal and vertical size of the view's buffer in pixels
	MEVP_BufferSize = 0
	# Horizontal and vertical field of view angles in radian
	MEVP_FieldOfView = 1
	# Tan(FieldOfView * 0.5)
	MEVP_TanHalfFieldOfView = 2
	# Horizontal and vertical size of the view in pixels
	MEVP_ViewSize = 3
	# Absolute world space view position (differs from the camera position in the shadow passes)
	MEVP_WorldSpaceViewPosition = 4
	# Absolute world space camera position
	MEVP_WorldSpaceCameraPosition = 5
	# Horizontal and vertical position of the viewport in pixels within the buffer.
	MEVP_ViewportOffset = 6
	# Number of temporal AA sample used across multiple to converge to anti aliased output.
	MEVP_TemporalSampleCount = 7
	# Index of the Temporal AA jitter for this frame.
	MEVP_TemporalSampleIndex = 8
	# Offset of the temporal sample for this frame in pixel size.
	MEVP_TemporalSampleOffset = 9
	# Mip Level that Runtime Virtual Texture Output is rendering to.
	MEVP_RuntimeVirtualTextureOutputLevel = 10
	# World space derivatives for Runtime Virtual Texture Output.
	MEVP_RuntimeVirtualTextureOutputDerivative = 11
	# Pre Exposure
	MEVP_PreExposure = 12
	# Maximum mip level of Runtime Virtual Texture that Runtime Virtual Texture Output is rendering to.
	MEVP_RuntimeVirtualTextureMaxLevel = 13
	# 
	MEVP_MAX = 14

class EWorldPositionIncludedOffsets(Enum):
	"""Specifies which shader generated offsets should included in the world position (displacement/WPO etc.)"""

	# Absolute world position with all material shader offsets applied
	WPT_Default = 0
	# Absolute world position with no material shader offsets applied
	WPT_ExcludeAllShaderOffsets = 1
	# Camera relative world position with all material shader offsets applied
	WPT_CameraRelative = 2
	# Camera relative world position with no material shader offsets applied
	WPT_CameraRelativeNoOffsets = 3
	# 
	WPT_MAX = 4

class ETrackActiveCondition(Enum):
	"""Required condition for this track to be enabled"""

	# Track is always active
	ETAC_Always = 0
	# Track is active when extreme content (gore) is enabled
	ETAC_GoreEnabled = 1
	# Track is active when extreme content (gore) is disabled
	ETAC_GoreDisabled = 2
	# 
	ETAC_MAX = 3

class ETrackToggleAction(Enum):
	"""Enumeration indicating toggle action"""

	# 
	ETTA_Off = 0
	# 
	ETTA_On = 1
	# 
	ETTA_Toggle = 2
	# 
	ETTA_Trigger = 3
	# 
	ETTA_MAX = 4

class EVisibilityTrackAction(Enum):
	"""Visibility track actions"""

	# Hides the object
	EVTA_Hide = 0
	# Shows the object
	EVTA_Show = 1
	# Toggles visibility of the object
	EVTA_Toggle = 2
	# 
	EVTA_MAX = 3

class EVisibilityTrackCondition(Enum):
	"""Required condition for firing this event"""

	# Always play this event
	EVTC_Always = 0
	# Only play this event when extreme content (gore) is enabled
	EVTC_GoreEnabled = 1
	# Only play this event when extreme content (gore) is disabled
	EVTC_GoreDisabled = 2
	# 
	EVTC_MAX = 3

class EInterpTrackMoveRotMode(Enum):
	"""EInterp Track Move Rot Mode"""

	# Should take orientation from the keyframe.
	IMR_Keyframed = 0
	# Point the X-Axis of the controlled Actor at the group specified by LookAtGroupName.
	IMR_LookAtGroup = 1
	# Do not change rotation. Ignore it.
	IMR_Ignore = 2
	# 
	IMR_MAX = 3

class EInterpMoveAxis(Enum):
	"""List of axies this track can use"""

	# 
	AXIS_TranslationX = 0
	# 
	AXIS_TranslationY = 1
	# 
	AXIS_TranslationZ = 2
	# 
	AXIS_RotationX = 3
	# 
	AXIS_RotationY = 4
	# 
	AXIS_RotationZ = 5

class EVertexPaintAxis(Enum):
	"""EVertex Paint Axis"""

	# 
	X = 0
	# 
	Y = 1
	# 
	Z = 2

class EParticleDetailMode(Enum):
	"""Detail mode for scene component rendering."""

	# 
	PDM_Low = 0
	# 
	PDM_Medium = 1
	# 
	PDM_High = 2
	# 
	PDM_MAX = 3

class EParticleSignificanceLevel(Enum):
	"""A level of significance for a particle system. Used by game code to enable/disable emitters progressively as they move away from the camera or are occluded/off screen."""

	# Low significance emitter. Culled first.
	Low = 0
	# Medium significance emitter.
	Medium = 1
	# High significance emitter. Culled last.
	High = 2
	# Critical emitter. Never culled.
	Critical = 3
	# 
	Num = 4

class EParticleSystemInsignificanceReaction(Enum):
	"""Determines what a particle system will do when all of it's emitters become insignificant."""

	# Looping systems will DisableTick. Non-looping systems will Complete.
	Auto = 0
	# The system will be considered complete and will auto destroy if desired etc.
	Complete = 1
	# The system will simply stop ticking. Tick will be re-enabled when any emitters become significant again. This is useful for persistent fx such as environmental fx.
	DisableTick = 2
	# As DisableTick but will also kill all particles.
	DisableTickAndKill = 3
	# Hidden for now until I make it useful i.e. Killing particles saves memory.
	Num = 4

class EModuleType(Enum):
	"""ModuleType
   Indicates the kind of emitter the module can be applied to.
   ie, EPMT_Beam - only applies to beam emitters.

   The TypeData field is present to speed up finding the TypeData module."""

	# General - all emitter types can use it
	EPMT_General = 0
	# TypeData - TypeData modules
	EPMT_TypeData = 1
	# Beam - only applied to beam emitters
	EPMT_Beam = 2
	# Trail - only applied to trail emitters
	EPMT_Trail = 3
	# Spawn - all emitter types REQUIRE it
	EPMT_Spawn = 4
	# Required - all emitter types REQUIRE it
	EPMT_Required = 5
	# Event - event related modules
	EPMT_Event = 6
	# Light related modules
	EPMT_Light = 7
	# SubUV related modules
	EPMT_SubUV = 8
	# 
	EPMT_MAX = 9

class EParticleSourceSelectionMethod(Enum):
	"""Particle Selection Method, for any emitters that utilize particles
as the source points."""

	# Random         - select a particle at random
	EPSSM_Random = 0
	# Sequential     - select a particle in order
	EPSSM_Sequential = 1
	# 
	EPSSM_MAX = 2

class EAttractorParticleSelectionMethod(Enum):
	"""EAttractor Particle Selection Method"""

	# 
	EAPSM_Random = 0
	# 
	EAPSM_Sequential = 1
	# 
	EAPSM_MAX = 2

class Beam2SourceTargetMethod(Enum):
	"""The method to use in determining the source/target."""

	# Default        - use the distribution.
	#     This is the fallback for when other modes can't be resolved.
	PEB2STM_Default = 0
	# UserSet        - use the user set value.
	#     Primarily intended for weapon effects.
	PEB2STM_UserSet = 1
	# Emitter        - use the emitter position as the source/target.
	PEB2STM_Emitter = 2
	# Particle       - use the particles from a given emitter in the system.
	#     The name of the emitter should be set in <Source/Target>Name.
	PEB2STM_Particle = 3
	# Actor          - use the actor as the source/target.
	#     The name of the actor should be set in <Source/Target>Name.
	PEB2STM_Actor = 4
	# 
	PEB2STM_MAX = 5

class Beam2SourceTargetTangentMethod(Enum):
	"""The method to use in determining the source/target tangent."""

	# Direct - a direct line between source and target.
	PEB2STTM_Direct = 0
	# UserSet        - use the user set value.
	PEB2STTM_UserSet = 1
	# Distribution - use the distribution.
	PEB2STTM_Distribution = 2
	# Emitter        - use the emitter direction.
	PEB2STTM_Emitter = 3
	# 
	PEB2STTM_MAX = 4

class BeamModifierType(Enum):
	"""What to modify."""

	# Modify the source of the beam.
	PEB2MT_Source = 0
	# Modify the target of the beam.
	PEB2MT_Target = 1
	# 
	PEB2MT_MAX = 2

class EParticleCameraOffsetUpdateMethod(Enum):
	"""The update method for the offset"""

	# 
	EPCOUM_DirectSet = 0
	# 
	EPCOUM_Additive = 1
	# 
	EPCOUM_Scalar = 2
	# 
	EPCOUM_MAX = 3

class EParticleCollisionComplete(Enum):
	"""Flags indicating what to do with the particle when MaxCollisions is reached"""

	# Kill the particle when MaxCollisions is reached
	EPCC_Kill = 0
	# Freeze the particle in place
	EPCC_Freeze = 1
	# Stop collision checks, but keep updating
	EPCC_HaltCollisions = 2
	# Stop translations of the particle
	EPCC_FreezeTranslation = 3
	# Stop rotations of the particle
	EPCC_FreezeRotation = 4
	# Stop all movement of the particle
	EPCC_FreezeMovement = 5
	# 
	EPCC_MAX = 6

class EParticleCollisionResponse(Enum):
	"""How particles respond to collision events."""

	# The particle will bounce off of the surface.
	Bounce = 0
	# The particle will stop on the surface.
	Stop = 1
	# The particle will be killed.
	Kill = 2

class EParticleSystemUpdateMode(Enum):
	"""ParticleSystemUpdateMode
Enumeration indicating the method by which the system should be updated"""

	# RealTime       - update via the delta time passed in
	EPSUM_RealTime = 0
	# FixedTime      - update via a fixed time step
	EPSUM_FixedTime = 1

class ParticleSystemLODMethod(Enum):
	"""ParticleSystemLODMethod"""

	# Automatically set the LOD level, checking every LODDistanceCheckTime seconds.
	PARTICLESYSTEMLODMETHOD_Automatic = 0
	# LOD level is directly set by the game code.
	PARTICLESYSTEMLODMETHOD_DirectSet = 1
	# LOD level is determined at Activation time, then left alone unless directly set by game code.
	PARTICLESYSTEMLODMETHOD_ActivateAutomatic = 2

class EParticleSystemOcclusionBoundsMethod(Enum):
	"""Occlusion method enumeration"""

	# Don't determine occlusion on this particle system
	EPSOBM_None = 0
	# Use the bounds of the particle system component when determining occlusion
	EPSOBM_ParticleBounds = 1
	# Use the custom occlusion bounds when determining occlusion
	EPSOBM_CustomBounds = 2

class EParticleSysParamType(Enum):
	"""Enum for specifying type of a name instance parameter."""

	# 
	PSPT_None = 0
	# 
	PSPT_Scalar = 1
	# 
	PSPT_ScalarRand = 2
	# 
	PSPT_Vector = 3
	# 
	PSPT_VectorRand = 4
	# 
	PSPT_Color = 5
	# 
	PSPT_Actor = 6
	# 
	PSPT_Material = 7
	# 
	PSPT_VectorUnitRand = 8
	# 
	PSPT_MAX = 9

class ParticleReplayState(Enum):
	"""Particle system replay state"""

	# Replay system is disabled.  Particles are simulated and rendered normally.
	PRS_Disabled = 0
	# Capture all particle data to the clip specified by ReplayClipIDNumber.  The frame to capture
	#               must be specified using the ReplayFrameIndex
	PRS_Capturing = 1
	# Replay captured particle state from the clip specified by ReplayClipIDNumber.  The frame to play
	#               must be specified using the ReplayFrameIndex
	PRS_Replaying = 2
	# 
	PRS_MAX = 3

class EParticleEventType(Enum):
	"""Event type"""

	# Any - allow any event
	EPET_Any = 0
	# Spawn - a particle spawn event
	EPET_Spawn = 1
	# Death - a particle death event
	EPET_Death = 2
	# Collision - a particle collision event
	EPET_Collision = 3
	# Burst - a particle burst event
	EPET_Burst = 4
	# Blueprint - an event generated by level script
	EPET_Blueprint = 5
	# 
	EPET_MAX = 6

class ELocationBoneSocketSource(Enum):
	"""ELocation Bone Socket Source"""

	# 
	BONESOCKETSOURCE_Bones = 0
	# 
	BONESOCKETSOURCE_Sockets = 1
	# 
	BONESOCKETSOURCE_MAX = 2

class ELocationBoneSocketSelectionMethod(Enum):
	"""ELocation Bone Socket Selection Method"""

	# 
	BONESOCKETSEL_Sequential = 0
	# 
	BONESOCKETSEL_Random = 1
	# 
	BONESOCKETSEL_MAX = 2

class ELocationEmitterSelectionMethod(Enum):
	"""ELocation Emitter Selection Method"""

	# 
	ELESM_Random = 0
	# 
	ELESM_Sequential = 1
	# 
	ELESM_MAX = 2

class CylinderHeightAxis(Enum):
	"""Cylinder Height Axis"""

	# 
	PMLPC_HEIGHTAXIS_X = 0
	# 
	PMLPC_HEIGHTAXIS_Y = 1
	# 
	PMLPC_HEIGHTAXIS_Z = 2
	# 
	PMLPC_HEIGHTAXIS_MAX = 3

class ELocationSkelVertSurfaceSource(Enum):
	"""ELocation Skel Vert Surface Source"""

	# 
	VERTSURFACESOURCE_Vert = 0
	# 
	VERTSURFACESOURCE_Surface = 1
	# 
	VERTSURFACESOURCE_MAX = 2

class EOrbitChainMode(Enum):
	"""EOrbit Chain Mode"""

	# Add the module values to the previous results
	EOChainMode_Add = 0
	# Multiply the module values by the previous results
	EOChainMode_Scale = 1
	# 'Break' the chain and apply the values from the previous results
	EOChainMode_Link = 2
	# 
	EOChainMode_MAX = 3

class EParticleAxisLock(Enum):
	"""Flags indicating lock"""

	# No locking to an axis...
	EPAL_NONE = 0
	# Lock the sprite facing towards the positive X-axis
	EPAL_X = 1
	# Lock the sprite facing towards the positive Y-axis
	EPAL_Y = 2
	# Lock the sprite facing towards the positive Z-axis
	EPAL_Z = 3
	# Lock the sprite facing towards the negative X-axis
	EPAL_NEGATIVE_X = 4
	# Lock the sprite facing towards the negative Y-axis
	EPAL_NEGATIVE_Y = 5
	# Lock the sprite facing towards the negative Z-axis
	EPAL_NEGATIVE_Z = 6
	# Lock the sprite rotation on the X-axis
	EPAL_ROTATE_X = 7
	# Lock the sprite rotation on the Y-axis
	EPAL_ROTATE_Y = 8
	# Lock the sprite rotation on the Z-axis
	EPAL_ROTATE_Z = 9
	# 
	EPAL_MAX = 10

class EEmitterDynamicParameterValue(Enum):
	"""EmitterDynamicParameterValue
Enumeration indicating the way a dynamic parameter should be set."""

	# UserSet - use the user set values in the distribution (the default)
	EDPV_UserSet = 0
	# AutoSet - ignore values set in the distribution, another module will handle this data
	EDPV_AutoSet = 1
	# VelocityX - pass the particle velocity along the X-axis thru
	EDPV_VelocityX = 2
	# VelocityY - pass the particle velocity along the Y-axis thru
	EDPV_VelocityY = 3
	# VelocityZ - pass the particle velocity along the Z-axis thru
	EDPV_VelocityZ = 4
	# VelocityMag - pass the particle velocity magnitude thru
	EDPV_VelocityMag = 5
	# 
	EDPV_MAX = 6

class EParticleBurstMethod(Enum):
	"""Burst emissions"""

	# 
	EPBM_Instant = 0
	# 
	EPBM_Interpolated = 1
	# 
	EPBM_MAX = 2

class EParticleSubUVInterpMethod(Enum):
	"""SubUV-related"""

	# 
	PSUVIM_None = 0
	# 
	PSUVIM_Linear = 1
	# 
	PSUVIM_Linear_Blend = 2
	# 
	PSUVIM_Random = 3
	# 
	PSUVIM_Random_Blend = 4
	# 
	PSUVIM_MAX = 5

class EEmitterRenderMode(Enum):
	"""Cascade-related"""

	# 
	ERM_Normal = 0
	# 
	ERM_Point = 1
	# 
	ERM_Cross = 2
	# 
	ERM_LightsOnly = 3
	# 
	ERM_None = 4
	# 
	ERM_MAX = 5

class EParticleScreenAlignment(Enum):
	"""EParticle Screen Alignment"""

	# 
	PSA_FacingCameraPosition = 0
	# 
	PSA_Square = 1
	# 
	PSA_Rectangle = 2
	# 
	PSA_Velocity = 3
	# 
	PSA_AwayFromCenter = 4
	# 
	PSA_TypeSpecific = 5
	# 
	PSA_FacingCameraDistanceBlend = 6
	# 
	PSA_MAX = 7

class ESubUVBoundingVertexCount(Enum):
	"""More bounding vertices results in reduced overdraw, but adds more triangle overhead.
The eight vertex mode is best used when the SubUV texture has a lot of space to cut out that is not captured by the four vertex version,
and when the particles using the texture will be few and large."""

	# 
	BVC_FourVertices = 0
	# 
	BVC_EightVertices = 1

class EOpacitySourceMode(Enum):
	"""EOpacity Source Mode"""

	# 
	OSM_Alpha = 0
	# 
	OSM_ColorBrightness = 1
	# 
	OSM_RedChannel = 2
	# 
	OSM_GreenChannel = 3
	# 
	OSM_BlueChannel = 4

class EParticleUVFlipMode(Enum):
	"""EParticle UVFlip Mode"""

	# Flips UV on all particles.
	None = 0
	# Flips UV on all particles.
	FlipUV = 1
	# Flips U only on all particles.
	FlipUOnly = 2
	# Flips V only on all particles.
	FlipVOnly = 3
	# Flips UV randomly for each particle on spawn.
	RandomFlipUV = 4
	# Flips U only randomly for each particle on spawn.
	RandomFlipUOnly = 5
	# Flips V only randomly for each particle on spawn.
	RandomFlipVOnly = 6
	# Flips U and V independently at random for each particle on spawn.
	RandomFlipUVIndependent = 7

class EParticleSortMode(Enum):
	"""EParticle Sort Mode"""

	# 
	PSORTMODE_None = 0
	# 
	PSORTMODE_ViewProjDepth = 1
	# 
	PSORTMODE_DistanceToView = 2
	# 
	PSORTMODE_Age_OldestFirst = 3
	# 
	PSORTMODE_Age_NewestFirst = 4
	# 
	PSORTMODE_MAX = 5

class EEmitterNormalsMode(Enum):
	"""EEmitter Normals Mode"""

	# Default mode, normals are based on the camera facing geometry.
	ENM_CameraFacing = 0
	# Normals are generated from a sphere centered at NormalsSphereCenter.
	ENM_Spherical = 1
	# Normals are generated from a cylinder going through NormalsSphereCenter, in the direction NormalsCylinderDirection.
	ENM_Cylindrical = 2
	# 
	ENM_MAX = 3

class ETrail2SourceMethod(Enum):
	"""ETrail 2Source Method"""

	# Default        - use the emitter position.
	#     This is the fallback for when other modes can't be resolved.
	PET2SRCM_Default = 0
	# Particle       - use the particles from a given emitter in the system.
	#     The name of the emitter should be set in SourceName.
	PET2SRCM_Particle = 1
	# Actor          - use the actor as the source.
	#     The name of the actor should be set in SourceName.
	PET2SRCM_Actor = 2
	# 
	PET2SRCM_MAX = 3

class EBeam2Method(Enum):
	"""EBeam 2Method"""

	# 
	PEB2M_Distance = 0
	# 
	PEB2M_Target = 1
	# 
	PEB2M_Branch = 2
	# 
	PEB2M_MAX = 3

class EBeamTaperMethod(Enum):
	"""Beam Tapering Variables."""

	# 
	PEBTM_None = 0
	# 
	PEBTM_Full = 1
	# 
	PEBTM_Partial = 2
	# 
	PEBTM_MAX = 3

class EMeshScreenAlignment(Enum):
	"""EMesh Screen Alignment"""

	# 
	PSMA_MeshFaceCameraWithRoll = 0
	# 
	PSMA_MeshFaceCameraWithSpin = 1
	# 
	PSMA_MeshFaceCameraWithLockedAxis = 2
	# 
	PSMA_MAX = 3

class EMeshCameraFacingUpAxis(Enum):
	"""EMesh Camera Facing Up Axis"""

	# 
	CameraFacing_NoneUP = 0
	# 
	CameraFacing_ZUp = 1
	# 
	CameraFacing_NegativeZUp = 2
	# 
	CameraFacing_YUp = 3
	# 
	CameraFacing_NegativeYUp = 4
	# 
	CameraFacing_MAX = 5

class EMeshCameraFacingOptions(Enum):
	"""EMesh Camera Facing Options"""

	# 
	XAxisFacing_NoUp = 0
	# 
	XAxisFacing_ZUp = 1
	# 
	XAxisFacing_NegativeZUp = 2
	# 
	XAxisFacing_YUp = 3
	# 
	XAxisFacing_NegativeYUp = 4
	# 
	LockedAxis_ZAxisFacing = 5
	# 
	LockedAxis_NegativeZAxisFacing = 6
	# 
	LockedAxis_YAxisFacing = 7
	# 
	LockedAxis_NegativeYAxisFacing = 8
	# 
	VelocityAligned_ZAxisFacing = 9
	# 
	VelocityAligned_NegativeZAxisFacing = 10
	# 
	VelocityAligned_YAxisFacing = 11
	# 
	VelocityAligned_NegativeYAxisFacing = 12
	# 
	EMeshCameraFacingOptions_MAX = 13

class ETrailsRenderAxisOption(Enum):
	"""ETrails Render Axis Option"""

	# 
	Trails_CameraUp = 0
	# 
	Trails_SourceUp = 1
	# 
	Trails_WorldUp = 2
	# 
	Trails_MAX = 3

class ESettingsDOF(Enum):
	"""ESettings DOF"""

	# Allows for full 3D movement and rotation.
	Full3D = 0
	# Allows 2D movement along the Y-Z plane.
	YZPlane = 1
	# Allows 2D movement along the X-Z plane.
	XZPlane = 2
	# Allows 2D movement along the X-Y plane.
	XYPlane = 3

class ESettingsLockedAxis(Enum):
	"""ESettings Locked Axis"""

	# No axis is locked.
	None = 0
	# Lock movement along the x-axis.
	X = 1
	# Lock movement along the y-axis.
	Y = 2
	# Lock movement along the z-axis.
	Z = 3
	# Used for backwards compatibility. Indicates that we've updated into the new struct.
	Invalid = 4

class EAudioBusChannels(Enum):
	"""The number of channels to mix audio into the source bus"""

	# 
	Mono = 0
	# 
	Stereo = 1

class EAudioOutputTarget(Enum):
	"""EAudio Output Target"""

	# Sound plays only from speakers.
	Speaker = 0
	# Sound plays only from controller if present.
	Controller = 1
	# Sound plays on the controller if present. If not present, it plays from speakers.
	ControllerFallbackToSpeaker = 2

class EVoiceSampleRate(Enum):
	"""Enumeration for what our options are for sample rates used for VOIP."""

	# 
	Low16000Hz = 16000
	# 
	Normal24000Hz = 24000

class EPanningMethod(Enum):
	"""Enumeration defines what method of panning to use (for non-binaural audio) with the audio-mixer."""

	# Linear panning maintains linear amplitude when panning between speakers.
	Linear = 0
	# Equal power panning maintains equal power when panning between speakers.
	EqualPower = 1

class EMonoChannelUpmixMethod(Enum):
	"""Enumeration defines how to treat mono 2D playback. Mono sounds need to upmixed to stereo when played back in 2D."""

	# The mono channel is split 0.5 left/right
	Linear = 0
	# The mono channel is split 0.707 left/right
	EqualPower = 1
	# The mono channel is split 1.0 left/right
	FullVolume = 2

class ModulationParamMode(Enum):
	"""Modulation Param Mode"""

	# Clamps input value to the range (MinInput, MaxInput) then maps to the range (MinOutput, MaxOutput)
	MPM_Normal = 0
	# Same as Normal except that the input value is treated as an absolute value
	MPM_Abs = 1
	# Use the input value directly without scaling or reference to Min or Max input or output values
	MPM_Direct = 2
	# 
	MPM_MAX = 3

class ESourceBusChannels(Enum):
	"""The number of channels to mix audio into the source bus"""

	# 
	Mono = 0
	# 
	Stereo = 1

class EFFTSize(Enum):
	"""EFFTSize"""

	# 512
	DefaultSize = 0
	# 64
	Min = 1
	# 256
	Small = 2
	# 512
	Medium = 3
	# 1024
	Large = 4
	# 2048
	VeryLarge = 5
	# 4096
	Max = 6

class EFFTPeakInterpolationMethod(Enum):
	"""EFFTPeak Interpolation Method"""

	# 
	NearestNeighbor = 0
	# 
	Linear = 1
	# 
	Quadratic = 2
	# 
	ConstantQ = 3

class EFFTWindowType(Enum):
	"""EFFTWindow Type"""

	# No window is applied. Technically a boxcar window.
	None = 0
	# Mainlobe width of -3 dB and sidelove attenuation of ~-40 dB. Good for COLA.
	Hamming = 1
	# Mainlobe width of -3 dB and sidelobe attenuation of ~-30dB. Good for COLA.
	Hann = 2
	# Mainlobe width of -3 dB and sidelobe attenuation of ~-60db. Tricky for COLA.
	Blackman = 3

class EAudioSpectrumType(Enum):
	"""EAudio Spectrum Type"""

	# Spectrum frequency values are equal to magnitude of frequency.
	MagnitudeSpectrum = 0
	# Spectrum frequency values are equal to magnitude squared.
	PowerSpectrum = 1
	# Returns decibels (0.0 dB is 1.0)
	Decibel = 2

class EGainParamMode(Enum):
	"""Whether to use linear or decibel values for audio gains"""

	# 
	Linear = 0
	# 
	Decibels = 1

class EVectorFieldConstructionOp(Enum):
	"""Operation used to construct the vector field from a 2D texture."""

	# 
	VFCO_Extrude = 0
	# 
	VFCO_Revolve = 1
	# 
	VFCO_MAX = 2

class EDrawDebugItemType(Enum):
	"""EDraw Debug Item Type"""

	# 
	DirectionalArrow = 0
	# 
	Sphere = 1
	# 
	Line = 2
	# 
	OnScreenMessage = 3
	# 
	CoordinateSystem = 4

class AnimPhysTwistAxis(Enum):
	"""Enum for picking current angular twist axis"""

	# 
	AxisX = 0
	# 
	AxisY = 1
	# 
	AxisZ = 2

class AnimPhysCollisionType(Enum):
	"""Anim Phys Collision Type"""

	# Only limit the center of mass from crossing planes.
	CoM = 0
	# Use the specified sphere radius to collide with planes.
	CustomSphere = 1
	# Use the largest sphere that fits entirely within the body extents to collide with planes.
	InnerSphere = 2
	# Use the smallest sphere that wholely contains the body extents to collide with planes.
	OuterSphere = 3

class EWindowTitleBarMode(Enum):
	"""EWindow Title Bar Mode"""

	# 
	Overlay = 0
	# 
	VerticalBox = 1

class FontOutlineSettings(object):
	"""Settings for applying an outline to a font"""

	@property
	def OutlineSize(self) -> int: ...
	"""Size of the outline in slate units (at 1.0 font scale this unit is a pixel)"""

	@property
	def bSeparateFillAlpha(self) -> bool: ...
	"""When enabled the outline will be completely translucent where the filled area will be.  This allows for a separate fill alpha value
The trade off when enabling this is slightly worse quality for completely opaque fills where the inner outline border meets the fill area"""

	@property
	def bApplyOutlineToDropShadows(self) -> bool: ...
	"""When enabled the outline will be applied to any drop shadow that uses this font"""

	@property
	def OutlineMaterial(self) -> Object: ...
	"""Optional material to apply to the outline"""

	@property
	def OutlineColor(self) -> LinearColor: ...
	"""The color of the outline for any character in this font"""

	pass

class SlateFontInfo(object):
	"""A representation of a font in Slate."""

	@property
	def FontObject(self) -> Object: ...
	"""The font object (valid when used from UMG or a Slate widget style asset)"""

	@property
	def FontMaterial(self) -> Object: ...
	"""The material to use when rendering this font"""

	@property
	def OutlineSettings(self) -> FontOutlineSettings: ...
	"""Settings for applying an outline to a font"""

	@property
	def TypefaceFontName(self) -> str: ...
	"""The name of the font to use from the default typeface (None will use the first entry)"""

	@property
	def Size(self) -> int: ...
	"""The font size is a measure in point values.  The conversion of points to Slate Units is done at 96 dpi.  So if
you're using a tool like Photoshop to prototype layouts and UI mock ups, be sure to change the default dpi
measurements from 72 dpi to 96 dpi."""

	@property
	def LetterSpacing(self) -> int: ...
	"""The uniform spacing (or tracking) between all characters in the text."""

	pass

class Geometry(object):
	"""Represents the position, size, and absolute position of a Widget in Slate.
The absolute location of a geometry is usually screen space or
window space depending on where the geometry originated.
Geometries are usually paired with a SWidget pointer in order
to provide information about a specific widget (see FArrangedWidget).
A Geometry's parent is generally thought to be the Geometry of the
the corresponding parent widget."""

	def __eq__(self, Other: Geometry) -> bool: ...

	def __ne__(self, Other: Geometry) -> bool: ...

	def MakeChild(self, ChildOffset: Vector2D, InLocalSize: Vector2D, ChildScale: float = ...) -> Geometry: ...

	def IsUnderLocation(self, AbsoluteCoordinate: Vector2D) -> bool: ...

	def AbsoluteToLocal(self, AbsoluteCoordinate: Vector2D) -> Vector2D: ...

	def LocalToAbsolute(self, LocalCoordinate: Vector2D) -> Vector2D: ...

	def LocalToRoundedLocal(self, LocalCoordinate: Vector2D) -> Vector2D: ...

	def ToString(self) -> str: ...

	def GetDrawSize(self) -> Vector2D: ...

	def GetLocalSize(self) -> Vector2D: ...

	def GetAbsolutePosition(self) -> Vector2D: ...

	def GetAbsoluteSize(self) -> Vector2D: ...

	def GetAbsolutePositionAtCoordinates(self, NormalCoordinates: Vector2D) -> Vector2D: ...

	def GetLocalPositionAtCoordinates(self, NormalCoordinates: Vector2D) -> Vector2D: ...

	def HasRenderTransform(self) -> bool: ...

	pass

class FocusEvent(object):
	"""FFocusEvent is used when notifying widgets about keyboard focus changes
It is passed to event handlers dealing with keyboard focus"""

	pass

class CaptureLostEvent(object):
	"""Capture Lost Event"""

	pass

class InputEvent(object):
	"""Base class for all mouse and keyevents."""

	pass

class KeyEvent(InputEvent):
	"""FKeyEvent describes a key action (keyboard/controller key/button pressed or released.)
It is passed to event handlers dealing with key input."""

	pass

class AnalogInputEvent(KeyEvent):
	"""FAnalogEvent describes a analog key value.
It is passed to event handlers dealing with analog keys."""

	pass

class CharacterEvent(InputEvent):
	"""FCharacterEvent describes a keyboard action where the utf-16 code is given.  Used for OnKeyChar messages"""

	pass

class PointerEvent(InputEvent):
	"""FPointerEvent describes a mouse or touch action (e.g. Press, Release, Move, etc).
It is passed to event handlers dealing with pointer-based input."""

	def GetScreenSpacePosition(self) -> Vector2D: ...

	def GetLastScreenSpacePosition(self) -> Vector2D: ...

	def GetCursorDelta(self) -> Vector2D: ...

	def GetWheelDelta(self) -> float: ...

	def GetUserIndex(self) -> int: ...

	def GetPointerIndex(self) -> int: ...

	def GetTouchpadIndex(self) -> int: ...

	def GetTouchForce(self) -> float: ...

	def IsTouchEvent(self) -> bool: ...

	def IsTouchForceChangedEvent(self) -> bool: ...

	def IsTouchFirstMoveEvent(self) -> bool: ...

	def GetGestureDelta(self) -> Vector2D: ...

	def IsDirectionInvertedFromDevice(self) -> bool: ...

	def ToText(self) -> str: ...

	def IsPointerEvent(self) -> bool: ...

	pass

class MotionEvent(InputEvent):
	"""FMotionEvent describes a touch pad action (press, move, lift)
It is passed to event handlers dealing with touch input."""

	pass

class NavigationEvent(InputEvent):
	"""FNavigationEvent describes a navigation action (Left, Right, Up, Down)
It is passed to event handlers dealing with navigation."""

	pass

class Margin(object):
	"""Describes the space around a Widget."""

	@property
	def Left(self) -> float: ...
	"""Holds the margin to the left."""

	@property
	def Top(self) -> float: ...
	"""Holds the margin to the top."""

	@property
	def Right(self) -> float: ...
	"""Holds the margin to the right."""

	@property
	def Bottom(self) -> float: ...
	"""Holds the margin to the bottom."""

	pass

class SlateSound(object):
	"""An intermediary to make UBaseSound available for Slate to play sounds"""

	pass

class SlateColor(object):
	"""A Slate color can be a directly specified value, or the color can be pulled from a WidgetStyle."""

	@overload
	def __init__(self): ...

	@overload
	def __init__(self, InColor: LinearColor): ...

	def GetSpecifiedColor(self) -> LinearColor: ...

	def IsColorSpecified(self) -> bool: ...

	def Unlink(self): ...

	def __eq__(self, Other: SlateColor) -> bool: ...

	def __ne__(self, Other: SlateColor) -> bool: ...

	@staticmethod
	def UseForeground() -> SlateColor: ...

	@staticmethod
	def UseSubduedForeground() -> SlateColor: ...

	pass

class SlateBrush(object):
	"""An brush which contains information about how to draw a Slate element
 //, meta = (HasNativeMake = ''))"""

	@property
	def ImageSize(self) -> Vector2D: ...
	"""Size of the resource in Slate Units"""

	@property
	def Margin(self) -> Margin: ...
	"""The margin to use in Box and Border modes"""

	@property
	def TintColor(self) -> SlateColor: ...
	"""Tinting applied to the image."""

	@property
	def DrawAs(self) -> int: ...
	"""How to draw the image"""

	@property
	def Tiling(self) -> int: ...
	"""How to tile the image in Image mode"""

	@property
	def Mirroring(self) -> int: ...
	"""How to mirror the image in Image mode.  This is normally only used for dynamic image brushes where the source texture
          comes from a hardware device such as a web camera."""

	@property
	def ImageType(self) -> int: ...
	"""The type of image"""

	pass

class SlateWidgetStyle(object):
	"""Base structure for widget styles."""

	pass

class CheckBoxStyle(SlateWidgetStyle):
	"""Represents the appearance of an SCheckBox"""

	@property
	def CheckBoxType(self) -> int: ...
	"""The visual type of the checkbox"""

	@property
	def UncheckedImage(self) -> SlateBrush: ...
	"""CheckBox appearance when the CheckBox is unchecked (normal)"""

	@property
	def UncheckedHoveredImage(self) -> SlateBrush: ...
	"""CheckBox appearance when the CheckBox is unchecked and hovered"""

	@property
	def UncheckedPressedImage(self) -> SlateBrush: ...
	"""CheckBox appearance when the CheckBox is unchecked and hovered"""

	@property
	def CheckedImage(self) -> SlateBrush: ...
	"""CheckBox appearance when the CheckBox is checked"""

	@property
	def CheckedHoveredImage(self) -> SlateBrush: ...
	"""CheckBox appearance when checked and hovered"""

	@property
	def CheckedPressedImage(self) -> SlateBrush: ...
	"""CheckBox appearance when checked and pressed"""

	@property
	def UndeterminedImage(self) -> SlateBrush: ...
	"""CheckBox appearance when the CheckBox is undetermined"""

	@property
	def UndeterminedHoveredImage(self) -> SlateBrush: ...
	"""CheckBox appearance when CheckBox is undetermined and hovered"""

	@property
	def UndeterminedPressedImage(self) -> SlateBrush: ...
	"""CheckBox appearance when CheckBox is undetermined and pressed"""

	@property
	def Padding(self) -> Margin: ...
	"""Padding"""

	@property
	def ForegroundColor(self) -> SlateColor: ...
	"""The foreground color"""

	@property
	def BorderBackgroundColor(self) -> SlateColor: ...
	"""BorderBackgroundColor refers to the actual color and opacity of the supplied border image on toggle buttons"""

	@property
	def CheckedSlateSound(self) -> SlateSound: ...
	"""The sound the check box should play when checked"""

	@property
	def UncheckedSlateSound(self) -> SlateSound: ...
	"""The sound the check box should play when unchecked"""

	@property
	def HoveredSlateSound(self) -> SlateSound: ...
	"""The sound the check box should play when initially hovered over"""

	pass

class TextBlockStyle(SlateWidgetStyle):
	"""Represents the appearance of an STextBlock"""

	@property
	def Font(self) -> SlateFontInfo: ...
	"""Font family and size to be used when displaying this text."""

	@property
	def ColorAndOpacity(self) -> SlateColor: ...
	"""The color and opacity of this text"""

	@property
	def ShadowOffset(self) -> Vector2D: ...
	"""How much should the shadow be offset? An offset of 0 implies no shadow."""

	@property
	def ShadowColorAndOpacity(self) -> LinearColor: ...
	"""The color and opacity of the shadow"""

	@property
	def SelectedBackgroundColor(self) -> SlateColor: ...
	"""The background color of selected text"""

	@property
	def HighlightColor(self) -> LinearColor: ...
	"""The color of highlighted text"""

	@property
	def HighlightShape(self) -> SlateBrush: ...
	"""The shape of highlighted text"""

	@property
	def StrikeBrush(self) -> SlateBrush: ...
	"""The brush used to draw an strike through the text (if any)"""

	@property
	def UnderlineBrush(self) -> SlateBrush: ...
	"""The brush used to draw an underline under the text (if any)"""

	pass

class ButtonStyle(SlateWidgetStyle):
	"""Represents the appearance of an SButton"""

	@property
	def Normal(self) -> SlateBrush: ...
	"""Button appearance when the button is not hovered or pressed"""

	@property
	def Hovered(self) -> SlateBrush: ...
	"""Button appearance when hovered"""

	@property
	def Pressed(self) -> SlateBrush: ...
	"""Button appearance when pressed"""

	@property
	def Disabled(self) -> SlateBrush: ...
	"""Button appearance when disabled, by default this is set to an invalid resource when that is the case default disabled drawing is used."""

	@property
	def NormalPadding(self) -> Margin: ...
	"""Padding that accounts for the border in the button's background image.
When this is applied, the content of the button should appear flush
with the button's border. Use this padding when the button is not pressed."""

	@property
	def PressedPadding(self) -> Margin: ...
	"""Same as NormalPadding but used when the button is pressed. Allows for moving the content to match
any 'movement' in the button's border image."""

	@property
	def PressedSlateSound(self) -> SlateSound: ...
	"""The sound the button should play when pressed"""

	@property
	def HoveredSlateSound(self) -> SlateSound: ...
	"""The sound the button should play when initially hovered over"""

	pass

class ComboButtonStyle(SlateWidgetStyle):
	"""Represents the appearance of an SComboButton"""

	@property
	def ButtonStyle(self) -> ButtonStyle: ...
	"""The style to use for our SButton."""

	@property
	def DownArrowImage(self) -> SlateBrush: ...
	"""Image to use for the down arrow."""

	@property
	def ShadowOffset(self) -> Vector2D: ...
	"""How much should the shadow be offset for the down arrow?
An offset of 0 implies no shadow."""

	@property
	def ShadowColorAndOpacity(self) -> LinearColor: ...
	"""The color and opacity of the shadow for the down arrow.
Only active if ShadowOffset is not (0,0)."""

	@property
	def MenuBorderBrush(self) -> SlateBrush: ...
	"""Brush to use to add a 'menu border' around the drop-down content."""

	@property
	def MenuBorderPadding(self) -> Margin: ...
	"""Padding to use to add a 'menu border' around the drop-down content."""

	pass

class ComboBoxStyle(SlateWidgetStyle):
	"""Represents the appearance of an SComboBox"""

	@property
	def ComboButtonStyle(self) -> ComboButtonStyle: ...
	"""The style to use for our SComboButton"""

	@property
	def PressedSlateSound(self) -> SlateSound: ...
	"""The sound the button should play when pressed"""

	@property
	def SelectionChangeSlateSound(self) -> SlateSound: ...
	"""The Sound to play when the selection is changed"""

	pass

class HyperlinkStyle(SlateWidgetStyle):
	"""Represents the appearance of an SHyperlink"""

	@property
	def UnderlineStyle(self) -> ButtonStyle: ...
	"""Underline style"""

	@property
	def TextStyle(self) -> TextBlockStyle: ...
	"""Text style"""

	@property
	def Padding(self) -> Margin: ...
	"""Padding"""

	pass

class EditableTextStyle(SlateWidgetStyle):
	"""Represents the appearance of an SEditableText"""

	@property
	def Font(self) -> SlateFontInfo: ...
	"""Font family and size to be used when displaying this text."""

	@property
	def ColorAndOpacity(self) -> SlateColor: ...
	"""The color and opacity of this text"""

	@property
	def BackgroundImageSelected(self) -> SlateBrush: ...
	"""Background image for the selected text"""

	@property
	def BackgroundImageComposing(self) -> SlateBrush: ...
	"""Background image for the selected text"""

	@property
	def CaretImage(self) -> SlateBrush: ...
	"""Image brush used for the caret"""

	pass

class ScrollBarStyle(SlateWidgetStyle):
	"""Represents the appearance of an SScrollBar"""

	@property
	def HorizontalBackgroundImage(self) -> SlateBrush: ...
	"""Background image to use when the scrollbar is oriented horizontally"""

	@property
	def VerticalBackgroundImage(self) -> SlateBrush: ...
	"""Background image to use when the scrollbar is oriented vertically"""

	@property
	def VerticalTopSlotImage(self) -> SlateBrush: ...
	"""The image to use to represent the track above the thumb when the scrollbar is oriented vertically"""

	@property
	def HorizontalTopSlotImage(self) -> SlateBrush: ...
	"""The image to use to represent the track above the thumb when the scrollbar is oriented horizontally"""

	@property
	def VerticalBottomSlotImage(self) -> SlateBrush: ...
	"""The image to use to represent the track below the thumb when the scrollbar is oriented vertically"""

	@property
	def HorizontalBottomSlotImage(self) -> SlateBrush: ...
	"""The image to use to represent the track below the thumb when the scrollbar is oriented horizontally"""

	@property
	def NormalThumbImage(self) -> SlateBrush: ...
	"""Image to use when the scrollbar thumb is in its normal state"""

	@property
	def HoveredThumbImage(self) -> SlateBrush: ...
	"""Image to use when the scrollbar thumb is in its hovered state"""

	@property
	def DraggedThumbImage(self) -> SlateBrush: ...
	"""Image to use when the scrollbar thumb is in its dragged state"""

	pass

class EditableTextBoxStyle(SlateWidgetStyle):
	"""Represents the appearance of an SEditableTextBox"""

	@property
	def BackgroundImageNormal(self) -> SlateBrush: ...
	"""Border background image when the box is not hovered or focused"""

	@property
	def BackgroundImageHovered(self) -> SlateBrush: ...
	"""Border background image when the box is hovered"""

	@property
	def BackgroundImageFocused(self) -> SlateBrush: ...
	"""Border background image when the box is focused"""

	@property
	def BackgroundImageReadOnly(self) -> SlateBrush: ...
	"""Border background image when the box is read-only"""

	@property
	def Padding(self) -> Margin: ...
	"""Padding"""

	@property
	def Font(self) -> SlateFontInfo: ...
	"""Font family and size to be used when displaying this text."""

	@property
	def ForegroundColor(self) -> SlateColor: ...
	"""The foreground color of text."""

	@property
	def BackgroundColor(self) -> SlateColor: ...
	"""The background color applied to the active background image"""

	@property
	def ReadOnlyForegroundColor(self) -> SlateColor: ...
	"""The read-only foreground color of text in read-only mode."""

	@property
	def HScrollBarPadding(self) -> Margin: ...
	"""Padding around the horizontal scrollbar"""

	@property
	def VScrollBarPadding(self) -> Margin: ...
	"""Padding around the vertical scrollbar"""

	@property
	def ScrollBarStyle(self) -> ScrollBarStyle: ...
	"""Style used for the scrollbars"""

	pass

class InlineEditableTextBlockStyle(SlateWidgetStyle):
	"""Represents the appearance of an SInlineEditableTextBlock"""

	@property
	def EditableTextBoxStyle(self) -> EditableTextBoxStyle: ...
	"""The style of the editable text box, which dictates the font, color, and shadow options."""

	@property
	def TextStyle(self) -> TextBlockStyle: ...
	"""The style of the text block, which dictates the font, color, and shadow options. Style overrides all other properties!"""

	pass

class ProgressBarStyle(SlateWidgetStyle):
	"""Represents the appearance of an SProgressBar"""

	@property
	def BackgroundImage(self) -> SlateBrush: ...
	"""Background image to use for the progress bar"""

	@property
	def FillImage(self) -> SlateBrush: ...
	"""Foreground image to use for the progress bar"""

	@property
	def MarqueeImage(self) -> SlateBrush: ...
	"""Image to use for marquee mode"""

	pass

class SliderStyle(SlateWidgetStyle):
	"""Represents the appearance of an SSlider"""

	@property
	def NormalBarImage(self) -> SlateBrush: ...
	"""Image to use when the slider bar is in its normal state"""

	@property
	def HoveredBarImage(self) -> SlateBrush: ...
	"""Image to use when the slider bar is in its hovered state"""

	@property
	def DisabledBarImage(self) -> SlateBrush: ...
	"""Image to use when the slider bar is in its disabled state"""

	@property
	def NormalThumbImage(self) -> SlateBrush: ...
	"""Image to use when the slider thumb is in its normal state"""

	@property
	def HoveredThumbImage(self) -> SlateBrush: ...
	"""Image to use when the slider thumb is in its hovered state"""

	@property
	def DisabledThumbImage(self) -> SlateBrush: ...
	"""Image to use when the slider thumb is in its disabled state"""

	@property
	def BarThickness(self) -> float: ...
	"""Bar Thickness"""

	pass

class SpinBoxStyle(SlateWidgetStyle):
	"""Represents the appearance of an SSpinBox"""

	@property
	def BackgroundBrush(self) -> SlateBrush: ...
	"""Brush used to draw the background of the spinbox"""

	@property
	def HoveredBackgroundBrush(self) -> SlateBrush: ...
	"""Brush used to draw the background of the spinbox when it's hovered over"""

	@property
	def ActiveFillBrush(self) -> SlateBrush: ...
	"""Brush used to fill the spinbox when it's active"""

	@property
	def InactiveFillBrush(self) -> SlateBrush: ...
	"""Brush used to fill the spinbox when it's inactive"""

	@property
	def ArrowsImage(self) -> SlateBrush: ...
	"""Image used to draw the spinbox arrows"""

	@property
	def ForegroundColor(self) -> SlateColor: ...
	"""Color used to draw the spinbox foreground elements"""

	@property
	def TextPadding(self) -> Margin: ...
	"""Padding to add around the spinbox and its text"""

	pass

class SplitterStyle(SlateWidgetStyle):
	"""Represents the appearance of an SSplitter"""

	@property
	def HandleNormalBrush(self) -> SlateBrush: ...
	"""Brush used to draw the handle in its normal state"""

	@property
	def HandleHighlightBrush(self) -> SlateBrush: ...
	"""Brush used to draw the handle in its highlight state"""

	pass

class TableRowStyle(SlateWidgetStyle):
	"""Represents the appearance of an STableRow"""

	@property
	def SelectorFocusedBrush(self) -> SlateBrush: ...
	"""Brush used as a selector when a row is focused"""

	@property
	def ActiveHoveredBrush(self) -> SlateBrush: ...
	"""Brush used when a selected row is active and hovered"""

	@property
	def ActiveBrush(self) -> SlateBrush: ...
	"""Brush used when a selected row is active"""

	@property
	def InactiveHoveredBrush(self) -> SlateBrush: ...
	"""Brush used when a selected row is inactive and hovered"""

	@property
	def InactiveBrush(self) -> SlateBrush: ...
	"""Brush used when a selected row is inactive"""

	@property
	def EvenRowBackgroundHoveredBrush(self) -> SlateBrush: ...
	"""Brush used when an even row is hovered"""

	@property
	def EvenRowBackgroundBrush(self) -> SlateBrush: ...
	"""Brush used when an even row is in its normal state"""

	@property
	def OddRowBackgroundHoveredBrush(self) -> SlateBrush: ...
	"""Brush used when an odd row is hovered"""

	@property
	def OddRowBackgroundBrush(self) -> SlateBrush: ...
	"""Brush to used when an odd row is in its normal state"""

	@property
	def TextColor(self) -> SlateColor: ...
	"""Text color used for all rows"""

	@property
	def SelectedTextColor(self) -> SlateColor: ...
	"""Text color used for the selected row"""

	@property
	def DropIndicator_Above(self) -> SlateBrush: ...
	"""Brush used to provide feedback that a user can drop above the hovered row."""

	@property
	def DropIndicator_Onto(self) -> SlateBrush: ...
	"""Brush used to provide feedback that a user can drop onto the hovered row."""

	@property
	def DropIndicator_Below(self) -> SlateBrush: ...
	"""Brush used to provide feedback that a user can drop below the hovered row."""

	@property
	def ActiveHighlightedBrush(self) -> SlateBrush: ...
	"""Brush used when a highlighted row is active"""

	@property
	def InactiveHighlightedBrush(self) -> SlateBrush: ...
	"""Brush used when a highlighted row is inactive and hovered"""

	pass

class ScrollBoxStyle(SlateWidgetStyle):
	"""Represents the appearance of an SScrollBox"""

	@property
	def TopShadowBrush(self) -> SlateBrush: ...
	"""Brush used to draw the top shadow of a scrollbox"""

	@property
	def BottomShadowBrush(self) -> SlateBrush: ...
	"""Brush used to draw the bottom shadow of a scrollbox"""

	@property
	def LeftShadowBrush(self) -> SlateBrush: ...
	"""Brush used to draw the left shadow of a scrollbox"""

	@property
	def RightShadowBrush(self) -> SlateBrush: ...
	"""Brush used to draw the right shadow of a scrollbox"""

	pass

class ScrollBorderStyle(SlateWidgetStyle):
	"""Represents the appearance of an FScrollBorderStyle"""

	@property
	def TopShadowBrush(self) -> SlateBrush: ...
	"""Brush used to draw the top shadow of a scrollborder"""

	@property
	def BottomShadowBrush(self) -> SlateBrush: ...
	"""Brush used to draw the bottom shadow of a scrollborder"""

	pass

class WindowStyle(SlateWidgetStyle):
	"""Represents the appearance of an SWindow"""

	@property
	def MinimizeButtonStyle(self) -> ButtonStyle: ...
	"""Style used to draw the window minimize button"""

	@property
	def MaximizeButtonStyle(self) -> ButtonStyle: ...
	"""Style used to draw the window maximize button"""

	@property
	def RestoreButtonStyle(self) -> ButtonStyle: ...
	"""Style used to draw the window restore button"""

	@property
	def CloseButtonStyle(self) -> ButtonStyle: ...
	"""Style used to draw the window close button"""

	@property
	def TitleTextStyle(self) -> TextBlockStyle: ...
	"""Style used to draw the window title text"""

	@property
	def ActiveTitleBrush(self) -> SlateBrush: ...
	"""Brush used to draw the window title area when the window is active"""

	@property
	def InactiveTitleBrush(self) -> SlateBrush: ...
	"""Brush used to draw the window title area when the window is inactive"""

	@property
	def FlashTitleBrush(self) -> SlateBrush: ...
	"""Brush used to draw the window title area when the window is flashing"""

	@property
	def BackgroundColor(self) -> SlateColor: ...
	"""Color used to draw the window background"""

	@property
	def OutlineBrush(self) -> SlateBrush: ...
	"""Brush used to draw the window outline"""

	@property
	def OutlineColor(self) -> SlateColor: ...
	"""Color used to draw the window outline"""

	@property
	def BorderBrush(self) -> SlateBrush: ...
	"""Brush used to draw the window border"""

	@property
	def BackgroundBrush(self) -> SlateBrush: ...
	"""Brush used to draw the window background"""

	@property
	def ChildBackgroundBrush(self) -> SlateBrush: ...
	"""Brush used to draw the background of child windows"""

	pass

class SlateWidgetStyleContainerBase(Object):
	"""Just a wrapper for the struct with real data in it."""

	pass

class InputChord(object):
	"""An Input Chord is a key and the modifier keys that are to be held with it."""

	@property
	def Key(self) -> Key: ...
	"""The Key is the core of the chord."""

	@property
	def bShift(self) -> bool: ...
	"""Whether the shift key is part of the chord."""

	@property
	def bCtrl(self) -> bool: ...
	"""Whether the control key is part of the chord."""

	@property
	def bAlt(self) -> bool: ...
	"""Whether the alt key is part of the chord."""

	@property
	def bCmd(self) -> bool: ...
	"""Whether the command key is part of the chord."""

	pass

class Anchors(object):
	"""Describes how a widget is anchored."""

	@property
	def Minimum(self) -> Vector2D: ...
	"""Holds the minimum anchors, left + top."""

	@property
	def Maximum(self) -> Vector2D: ...
	"""Holds the maximum anchors, right + bottom."""

	pass

class ButtonWidgetStyle(SlateWidgetStyleContainerBase):
	"""Button Widget Style"""

	@property
	def ButtonStyle(self) -> ButtonStyle: ...
	"""The actual data describing the button's appearance."""

	pass

class ProgressWidgetStyle(SlateWidgetStyleContainerBase):
	"""Progress Widget Style"""

	@property
	def ProgressBarStyle(self) -> ProgressBarStyle: ...
	"""The actual data describing the button's appearance."""

	pass

class ToolMenuBase(Object):
	"""Tool Menu Base"""

	pass

class ESlateDebuggingInputEvent(Enum):
	"""ESlate Debugging Input Event"""

	# 
	MouseMove = 0
	# 
	MouseEnter = 1
	# 
	MouseLeave = 2
	# 
	PreviewMouseButtonDown = 3
	# 
	MouseButtonDown = 4
	# 
	MouseButtonUp = 5
	# 
	MouseButtonDoubleClick = 6
	# 
	MouseWheel = 7
	# 
	TouchStart = 8
	# 
	TouchEnd = 9
	# 
	TouchForceChanged = 10
	# 
	TouchFirstMove = 11
	# 
	TouchMoved = 12
	# 
	DragDetected = 13
	# 
	DragEnter = 14
	# 
	DragLeave = 15
	# 
	DragOver = 16
	# 
	DragDrop = 17
	# 
	DropMessage = 18
	# 
	PreviewKeyDown = 19
	# 
	KeyDown = 20
	# 
	KeyUp = 21
	# 
	KeyChar = 22
	# 
	AnalogInput = 23
	# 
	TouchGesture = 24
	# 
	MotionDetected = 25
	# 
	MAX = 26

class ESlateDebuggingStateChangeEvent(Enum):
	"""ESlate Debugging State Change Event"""

	# 
	MouseCaptureGained = 0
	# 
	MouseCaptureLost = 1

class ESlateDebuggingNavigationMethod(Enum):
	"""ESlate Debugging Navigation Method"""

	# 
	Unknown = 0
	# 
	Explicit = 1
	# 
	CustomDelegateBound = 2
	# 
	CustomDelegateUnbound = 3
	# 
	NextOrPrevious = 4
	# 
	HitTestGrid = 5

class ESlateDebuggingFocusEvent(Enum):
	"""ESlate Debugging Focus Event"""

	# 
	FocusChanging = 0
	# 
	FocusLost = 1
	# 
	FocusReceived = 2
	# 
	MAX = 3

class EFontHinting(Enum):
	"""EFont Hinting"""

	# Use the default hinting specified in the font.
	Default = 0
	# Force the use of an automatic hinting algorithm.
	Auto = 1
	# Force the use of an automatic light hinting algorithm, optimized for non-monochrome displays.
	AutoLight = 2
	# Force the use of an automatic hinting algorithm optimized for monochrome displays.
	Monochrome = 3
	# Do not use hinting.
	None = 4

class EFontLoadingPolicy(Enum):
	"""EFont Loading Policy"""

	# Lazy load the entire font into memory. This will consume more memory than Streaming, however there will be zero file-IO when rendering glyphs within the font, although the initial load may cause a hitch.
	LazyLoad = 0
	# Stream the font from disk. This will consume less memory than LazyLoad or Inline, however there will be file-IO when rendering glyphs, which may cause hitches under certain circumstances or on certain platforms.
	Stream = 1
	# Embed the font data within the asset. This will consume more memory than Streaming, however it is guaranteed to be hitch free (only valid for font data within a Font Face asset).
	Inline = 2

class EFontLayoutMethod(Enum):
	"""EFont Layout Method"""

	# Layout the font using the metrics data available in the font. This is typically the desired option, however some fonts have broken or incorrect metrics so may yield better results when using the bounding box values to layout the font.
	Metrics = 0
	# Layout the font using the values from its bounding box. This typically yields a larger line height for fonts that have valid metrics, however it can also produce much better results for fonts that have broken or incorrect metrics.
	BoundingBox = 1

class ETextShapingMethod(Enum):
	"""Methods that can be used to shape text.
@note If you change this enum, make sure and update CVarDefaultTextShapingMethod and GetDefaultTextShapingMethod."""

	# Automatically picks the fastest possible shaping method (either KerningOnly or FullShaping) based on the reading direction of the text.
	# Left-to-right text uses the KerningOnly method, and right-to-left text uses the FullShaping method.
	Auto = 0
	# Provides fake shaping using only kerning data.
	# This can be faster than full shaping, but won't render complex right-to-left or bi-directional glyphs (such as Arabic) correctly.
	# This can be useful as an optimization when you know your text block will only show simple glyphs (such as numbers).
	KerningOnly = 1
	# Provides full text shaping, allowing accurate rendering of complex right-to-left or bi-directional glyphs (such as Arabic).
	# This mode will perform ligature replacement for all languages (such as the combined 'fi' glyph in English).
	FullShaping = 2

class EButtonClickMethod(Enum):
	"""Enumerates different methods that a button click can be triggered. Normally, DownAndUp is appropriate."""

	# User must press the button, then release while over the button to trigger the click.
	# This is the most common type of button.
	DownAndUp = 0
	# Click will be triggered immediately on mouse down, and mouse will not be captured.
	MouseDown = 1
	# Click will always be triggered when mouse button is released over the button,
	# even if the button wasn't pressed down over it.
	MouseUp = 2
	# Inside a list, buttons can only be clicked with precise tap.
	# Moving the pointer will scroll the list, also allows drag-droppable buttons.
	PreciseClick = 3

class EButtonTouchMethod(Enum):
	"""Ways in which touch interactions trigger a 'Clicked' event."""

	# Most buttons behave this way.
	DownAndUp = 0
	# Click will be triggered immediately on touch down, and touch will not be captured.
	Down = 1
	# Inside a list, buttons can only be clicked with precise tap.
	# Moving the pointer will scroll the list.
	PreciseTap = 2

class EButtonPressMethod(Enum):
	"""Enumerates different methods that a button can be triggered with keyboard/controller. Normally, DownAndUp is appropriate."""

	# User must press the button, then release while the button has focus to trigger the click.
	# This is the most common type of button.
	DownAndUp = 0
	# Click will be triggered immediately on button press.
	ButtonPress = 1
	# Click will always be triggered when a button release occurs on the focused button,
	# even if the button wasn't pressed while focused.
	ButtonRelease = 2

class EUINavigation(Enum):
	"""Navigation context for event"""

	# Four cardinal directions
	Left = 0
	# 
	Right = 1
	# 
	Up = 2
	# 
	Down = 3
	# Conceptual next and previous
	Next = 4
	# 
	Previous = 5
	# Number of navigation types
	Num = 6
	# Denotes an invalid navigation, more important used to denote no specified navigation
	Invalid = 7

class EUINavigationAction(Enum):
	"""Generic UI navigation action that are usually bound to a gamepad or other input device"""

	# Accept, normally acts like a mouse click. Corresponds to Virtual_Accept key
	Accept = 0
	# Back/Cancel, normally acts like escape. Corresponds to Virtual_Back key
	Back = 1
	# Number of navigation actions
	Num = 2
	# Invalid action
	Invalid = 3

class ENavigationSource(Enum):
	"""Enumerates the source of the navigation"""

	# Navigate from the focused widget
	FocusedWidget = 0
	# Navigate from the widget under the cursor
	WidgetUnderCursor = 1

class ENavigationGenesis(Enum):
	"""Enumerates the genesis of the navigation, where generated the navigation"""

	# Navigation caused by the Keyboard
	Keyboard = 0
	# Navigation caused by a Controller
	Controller = 1
	# Navigate caused by a user generated event (Users = WIdgets, Client Code, ...)
	User = 2

class EHorizontalAlignment(Enum):
	"""Enumerates horizontal alignment options, i.e. for widget slots."""

	# Fill the entire width.
	HAlign_Fill = 0
	# Left-align.
	HAlign_Left = 1
	# Center-align.
	HAlign_Center = 2
	# Right-align.
	HAlign_Right = 3

class EVerticalAlignment(Enum):
	"""Enumerates vertical alignment options, i.e. for widget slots."""

	# Fill the entire height.
	VAlign_Fill = 0
	# Top-align.
	VAlign_Top = 1
	# Center-align.
	VAlign_Center = 2
	# Bottom-align.
	VAlign_Bottom = 3

class EMenuPlacement(Enum):
	"""Enumerates possible placements for pop-up menus."""

	# Place the menu immediately below the anchor
	MenuPlacement_BelowAnchor = 0
	# Place the menu immediately centered below the anchor
	MenuPlacement_CenteredBelowAnchor = 1
	# Place the menu immediately below the anchor aligned to the right of the content
	MenuPlacement_BelowRightAnchor = 2
	# Place the menu immediately below the anchor and match is width to the anchor's content
	MenuPlacement_ComboBox = 3
	# Place the menu immediately below the anchor and match is width to the anchor's content. If the width overflows, align with the right edge of the anchor.
	MenuPlacement_ComboBoxRight = 4
	# Place the menu to the right of the anchor
	MenuPlacement_MenuRight = 5
	# Place the menu immediately above the anchor, no transition effect
	MenuPlacement_AboveAnchor = 6
	# Place the menu immediately centered above the anchor, no transition effect
	MenuPlacement_CenteredAboveAnchor = 7
	# Place the menu immediately above the anchor aligned to the right of the content
	MenuPlacement_AboveRightAnchor = 8
	# Place the menu to the left of the anchor
	MenuPlacement_MenuLeft = 9
	# Place the menu's center on top of the menu anchor's center point
	MenuPlacement_Center = 10
	# Place the menu's vertical center on the left side at the menu anchor's vertical center on the right side
	MenuPlacement_RightLeftCenter = 11
	# Place the menu's bottom left corner directly on top of the menu anchor's bottom left corner
	MenuPlacement_MatchBottomLeft = 12

class EOrientation(Enum):
	"""Enumerates widget orientations."""

	# Orient horizontally, i.e. left to right.
	Orient_Horizontal = 0
	# Orient vertically, i.e. top to bottom.
	Orient_Vertical = 1

class EScrollDirection(Enum):
	"""Enumerates scroll directions."""

	# Scroll down.
	Scroll_Down = 0
	# Scroll up.
	Scroll_Up = 1

class ETextCommit(Enum):
	"""Additional information about a text committal"""

	# Losing focus or similar event caused implicit commit
	Default = 0
	# User committed via the enter key
	OnEnter = 1
	# User committed via tabbing away or moving focus explicitly away
	OnUserMovedFocus = 2
	# Keyboard focus was explicitly cleared via the escape key or other similar action
	OnCleared = 3

class ESelectInfo(Enum):
	"""Additional information about a selection event"""

	# User selected via a key press
	OnKeyPress = 0
	# User selected by navigating to the item
	OnNavigation = 1
	# User selected by clicking on the item
	OnMouseClick = 2
	# Selection was directly set in code
	Direct = 3

class EFocusCause(Enum):
	"""Context for focus change"""

	# Focus was changed because of a mouse action.
	Mouse = 0
	# Focus was changed in response to a navigation, such as the arrow keys, TAB key, controller DPad, ...
	Navigation = 1
	# Focus was changed because someone asked the application to change it.
	SetDirectly = 2
	# Focus was explicitly cleared via the escape key or other similar action.
	Cleared = 3
	# Focus was changed because another widget lost focus, and focus moved to a new widget.
	OtherWidgetLostFocus = 4
	# Focus was set in response to the owning window being activated.
	WindowActivate = 5

class EUINavigationRule(Enum):
	"""EUINavigation Rule"""

	# Allow the movement to continue in that direction, seeking the next navigable widget automatically.
	Escape = 0
	# Move to a specific widget.
	Explicit = 1
	# Wrap movement inside this container, causing the movement to cycle around from the opposite side,
	# if the navigation attempt would have escaped.
	Wrap = 2
	# Stops movement in this direction
	Stop = 3
	# Custom navigation handled by user code.
	Custom = 4
	# Custom navigation handled by user code if the boundary is hit.
	CustomBoundary = 5
	# Invalid Rule
	Invalid = 6

class EColorVisionDeficiency(Enum):
	"""Enumerates color vision deficiency types."""

	# 
	NormalVision = 0
	# 
	Deuteranope = 1
	# 
	Protanope = 2
	# 
	Tritanope = 3

class EWidgetClipping(Enum):
	"""This enum controls clipping of widgets in Slate.  By default all SWidgets do not need to clip their children.
Most of the time, you don't need to clip, the only times it becomes important is when something might become hidden
due to panning.  You should use this wisely, as Slate can not batch across clipping areas, so if widget A and widget B
are set to EWidgetClipping::Yes, no drawing that happens inside their widget trees will ever be batch together, adding
additional GPU overhead."""

	# This widget does not clip children, it and all children inherit the clipping area of the last widget that clipped.
	Inherit = 0
	# This widget clips content the bounds of this widget.  It intersects those bounds with any previous clipping area.
	ClipToBounds = 1
	# This widget clips to its bounds.  It does NOT intersect with any existing clipping geometry, it pushes a new clipping
	# state.  Effectively allowing it to render outside the bounds of hierarchy that does clip.
	# 
	# NOTE: This will NOT allow you ignore the clipping zone that is set to [Yes - Always].
	ClipToBoundsWithoutIntersecting = 2
	# This widget clips to its bounds.  It intersects those bounds with any previous clipping area.
	# 
	# NOTE: This clipping area can NOT be ignored, it will always clip children.  Useful for hard barriers
	# in the UI where you never want animations or other effects to break this region.
	ClipToBoundsAlways = 3
	# This widget clips to its bounds when it's Desired Size is larger than the allocated geometry
	# the widget is given.  If that occurs, it work like [Yes].
	# 
	# NOTE: This mode was primarily added for Text, which is often placed into containers that eventually
	# are resized to not be able to support the length of the text.  So rather than needing to tag every
	# container that could contain text with [Yes], which would result in almost no batching, this mode
	# was added to dynamically adjust the clipping if needed.  The reason not every panel is set to OnDemand,
	# is because not every panel returns a Desired Size that matches what it plans to render at.
	OnDemand = 4

class EFlowDirectionPreference(Enum):
	"""EFlow Direction Preference"""

	# Inherits the flow direction set by the parent widget.
	Inherit = 0
	# Begins laying out widgets using the current cultures layout direction preference, flipping the directionality of flows.
	Culture = 1
	# Forces a Left to Right layout flow.
	LeftToRight = 2
	# Forces a Right to Left layout flow.
	RightToLeft = 3

class ESlateColorStylingMode(Enum):
	"""Enumerates types of color values that can be held by Slate color.

Should we use the specified color? If not, then which color from the style should we use."""

	# Color value is stored in this Slate color.
	UseColor_Specified = 0
	# Color value is stored in the linked color.
	UseColor_Specified_Link = 1
	# Use the widget's foreground color.
	UseColor_Foreground = 2
	# Use the widget's subdued color.
	UseColor_Foreground_Subdued = 3

class ESlateBrushDrawType(Enum):
	"""Enumerates ways in which an image can be drawn."""

	# Don't do anything
	NoDrawType = 0
	# Draw a 3x3 box, where the sides and the middle stretch based on the Margin
	Box = 1
	# Draw a 3x3 border where the sides tile and the middle is empty
	Border = 2
	# Draw an image; margin is ignored
	Image = 3

class ESlateBrushTileType(Enum):
	"""Enumerates tiling options for image drawing."""

	# Just stretch
	NoTile = 0
	# Tile the image horizontally
	Horizontal = 1
	# Tile the image vertically
	Vertical = 2
	# Tile in both directions
	Both = 3

class ESlateBrushMirrorType(Enum):
	"""Possible options for mirroring the brush image"""

	# Don't mirror anything, just draw the texture as it is.
	NoMirror = 0
	# Mirror the image horizontally.
	Horizontal = 1
	# Mirror the image vertically.
	Vertical = 2
	# Mirror in both directions.
	Both = 3

class ESlateBrushImageType(Enum):
	"""Enumerates brush image types."""

	# No image is loaded.  Color only brushes, transparent brushes etc.
	NoImage = 0
	# The image to be loaded is in full color.
	FullColor = 1
	# The image is a special texture in linear space (usually a rendering resource such as a lookup table).
	Linear = 2

class EConsumeMouseWheel(Enum):
	"""Used to determine how we should handle mouse wheel input events when someone scrolls."""

	# Only consume the mouse wheel event when we actually scroll some amount.
	WhenScrollingPossible = 0
	# Always consume mouse wheel event even if we don't scroll at all.
	Always = 1
	# Never consume the mouse wheel
	Never = 2

class ESlateParentWindowSearchMethod(Enum):
	"""Used to determine which search method we should use when finding a suitable parent window"""

	# Favor using the active window (will fallback to the main window if the active window is unsuitable)
	ActiveWindow = 0
	# Favor using the main window
	MainWindow = 1

class ESlateCheckBoxType(Enum):
	"""Type of check box"""

	# Traditional check box with check button and label (or other content)
	CheckBox = 0
	# Toggle button.  You provide button content (such as an image), and the user can press to toggle it.
	ToggleButton = 1

class ECheckBoxState(Enum):
	"""Current state of the check box"""

	# Unchecked
	Unchecked = 0
	# Checked
	Checked = 1
	# Neither checked nor unchecked
	Undetermined = 2

class EUserInterfaceActionType(Enum):
	"""Types of user interfaces that can be associated with a user interface action"""

	# An action which should not be associated with a user interface action
	None = 0
	# Momentary buttons or menu items.  These support enable state, and execute a delegate when clicked.
	Button = 1
	# Toggleable buttons or menu items that store on/off state.  These support enable state, and execute a delegate when toggled.
	ToggleButton = 2
	# Radio buttons are similar to toggle buttons in that they are for menu items that store on/off state.  However they should be used to indicate that menu items in a group can only be in one state
	RadioButton = 3
	# Similar to Button but will display a readonly checkbox next to the item.
	Check = 4
	# Similar to Button but has the checkbox area collapsed
	CollapsedButton = 5

class EMultipleKeyBindingIndex(Enum):
	"""EMultiple Key Binding Index"""

	# 
	Primary = 0
	# 
	Secondary = 1
	# 
	NumChords = 2

class EMultiBoxType(Enum):
	"""Types of MultiBoxes"""

	# Horizontal menu bar
	MenuBar = 0
	# Horizontal tool bar
	ToolBar = 1
	# Vertical tool bar
	VerticalToolBar = 2
	# A toolbar that tries to arrange all toolbar items uniformly (supports only horizontal toolbars for now)
	UniformToolBar = 3
	# Vertical menu (pull-down menu, or context menu)
	Menu = 4
	# Buttons arranged in rows, with a maximum number of buttons per row, like a toolbar but can have multiple rows
	ButtonRow = 5

class EMultiBlockType(Enum):
	"""Types of MultiBlocks"""

	# 
	None = 0
	# 
	ButtonRow = 1
	# 
	EditableText = 2
	# 
	Heading = 3
	# 
	MenuEntry = 4
	# 
	Separator = 5
	# 
	ToolBarButton = 6
	# 
	ToolBarComboButton = 7
	# 
	Widget = 8

class ECustomizedToolMenuVisibility(Enum):
	"""ECustomized Tool Menu Visibility"""

	# 
	None = 0
	# 
	Visible = 1
	# 
	Hidden = 2

class ETextJustify(Enum):
	"""EText Justify"""

	# Justify the text logically to the left.
	# When text is flowing left-to-right, this will align text visually to the left.
	# When text is flowing right-to-left, this will align text visually to the right.
	Left = 0
	# Justify the text in the center.
	# Text flow direction has no impact on this justification mode.
	Center = 1
	# Justify the text logically to the right.
	# When text is flowing left-to-right, this will align text visually to the right.
	# When text is flowing right-to-left, this will align text visually to the left.
	Right = 2

class ETextTransformPolicy(Enum):
	"""The different methods that can be used if a word is too long to be broken by the default line-break iterator."""

	# No transform, just use the given text as-is
	None = 0
	# Convert the text to lowercase for display
	ToLower = 1
	# Convert the text to uppercase for display
	ToUpper = 2

class ETextWrappingPolicy(Enum):
	"""The different methods that can be used if a word is too long to be broken by the default line-break iterator."""

	# No fallback, just use the given line-break iterator
	DefaultWrapping = 0
	# Fallback to per-character wrapping if a word is too long
	AllowPerCharacterWrapping = 1

class ETextFlowDirection(Enum):
	"""The different directions that text can flow within a paragraph of text.
@note If you change this enum, make sure and update CVarDefaultTextFlowDirection and GetDefaultTextFlowDirection."""

	# Automatically detect the flow direction for each paragraph from its text
	Auto = 0
	# Force text to be flowed left-to-right
	LeftToRight = 1
	# Force text to be flowed right-to-left
	RightToLeft = 2

class ESelectionMode(Enum):
	"""ESelection Mode"""

	# Nothing can be selected and there is no hover cue for selection.  You can still handle mouse button events though.
	None = 0
	# A single item can be selected at once, or no item may be selected.
	Single = 1
	# A single item can be selected at once, or no item may be selected.  You can click the item to toggle selection on and off.
	SingleToggle = 2
	# Multiple items can be selected at the same time.
	Multi = 3

class ETableViewMode(Enum):
	"""Lists can exist as regular lists or as backing widgets for a tree."""

	# 
	List = 0
	# 
	Tile = 1
	# 
	Tree = 2

class EStretchDirection(Enum):
	"""EStretch Direction"""

	# Will scale the content up or down.
	Both = 0
	# Will only make the content smaller, will never scale it larger than the content's desired size.
	DownOnly = 1
	# Will only make the content larger, will never scale it smaller than the content's desired size.
	UpOnly = 2

class EStretch(Enum):
	"""EStretch"""

	# Does not scale the content.
	None = 0
	# Scales the content non-uniformly filling the entire space of the area.
	Fill = 1
	# Scales the content uniformly (preserving aspect ratio)
	# until it can no longer scale the content without clipping it.
	ScaleToFit = 2
	# Scales the content uniformly (preserving aspect ratio)
	# until it can no longer scale the content without clipping it along the x-axis,
	# the y-axis can/will be clipped.
	ScaleToFitX = 3
	# Scales the content uniformly (preserving aspect ratio)
	# until it can no longer scale the content without clipping it along the y-axis,
	# the x-axis can/will be clipped.
	ScaleToFitY = 4
	# Scales the content uniformly (preserving aspect ratio), until all sides meet
	# or exceed the size of the area.  Will result in clipping the longer side.
	ScaleToFill = 5
	# Scales the content according to the size of the safe zone currently applied to the viewport.
	ScaleBySafeZone = 6
	# Scales the content by the scale specified by the user.
	UserSpecified = 7

class EDescendantScrollDestination(Enum):
	"""Where to scroll the descendant to"""

	# Scroll the widget into view using the least amount of energy possible.  So if the new item
	# is above the visible set, it will stop as soon as it's in view at the top.  If it's below the
	# visible set, it stop it comes into view at the bottom.
	IntoView = 0
	# Always scroll the widget so it appears at the top/Left of the scrollable area.
	TopOrLeft = 1
	# Always scroll the widget so it appears at the center of the scrollable area, if possible.
	# This won't be possible for the first few items and the last few items, as there's not enough
	# slack.
	Center = 2

class EScrollWhenFocusChanges(Enum):
	"""Set behavior when user focus changes inside this scroll box"""

	# Don't automatically scroll, navigation or child widget will handle this
	NoScroll = 0
	# Instantly scroll using NavigationDestination rule
	InstantScroll = 1
	# Use animation to scroll using NavigationDestination rule
	AnimatedScroll = 2

class EProgressBarFillType(Enum):
	"""SProgressBar Fill Type"""

	# will fill up from the left side to the right
	LeftToRight = 0
	# will fill up from the right side to the left side
	RightToLeft = 1
	# will fill up from the center to the outer edges
	FillFromCenter = 2
	# will fill up from the top to the the bottom
	TopToBottom = 3
	# will fill up from the bottom to the the top
	BottomToTop = 4

class EVirtualKeyboardTrigger(Enum):
	"""EVirtual Keyboard Trigger"""

	# Display the virtual keyboard when the widget gains keyboard focus by a pointer action.
	OnFocusByPointer = 0
	# Display the virtual keyboard when the widget gains keyboard focus by any means.
	OnAllFocusEvents = 1

class EVirtualKeyboardDismissAction(Enum):
	"""EVirtual Keyboard Dismiss Action"""

	# Sends a text changed message when the virtual keyboard is dismissed by the user.
	TextChangeOnDismiss = 0
	# Send a text commit message if the user dismisses the keyboard by accepting text. Send a text changed message if the user cancels the virtual keyboard.
	TextCommitOnAccept = 1
	# Send a text commit message when the virtual keyboard is dismissed by the user.
	TextCommitOnDismiss = 2

class EListItemAlignment(Enum):
	"""If the list panel is arranging items as tiles, this enum dictates how the items should be aligned (basically, where any extra space is placed)"""

	# Items are distributed evenly along the line (any extra space is added as padding between the items)
	EvenlyDistributed = 0
	# Items are distributed evenly along the line (any extra space is used to scale up the size of the item proportionally.)
	EvenlySize = 1
	# Items are distributed evenly along the line, any extra space is used to scale up width of the items proportionally.)
	EvenlyWide = 2
	# Items are left aligned on the line (any extra space is added to the right of the items)
	LeftAligned = 3
	# Items are right aligned on the line (any extra space is added to the left of the items)
	RightAligned = 4
	# Items are center aligned on the line (any extra space is halved and added to the left of the items)
	CenterAligned = 5
	# Items are evenly stretched to distribute any extra space on the line
	Fill = 6

class MovieSceneSectionParameters(object):
	"""Movie Scene Section Parameters"""

	@property
	def StartFrameOffset(self) -> FrameNumber: ...
	"""Number of frames (in display rate) to skip at the beginning of the sub-sequence."""

	@property
	def bCanLoop(self) -> bool: ...
	"""Whether this section supports looping the sub-sequence."""

	@property
	def EndFrameOffset(self) -> FrameNumber: ...
	"""Number of frames (in display rate) to skip at the beginning of the sub-sequence."""

	@property
	def FirstLoopStartFrameOffset(self) -> FrameNumber: ...
	"""Number of frames (in display rate) to offset the first loop of the sub-sequence."""

	@property
	def TimeScale(self) -> float: ...
	"""Playback time scaling factor."""

	@property
	def HierarchicalBias(self) -> int: ...
	"""Hierachical bias. Higher bias will take precedence."""

	pass

class MovieSceneObjectBindingID(object):
	"""Persistent identifier to a specific object binding within a sequence hierarchy."""

	pass

class MovieSceneMarkedFrame(object):
	"""Movie Scene Marked Frame"""

	@property
	def FrameNumber(self) -> FrameNumber: ...
	"""Frame Number"""

	@property
	def Label(self) -> str: ...
	"""Label"""

	pass

class OptionalMovieSceneBlendType(object):
	"""Optional blend type structure"""

	pass

class MovieSceneSequenceLoopCount(object):
	"""POD struct that represents a number of loops where -1 signifies infinite looping, 0 means no loops, etc
Defined as a struct rather than an int so a property type customization can be bound to it"""

	@property
	def Value(self) -> int: ...
	"""Number of times to loop playback. -1 for infinite, else the number of times to loop before stopping"""

	pass

class MovieSceneSequencePlaybackSettings(object):
	"""Settings for the level sequence player actor."""

	@property
	def bAutoPlay(self) -> bool: ...
	"""Auto-play the sequence when created"""

	@property
	def LoopCount(self) -> MovieSceneSequenceLoopCount: ...
	"""Number of times to loop playback. -1 for infinite, else the number of times to loop before stopping"""

	@property
	def PlayRate(self) -> float: ...
	"""The rate at which to playback the animation"""

	@property
	def StartTime(self) -> float: ...
	"""Start playback at the specified offset from the start of the sequence's playback range"""

	@property
	def bRandomStartTime(self) -> bool: ...
	"""Start playback at a random time"""

	@property
	def bRestoreState(self) -> bool: ...
	"""Flag used to specify whether actor states should be restored on stop"""

	@property
	def bDisableMovementInput(self) -> bool: ...
	"""Disable Input from player during play"""

	@property
	def bDisableLookAtInput(self) -> bool: ...
	"""Disable LookAt Input from player during play"""

	@property
	def bHidePlayer(self) -> bool: ...
	"""Hide Player Pawn during play"""

	@property
	def bHideHud(self) -> bool: ...
	"""Hide HUD during play"""

	@property
	def bDisableCameraCuts(self) -> bool: ...
	"""Disable camera cuts"""

	@property
	def bPauseAtEnd(self) -> bool: ...
	"""Pause the sequence when playback reaches the end rather than stopping it"""

	pass

class MovieSceneSequencePlaybackParams(object):
	"""Movie Scene Sequence Playback Params"""

	@property
	def Frame(self) -> typing.Any: ...
	"""Frame"""

	@property
	def Time(self) -> float: ...
	"""Time"""

	@property
	def MarkedFrame(self) -> str: ...
	"""Marked Frame"""

	@property
	def PositionType(self) -> int: ...
	"""Position Type"""

	@property
	def UpdateMethod(self) -> int: ...
	"""Update Method"""

	pass

class MovieSceneBuiltInEasingFunction(Object):
	"""Movie Scene Built in Easing Function"""

	@property
	def Type(self) -> int: ...
	"""Type"""

	pass

class MovieSceneEasingFunction(Interface):
	"""Movie Scene Easing Function"""

	pass

class MovieSceneSignedObject(Object):
	"""Movie Scene Signed Object"""

	pass

class MovieSceneTrack(MovieSceneSignedObject):
	"""Base class for a track in a Movie Scene"""

	@property
	def EvalOptions(self) -> typing.Any: ...
	"""General evaluation options for a given track"""

	pass

class MovieSceneNameableTrack(MovieSceneTrack):
	"""Base class for movie scene tracks that can be renamed by the user."""

	pass

class MovieSceneSection(MovieSceneSignedObject):
	"""Base class for movie scene sections"""

	@property
	def EvalOptions(self) -> typing.Any: ...
	"""Eval Options"""

	@property
	def Easing(self) -> typing.Any: ...
	"""Easing"""

	@property
	def SectionRange(self) -> typing.Any: ...
	"""The range in which this section is active"""

	def GetPostRollFrames(self) -> int: ...
	"""Get Post Roll Frames"""

	def SetPostRollFrames(self, InPostRollFrames: int): ...
	"""Gets/sets the number of frames to continue 'postrolling' this section for after evaluation has ended."""

	def GetPreRollFrames(self) -> int: ...
	"""Get Pre Roll Frames"""

	def SetPreRollFrames(self, InPreRollFrames: int): ...
	"""Gets the number of frames to prepare this section for evaluation before it actually starts."""

	def IsLocked(self) -> bool: ...
	"""Is Locked"""

	def SetIsLocked(self, bInIsLocked: bool): ...
	"""Whether or not this section is locked."""

	def IsActive(self) -> bool: ...
	"""Is Active"""

	def SetIsActive(self, bInIsActive: bool): ...
	"""Whether or not this section is active."""

	def GetOverlapPriority(self) -> int: ...
	"""Gets this section's priority over overlapping sections (higher wins)"""

	def SetOverlapPriority(self, NewPriority: int): ...
	"""Sets this section's priority over overlapping sections (higher wins)"""

	def GetRowIndex(self) -> int: ...
	"""Gets the row index for this section"""

	def SetRowIndex(self, NewRowIndex: int): ...
	"""Sets this section's new row index"""

	def SetBlendType(self, InBlendType: int): ...
	"""Sets this section's blend type"""

	def GetBlendType(self) -> OptionalMovieSceneBlendType: ...
	"""Gets this section's blend type"""

	def SetCompletionMode(self, InCompletionMode: int): ...
	"""* Sets this section's completion mode"""

	def GetCompletionMode(self) -> int: ...
	"""Gets this section's completion mode"""

	pass

class MovieSceneSequence(MovieSceneSignedObject):
	"""Abstract base class for movie scene animations (C++ version)."""

	@property
	def DefaultCompletionMode(self) -> int: ...
	"""The default completion mode for this movie scene when a section's completion mode is set to project default"""

	def FindBindingsByTag(self, InBindingName: str) -> typing.List[MovieSceneObjectBindingID]: ...
	"""Find all object binding IDs associated with the specified tag name (set up through RMB->Expose on Object bindings from within sequencer)"""

	def FindBindingByTag(self, InBindingName: str) -> MovieSceneObjectBindingID: ...
	"""Find the first object binding ID associated with the specified tag name (set up through RMB->Expose on Object bindings from within sequencer)"""

	pass

class MovieSceneSequencePlayer(Object):
	"""Abstract class that provides consistent player behaviour for various animation players"""

	@property
	def OnPlay(self) -> typing.Any: ...
	"""Event triggered when the level sequence player is played"""

	@property
	def OnPlayReverse(self) -> typing.Any: ...
	"""Event triggered when the level sequence player is played in reverse"""

	@property
	def OnStop(self) -> typing.Any: ...
	"""Event triggered when the level sequence player is stopped"""

	@property
	def OnPause(self) -> typing.Any: ...
	"""Event triggered when the level sequence player is paused"""

	@property
	def OnFinished(self) -> typing.Any: ...
	"""Event triggered when the level sequence player finishes naturally (without explicitly calling stop)"""

	def GetObjectBindings(self, InObject: Object) -> typing.List[MovieSceneObjectBindingID]: ...
	"""Get the object bindings for the requested object"""

	def GetBoundObjects(self, ObjectBinding: MovieSceneObjectBindingID) -> typing.List[Object]: ...
	"""Retrieve all objects currently bound to the specified binding identifier"""

	def GetDisableCameraCuts(self) -> bool: ...
	"""Set whether to disable camera cuts"""

	def SetDisableCameraCuts(self, bInDisableCameraCuts: bool): ...
	"""Set whether to disable camera cuts"""

	def SetPlayRate(self, PlayRate: float): ...
	"""Set the playback rate of this player. Negative values will play the animation in reverse.
@param PlayRate - The new rate of playback for the animation."""

	def GetPlayRate(self) -> float: ...
	"""Get the playback rate of this player."""

	def IsReversed(self) -> bool: ...
	"""Check whether playback is reversed."""

	def IsPaused(self) -> bool: ...
	"""Check whether the sequence is paused."""

	def IsPlaying(self) -> bool: ...
	"""Check whether the sequence is actively playing."""

	def SetPlaybackPosition(self, PlaybackParams: MovieSceneSequencePlaybackParams): ...
	"""Set the current time of the player by evaluating from the current time to the specified time, as if the sequence is playing.
Triggers events that lie within the evaluated range. Does not alter the persistent playback status of the player (IsPlaying).

@param PlaybackParams The position settings (ie. the position to set playback to)"""

	def PlayTo(self, PlaybackParams: MovieSceneSequencePlaybackParams): ...
	"""Play from the current position to the requested position and pause. If requested position is before the current position,
playback will be reversed. Playback to the requested position will be cancelled if Stop() or Pause() is invoked during this
playback.

@param PlaybackParams The position settings (ie. the position to play to)"""

	def SetTimeRange(self, StartTime: float, Duration: float): ...
	"""Set the valid play range for this sequence, determined by a starting time  and a duration (in seconds)

@param StartTime       The time to start playing back the sequence in seconds
@param Duration        The length to play for"""

	def SetFrameRange(self, StartFrame: int, Duration: int, SubFrames: float = ...): ...
	"""Set the valid play range for this sequence, determined by a starting frame number (in this sequence player's plaback frame), and a number of frames duration

@param StartFrame      The frame number to start playing back the sequence
@param Duration        The number of frames to play"""

	def GetEndTime(self) -> QualifiedFrameTime: ...
	"""Get the offset within the level sequence to finish playing"""

	def GetStartTime(self) -> QualifiedFrameTime: ...
	"""Get the offset within the level sequence to start playing"""

	def SetFrameRate(self, FrameRate: FrameRate): ...
	"""Set the frame-rate that this player should play with, making all frame numbers in the specified time-space"""

	def GetFrameRate(self) -> FrameRate: ...
	"""Get this sequence's display rate."""

	def GetFrameDuration(self) -> int: ...
	"""Get this sequence's duration in frames"""

	def GetDuration(self) -> QualifiedFrameTime: ...
	"""Get the total duration of the sequence"""

	def GetCurrentTime(self) -> QualifiedFrameTime: ...
	"""Get the current playback position
@return The current playback position"""

	def GoToEndAndStop(self): ...
	"""Go to end of the sequence and stop. Adheres to 'When Finished' section rules."""

	def StopAtCurrentTime(self): ...
	"""Stop playback without moving the cursor."""

	def Stop(self): ...
	"""Stop playback and move the cursor to the end (or start, for reversed playback) of the sequence."""

	def Scrub(self): ...
	"""Scrub playback."""

	def Pause(self): ...
	"""Pause playback."""

	def PlayLooping(self, NumLoops: int = ...): ...
	"""Start playback from the current time cursor position, looping the specified number of times.
@param NumLoops - The number of loops to play. -1 indicates infinite looping."""

	def ChangePlaybackDirection(self): ...
	"""Changes the direction of playback (go in reverse if it was going forward, or vice versa)"""

	def PlayReverse(self): ...
	"""Reverse playback."""

	def Play(self): ...
	"""Start playback forwards from the current time cursor position, using the current play rate."""

	pass

class MovieSceneBoolSection(MovieSceneSection):
	"""A single bool section."""

	pass

class MovieSceneSpawnSection(MovieSceneBoolSection):
	"""A spawn section."""

	pass

class MovieSceneSubSection(MovieSceneSection):
	"""Implements a section in sub-sequence tracks."""

	@property
	def Parameters(self) -> MovieSceneSectionParameters: ...
	"""Parameters"""

	def SetSequence(self, Sequence: MovieSceneSequence): ...
	"""Sets the sequence played by this section.

@param Sequence The sequence to play.
@see GetSequence"""

	def GetSequence(self) -> MovieSceneSequence: ...
	"""Get the sequence that is assigned to this section.

@return The sequence.
@see SetSequence"""

	pass

class MovieSceneSpawnTrack(MovieSceneTrack):
	"""Handles when a spawnable should be spawned and destroyed"""

	pass

class MovieSceneSubTrack(MovieSceneNameableTrack):
	"""A track that holds sub-sequences within a larger sequence."""

	pass

class MovieSceneCameraShakeSourceTrigger(object):
	"""Movie Scene Camera Shake Source Trigger"""

	@property
	def ShakeClass(self) -> CameraShakeBase: ...
	"""Class of the camera shake to play"""

	@property
	def PlayScale(self) -> float: ...
	"""Scalar that affects shake intensity"""

	@property
	def PlaySpace(self) -> int: ...
	"""Play Space"""

	@property
	def UserDefinedPlaySpace(self) -> Rotator: ...
	"""User Defined Play Space"""

	pass

class MovieSceneEventPtrs(object):
	"""Compiled reflection pointers for the event function and parameters"""

	@property
	def Function(self) -> typing.Any: ...
	"""Function"""

	@property
	def BoundObjectProperty(self) -> typing.Any: ...
	"""Bound Object Property"""

	pass

class MovieSceneEvent(object):
	"""Movie Scene Event"""

	@property
	def Ptrs(self) -> MovieSceneEventPtrs: ...
	"""The function that should be called to invoke this event.
Functions must have either no parameters, or a single, pass-by-value object/interface parameter, with no return parameter."""

	pass

class MovieSceneEventParameters(object):
	"""Movie Scene Event Parameters"""

	pass

class EventPayload(object):
	"""Event Payload"""

	@property
	def EventName(self) -> str: ...
	"""The name of the event to trigger"""

	@property
	def Parameters(self) -> MovieSceneEventParameters: ...
	"""The event parameters"""

	pass

class MovieSceneSkeletalAnimationParams(object):
	"""Movie Scene Skeletal Animation Params"""

	@property
	def Animation(self) -> AnimSequenceBase: ...
	"""The animation this section plays"""

	@property
	def FirstLoopStartFrameOffset(self) -> FrameNumber: ...
	"""The offset into the beginning of the animation clip for the first loop of play."""

	@property
	def StartFrameOffset(self) -> FrameNumber: ...
	"""The offset into the beginning of the animation clip"""

	@property
	def EndFrameOffset(self) -> FrameNumber: ...
	"""The offset into the end of the animation clip"""

	@property
	def PlayRate(self) -> float: ...
	"""The playback rate of the animation clip"""

	@property
	def bReverse(self) -> bool: ...
	"""Reverse the playback of the animation clip"""

	@property
	def SlotName(self) -> str: ...
	"""The slot name to use for the animation"""

	@property
	def Weight(self) -> typing.Any: ...
	"""The weight curve for this animation section"""

	@property
	def bSkipAnimNotifiers(self) -> bool: ...
	"""If on will skip sending animation notifies"""

	@property
	def bForceCustomMode(self) -> bool: ...
	"""If on animation sequence will always play when active even if the animation is controlled by a Blueprint or Anim Instance Class"""

	pass

class MovieScene3DConstraintSection(MovieSceneSection):
	"""Base class for 3D constraint section"""

	def SetConstraintBindingID(self, InConstraintBindingID: MovieSceneObjectBindingID): ...
	"""Sets the constraint binding for this Constraint section"""

	def GetConstraintBindingID(self) -> MovieSceneObjectBindingID: ...
	"""Gets the constraint binding for this Constraint section"""

	pass

class MovieScene3DAttachSection(MovieScene3DConstraintSection):
	"""A 3D Attach section"""

	@property
	def AttachSocketName(self) -> str: ...
	"""Attach Socket Name"""

	@property
	def AttachComponentName(self) -> str: ...
	"""Attach Component Name"""

	@property
	def AttachmentLocationRule(self) -> int: ...
	"""Attachment Location Rule"""

	@property
	def AttachmentRotationRule(self) -> int: ...
	"""Attachment Rotation Rule"""

	@property
	def AttachmentScaleRule(self) -> int: ...
	"""Attachment Scale Rule"""

	@property
	def DetachmentLocationRule(self) -> int: ...
	"""Detachment Location Rule"""

	@property
	def DetachmentRotationRule(self) -> int: ...
	"""Detachment Rotation Rule"""

	@property
	def DetachmentScaleRule(self) -> int: ...
	"""Detachment Scale Rule"""

	pass

class MovieScene3DPathSection(MovieScene3DConstraintSection):
	"""A 3D Path section"""

	@property
	def TimingCurve(self) -> typing.Any: ...
	"""Timing Curve"""

	@property
	def FrontAxisEnum(self) -> int: ...
	"""Front Axis"""

	@property
	def UpAxisEnum(self) -> int: ...
	"""Up Axis"""

	@property
	def bFollow(self) -> bool: ...
	"""Follow Curve"""

	@property
	def bReverse(self) -> bool: ...
	"""Reverse Timing"""

	@property
	def bForceUpright(self) -> bool: ...
	"""Force Upright"""

	pass

class MovieScene3DTransformSection(MovieSceneSection):
	"""A 3D transform section"""

	pass

class MovieSceneActorReferenceSection(MovieSceneSection):
	"""A single actor reference point section"""

	pass

class MovieSceneAudioSection(MovieSceneSection):
	"""Audio section, for use in the master audio, or by attached audio objects"""

	def GetStartOffset(self) -> FrameNumber: ...
	"""Get the offset into the beginning of the audio clip"""

	def SetStartOffset(self, InStartOffset: FrameNumber): ...
	"""Set the offset into the beginning of the audio clip"""

	def GetSound(self) -> SoundBase: ...
	"""Gets the sound for this section"""

	def SetSound(self, InSound: SoundBase): ...
	"""Sets this section's sound"""

	pass

class MovieSceneByteSection(MovieSceneSection):
	"""A single byte section."""

	@property
	def ByteCurve(self) -> typing.Any: ...
	"""Ordered curve data"""

	pass

class MovieSceneCameraAnimSection(MovieSceneSection):
	"""Movie Scene Camera Anim Section"""

	@property
	def AnimData(self) -> typing.Any: ...
	"""Anim Data"""

	pass

class MovieSceneCameraCutSection(MovieSceneSection):
	"""Movie CameraCuts are sections on the CameraCuts track, that show what the viewer 'sees'"""

	@property
	def bLockPreviousCamera(self) -> bool: ...
	"""When blending, lock the previous camera (camera cut or gameplay camera)."""

	def SetCameraBindingID(self, InCameraBindingID: MovieSceneObjectBindingID): ...
	"""Sets the camera binding for this CameraCut section"""

	def GetCameraBindingID(self) -> MovieSceneObjectBindingID: ...
	"""Gets the camera binding for this CameraCut section"""

	pass

class MovieSceneCameraShakeSection(MovieSceneSection):
	"""Movie Scene Camera Shake Section"""

	@property
	def ShakeData(self) -> typing.Any: ...
	"""Shake Data"""

	pass

class MovieSceneCameraShakeSourceShakeSection(MovieSceneSection):
	"""Movie Scene Camera Shake Source Shake Section"""

	@property
	def ShakeData(self) -> typing.Any: ...
	"""Shake Data"""

	pass

class MovieSceneCameraShakeSourceTriggerSection(MovieSceneSection):
	"""Movie Scene Camera Shake Source Trigger Section"""

	pass

class MovieSceneCinematicShotSection(MovieSceneSubSection):
	"""Implements a cinematic shot section."""

	def SetShotDisplayName(self, InShotDisplayName: str): ...
	"""Set the shot display name"""

	def GetShotDisplayName(self) -> str: ...
	"""@return The shot display name"""

	pass

class MovieSceneColorSection(MovieSceneSection):
	"""A single floating point section"""

	pass

class MovieSceneEnumSection(MovieSceneSection):
	"""A single enum section."""

	@property
	def EnumCurve(self) -> typing.Any: ...
	"""Ordered curve data"""

	pass

class MovieSceneEventSectionBase(MovieSceneSection):
	"""Base class for all event sections. Manages dirtying the section and track on recompilation of the director blueprint."""

	pass

class MovieSceneEventRepeaterSection(MovieSceneEventSectionBase):
	"""Event section that will trigger its event exactly once, every time it is evaluated."""

	@property
	def Event(self) -> MovieSceneEvent: ...
	"""The event that should be triggered each time this section is evaluated"""

	pass

class MovieSceneEventSection(MovieSceneSection):
	"""Implements a section in movie scene event tracks."""

	pass

class MovieSceneEventTriggerSection(MovieSceneEventSectionBase):
	"""Event section that triggeres specific timed events."""

	@property
	def EventChannel(self) -> typing.Any: ...
	"""The channel that defines this section's timed events"""

	pass

class MovieSceneFadeSection(MovieSceneSection):
	"""A single floating point section."""

	@property
	def FloatCurve(self) -> typing.Any: ...
	"""Float data"""

	@property
	def FadeColor(self) -> LinearColor: ...
	"""Fade color."""

	@property
	def bFadeAudio(self) -> bool: ...
	"""Fade audio."""

	pass

class MovieSceneFloatSection(MovieSceneSection):
	"""A single floating point section"""

	pass

class MovieSceneIntegerSection(MovieSceneSection):
	"""A single integer section."""

	pass

class MovieSceneLevelVisibilitySection(MovieSceneSection):
	"""A section for use with the movie scene level visibility track, which controls streamed level visibility."""

	def SetLevelNames(self, InLevelNames: typing.List[str]): ...
	"""Set Level Names"""

	def GetLevelNames(self) -> typing.List[str]: ...
	"""Get Level Names"""

	def SetVisibility(self, InVisibility: int): ...
	"""Set Visibility"""

	def GetVisibility(self) -> int: ...
	"""Get Visibility"""

	pass

class MovieSceneObjectPropertySection(MovieSceneSection):
	"""Movie Scene Object Property Section"""

	@property
	def ObjectChannel(self) -> typing.Any: ...
	"""Object Channel"""

	pass

class MovieSceneParameterSection(MovieSceneSection):
	"""A single movie scene section which can contain data for multiple named parameters."""

	def GetParameterNames(self) -> typing.Set[str]: ...
	"""Gets the set of all parameter names used by this section."""

	def RemoveTransformParameter(self, InParameterName: str) -> bool: ...
	"""Removes a transform parameter from this section.

@param InParameterName The name of the transform parameter to remove.
@returns True if a parameter with that name was found and removed, otherwise false."""

	def RemoveColorParameter(self, InParameterName: str) -> bool: ...
	"""Removes a color parameter from this section.

@param InParameterName The name of the color parameter to remove.
@returns True if a parameter with that name was found and removed, otherwise false."""

	def RemoveVectorParameter(self, InParameterName: str) -> bool: ...
	"""Removes a vector parameter from this section.

@param InParameterName The name of the vector parameter to remove.
@returns True if a parameter with that name was found and removed, otherwise false."""

	def RemoveVector2DParameter(self, InParameterName: str) -> bool: ...
	"""Removes a vector2D parameter from this section.

@param InParameterName The name of the vector2D parameter to remove.
@returns True if a parameter with that name was found and removed, otherwise false."""

	def RemoveBoolParameter(self, InParameterName: str) -> bool: ...
	"""Removes a bool parameter from this section.

@param InParameterName The name of the bool parameter to remove.
@returns True if a parameter with that name was found and removed, otherwise false."""

	def RemoveScalarParameter(self, InParameterName: str) -> bool: ...
	"""Removes a scalar parameter from this section.

@param InParameterName The name of the scalar parameter to remove.
@returns True if a parameter with that name was found and removed, otherwise false."""

	def AddTransformParameterKey(self, InParameterName: str, InTime: FrameNumber, InValue: Transform): ...
	"""Adds a a key for a specific color parameter at the specified time with the specified value."""

	def AddColorParameterKey(self, InParameterName: str, InTime: FrameNumber, InValue: LinearColor): ...
	"""Adds a a key for a specific color parameter at the specified time with the specified value."""

	def AddVectorParameterKey(self, InParameterName: str, InTime: FrameNumber, InValue: Vector): ...
	"""Adds a a key for a specific vector parameter at the specified time with the specified value."""

	def AddVector2DParameterKey(self, InParameterName: str, InTime: FrameNumber, InValue: Vector2D): ...
	"""Adds a a key for a specific vector2D parameter at the specified time with the specified value."""

	def AddBoolParameterKey(self, InParameterName: str, InTime: FrameNumber, InValue: bool): ...
	"""Adds a a key for a specific bool parameter at the specified time with the specified value."""

	def AddScalarParameterKey(self, InParameterName: str, InTime: FrameNumber, InValue: float): ...
	"""Adds a a key for a specific scalar parameter at the specified time with the specified value."""

	pass

class MovieSceneParticleSection(MovieSceneSection):
	"""Particle section, for particle toggling and triggering."""

	@property
	def ParticleKeys(self) -> typing.Any: ...
	"""Curve containing the particle keys."""

	pass

class MovieScenePrimitiveMaterialSection(MovieSceneSection):
	"""Movie Scene Primitive Material Section"""

	@property
	def MaterialChannel(self) -> typing.Any: ...
	"""Material Channel"""

	pass

class MovieSceneSkeletalAnimationSection(MovieSceneSection):
	"""Movie scene section that control skeletal animation"""

	@property
	def Params(self) -> MovieSceneSkeletalAnimationParams: ...
	"""Params"""

	@property
	def StartLocationOffset(self) -> Vector: ...
	"""Location Offset applied to this this animations start root motion"""

	@property
	def StartRotationOffset(self) -> Rotator: ...
	"""Rotation Offset applied to this this animations start root motion"""

	@property
	def bMatchWithPrevious(self) -> bool: ...
	"""Match with Previous"""

	@property
	def MatchedBoneName(self) -> str: ...
	"""Matched Bone Name"""

	@property
	def MatchedLocationOffset(self) -> Vector: ...
	"""Matched Location Offset"""

	@property
	def MatchedRotationOffset(self) -> Rotator: ...
	"""Matched Rotation Offset"""

	@property
	def bMatchTranslation(self) -> bool: ...
	"""Match Translation"""

	@property
	def bMatchIncludeZHeight(self) -> bool: ...
	"""Match Include ZHeight"""

	@property
	def bMatchRotationYaw(self) -> bool: ...
	"""Match Rotation Yaw"""

	@property
	def bMatchRotationPitch(self) -> bool: ...
	"""Match Rotation Pitch"""

	@property
	def bMatchRotationRoll(self) -> bool: ...
	"""Match Rotation Roll"""

	pass

class MovieSceneSlomoSection(MovieSceneSection):
	"""A single floating point section."""

	@property
	def FloatCurve(self) -> typing.Any: ...
	"""Float data"""

	pass

class MovieSceneStringSection(MovieSceneSection):
	"""A single string section"""

	pass

class MovieSceneVectorSection(MovieSceneSection):
	"""A vector section."""

	pass

class MovieSceneTransformOrigin(Interface):
	"""Movie Scene Transform Origin"""

	pass

class MovieScene3DConstraintTrack(MovieSceneTrack):
	"""Base class for constraint tracks (tracks that are dependent upon other objects)."""

	pass

class MovieScene3DAttachTrack(MovieScene3DConstraintTrack):
	"""Handles manipulation of path tracks in a movie scene."""

	pass

class MovieScene3DPathTrack(MovieScene3DConstraintTrack):
	"""Handles manipulation of path tracks in a movie scene"""

	pass

class MovieScenePropertyTrack(MovieSceneNameableTrack):
	"""Base class for tracks that animate an object property"""

	pass

class MovieScene3DTransformTrack(MovieScenePropertyTrack):
	"""Handles manipulation of component transforms in a movie scene"""

	pass

class MovieSceneActorReferenceTrack(MovieScenePropertyTrack):
	"""Handles manipulation of actor reference properties in a movie scene"""

	pass

class MovieSceneAudioTrack(MovieSceneNameableTrack):
	"""Handles manipulation of audio."""

	pass

class MovieSceneBoolTrack(MovieScenePropertyTrack):
	"""Handles manipulation of float properties in a movie scene"""

	pass

class MovieSceneByteTrack(MovieScenePropertyTrack):
	"""Handles manipulation of byte properties in a movie scene"""

	pass

class MovieSceneCameraAnimTrack(MovieSceneNameableTrack):
	"""Movie Scene Camera Anim Track"""

	pass

class MovieSceneCameraCutTrack(MovieSceneNameableTrack):
	"""Handles manipulation of CameraCut properties in a movie scene."""

	@property
	def bCanBlend(self) -> bool: ...
	"""Can Blend"""

	pass

class MovieSceneCameraShakeSourceShakeTrack(MovieSceneNameableTrack):
	"""Movie Scene Camera Shake Source Shake Track"""

	pass

class MovieSceneCameraShakeSourceTriggerTrack(MovieSceneTrack):
	"""Movie Scene Camera Shake Source Trigger Track"""

	pass

class MovieSceneCameraShakeTrack(MovieSceneNameableTrack):
	"""Movie Scene Camera Shake Track"""

	pass

class MovieSceneCinematicShotTrack(MovieSceneSubTrack):
	"""A track that holds consecutive sub sequences."""

	pass

class MovieSceneColorTrack(MovieScenePropertyTrack):
	"""Handles manipulation of float properties in a movie scene"""

	pass

class MovieSceneEnumTrack(MovieScenePropertyTrack):
	"""Handles manipulation of byte properties in a movie scene"""

	pass

class MovieSceneEulerTransformTrack(MovieScenePropertyTrack):
	"""Handles manipulation of 3D euler transform properties in a movie scene"""

	pass

class MovieSceneEventTrack(MovieSceneNameableTrack):
	"""Implements a movie scene track that triggers discrete events during playback."""

	@property
	def bFireEventsWhenForwards(self) -> bool: ...
	"""If events should be fired when passed playing the sequence forwards."""

	@property
	def bFireEventsWhenBackwards(self) -> bool: ...
	"""If events should be fired when passed playing the sequence backwards."""

	@property
	def EventPosition(self) -> int: ...
	"""Defines where in the evaluation to trigger events"""

	pass

class MovieSceneFloatTrack(MovieScenePropertyTrack):
	"""Handles manipulation of float properties in a movie scene"""

	pass

class MovieSceneFadeTrack(MovieSceneFloatTrack):
	"""Implements a movie scene track that controls a fade."""

	pass

class MovieSceneIntegerTrack(MovieScenePropertyTrack):
	"""Handles manipulation of integer properties in a movie scene"""

	pass

class MovieSceneLevelVisibilityTrack(MovieSceneNameableTrack):
	"""A track for controlling the visibility of streamed levels."""

	pass

class MovieSceneMaterialTrack(MovieSceneNameableTrack):
	"""Handles manipulation of material parameters in a movie scene."""

	pass

class MovieSceneMaterialParameterCollectionTrack(MovieSceneMaterialTrack):
	"""Handles manipulation of material parameter collections in a movie scene."""

	@property
	def MPC(self) -> MaterialParameterCollection: ...
	"""The material parameter collection to manipulate"""

	pass

class MovieSceneComponentMaterialTrack(MovieSceneMaterialTrack):
	"""A material track which is specialized for animation materials which are owned by actor components."""

	pass

class MovieSceneObjectPropertyTrack(MovieScenePropertyTrack):
	"""Movie Scene Object Property Track"""

	@property
	def PropertyClass(self) -> Object: ...
	"""Property Class"""

	pass

class MovieSceneParticleParameterTrack(MovieSceneNameableTrack):
	"""Handles manipulation of material parameters in a movie scene."""

	pass

class MovieSceneParticleTrack(MovieSceneNameableTrack):
	"""Handles triggering of particle emitters"""

	pass

class MovieScenePrimitiveMaterialTrack(MovieScenePropertyTrack):
	"""Movie Scene Primitive Material Track"""

	@property
	def MaterialIndex(self) -> int: ...
	"""Material Index"""

	pass

class MovieSceneSkeletalAnimationTrack(MovieSceneNameableTrack):
	"""Handles animation of skeletal mesh actors"""

	@property
	def AnimationSections(self) -> typing.List[MovieSceneSection]: ...
	"""List of all animation sections"""

	@property
	def bUseLegacySectionIndexBlend(self) -> bool: ...
	"""Use Legacy Section Index Blend"""

	@property
	def RootMotionParams(self) -> typing.Any: ...
	"""Root Motion Params"""

	@property
	def bBlendFirstChildOfRoot(self) -> bool: ...
	"""Whether to blend and adjust the first child node instead of the root, this should be true for blending when the root is static, false if the animations have proper root motion"""

	pass

class MovieSceneSlomoTrack(MovieSceneFloatTrack):
	"""Implements a movie scene track that controls a movie scene's world time dilation."""

	pass

class MovieSceneStringTrack(MovieScenePropertyTrack):
	"""Implements a movie scene track that holds a series of strings."""

	pass

class MovieSceneTransformTrack(MovieScenePropertyTrack):
	"""Handles manipulation of 3D transform properties in a movie scene"""

	pass

class MovieSceneVectorTrack(MovieScenePropertyTrack):
	"""Handles manipulation of component transforms in a movie scene"""

	pass

class MovieSceneVisibilityTrack(MovieSceneBoolTrack):
	"""Handles manipulation of visibility properties in a movie scene"""

	pass

class EMovieSceneKeyInterpolation(Enum):
	"""EMovie Scene Key Interpolation"""

	# Auto.
	Auto = 0
	# User.
	User = 1
	# Break.
	Break = 2
	# Linear.
	Linear = 3
	# Constant.
	Constant = 4

class EMovieScenePlayerStatus(Enum):
	"""EMovie Scene Player Status"""

	# 
	Stopped = 0
	# 
	Playing = 1
	# 
	Recording = 2
	# 
	Scrubbing = 3
	# 
	Jumping = 4
	# 
	Stepping = 5
	# 
	Paused = 6
	# 
	MAX = 7

class EMovieSceneEvaluationType(Enum):
	"""EMovie Scene Evaluation Type"""

	# Play the sequence frame-locked to its playback rate (snapped to the tick resolution - no sub-frames)
	FrameLocked = 0
	# Play the sequence in real-time, with sub-frame interpolation if necessary
	WithSubFrames = 1

class EUpdateClockSource(Enum):
	"""Enum used to define how to update to a particular time"""

	# Use the default world tick delta for timing. Honors world and actor pause state, but is susceptible to accumulation errors
	Tick = 0
	# Use the platform clock for timing. Does not honor world or actor pause state.
	Platform = 1
	# Use the audio clock for timing. Does not honor world or actor pause state.
	Audio = 2
	# Time relative to the timecode provider for timing. Does not honor world or actor pause state.
	RelativeTimecode = 3
	# Use current timecode provider for timing. Does not honor world or actor pause state.
	Timecode = 4
	# Custom clock source created and defined externally.
	Custom = 5

class EMovieSceneSequenceFlags(Enum):
	"""Bitfield flags that define special behavior for any UMovieSceneSequence."""

	# Symbolic entry for no flags
	None = 0
	# Flag signifying that this sequence can change dynamically at runtime or during the game so the template must be checked for validity and recompiled as necessary before each evaluation.
	# The absence of this flag will result in the same compiled data being used for the duration of the program, as well as being pre-built during cook. As such, any dynamic changes to the
	# sequence will not be reflected in the evaluation itself. This flag *must* be set if *any* procedural changes will be made to the source sequence data in-game.
	Volatile = -1
	# Indicates that a sequence must fully evaluate and apply its state every time it is updated, blocking until complete. Should be used sparingly as it will severely affect performance.
	BlockingEvaluation = -1
	# Symbolic entry for all flags that should be inherited by parent sequences when present on a sub sequence
	InheritedFlags = -1

class ESectionEvaluationFlags(Enum):
	"""Enumeration specifying how to evaluate a particular section when inside a segment"""

	# No special flags - normal evaluation
	None = 0
	# Segment resides inside the 'pre-roll' time for the section
	PreRoll = 1
	# Segment resides inside the 'post-roll' time for the section
	PostRoll = 2

class ESpawnOwnership(Enum):
	"""ESpawn Ownership"""

	# The object's lifetime is managed by the sequence that spawned it
	InnerSequence = 0
	# The object's lifetime is managed by the outermost sequence
	MasterSequence = 1
	# Once spawned, the object's lifetime is managed externally.
	External = 2

class EMovieSceneObjectBindingSpace(Enum):
	"""Enumeration specifying how a movie scene object binding ID relates to the sequence"""

	# The object binding sequence ID resolves from a local sequence (ie, it may need to accumulate a parent sequence ID before it resolves correctly)
	Local = 0
	# The object binding sequence ID resolves from the root of the sequence
	Root = 1

class EMovieSceneBlendType(Enum):
	"""Movie scene blend type enumeration"""

	# 
	Invalid = 0
	# Blends all other weighted values together as an average of the total weight
	Absolute = 1
	# Applies this value as a sum total of all other additives
	Additive = 2
	# Applies this value as a sum total of all other additives and the initial value before the animation
	Relative = 4
	# Applies this value as an additive equal to the difference between the current value and the first value
	AdditiveFromBase = 8

class EMovieSceneCompletionMode(Enum):
	"""Enumeration specifying how to handle state when this section is no longer evaluated"""

	# 
	KeepState = 0
	# 
	RestoreState = 1
	# 
	ProjectDefault = 2

class EEvaluationMethod(Enum):
	"""Enumeration to determine how a track should be evaluated"""

	# Evaluation only ever occurs at a single time. Delta is irrelevant. Example: Basic curve eval, animation
	Static = 0
	# Evaluation from one frame to the next must consider the entire swept delta range on the track. Example: Events
	Swept = 1

class EMovieSceneBuiltInEasing(Enum):
	"""EMovie Scene Built in Easing"""

	# Linear easing
	Linear = 0
	# Sinusoidal easing
	SinIn = 1
	# 
	SinOut = 2
	# 
	SinInOut = 3
	# Quadratic easing
	QuadIn = 4
	# 
	QuadOut = 5
	# 
	QuadInOut = 6
	# Cubic easing
	CubicIn = 7
	# 
	CubicOut = 8
	# 
	CubicInOut = 9
	# Quartic easing
	QuartIn = 10
	# 
	QuartOut = 11
	# 
	QuartInOut = 12
	# Quintic easing
	QuintIn = 13
	# 
	QuintOut = 14
	# 
	QuintInOut = 15
	# Exponential easing
	ExpoIn = 16
	# 
	ExpoOut = 17
	# 
	ExpoInOut = 18
	# Circular easing
	CircIn = 19
	# 
	CircOut = 20
	# 
	CircInOut = 21

class EUpdatePositionMethod(Enum):
	"""Enum used to define how to update to a particular time"""

	# Update from the current position to a specified position (including triggering events), using the current player status
	Play = 0
	# Jump to a specified position (without triggering events in between), using the current player status
	Jump = 1
	# Jump to a specified position, temporarily using EMovieScenePlayerStatus::Scrubbing
	Scrub = 2

class EMovieScenePositionType(Enum):
	"""EMovie Scene Position Type"""

	# 
	Frame = 0
	# 
	Time = 1
	# 
	MarkedFrame = 2

class EShow3DTrajectory(Enum):
	"""Visibility options for 3d trajectory."""

	# 
	EST_OnlyWhenSelected = 0
	# 
	EST_Always = 1
	# 
	EST_Never = 2

class MovieScene3DPathSection_Axis(Enum):
	"""Movie Scene 3DPath Section Axis"""

	# 
	X = 0
	# 
	Y = 1
	# 
	Z = 2
	# 
	NEG_X = 3
	# 
	NEG_Y = 4
	# 
	NEG_Z = 5

class ELevelVisibility(Enum):
	"""Visibility options for the level visibility section."""

	# The streamed levels should be visible.
	Visible = 0
	# The streamed levels should be hidden.
	Hidden = 1

class EParticleKey(Enum):
	"""Defines the types of particle keys."""

	# 
	Activate = 0
	# 
	Deactivate = 1
	# 
	Trigger = 2

class EFireEventsAtPosition(Enum):
	"""Indicates at what point in the sequence evaluation events should fire"""

	# Fire events before anything else is evaluated in the sequence
	AtStartOfEvaluation = 0
	# Fire events after everything else has been evaluated in the sequence
	AtEndOfEvaluation = 1
	# Fire events right after any spawn tracks have been evaluated
	AfterSpawn = 2

class EventReply(object):
	"""Allows users to handle events and return information to the underlying UI layer."""

	pass

class SlateChildSize(object):
	"""A struct exposing size param related properties to UMG."""

	@property
	def Value(self) -> float: ...
	"""The parameter of the size rule."""

	@property
	def SizeRule(self) -> int: ...
	"""The sizing rule of the content."""

	pass

class WidgetTransform(object):
	"""Describes the standard transformation of a widget"""

	@property
	def Translation(self) -> Vector2D: ...
	"""The amount to translate the widget in slate units"""

	@property
	def Scale(self) -> Vector2D: ...
	"""The scale to apply to the widget"""

	@property
	def Shear(self) -> Vector2D: ...
	"""The amount to shear the widget in slate units"""

	@property
	def Angle(self) -> float: ...
	"""The angle in degrees to rotate"""

	pass

class WidgetNavigationData(object):
	"""Widget Navigation Data"""

	@property
	def Rule(self) -> int: ...
	"""Rule"""

	@property
	def WidgetToFocus(self) -> str: ...
	"""This either the widget to focus, OR the name of the function to call."""

	@property
	def Widget(self) -> Widget: ...
	"""Widget"""

	@property
	def CustomDelegate(self) -> typing.Any: ...
	"""Custom Delegate"""

	pass

class PaintContext(object):
	"""The state passed into OnPaint that we can expose as a single painting structure to blueprints to
allow script code to override OnPaint behavior."""

	pass

class AnchorData(object):
	"""Anchor Data"""

	@property
	def Offsets(self) -> Margin: ...
	"""Offset."""

	@property
	def Anchors(self) -> Anchors: ...
	"""Anchors."""

	@property
	def Alignment(self) -> Vector2D: ...
	"""Alignment is the pivot point of the widget.  Starting in the upper left at (0,0),
ending in the lower right at (1,1).  Moving the alignment point allows you to move
the origin of the widget."""

	pass

class RadialBoxSettings(object):
	"""Radial Box Settings"""

	@property
	def bDistributeItemsEvenly(self) -> bool: ...
	"""Distribute Items evenly in the whole circle. Checking this option ignores AngleBetweenItems"""

	@property
	def AngleBetweenItems(self) -> float: ...
	"""Amount of Euler degrees that separate each item"""

	@property
	def StartingAngle(self) -> float: ...
	"""At what angle will we place the first element of the wheel?"""

	pass

class ShapedTextOptions(object):
	"""Common data for all widgets that use shaped text.
Contains the common options that should be exposed for the underlying Slate widget."""

	@property
	def bOverride_TextShapingMethod(self) -> bool: ...
	"""Override Text Shaping Method"""

	@property
	def bOverride_TextFlowDirection(self) -> bool: ...
	"""Override Text Flow Direction"""

	@property
	def TextShapingMethod(self) -> int: ...
	"""Which text shaping method should the text within this widget use? (unset to use the default returned by GetDefaultTextShapingMethod)"""

	@property
	def TextFlowDirection(self) -> int: ...
	"""Which text flow direction should the text within this widget use? (unset to use the default returned by GetDefaultTextFlowDirection)"""

	pass

class RichTextStyleRow(TableRowBase):
	"""Simple struct for rich text styles"""

	@property
	def TextStyle(self) -> TextBlockStyle: ...
	"""Text Style"""

	pass

class RichImageRow(TableRowBase):
	"""Simple struct for rich text styles"""

	@property
	def Brush(self) -> SlateBrush: ...
	"""Brush"""

	pass

class MovieScene2DTransformSection(MovieSceneSection):
	"""A transform section"""

	@property
	def TransformMask(self) -> typing.Any: ...
	"""Transform Mask"""

	@property
	def Translation(self) -> typing.List[unsupported]: ...
	"""Translation curves"""

	@property
	def Rotation(self) -> typing.Any: ...
	"""Rotation curve"""

	@property
	def Scale(self) -> typing.List[unsupported]: ...
	"""Scale curves"""

	@property
	def Shear(self) -> typing.List[unsupported]: ...
	"""Shear curve"""

	pass

class MovieScene2DTransformTrack(MovieScenePropertyTrack):
	"""Handles manipulation of 2D transforms in a movie scene"""

	pass

class MovieSceneMarginSection(MovieSceneSection):
	"""A section in a Margin track"""

	@property
	def TopCurve(self) -> typing.Any: ...
	"""Red curve data"""

	@property
	def LeftCurve(self) -> typing.Any: ...
	"""Green curve data"""

	@property
	def RightCurve(self) -> typing.Any: ...
	"""Blue curve data"""

	@property
	def BottomCurve(self) -> typing.Any: ...
	"""Alpha curve data"""

	pass

class MovieSceneMarginTrack(MovieScenePropertyTrack):
	"""Handles manipulation of FMargins in a movie scene"""

	pass

class MovieSceneWidgetMaterialTrack(MovieSceneMaterialTrack):
	"""A material track which is specialized for materials which are owned by widget brushes."""

	pass

class UMGSequencePlayer(Object):
	"""UMGSequence Player"""

	def SetUserTag(self, InUserTag: str): ...
	"""Set User Tag"""

	def GetUserTag(self) -> str: ...
	"""@return"""

	pass

class WidgetAnimation(MovieSceneSequence):
	"""Widget Animation"""

	@property
	def MovieScene(self) -> typing.Any: ...
	"""Pointer to the movie scene that controls this animation."""

	@property
	def AnimationBindings(self) -> typing.List[unsupported]: ...
	"""Animation Bindings"""

	def UnbindFromAnimationFinished(self, Widget: UserWidget, Delegate): ...
	"""Unbind from Animation Finished"""

	def BindToAnimationFinished(self, Widget: UserWidget, Delegate): ...
	"""Bind to Animation Finished"""

	def UnbindFromAnimationStarted(self, Widget: UserWidget, Delegate): ...
	"""Unbind from Animation Started"""

	def BindToAnimationStarted(self, Widget: UserWidget, Delegate): ...
	"""These animation binding functions were added so that we could cleanly upgrade assets
from before animation sharing, they don't actually modify the animation, they just pipe
through to the UUserWidget.  If we didn't put the functions here, it would be much more
difficult to upgrade users who were taking advantage of the Many-To-1, blueprint having
many animations binding to the same delegate."""

	def GetEndTime(self) -> float: ...
	"""Get the end time of this animation.

@return End time in seconds.
@see GetStartTime"""

	def GetStartTime(self) -> float: ...
	"""Get the start time of this animation.

@return Start time in seconds.
@see GetEndTime"""

	pass

class WidgetAnimationPlayCallbackProxy(Object):
	"""Widget Animation Play Callback Proxy"""

	@property
	def Finished(self) -> typing.Any: ...
	"""Called when animation has been completed"""

	pass

class AsyncTaskDownloadImage(BlueprintAsyncActionBase):
	"""Async Task Download Image"""

	@property
	def OnSuccess(self) -> typing.Any: ...
	"""On Success"""

	@property
	def OnFail(self) -> typing.Any: ...
	"""On Fail"""

	@staticmethod
	def DownloadImage(URL: str) -> AsyncTaskDownloadImage: ...
	"""Download Image"""

	pass

class DragDropOperation(Object):
	"""This class is the base drag drop operation for UMG, extend it to add additional data and add new functionality."""

	@property
	def Tag(self) -> str: ...
	"""A simple string tag you can optionally use to provide extra metadata about the operation."""

	@property
	def Payload(self) -> Object: ...
	"""The payload of the drag operation.  This can be any UObject that you want to pass along as dragged data.  If you
were building an inventory screen this would be the UObject representing the item being moved to another slot."""

	@property
	def DefaultDragVisual(self) -> Widget: ...
	"""The Drag Visual is the widget to display when dragging the item.  Normally people create a new widget to represent the
temporary drag."""

	@property
	def Pivot(self) -> int: ...
	"""Controls where the drag widget visual will appear when dragged relative to the pointer performing
the drag operation."""

	@property
	def Offset(self) -> Vector2D: ...
	"""A percentage offset (-1..+1) from the Pivot location, the percentage is of the desired size of the dragged visual."""

	@property
	def OnDrop(self) -> typing.Any: ...
	"""On Drop"""

	@property
	def OnDragCancelled(self) -> typing.Any: ...
	"""On Drag Cancelled"""

	@property
	def OnDragged(self) -> typing.Any: ...
	"""On Dragged"""

	def Dragged(self, PointerEvent: PointerEvent): ...
	"""Dragged"""

	def DragCancelled(self, PointerEvent: PointerEvent): ...
	"""Drag Cancelled"""

	def Drop(self, PointerEvent: PointerEvent): ...
	"""Drop"""

	pass

class UserListEntry(Interface):
	"""User List Entry"""

	pass

class UserListEntryLibrary(BlueprintFunctionLibrary):
	"""Static library to supply 'for free' functionality to widgets that implement IUserListEntry"""

	@staticmethod
	def GetOwningListView(UserListEntry: UserListEntry) -> ListViewBase: ...
	"""Returns the list view that contains this entry.
@param UserListEntry Note: Visually not transmitted, but this defaults to 'self'. No need to hook up if calling internally."""

	@staticmethod
	def IsListItemExpanded(UserListEntry: UserListEntry) -> bool: ...
	"""Returns true if the item represented by this entry is currently expanded and showing its children. Tree view entries only.
@param UserListEntry Note: Visually not transmitted, but this defaults to 'self'. No need to hook up if calling internally."""

	@staticmethod
	def IsListItemSelected(UserListEntry: UserListEntry) -> bool: ...
	"""Returns true if the item represented by this entry is currently selected in the owning list view.
@param UserListEntry Note: Visually not transmitted, but this defaults to 'self'. No need to hook up if calling internally."""

	pass

class UserObjectListEntry(UserListEntry):
	"""User Object List Entry"""

	pass

class UserObjectListEntryLibrary(BlueprintFunctionLibrary):
	"""Static library to supply 'for free' functionality to widgets that implement IUserListEntry"""

	@staticmethod
	def GetListItemObject(UserObjectListEntry: UserObjectListEntry) -> Object: ...
	"""Returns the item in the owning list view that this entry is currently assigned to represent.
@param UserObjectListEntry Note: Visually not transmitted, but this defaults to 'self'. No need to hook up if calling internally."""

	pass

class SlateBlueprintLibrary(BlueprintFunctionLibrary):
	"""Slate Blueprint Library"""

	@staticmethod
	def ScreenToViewport(WorldContextObject: Object, ScreenPosition: Vector2D) -> Vector2D: ...
	"""Translates a screen position in pixels into the local space of the viewport widget."""

	@staticmethod
	def ScreenToWidgetAbsolute(WorldContextObject: Object, ScreenPosition: Vector2D, bIncludeWindowPosition: bool) -> Vector2D: ...
	"""Translates a screen position in pixels into absolute application coordinates.
If bIncludeWindowPosition is true, then this method will also remove the game window's position (useful when in windowed mode)."""

	@staticmethod
	def ScreenToWidgetLocal(WorldContextObject: Object, Geometry: Geometry, ScreenPosition: Vector2D, bIncludeWindowPosition: bool) -> Vector2D: ...
	"""Translates a screen position in pixels into the local space of a widget with the given geometry.
If bIncludeWindowPosition is true, then this method will also remove the game window's position (useful when in windowed mode)."""

	@staticmethod
	def AbsoluteToViewport(WorldContextObject: Object, AbsoluteDesktopCoordinate: Vector2D) -> typing.Tuple[Vector2D, Vector2D]: ...
	"""Translates absolute coordinate in desktop space of the geometry provided into local viewport coordinates.

@param PixelPosition The position in the game's viewport, usable for line traces and
other uses where you need a coordinate in the space of viewport resolution units.
@param ViewportPosition The position in the space of other widgets in the viewport.  Like if you wanted
to add another widget to the viewport at the same position in viewport space as this location, this is
what you would use."""

	@staticmethod
	def LocalToViewport(WorldContextObject: Object, Geometry: Geometry, LocalCoordinate: Vector2D) -> typing.Tuple[Vector2D, Vector2D]: ...
	"""Translates local coordinate of the geometry provided into local viewport coordinates.

@param PixelPosition The position in the game's viewport, usable for line traces and
other uses where you need a coordinate in the space of viewport resolution units.
@param ViewportPosition The position in the space of other widgets in the viewport.  Like if you wanted
to add another widget to the viewport at the same position in viewport space as this location, this is
what you would use."""

	@staticmethod
	def EqualEqual_SlateBrush(A: SlateBrush, B: SlateBrush) -> bool: ...
	"""Returns whether brushes A and B are identical."""

	@staticmethod
	def TransformVectorLocalToAbsolute(Geometry: Geometry, LocalVector: Vector2D) -> Vector2D: ...
	"""Transform Vector Local to Absolute"""

	@staticmethod
	def TransformVectorAbsoluteToLocal(Geometry: Geometry, AbsoluteVector: Vector2D) -> Vector2D: ...
	"""Transform Vector Absolute to Local"""

	@staticmethod
	def TransformScalarLocalToAbsolute(Geometry: Geometry, LocalScalar: float) -> float: ...
	"""Transform Scalar Local to Absolute"""

	@staticmethod
	def TransformScalarAbsoluteToLocal(Geometry: Geometry, AbsoluteScalar: float) -> float: ...
	"""Transform Scalar Absolute to Local"""

	@staticmethod
	def GetAbsoluteSize(Geometry: Geometry) -> Vector2D: ...
	"""Returns the size of the geometry in absolute space."""

	@staticmethod
	def GetLocalSize(Geometry: Geometry) -> Vector2D: ...
	"""Returns the size of the geometry in local space."""

	@staticmethod
	def GetLocalTopLeft(Geometry: Geometry) -> Vector2D: ...
	"""Returns the local top/left of the geometry in local space."""

	@staticmethod
	def LocalToAbsolute(Geometry: Geometry, LocalCoordinate: Vector2D) -> Vector2D: ...
	"""Translates local coordinates into absolute coordinates

Absolute coordinates could be either desktop or window space depending on what space the root of the widget hierarchy is in.

@return  Absolute coordinates"""

	@staticmethod
	def AbsoluteToLocal(Geometry: Geometry, AbsoluteCoordinate: Vector2D) -> Vector2D: ...
	"""Absolute coordinates could be either desktop or window space depending on what space the root of the widget hierarchy is in.

@return Transforms AbsoluteCoordinate into the local space of this Geometry."""

	@staticmethod
	def IsUnderLocation(Geometry: Geometry, AbsoluteCoordinate: Vector2D) -> bool: ...
	"""Absolute coordinates could be either desktop or window space depending on what space the root of the widget hierarchy is in.

@return true if the provided location in absolute coordinates is within the bounds of this geometry."""

	pass

class Visual(Object):
	"""The base class for elements in UMG: slots and widgets."""

	pass

class Widget(Visual):
	"""This is the base class for all wrapped Slate controls that are exposed to UObjects."""

	@property
	def Slot(self) -> PanelSlot: ...
	"""The parent slot of the UWidget.  Allows us to easily inline edit the layout controlling this widget."""

	@property
	def bIsEnabledDelegate(self) -> typing.Any: ...
	"""A bindable delegate for bIsEnabled"""

	@property
	def ToolTipText(self) -> str: ...
	"""Tooltip text to show when the user hovers over the widget with the mouse"""

	@property
	def ToolTipTextDelegate(self) -> typing.Any: ...
	"""A bindable delegate for ToolTipText"""

	@property
	def ToolTipWidget(self) -> Widget: ...
	"""Tooltip widget to show when the user hovers over the widget with the mouse"""

	@property
	def ToolTipWidgetDelegate(self) -> typing.Any: ...
	"""A bindable delegate for ToolTipWidget"""

	@property
	def VisibilityDelegate(self) -> typing.Any: ...
	"""A bindable delegate for Visibility"""

	@property
	def RenderTransform(self) -> WidgetTransform: ...
	"""The render transform of the widget allows for arbitrary 2D transforms to be applied to the widget."""

	@property
	def RenderTransformPivot(self) -> Vector2D: ...
	"""The render transform pivot controls the location about which transforms are applied.
This value is a normalized coordinate about which things like rotations will occur."""

	@property
	def bIsVariable(self) -> bool: ...
	"""Allows controls to be exposed as variables in a blueprint.  Not all controls need to be exposed
as variables, so this allows only the most useful ones to end up being exposed."""

	@property
	def bCreatedByConstructionScript(self) -> bool: ...
	"""Flag if the Widget was created from a blueprint"""

	@property
	def bIsEnabled(self) -> bool: ...
	"""Sets whether this widget can be modified interactively by the user"""

	@property
	def bOverride_Cursor(self) -> bool: ...
	"""Override Cursor"""

	@property
	def Cursor(self) -> int: ...
	"""The cursor to show when the mouse is over the widget"""

	@property
	def Clipping(self) -> int: ...
	"""Controls how the clipping behavior of this widget.  Normally content that overflows the
bounds of the widget continues rendering.  Enabling clipping prevents that overflowing content
from being seen.

NOTE: Elements in different clipping spaces can not be batched together, and so there is a
performance cost to clipping.  Do not enable clipping unless a panel actually needs to prevent
content from showing up outside its bounds."""

	@property
	def Visibility(self) -> int: ...
	"""The visibility of the widget"""

	@property
	def RenderOpacity(self) -> float: ...
	"""The opacity of the widget"""

	@property
	def Navigation(self) -> WidgetNavigation: ...
	"""The navigation object for this widget is optionally created if the user has configured custom
navigation rules for this widget in the widget designer.  Those rules determine how navigation transitions
can occur between widgets."""

	@property
	def FlowDirectionPreference(self) -> int: ...
	"""Allows you to set a new flow direction"""

	def GetAccessibleSummaryText(self) -> str: ...
	"""Gets the accessible summary text from the underlying Slate accessible widget.
@return The accessible summary text of the underlying Slate accessible widget. Returns an empty text if
accessibility is dsabled or the underlying accessible widget is invalid."""

	def GetAccessibleText(self) -> str: ...
	"""Gets the accessible text from the underlying Slate accessible widget
@return The accessible text of the underlying Slate accessible widget. Returns an empty text if
accessibility is dsabled or the underlying accessible widget is invalid."""

	def GetOwningLocalPlayer(self) -> typing.Any: ...
	"""Gets the local player associated with this UI.
@return The owning local player."""

	def GetOwningPlayer(self) -> PlayerController: ...
	"""Gets the player controller associated with this UI.
@return The player controller that owns the UI."""

	def GetGameInstance(self) -> GameInstance: ...
	"""Gets the game instance associated with this UI.
@return a pointer to the owning game instance"""

	def GetPaintSpaceGeometry(self) -> Geometry: ...
	"""Get Paint Space Geometry"""

	def GetTickSpaceGeometry(self) -> Geometry: ...
	"""Get Tick Space Geometry"""

	def GetCachedGeometry(self) -> Geometry: ...
	"""Gets the last geometry used to Tick the widget.  This data may not exist yet if this call happens prior to
the widget having been ticked/painted, or it may be out of date, or a frame behind.

We recommend not to use this data unless there's no other way to solve your problem.  Normally in Slate we
try and handle these issues by making a dependent widget part of the hierarchy, as to avoid frame behind
or what are referred to as hysteresis problems, both caused by depending on geometry from the previous frame
being used to advise how to layout a dependent object the current frame."""

	def RemoveFromParent(self): ...
	"""Removes the widget from its parent widget.  If this widget was added to the player's screen or the viewport
it will also be removed from those containers."""

	def GetParent(self) -> PanelWidget: ...
	"""Gets the parent widget"""

	def SetNavigationRuleCustomBoundary(self, Direction: int, InCustomDelegate): ...
	"""Sets the widget navigation rules for a specific direction. This can only be called on widgets that are in a widget tree. This works only for CustomBoundary Rule.
@param Direction
@param InCustomDelegate Custom Delegate that will be called"""

	def SetNavigationRuleCustom(self, Direction: int, InCustomDelegate): ...
	"""Sets the widget navigation rules for a specific direction. This can only be called on widgets that are in a widget tree. This works only for Custom Rule.
@param Direction
@param InCustomDelegate Custom Delegate that will be called"""

	def SetNavigationRuleExplicit(self, Direction: int, InWidget: Widget): ...
	"""Sets the widget navigation rules for a specific direction. This can only be called on widgets that are in a widget tree. This works only for Explicit Rule.
@param Direction
@param InWidget Focus on this widget instance"""

	def SetNavigationRuleBase(self, Direction: int, Rule: int): ...
	"""Sets the widget navigation rules for a specific direction. This can only be called on widgets that are in a widget tree. This works only for non Explicit, non Custom and non CustomBoundary Rules.
@param Direction
@param Rule The rule to use when navigation is taking place"""

	def SetNavigationRule(self, Direction: int, Rule: int, WidgetToFocus: str): ...
	"""Set Navigation Rule"""

	def SetAllNavigationRules(self, Rule: int, WidgetToFocus: str): ...
	"""Sets the widget navigation rules for all directions. This can only be called on widgets that are in a widget tree.
@param Rule The rule to use when navigation is taking place
@param WidgetToFocus When using the Explicit rule, focus on this widget"""

	def GetDesiredSize(self) -> Vector2D: ...
	"""Gets the widgets desired size.
NOTE: The underlying Slate widget must exist and be valid, also at least one pre-pass must
      have occurred before this value will be of any use.

@return The widget's desired size"""

	def InvalidateLayoutAndVolatility(self): ...
	"""Invalidates the widget from the view of a layout caching widget that may own this widget.
will force the owning widget to redraw and cache children on the next paint pass."""

	def ForceLayoutPrepass(self): ...
	"""Forces a pre-pass.  A pre-pass caches the desired size of the widget hierarchy owned by this widget.
One pre-pass already happens for every widget before Tick occurs.  You only need to perform another
pre-pass if you are adding child widgets this frame and want them to immediately be visible this frame."""

	def SetUserFocus(self, PlayerController: PlayerController): ...
	"""Sets the focus to this widget for a specific user (if setting focus for the owning user, prefer SetFocus())"""

	def SetFocus(self): ...
	"""Sets the focus to this widget for the owning user"""

	def HasUserFocusedDescendants(self, PlayerController: PlayerController) -> bool: ...
	"""Returns true if any descendant widget is focused by a specific user."""

	def HasFocusedDescendants(self) -> bool: ...
	"""Returns true if any descendant widget is focused by any user."""

	def HasAnyUserFocus(self) -> bool: ...
	"""Returns true if this widget is focused by any user."""

	def HasUserFocus(self, PlayerController: PlayerController) -> bool: ...
	"""Returns true if this widget is focused by a specific user."""

	def SetKeyboardFocus(self): ...
	"""Sets the focus to this widget."""

	def HasMouseCaptureByUser(self, UserIndex: int, PointerIndex: int = ...) -> bool: ...
	"""Checks to see if this widget is the current mouse captor
     @param User index to check for capture
     @param Optional pointer index to check for capture
     @return  True if this widget has captured the mouse with given user and pointer"""

	def HasMouseCapture(self) -> bool: ...
	"""Checks to see if this widget is the current mouse captor
@return  True if this widget has captured the mouse"""

	def HasKeyboardFocus(self) -> bool: ...
	"""Checks to see if this widget currently has the keyboard focus

@return  True if this widget has keyboard focus"""

	def IsHovered(self) -> bool: ...
	"""Returns true if the widget is currently being hovered by a pointer device"""

	def ForceVolatile(self, bForce: bool): ...
	"""Sets the forced volatility of the widget."""

	def SetClipping(self, InClipping: int): ...
	"""Sets the clipping state of this widget."""

	def GetClipping(self) -> int: ...
	"""Gets the clipping state of this widget."""

	def SetRenderOpacity(self, InOpacity: float): ...
	"""Sets the visibility of the widget."""

	def GetRenderOpacity(self) -> float: ...
	"""Gets the current visibility of the widget."""

	def SetVisibility(self, InVisibility: int): ...
	"""Sets the visibility of the widget."""

	def GetVisibility(self) -> int: ...
	"""Gets the current visibility of the widget."""

	def IsVisible(self) -> bool: ...
	"""Returns true if the widget is Visible, HitTestInvisible or SelfHitTestInvisible."""

	def ResetCursor(self): ...
	"""Resets the cursor to use on the widget, removing any customization for it."""

	def SetCursor(self, InCursor: int): ...
	"""Sets the cursor to show over the widget."""

	def SetToolTip(self, Widget: Widget): ...
	"""Sets a custom widget as the tooltip of the widget."""

	def SetToolTipText(self, InToolTipText: str): ...
	"""Sets the tooltip text for the widget."""

	def SetIsEnabled(self, bInIsEnabled: bool): ...
	"""Sets the current enabled status of the widget"""

	def GetIsEnabled(self) -> bool: ...
	"""Gets the current enabled status of the widget"""

	def SetRenderTransformPivot(self, Pivot: Vector2D): ...
	"""Set Render Transform Pivot"""

	def SetRenderTranslation(self, Translation: Vector2D): ...
	"""Set Render Translation"""

	def GetRenderTransformAngle(self) -> float: ...
	"""Get Render Transform Angle"""

	def SetRenderTransformAngle(self, Angle: float): ...
	"""Set Render Transform Angle"""

	def SetRenderShear(self, Shear: Vector2D): ...
	"""Set Render Shear"""

	def SetRenderScale(self, Scale: Vector2D): ...
	"""Set Render Scale"""

	def SetRenderTransform(self, InTransform: WidgetTransform): ...
	"""Set Render Transform"""

	pass

class UserWidget(Widget):
	"""The user widget is extensible by users through the WidgetBlueprint."""

	@property
	def ColorAndOpacity(self) -> LinearColor: ...
	"""The color and opacity of this widget.  Tints all child widgets."""

	@property
	def ColorAndOpacityDelegate(self) -> typing.Any: ...
	"""Color and Opacity Delegate"""

	@property
	def ForegroundColor(self) -> SlateColor: ...
	"""The foreground color of the widget, this is inherited by sub widgets.  Any color property
that is marked as inherit will use this color."""

	@property
	def ForegroundColorDelegate(self) -> typing.Any: ...
	"""Foreground Color Delegate"""

	@property
	def OnVisibilityChanged(self) -> typing.Any: ...
	"""Called when the visibility has changed"""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area around the content."""

	@property
	def ActiveSequencePlayers(self) -> typing.List[UMGSequencePlayer]: ...
	"""All the sequence players currently playing"""

	@property
	def AnimationTickManager(self) -> typing.Any: ...
	"""Animation Tick Manager"""

	@property
	def StoppedSequencePlayers(self) -> typing.List[UMGSequencePlayer]: ...
	"""List of sequence players to cache and clean up when safe"""

	@property
	def WidgetTree(self) -> typing.Any: ...
	"""The widget tree contained inside this user widget initialized by the blueprint"""

	@property
	def Priority(self) -> int: ...
	"""Priority"""

	@property
	def bIsFocusable(self) -> bool: ...
	"""Setting this flag to true, allows this widget to accept focus when clicked, or when navigated to."""

	@property
	def bStopAction(self) -> bool: ...
	"""Stop Action"""

	@property
	def bHasScriptImplementedTick(self) -> bool: ...
	"""If a widget has an implemented tick blueprint function"""

	@property
	def bHasScriptImplementedPaint(self) -> bool: ...
	"""If a widget has an implemented paint blueprint function"""

	def IsPlayingAnimation(self) -> bool: ...
	"""Are we currently playing any animations?"""

	def FlushAnimations(self): ...
	"""Flushes all animations on all widgets to guarantee that any queued updates are processed before this call returns"""

	def IsAnimationPlayingForward(self, InAnimation: WidgetAnimation) -> bool: ...
	"""returns true if the animation is currently playing forward, false otherwise.

@param InAnimation The playing animation that we want to know about"""

	def ReverseAnimation(self, InAnimation: WidgetAnimation): ...
	"""If an animation is playing, this function will reverse the playback.

@param InAnimation The playing animation that we want to reverse"""

	def SetPlaybackSpeed(self, InAnimation: WidgetAnimation, PlaybackSpeed: float = ...): ...
	"""Changes the playback rate of a playing animation

@param InAnimation The animation that is already playing
@param PlaybackRate Playback rate multiplier (1 is default)"""

	def SetNumLoopsToPlay(self, InAnimation: WidgetAnimation, NumLoopsToPlay: int): ...
	"""Changes the number of loops to play given a playing animation

@param InAnimation The animation that is already playing
@param NumLoopsToPlay The number of loops to play. (0 to loop indefinitely)"""

	def IsAnyAnimationPlaying(self) -> bool: ...
	"""@return True if any animation is currently playing"""

	def IsAnimationPlaying(self, InAnimation: WidgetAnimation) -> bool: ...
	"""Gets whether an animation is currently playing on this widget.

@param InAnimation The animation to check the playback status of
@return True if the animation is currently playing"""

	def SetAnimationCurrentTime(self, InAnimation: WidgetAnimation, InTime: float): ...
	"""Sets the current time of the animation in this widget. Does not change state.

@param The name of the animation to get the current time for
@param The current time of the animation."""

	def GetAnimationCurrentTime(self, InAnimation: WidgetAnimation) -> float: ...
	"""Gets the current time of the animation in this widget

@param The name of the animation to get the current time for
@return the current time of the animation."""

	def PauseAnimation(self, InAnimation: WidgetAnimation) -> float: ...
	"""Pauses an already running animation in this widget

@param The name of the animation to pause
@return the time point the animation was at when it was paused, relative to its start position.  Use this as the StartAtTime when you trigger PlayAnimation."""

	def StopAllAnimations(self): ...
	"""Stop All actively running animations.

@param The name of the animation to stop"""

	def StopAnimation(self, InAnimation: WidgetAnimation): ...
	"""Stops an already running animation in this widget

@param The name of the animation to stop"""

	def PlayAnimationReverse(self, InAnimation: WidgetAnimation, PlaybackSpeed: float = ..., bRestoreState: bool = ...) -> UMGSequencePlayer: ...
	"""Plays an animation on this widget relative to it's current state in reverse.  You should use this version in situations where
say a user can click a button and that causes a panel to slide out, and you want to reverse that same animation to begin sliding
in the opposite direction.

@param InAnimation The animation to play
@param PlayMode Specifies the playback mode
@param PlaybackSpeed The speed at which the animation should play
@param bRestoreState Restores widgets to their pre-animated state when the animation stops"""

	def PlayAnimationForward(self, InAnimation: WidgetAnimation, PlaybackSpeed: float = ..., bRestoreState: bool = ...) -> UMGSequencePlayer: ...
	"""Plays an animation on this widget relative to it's current state forward.  You should use this version in situations where
say a user can click a button and that causes a panel to slide out, and you want to reverse that same animation to begin sliding
in the opposite direction.

@param InAnimation The animation to play
@param PlayMode Specifies the playback mode
@param PlaybackSpeed The speed at which the animation should play
@param bRestoreState Restores widgets to their pre-animated state when the animation stops"""

	def PlayAnimationTimeRange(self, InAnimation: WidgetAnimation, StartAtTime: float = ..., EndAtTime: float = ..., NumLoopsToPlay: int = ..., PlayMode: int = ..., PlaybackSpeed: float = ..., bRestoreState: bool = ...) -> UMGSequencePlayer: ...
	"""Plays an animation in this widget a specified number of times stopping at a specified time

@param InAnimation The animation to play
@param StartAtTime The time in the animation from which to start playing, relative to the start position. For looped animations, this will only affect the first playback of the animation.
@param EndAtTime The absolute time in the animation where to stop, this is only considered in the last loop.
@param NumLoopsToPlay The number of times to loop this animation (0 to loop indefinitely)
@param PlayMode Specifies the playback mode
@param PlaybackSpeed The speed at which the animation should play
@param bRestoreState Restores widgets to their pre-animated state when the animation stops"""

	def PlayAnimation(self, InAnimation: WidgetAnimation, StartAtTime: float = ..., NumLoopsToPlay: int = ..., PlayMode: int = ..., PlaybackSpeed: float = ..., bRestoreState: bool = ...) -> UMGSequencePlayer: ...
	"""Plays an animation in this widget a specified number of times

@param InAnimation The animation to play
@param StartAtTime The time in the animation from which to start playing, relative to the start position. For looped animations, this will only affect the first playback of the animation.
@param NumLoopsToPlay The number of times to loop this animation (0 to loop indefinitely)
@param PlaybackSpeed The speed at which the animation should play
@param PlayMode Specifies the playback mode
@param bRestoreState Restores widgets to their pre-animated state when the animation stops"""

	def SetPadding(self, InPadding: Margin): ...
	"""Sets the padding for the user widget, putting a larger gap between the widget border and it's root widget."""

	def SetForegroundColor(self, InForegroundColor: SlateColor): ...
	"""Sets the foreground color of the widget, this is inherited by sub widgets.  Any color property
that is marked as inherit will use this color.

@param InForegroundColor     The foreground color."""

	def SetColorAndOpacity(self, InColorAndOpacity: LinearColor): ...
	"""Sets the tint of the widget, this affects all child widgets.

@param InColorAndOpacity     The tint to apply to all child widgets."""

	def BindToAnimationEvent(self, Animation: WidgetAnimation, Delegate, AnimationEvent: int, UserTag: str = ...): ...
	"""Allows binding to a specific animation's event.
@param Animation the animation to listen for starting or finishing.
@param Delegate the delegate to call when the animation's state changes
@param AnimationEvent the event to watch for.
@param UserTag Scopes the delegate to only be called when the animation completes with a specific tag set on it when it was played."""

	def UnbindAllFromAnimationFinished(self, Animation: WidgetAnimation): ...
	"""Unbind All from Animation Finished"""

	def UnbindFromAnimationFinished(self, Animation: WidgetAnimation, Delegate): ...
	"""Unbind an animation finished delegate.
@param Animation the animation to listen for starting or finishing.
@param Delegate the delegate to call when the animation's state changes"""

	def BindToAnimationFinished(self, Animation: WidgetAnimation, Delegate): ...
	"""Bind an animation finished delegate.
@param Animation the animation to listen for starting or finishing.
@param Delegate the delegate to call when the animation's state changes"""

	def UnbindAllFromAnimationStarted(self, Animation: WidgetAnimation): ...
	"""Unbind All from Animation Started"""

	def UnbindFromAnimationStarted(self, Animation: WidgetAnimation, Delegate): ...
	"""Unbind an animation started delegate.
@param Animation the animation to listen for starting or finishing.
@param Delegate the delegate to call when the animation's state changes"""

	def BindToAnimationStarted(self, Animation: WidgetAnimation, Delegate): ...
	"""Bind an animation started delegate.
@param Animation the animation to listen for starting or finishing.
@param Delegate the delegate to call when the animation's state changes"""

	def StopAnimationsAndLatentActions(self): ...
	"""Cancels any pending Delays or timer callbacks for this widget, and stops all active animations on the widget."""

	def CancelLatentActions(self): ...
	"""Cancels any pending Delays or timer callbacks for this widget."""

	def GetOwningPlayerCameraManager(self) -> PlayerCameraManager: ...
	"""Gets the player camera manager associated with this UI.
@return Gets the owning player camera manager that's owned by the player controller assigned to this widget."""

	def GetOwningPlayerPawn(self) -> Pawn: ...
	"""Gets the player pawn associated with this UI.
@return Gets the owning player pawn that's owned by the player controller assigned to this widget."""

	def SetOwningPlayer(self, LocalPlayerController: PlayerController): ...
	"""Sets the local player associated with this UI via PlayerController reference.
@param LocalPlayerController The PlayerController of the local player you want to be the conceptual owner of this UI."""

	def IsInViewport(self) -> bool: ...
	"""@return true if the widget was added to the viewport using AddToViewport."""

	def GetAlignmentInViewport(self) -> Vector2D: ...
	"""Get Alignment in Viewport"""

	def GetAnchorsInViewport(self) -> Anchors: ...
	"""Get Anchors in Viewport"""

	def SetAlignmentInViewport(self, Alignment: Vector2D): ...
	"""Set Alignment in Viewport"""

	def SetAnchorsInViewport(self, Anchors: Anchors): ...
	"""Set Anchors in Viewport"""

	def SetDesiredSizeInViewport(self, Size: Vector2D): ...
	"""Set Desired Size in Viewport"""

	def SetPositionInViewport(self, Position: Vector2D, bRemoveDPIScale: bool = ...): ...
	"""Sets the widgets position in the viewport.
@param Position The 2D position to set the widget to in the viewport.
@param bRemoveDPIScale If you've already calculated inverse DPI, set this to false.
Otherwise inverse DPI is applied to the position so that when the location is scaled
by DPI, it ends up in the expected position."""

	def AddToPlayerScreen(self, ZOrder: int = ...) -> bool: ...
	"""Adds the widget to the game's viewport in a section dedicated to the player.  This is valuable in a split screen
game where you need to only show a widget over a player's portion of the viewport.

@param ZOrder The higher the number, the more on top this widget will be."""

	def AddToViewport(self, ZOrder: int = ...): ...
	"""Adds it to the game's viewport and fills the entire screen, unless SetDesiredSizeInViewport is called
to explicitly set the size.

@param ZOrder The higher the number, the more on top this widget will be."""

	def SetPythonInstance(self, PythonInstance: object) -> None: ...

	def NativeConstruct(self) -> None: ...

	def GetWidgetFromName(self, WidgetName: str) -> Widget: ...

	pass

class WidgetBlueprintLibrary(BlueprintFunctionLibrary):
	"""Widget Blueprint Library"""

	@staticmethod
	def SetWindowTitleBarCloseButtonActive(bActive: bool): ...
	"""Set Window Title Bar Close Button Active"""

	@staticmethod
	def SetWindowTitleBarOnCloseClickedDelegate(Delegate): ...
	"""Set Window Title Bar on Close Clicked Delegate"""

	@staticmethod
	def RestorePreviousWindowTitleBarState(): ...
	"""Restore Previous Window Title Bar State"""

	@staticmethod
	def SetWindowTitleBarState(TitleBarContent: Widget, Mode: int, bTitleBarDragEnabled: bool, bWindowButtonsVisible: bool, bTitleBarVisible: bool): ...
	"""Set Window Title Bar State"""

	@staticmethod
	def SetHardwareCursor(WorldContextObject: Object, CursorShape: int, CursorName: str, HotSpot: Vector2D) -> bool: ...
	"""Loads or sets a hardware cursor from the content directory in the game."""

	@staticmethod
	def SetColorVisionDeficiencyType(Type: int, Severity: float, CorrectDeficiency: bool, ShowCorrectionWithDeficiency: bool): ...
	"""Apply color deficiency correction settings to the game window
@param Type The type of color deficiency correction to apply.
@param Severity Intensity of the color deficiency correction effect, from 0 to 1.
@param CorrectDeficiency Shifts the color spectrum to the visible range based on the current deficiency type.
@param ShowCorrectionWithDeficiency If you're correcting the color deficiency, you can use this to visualize what the correction looks like with the deficiency."""

	@staticmethod
	def GetSafeZonePadding(WorldContextObject: Object) -> typing.Tuple[Vector4, Vector2D, Vector4]: ...
	"""Gets the amount of padding that needs to be added when accounting for the safe zone on TVs."""

	@staticmethod
	def GetInputEventFromNavigationEvent(Event: NavigationEvent) -> InputEvent: ...
	"""Get Input Event from Navigation Event"""

	@staticmethod
	def GetInputEventFromPointerEvent(Event: PointerEvent) -> InputEvent: ...
	"""Get Input Event from Pointer Event"""

	@staticmethod
	def GetInputEventFromCharacterEvent(Event: CharacterEvent) -> InputEvent: ...
	"""Get Input Event from Character Event"""

	@staticmethod
	def GetKeyEventFromAnalogInputEvent(Event: AnalogInputEvent) -> KeyEvent: ...
	"""Get Key Event from Analog Input Event"""

	@staticmethod
	def GetInputEventFromKeyEvent(Event: KeyEvent) -> InputEvent: ...
	"""Get Input Event from Key Event"""

	@staticmethod
	def GetAllWidgetsWithInterface(WorldContextObject: Object, Interface, TopLevelOnly: bool) -> typing.List[UserWidget]: ...
	"""Find all widgets in the world with the specified interface.
This is a slow operation, use with caution e.g. do not use every frame.
@param Interface The interface to find. Must be specified or result array will be empty.
@param FoundWidgets Output array of widgets that implement the specified interface.
@param TopLevelOnly Only the widgets that are direct children of the viewport will be returned."""

	@staticmethod
	def GetAllWidgetsOfClass(WorldContextObject: Object, WidgetClass: UserWidget, TopLevelOnly: bool = ...) -> typing.List[UserWidget]: ...
	"""Find all widgets of a certain class.
@param FoundWidgets The widgets that were found matching the filter.
@param WidgetClass The widget class to filter by.
@param TopLevelOnly Only the widgets that are direct children of the viewport will be returned."""

	@staticmethod
	def DismissAllMenus(): ...
	"""Closes any popup menu"""

	@staticmethod
	def GetDynamicMaterial(Brush: SlateBrush) -> MaterialInstanceDynamic: ...
	"""Gets the material that allows changes to parameters at runtime.  The brush must already have a material assigned to it,
if it does it will automatically be converted to a MID.

@return A material that supports dynamic input from the game."""

	@staticmethod
	def NoResourceBrush() -> SlateBrush: ...
	"""Creates a Slate Brush that wont draw anything, the 'Null Brush'.

@return A new slate brush that wont draw anything."""

	@staticmethod
	def SetBrushResourceToMaterial(Brush: SlateBrush, Material: MaterialInterface): ...
	"""Sets the resource on a brush to be a Material."""

	@staticmethod
	def SetBrushResourceToTexture(Brush: SlateBrush, Texture: Texture2D): ...
	"""Sets the resource on a brush to be a UTexture2D."""

	@staticmethod
	def GetBrushResourceAsMaterial(Brush: SlateBrush) -> MaterialInterface: ...
	"""Gets the brush resource as a material."""

	@staticmethod
	def GetBrushResourceAsTexture2D(Brush: SlateBrush) -> Texture2D: ...
	"""Gets the brush resource as a texture 2D."""

	@staticmethod
	def GetBrushResource(Brush: SlateBrush) -> Object: ...
	"""Gets the resource object on a brush.  This could be a UTexture2D or a UMaterialInterface."""

	@staticmethod
	def MakeBrushFromMaterial(Material: MaterialInterface, Width: int = ..., Height: int = ...) -> SlateBrush: ...
	"""Creates a Slate Brush from a Material.  Materials don't have an implicit size, so providing a widget and height
is required to hint slate with how large the image wants to be by default.

@return A new slate brush using the material."""

	@staticmethod
	def MakeBrushFromTexture(Texture: Texture2D, Width: int = ..., Height: int = ...) -> SlateBrush: ...
	"""Creates a Slate Brush from a Texture2D

@param Width  When less than or equal to zero, the Width of the brush will default to the Width of the Texture
@param Height  When less than or equal to zero, the Height of the brush will default to the Height of the Texture

@return A new slate brush using the texture."""

	@staticmethod
	def MakeBrushFromAsset(BrushAsset: SlateBrushAsset) -> SlateBrush: ...
	"""Creates a Slate Brush from a Slate Brush Asset

@return A new slate brush using the asset's brush."""

	@staticmethod
	def CancelDragDrop(): ...
	"""Cancels any current drag drop operation."""

	@staticmethod
	def GetDragDroppingContent() -> DragDropOperation: ...
	"""Returns the drag and drop operation that is currently occurring if any, otherwise nothing."""

	@staticmethod
	def IsDragDropping() -> bool: ...
	"""Returns true if a drag/drop event is occurring that a widget can handle."""

	@staticmethod
	def EndDragDrop(Reply: EventReply) -> EventReply: ...
	"""An event should return FReply::Handled().EndDragDrop() to request that the current drag/drop operation be terminated."""

	@staticmethod
	def DetectDragIfPressed(PointerEvent: PointerEvent, WidgetDetectingDrag: Widget, DragKey: Key) -> EventReply: ...
	"""Given the pointer event, emit the DetectDrag reply if the provided key was pressed.
If the DragKey is a touch key, that will also automatically work.
@param PointerEvent  The pointer device event coming in.
@param WidgetDetectingDrag  Detect dragging in this widget.
@param DragKey                      This button should be pressed to detect the drag, won't emit the DetectDrag FEventReply unless this is pressed."""

	@staticmethod
	def DetectDrag(Reply: EventReply, WidgetDetectingDrag: Widget, DragKey: Key) -> EventReply: ...
	"""Ask Slate to detect if a user starts dragging in this widget later.  Slate internally tracks the movement
and if it surpasses the drag threshold, Slate will send an OnDragDetected event to the widget.

@param WidgetDetectingDrag  Detect dragging in this widget
@param DragKey                      This button should be pressed to detect the drag"""

	@staticmethod
	def SetMousePosition(Reply: EventReply, NewMousePosition: Vector2D) -> EventReply: ...
	"""Set Mouse Position"""

	@staticmethod
	def ClearUserFocus(Reply: EventReply, bInAllUsers: bool = ...) -> EventReply: ...
	"""Clear User Focus"""

	@staticmethod
	def SetUserFocus(Reply: EventReply, FocusWidget: Widget, bInAllUsers: bool = ...) -> EventReply: ...
	"""Set User Focus"""

	@staticmethod
	def UnlockMouse(Reply: EventReply) -> EventReply: ...
	"""Unlock Mouse"""

	@staticmethod
	def LockMouse(Reply: EventReply, CapturingWidget: Widget) -> EventReply: ...
	"""Lock Mouse"""

	@staticmethod
	def ReleaseMouseCapture(Reply: EventReply) -> EventReply: ...
	"""Release Mouse Capture"""

	@staticmethod
	def CaptureMouse(Reply: EventReply, CapturingWidget: Widget) -> EventReply: ...
	"""Capture Mouse"""

	@staticmethod
	def Unhandled() -> EventReply: ...
	"""The event reply to use when you choose not to handle an event."""

	@staticmethod
	def Handled() -> EventReply: ...
	"""The event reply to use when you choose to handle an event.  This will prevent the event
from continuing to bubble up / down the widget hierarchy."""

	@staticmethod
	def DrawTextFormatted(Context: PaintContext, Text: str, Position: Vector2D, Font: Font, FontSize: int = ..., FontTypeFace: str = ..., Tint: LinearColor = ...): ...
	"""Draws text.

@param Text                  The string to draw.
@param Position              The starting position where the text is drawn in local space.
@param Tint                  Color to render the line."""

	@staticmethod
	def DrawLines(Context: PaintContext, Points: typing.List[Vector2D], Tint: LinearColor = ..., bAntiAlias: bool = ..., Thickness: float = ...): ...
	"""Draws several line segments.

@param Points                Line pairs, each line needs to be 2 separate points in the array.
@param Tint                  Color to render the line.
@param bAntialias    Whether the line should be antialiased.
@param Thickness             How many pixels thick this line should be."""

	@staticmethod
	def DrawLine(Context: PaintContext, PositionA: Vector2D, PositionB: Vector2D, Tint: LinearColor = ..., bAntiAlias: bool = ..., Thickness: float = ...): ...
	"""Draws a line.

@param PositionA             Starting position of the line in local space.
@param PositionB             Ending position of the line in local space.
@param Tint                  Color to render the line.
@param bAntialias    Whether the line should be antialiased.
@param Thickness             How many pixels thick this line should be."""

	@staticmethod
	def DrawBox(Context: PaintContext, Position: Vector2D, Size: Vector2D, Brush: SlateBrushAsset, Tint: LinearColor = ...): ...
	"""Draws a box"""

	@staticmethod
	def SetFocusToGameViewport(): ...
	"""Set Focus to Game Viewport"""

	@staticmethod
	def SetInputMode_GameOnly(PlayerController: PlayerController): ...
	"""Setup an input mode that allows only player input / player controller to respond to user input."""

	@staticmethod
	def SetInputMode_GameAndUIEx(PlayerController: PlayerController, InWidgetToFocus: Widget = ..., InMouseLockMode: int = ..., bHideCursorDuringCapture: bool = ...): ...
	"""Setup an input mode that allows only the UI to respond to user input, and if the UI doesn't handle it player input / player controller gets a chance."""

	@staticmethod
	def SetInputMode_UIOnlyEx(PlayerController: PlayerController, InWidgetToFocus: Widget = ..., InMouseLockMode: int = ...): ...
	"""Setup an input mode that allows only the UI to respond to user input."""

	@staticmethod
	def CreateDragDropOperation(OperationClass: DragDropOperation) -> DragDropOperation: ...
	"""Creates a new drag and drop operation that can be returned from a drag begin to inform the UI what i
being dragged and dropped and what it looks like."""

	@staticmethod
	def Create(WorldContext: Object, WidgetType: Class, OwningPlayer: PlayerController = ...) -> UserWidget: ...

	pass

class WidgetLayoutLibrary(BlueprintFunctionLibrary):
	"""Widget Layout Library"""

	@staticmethod
	def RemoveAllWidgets(WorldContextObject: Object): ...
	"""Removes all widgets from the viewport."""

	@staticmethod
	def SlotAsWidgetSwitcherSlot(Widget: Widget) -> WidgetSwitcherSlot: ...
	"""Gets the slot object on the child widget as a Widget Switcher Slot, allowing you to manipulate its information.
@param Widget The child widget of a Widget Switcher Slot."""

	@staticmethod
	def SlotAsWrapBoxSlot(Widget: Widget) -> WrapBoxSlot: ...
	"""Gets the slot object on the child widget as a Wrap Box Slot, allowing you to manipulate its information.
@param Widget The child widget of a Wrap Box."""

	@staticmethod
	def SlotAsSizeBoxSlot(Widget: Widget) -> SizeBoxSlot: ...
	"""Gets the slot object on the child widget as a Size Box Slot, allowing you to manipulate its information.
@param Widget The child widget of a Size Box."""

	@staticmethod
	def SlotAsScaleBoxSlot(Widget: Widget) -> ScaleBoxSlot: ...
	"""Gets the slot object on the child widget as a Scale Box Slot, allowing you to manipulate its information.
@param Widget The child widget of a Scale Box."""

	@staticmethod
	def SlotAsSafeBoxSlot(Widget: Widget) -> SafeZoneSlot: ...
	"""Gets the slot object on the child widget as a Safe Box Slot, allowing you to manipulate its information.
@param Widget The child widget of a Safe Box."""

	@staticmethod
	def SlotAsScrollBoxSlot(Widget: Widget) -> ScrollBoxSlot: ...
	"""Gets the slot object on the child widget as a Scroll Box Slot, allowing you to manipulate its information.
@param Widget The child widget of a Scroll Box."""

	@staticmethod
	def SlotAsVerticalBoxSlot(Widget: Widget) -> VerticalBoxSlot: ...
	"""Gets the slot object on the child widget as a Vertical Box Slot, allowing you to manipulate its information.
@param Widget The child widget of a Vertical Box."""

	@staticmethod
	def SlotAsUniformGridSlot(Widget: Widget) -> UniformGridSlot: ...
	"""Gets the slot object on the child widget as a Uniform Grid Slot, allowing you to manipulate layout information.
@param Widget The child widget of a uniform grid panel."""

	@staticmethod
	def SlotAsOverlaySlot(Widget: Widget) -> OverlaySlot: ...
	"""Gets the slot object on the child widget as a Overlay Slot, allowing you to manipulate layout information.
@param Widget The child widget of a overlay panel."""

	@staticmethod
	def SlotAsHorizontalBoxSlot(Widget: Widget) -> HorizontalBoxSlot: ...
	"""Gets the slot object on the child widget as a Horizontal Box Slot, allowing you to manipulate its information.
@param Widget The child widget of a Horizontal Box."""

	@staticmethod
	def SlotAsGridSlot(Widget: Widget) -> GridSlot: ...
	"""Gets the slot object on the child widget as a Grid Slot, allowing you to manipulate layout information.
@param Widget The child widget of a grid panel."""

	@staticmethod
	def SlotAsCanvasSlot(Widget: Widget) -> CanvasPanelSlot: ...
	"""Gets the slot object on the child widget as a Canvas Slot, allowing you to manipulate layout information.
@param Widget The child widget of a canvas panel."""

	@staticmethod
	def SlotAsBorderSlot(Widget: Widget) -> BorderSlot: ...
	"""Gets the slot object on the child widget as a Border Slot, allowing you to manipulate layout information.
@param Widget The child widget of a border panel."""

	@staticmethod
	def GetMousePositionScaledByDPI(Player: PlayerController) -> typing.Tuple[bool, float, float]: ...
	"""Gets the mouse position of the player controller, scaled by the DPI.  If you're trying to go from raw mouse screenspace coordinates
to fullscreen widget space, you'll need to transform the mouse into DPI Scaled space.  This function performs that scaling.

MousePositionScaledByDPI = MousePosition * (1 / ViewportScale).
        //UE_DEPRECATED(4.17, 'Use GetMousePositionOnViewport() instead.  Optionally and for more options, you can use GetViewportWidgetGeometry and GetPlayerScreenWidgetGeometry are newly introduced to give you the geometry of the viewport and the player screen for widgets to help convert between spaces.')"""

	@staticmethod
	def GetMousePositionOnViewport(WorldContextObject: Object) -> Vector2D: ...
	"""Gets the platform's mouse cursor position in the local space of the viewport widget."""

	@staticmethod
	def GetMousePositionOnPlatform() -> Vector2D: ...
	"""Gets the platform's mouse cursor position.  This is the 'absolute' desktop location of the mouse."""

	@staticmethod
	def GetPlayerScreenWidgetGeometry(PlayerController: PlayerController) -> Geometry: ...
	"""Gets the geometry of the widget holding all widgets added to the 'Player Screen'. You
can use this geometry to convert between absolute and local space of widgets held on this
widget."""

	@staticmethod
	def GetViewportWidgetGeometry(WorldContextObject: Object) -> Geometry: ...
	"""Gets the geometry of the widget holding all widgets added to the 'Viewport'.  You
can use this geometry to convert between absolute and local space of widgets held on this
widget."""

	@staticmethod
	def GetViewportSize(WorldContextObject: Object) -> Vector2D: ...
	"""Gets the size of the game viewport."""

	@staticmethod
	def GetViewportScale(WorldContextObject: Object) -> float: ...
	"""Gets the current DPI Scale being applied to the viewport and all the Widgets."""

	@staticmethod
	def ProjectWorldLocationToWidgetPosition(PlayerController: PlayerController, WorldLocation: Vector, bPlayerViewportRelative: bool) -> typing.Tuple[bool, Vector2D]: ...
	"""Gets the projected world to screen position for a player, then converts it into a widget
position, which takes into account any quality scaling.
@param PlayerController The player controller to project the position in the world to their screen.
@param WorldLocation The world location to project from.
@param ScreenPosition The position in the viewport with quality scale removed and DPI scale remove.
@param bPlayerViewportRelative Should this be relative to the player viewport subregion (useful when using player attached widgets in split screen or when aspect-ratio constrained)
@return true if the position projects onto the screen."""

	pass

class WidgetNavigation(Object):
	"""Widget Navigation"""

	@property
	def Up(self) -> WidgetNavigationData: ...
	"""Happens when the user presses up arrow, joystick, d-pad."""

	@property
	def Down(self) -> WidgetNavigationData: ...
	"""Happens when the user presses down arrow, joystick, d-pad."""

	@property
	def Left(self) -> WidgetNavigationData: ...
	"""Happens when the user presses left arrow, joystick, d-pad."""

	@property
	def Right(self) -> WidgetNavigationData: ...
	"""Happens when the user presses right arrow, joystick, d-pad."""

	@property
	def Next(self) -> WidgetNavigationData: ...
	"""Happens when the user presses Tab."""

	@property
	def Previous(self) -> WidgetNavigationData: ...
	"""Happens when the user presses Shift+Tab."""

	pass

class PanelWidget(Widget):
	"""The base class for all UMG panel widgets.  Panel widgets layout a collection of child widgets."""

	def ClearChildren(self): ...
	"""Remove all child widgets from the panel widget."""

	def HasAnyChildren(self) -> bool: ...
	"""Returns true if there are any child widgets in the panel"""

	def RemoveChild(self, Content: Widget) -> bool: ...
	"""Removes a specific widget from the container.
@return true if the widget was found and removed."""

	def AddChild(self, Content: Widget) -> PanelSlot: ...
	"""Adds a new child widget to the container.  Returns the base slot type,
requires casting to turn it into the type specific to the container."""

	def RemoveChildAt(self, Index: int) -> bool: ...
	"""Removes a child by it's index."""

	def HasChild(self, Content: Widget) -> bool: ...
	"""Returns true if panel contains this widget"""

	def GetChildIndex(self, Content: Widget) -> int: ...
	"""Gets the index of a specific child widget"""

	def GetAllChildren(self) -> typing.List[Widget]: ...
	"""Gets all widgets in the container"""

	def GetChildAt(self, Index: int) -> Widget: ...
	"""Gets the widget at an index.
@param Index The index of the widget.
@return The widget at the given index, or nothing if there is no widget there."""

	def GetChildrenCount(self) -> int: ...
	"""Gets number of child widgets in the container."""

	pass

class ContentWidget(PanelWidget):
	"""Content Widget"""

	def GetContent(self) -> Widget: ...
	"""Get Content"""

	def SetContent(self, Content: Widget) -> PanelSlot: ...
	"""Set Content"""

	def GetContentSlot(self) -> PanelSlot: ...
	"""Get Content Slot"""

	pass

class BackgroundBlur(ContentWidget):
	"""A background blur is a container widget that can contain one child widget, providing an opportunity
to surround it with adjustable padding and apply a post-process Gaussian blur to all content beneath the widget.

* Single Child
* Blur Effect"""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the content horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the content vertically."""

	@property
	def bApplyAlphaToBlur(self) -> bool: ...
	"""True to modulate the strength of the blur based on the widget alpha."""

	@property
	def BlurStrength(self) -> float: ...
	"""How blurry the background is.  Larger numbers mean more blurry but will result in larger runtime cost on the gpu."""

	@property
	def bOverrideAutoRadiusCalculation(self) -> bool: ...
	"""Whether or not the radius should be computed automatically or if it should use the radius"""

	@property
	def BlurRadius(self) -> int: ...
	"""This is the number of pixels which will be weighted in each direction from any given pixel when computing the blur
A larger value is more costly but allows for stronger blurs."""

	@property
	def LowQualityFallbackBrush(self) -> SlateBrush: ...
	"""An image to draw instead of applying a blur when low quality override mode is enabled.
You can enable low quality mode for background blurs by setting the cvar Slate.ForceBackgroundBlurLowQualityOverride to 1.
This is usually done in the project's scalability settings"""

	def SetLowQualityFallbackBrush(self, InBrush: SlateBrush): ...
	"""Set Low Quality Fallback Brush"""

	def SetBlurStrength(self, InStrength: float): ...
	"""Set Blur Strength"""

	def SetBlurRadius(self, InBlurRadius: int): ...
	"""Set Blur Radius"""

	def SetApplyAlphaToBlur(self, bInApplyAlphaToBlur: bool): ...
	"""Set Apply Alpha to Blur"""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class PanelSlot(Visual):
	"""The base class for all Slots in UMG."""

	@property
	def Parent(self) -> PanelWidget: ...
	"""Parent"""

	@property
	def Content(self) -> Widget: ...
	"""Content"""

	pass

class BackgroundBlurSlot(PanelSlot):
	"""The Slot for the UBackgroundBlurSlot, contains the widget displayed in a BackgroundBlur's single slot"""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class Border(ContentWidget):
	"""A border is a container widget that can contain one child widget, providing an opportunity
to surround it with a background image and adjustable padding.

* Single Child
* Image"""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the content horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the content vertically."""

	@property
	def bShowEffectWhenDisabled(self) -> bool: ...
	"""Whether or not to show the disabled effect when this border is disabled"""

	@property
	def ContentColorAndOpacity(self) -> LinearColor: ...
	"""Color and opacity multiplier of content in the border"""

	@property
	def ContentColorAndOpacityDelegate(self) -> typing.Any: ...
	"""A bindable delegate for the ContentColorAndOpacity."""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def Background(self) -> SlateBrush: ...
	"""Brush to drag as the background"""

	@property
	def BackgroundDelegate(self) -> typing.Any: ...
	"""A bindable delegate for the Brush."""

	@property
	def BrushColor(self) -> LinearColor: ...
	"""Color and opacity of the actual border image"""

	@property
	def BrushColorDelegate(self) -> typing.Any: ...
	"""A bindable delegate for the BrushColor."""

	@property
	def DesiredSizeScale(self) -> Vector2D: ...
	"""Scales the computed desired size of this border and its contents. Useful
for making things that slide open without having to hard-code their size.
Note: if the parent widget is set up to ignore this widget's desired size,
then changing this value will have no effect."""

	@property
	def bFlipForRightToLeftFlowDirection(self) -> bool: ...
	"""Flips the background image if the localization's flow direction is RightToLeft"""

	@property
	def OnMouseButtonDownEvent(self) -> typing.Any: ...
	"""On Mouse Button Down Event"""

	@property
	def OnMouseButtonUpEvent(self) -> typing.Any: ...
	"""On Mouse Button Up Event"""

	@property
	def OnMouseMoveEvent(self) -> typing.Any: ...
	"""On Mouse Move Event"""

	@property
	def OnMouseDoubleClickEvent(self) -> typing.Any: ...
	"""On Mouse Double Click Event"""

	def SetDesiredSizeScale(self, InScale: Vector2D): ...
	"""Sets the DesireSizeScale of this border.

@param InScale    The X and Y multipliers for the desired size"""

	def GetDynamicMaterial(self) -> MaterialInstanceDynamic: ...
	"""Get Dynamic Material"""

	def SetBrushFromMaterial(self, Material: MaterialInterface): ...
	"""Set Brush from Material"""

	def SetBrushFromTexture(self, Texture: Texture2D): ...
	"""Set Brush from Texture"""

	def SetBrushFromAsset(self, Asset: SlateBrushAsset): ...
	"""Set Brush from Asset"""

	def SetBrush(self, InBrush: SlateBrush): ...
	"""Set Brush"""

	def SetBrushColor(self, InBrushColor: LinearColor): ...
	"""Set Brush Color"""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	def SetContentColorAndOpacity(self, InContentColorAndOpacity: LinearColor): ...
	"""Set Content Color and Opacity"""

	pass

class BorderSlot(PanelSlot):
	"""The Slot for the UBorderSlot, contains the widget displayed in a border's single slot"""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class Button(ContentWidget):
	"""The button is a click-able primitive widget to enable basic interaction, you
can place any other widget inside a button to make a more complex and
interesting click-able element in your UI.

* Single Child
* Clickable"""

	@property
	def WidgetStyle(self) -> ButtonStyle: ...
	"""The button style used at runtime"""

	@property
	def ColorAndOpacity(self) -> LinearColor: ...
	"""The color multiplier for the button content"""

	@property
	def BackgroundColor(self) -> LinearColor: ...
	"""The color multiplier for the button background"""

	@property
	def ClickMethod(self) -> int: ...
	"""The type of mouse action required by the user to trigger the buttons 'Click'"""

	@property
	def TouchMethod(self) -> int: ...
	"""The type of touch action required by the user to trigger the buttons 'Click'"""

	@property
	def PressMethod(self) -> int: ...
	"""The type of keyboard/gamepad button press action required by the user to trigger the buttons 'Click'"""

	@property
	def IsFocusable(self) -> bool: ...
	"""Sometimes a button should only be mouse-clickable and never keyboard focusable."""

	@property
	def OnClicked(self) -> typing.Any: ...
	"""Called when the button is clicked"""

	@property
	def OnPressed(self) -> typing.Any: ...
	"""Called when the button is pressed"""

	@property
	def OnReleased(self) -> typing.Any: ...
	"""Called when the button is released"""

	@property
	def OnHovered(self) -> typing.Any: ...
	"""On Hovered"""

	@property
	def OnUnhovered(self) -> typing.Any: ...
	"""On Unhovered"""

	def SetPressMethod(self, InPressMethod: int): ...
	"""Set Press Method"""

	def SetTouchMethod(self, InTouchMethod: int): ...
	"""Set Touch Method"""

	def SetClickMethod(self, InClickMethod: int): ...
	"""Set Click Method"""

	def IsPressed(self) -> bool: ...
	"""Returns true if the user is actively pressing the button.  Do not use this for detecting 'Clicks', use the OnClicked event instead.

@return true if the user is actively pressing the button otherwise false."""

	def SetBackgroundColor(self, InBackgroundColor: LinearColor): ...
	"""Sets the color multiplier for the button background"""

	def SetColorAndOpacity(self, InColorAndOpacity: LinearColor): ...
	"""Sets the color multiplier for the button content"""

	def SetStyle(self, InStyle: ButtonStyle): ...
	"""Sets the color multiplier for the button background"""

	pass

class ButtonSlot(PanelSlot):
	"""The Slot for the UButtonSlot, contains the widget displayed in a button's single slot"""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the object horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the object vertically."""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class CanvasPanel(PanelWidget):
	"""The canvas panel is a designer friendly panel that allows widgets to be laid out at arbitrary
locations, anchored and z-ordered with other children of the canvas.  The canvas is a great widget
for manual layout, but bad when you want to procedurally just generate widgets and place them in a
container (unless you want absolute layout).

* Many Children
* Absolute Layout
* Anchors"""

	def AddChildToCanvas(self, Content: Widget) -> CanvasPanelSlot: ...
	"""Add Child to Canvas"""

	pass

class CanvasPanelSlot(PanelSlot):
	"""Canvas Panel Slot"""

	@property
	def LayoutData(self) -> AnchorData: ...
	"""The anchoring information for the slot"""

	@property
	def bAutoSize(self) -> bool: ...
	"""When AutoSize is true we use the widget's desired size"""

	@property
	def ZOrder(self) -> int: ...
	"""The order priority this widget is rendered in.  Higher values are rendered last (and so they will appear to be on top)."""

	def SetMaximum(self, InMaximumAnchors: Vector2D): ...
	"""Sets the anchors on the slot"""

	def SetMinimum(self, InMinimumAnchors: Vector2D): ...
	"""Sets the anchors on the slot"""

	def GetZOrder(self) -> int: ...
	"""Gets the z-order on the slot"""

	def SetZOrder(self, InZOrder: int): ...
	"""Sets the z-order on the slot"""

	def GetAutoSize(self) -> bool: ...
	"""Gets if the slot to be auto-sized"""

	def SetAutoSize(self, InbAutoSize: bool): ...
	"""Sets if the slot to be auto-sized"""

	def GetAlignment(self) -> Vector2D: ...
	"""Gets the alignment on the slot"""

	def SetAlignment(self, InAlignment: Vector2D): ...
	"""Sets the alignment on the slot"""

	def GetAnchors(self) -> Anchors: ...
	"""Gets the anchors on the slot"""

	def SetAnchors(self, InAnchors: Anchors): ...
	"""Sets the anchors on the slot"""

	def GetOffsets(self) -> Margin: ...
	"""Gets the offset data of the slot, which could be position and size, or margins depending on the anchor points"""

	def SetOffsets(self, InOffset: Margin): ...
	"""Sets the offset data of the slot, which could be position and size, or margins depending on the anchor points"""

	def GetSize(self) -> Vector2D: ...
	"""Gets the size of the slot"""

	def SetSize(self, InSize: Vector2D): ...
	"""Sets the size of the slot"""

	def GetPosition(self) -> Vector2D: ...
	"""Gets the position of the slot"""

	def SetPosition(self, InPosition: Vector2D): ...
	"""Sets the position of the slot"""

	def GetLayout(self) -> AnchorData: ...
	"""Gets the layout data of the slot"""

	def SetLayout(self, InLayoutData: AnchorData): ...
	"""Sets the layout data of the slot"""

	pass

class CheckBox(ContentWidget):
	"""The checkbox widget allows you to display a toggled state of 'unchecked', 'checked' and
'indeterminable.  You can use the checkbox for a classic checkbox, or as a toggle button,
or as radio buttons.

* Single Child
* Toggle"""

	@property
	def CheckedState(self) -> int: ...
	"""Whether the check box is currently in a checked state"""

	@property
	def CheckedStateDelegate(self) -> typing.Any: ...
	"""A bindable delegate for the IsChecked."""

	@property
	def WidgetStyle(self) -> CheckBoxStyle: ...
	"""The checkbox bar style"""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""How the content of the toggle button should align within the given space"""

	@property
	def ClickMethod(self) -> int: ...
	"""The type of mouse action required by the user to trigger the buttons 'Click'"""

	@property
	def TouchMethod(self) -> int: ...
	"""The type of touch action required by the user to trigger the buttons 'Click'"""

	@property
	def PressMethod(self) -> int: ...
	"""The type of keyboard/gamepad button press action required by the user to trigger the buttons 'Click'"""

	@property
	def IsFocusable(self) -> bool: ...
	"""Sometimes a button should only be mouse-clickable and never keyboard focusable."""

	@property
	def OnCheckStateChanged(self) -> typing.Any: ...
	"""Called when the checked state has changed"""

	def SetPressMethod(self, InPressMethod: int): ...
	"""Set Press Method"""

	def SetTouchMethod(self, InTouchMethod: int): ...
	"""Set Touch Method"""

	def SetClickMethod(self, InClickMethod: int): ...
	"""Set Click Method"""

	def SetCheckedState(self, InCheckedState: int): ...
	"""Sets the checked state."""

	def SetIsChecked(self, InIsChecked: bool): ...
	"""Sets the checked state."""

	def GetCheckedState(self) -> int: ...
	"""Returns the full current checked state."""

	def IsChecked(self) -> bool: ...
	"""Returns true if the checkbox is currently checked"""

	def IsPressed(self) -> bool: ...
	"""Returns true if this button is currently pressed"""

	pass

class CircularThrobber(Widget):
	"""A throbber widget that orients images in a spinning circle.

* No Children
* Spinner Progress"""

	@property
	def NumberOfPieces(self) -> int: ...
	"""How many pieces there are"""

	@property
	def Period(self) -> float: ...
	"""The amount of time for a full circle (in seconds)"""

	@property
	def Radius(self) -> float: ...
	"""The radius of the circle. If the throbber is a child of Canvas Panel, the 'Size to Content' option must be enabled in order to set Radius."""

	@property
	def Image(self) -> SlateBrush: ...
	"""Image"""

	def SetRadius(self, InRadius: float): ...
	"""Sets the radius of the circle."""

	def SetPeriod(self, InPeriod: float): ...
	"""Sets the amount of time for a full circle (in seconds)."""

	def SetNumberOfPieces(self, InNumberOfPieces: int): ...
	"""Sets how many pieces there are."""

	pass

class ComboBox(Widget):
	"""The combobox allows you to display a list of options to the user in a dropdown menu for them to select one."""

	@property
	def Items(self) -> typing.List[Object]: ...
	"""The list of items to be displayed on the combobox."""

	@property
	def OnGenerateWidgetEvent(self) -> typing.Any: ...
	"""Called when the widget is needed for the item."""

	@property
	def bIsFocusable(self) -> bool: ...
	"""Is Focusable"""

	pass

class ComboBoxString(Widget):
	"""The combobox allows you to display a list of options to the user in a dropdown menu for them to select one."""

	@property
	def WidgetStyle(self) -> ComboBoxStyle: ...
	"""The style."""

	@property
	def ItemStyle(self) -> TableRowStyle: ...
	"""The item row style."""

	@property
	def ContentPadding(self) -> Margin: ...
	"""Content Padding"""

	@property
	def MaxListHeight(self) -> float: ...
	"""The max height of the combobox list that opens"""

	@property
	def HasDownArrow(self) -> bool: ...
	"""When false, the down arrow is not generated and it is up to the API consumer
to make their own visual hint that this is a drop down."""

	@property
	def EnableGamepadNavigationMode(self) -> bool: ...
	"""When false, directional keys will change the selection. When true, ComboBox
must be activated and will only capture arrow input while activated."""

	@property
	def Font(self) -> SlateFontInfo: ...
	"""The default font to use in the combobox, only applies if you're not implementing OnGenerateWidgetEvent
to factory each new entry."""

	@property
	def ForegroundColor(self) -> SlateColor: ...
	"""The foreground color to pass through the hierarchy."""

	@property
	def bIsFocusable(self) -> bool: ...
	"""Is Focusable"""

	@property
	def OnGenerateWidgetEvent(self) -> typing.Any: ...
	"""Called when the widget is needed for the item."""

	@property
	def OnSelectionChanged(self) -> typing.Any: ...
	"""Called when a new item is selected in the combobox."""

	@property
	def OnOpening(self) -> typing.Any: ...
	"""Called when the combobox is opening"""

	def IsOpen(self) -> bool: ...
	"""Is Open"""

	def GetOptionCount(self) -> int: ...
	"""Returns the number of options"""

	def GetSelectedIndex(self) -> int: ...
	"""Get Selected Index"""

	def GetSelectedOption(self) -> str: ...
	"""Get Selected Option"""

	def SetSelectedIndex(self, Index: int): ...
	"""Set Selected Index"""

	def SetSelectedOption(self, Option: str): ...
	"""Set Selected Option"""

	def RefreshOptions(self): ...
	"""Refreshes the list of options.  If you added new ones, and want to update the list even if it's
currently being displayed use this."""

	def ClearSelection(self): ...
	"""Clear Selection"""

	def ClearOptions(self): ...
	"""Clear Options"""

	def GetOptionAtIndex(self, Index: int) -> str: ...
	"""Get Option at Index"""

	def FindOptionIndex(self, Option: str) -> int: ...
	"""Find Option Index"""

	def RemoveOption(self, Option: str) -> bool: ...
	"""Remove Option"""

	def AddOption(self, Option: str): ...
	"""Add Option"""

	pass

class DynamicEntryBoxBase(Widget):
	"""Base for widgets that support a dynamic number of auto-generated entries at both design- and run-time.
Contains all functionality needed to create, construct, and cache an arbitrary number of entry widgets, but exposes no means of entry creation or removal
It's up to child classes to decide how they want to perform the population (some may do so entirely on their own without exposing a thing)

See: UDynamicEntryBox for a ready-to-use version"""

	def SetRadialSettings(self, InSettings: RadialBoxSettings): ...
	"""Set Radial Settings"""

	def SetEntrySpacing(self, InEntrySpacing: Vector2D): ...
	"""Set Entry Spacing"""

	def GetNumEntries(self) -> int: ...
	"""Get Num Entries"""

	def GetAllEntries(self) -> typing.List[UserWidget]: ...
	"""Get All Entries"""

	pass

class DynamicEntryBox(DynamicEntryBoxBase):
	"""A special box panel that auto-generates its entries at both design-time and runtime.
Useful for cases where you can have a varying number of entries, but it isn't worth the effort or conceptual overhead to set up a list/tile view.
Note that entries here are *not* virtualized as they are in the list views, so generally this should be avoided if you intend to scroll through lots of items.

No children can be manually added in the designer - all are auto-generated based on the given entry class."""

	def RemoveEntry(self, EntryWidget: UserWidget): ...
	"""Remove Entry"""

	def Reset(self, bDeleteWidgets: bool = ...): ...
	"""Clear out the box entries, optionally deleting the underlying Slate widgets entirely as well."""

	pass

class EditableText(Widget):
	"""Editable text box widget"""

	@property
	def Text(self) -> str: ...
	"""The text content for this editable text box widget"""

	@property
	def TextDelegate(self) -> typing.Any: ...
	"""A bindable delegate to allow logic to drive the text of the widget"""

	@property
	def HintText(self) -> str: ...
	"""Hint text that appears when there is no text in the text box"""

	@property
	def HintTextDelegate(self) -> typing.Any: ...
	"""A bindable delegate to allow logic to drive the hint text of the widget"""

	@property
	def WidgetStyle(self) -> EditableTextStyle: ...
	"""The style"""

	@property
	def IsReadOnly(self) -> bool: ...
	"""Sets whether this text box can actually be modified interactively by the user"""

	@property
	def IsPassword(self) -> bool: ...
	"""Sets whether this text box is for storing a password"""

	@property
	def MinimumDesiredWidth(self) -> float: ...
	"""Minimum width that a text block should be"""

	@property
	def IsCaretMovedWhenGainFocus(self) -> bool: ...
	"""Workaround as we lose focus when the auto completion closes."""

	@property
	def SelectAllTextWhenFocused(self) -> bool: ...
	"""Whether to select all text when the user clicks to give focus on the widget"""

	@property
	def RevertTextOnEscape(self) -> bool: ...
	"""Whether to allow the user to back out of changes when they press the escape key"""

	@property
	def ClearKeyboardFocusOnCommit(self) -> bool: ...
	"""Whether to clear keyboard focus when pressing enter to commit changes"""

	@property
	def SelectAllTextOnCommit(self) -> bool: ...
	"""Whether to select all text when pressing enter to commit changes"""

	@property
	def AllowContextMenu(self) -> bool: ...
	"""Whether the context menu can be opened"""

	@property
	def KeyboardType(self) -> int: ...
	"""If we're on a platform that requires a virtual keyboard, what kind of keyboard should this widget use?"""

	@property
	def VirtualKeyboardOptions(self) -> typing.Any: ...
	"""Additional options for the virtual keyboard"""

	@property
	def VirtualKeyboardTrigger(self) -> int: ...
	"""Virtual Keyboard Trigger"""

	@property
	def VirtualKeyboardDismissAction(self) -> int: ...
	"""What action should be taken when the virtual keyboard is dismissed?"""

	@property
	def Justification(self) -> int: ...
	"""How the text should be aligned with the margin."""

	@property
	def ShapedTextOptions(self) -> ShapedTextOptions: ...
	"""Controls how the text within this widget should be shaped."""

	@property
	def OnTextChanged(self) -> typing.Any: ...
	"""Called whenever the text is changed programmatically or interactively by the user"""

	@property
	def OnTextCommitted(self) -> typing.Any: ...
	"""Called whenever the text is committed.  This happens when the user presses enter or the text box loses focus."""

	def SetJustification(self, InJustification: int): ...
	"""Set Justification"""

	def SetIsReadOnly(self, InbIsReadyOnly: bool): ...
	"""Set Is Read Only"""

	def SetHintText(self, InHintText: str): ...
	"""Set Hint Text"""

	def SetIsPassword(self, InbIsPassword: bool): ...
	"""Set Is Password"""

	def SetText(self, InText: str): ...
	"""Directly sets the widget text.
Warning: This will wipe any binding created for the Text property!
@param InText The text to assign to the widget"""

	def GetText(self) -> str: ...
	"""Gets the widget text
@return The widget text"""

	pass

class EditableTextBox(Widget):
	"""Allows the user to type in custom text.  Only permits a single line of text to be entered.

* No Children
* Text Entry"""

	@property
	def Text(self) -> str: ...
	"""The text content for this editable text box widget"""

	@property
	def TextDelegate(self) -> typing.Any: ...
	"""A bindable delegate to allow logic to drive the text of the widget"""

	@property
	def WidgetStyle(self) -> EditableTextBoxStyle: ...
	"""The style"""

	@property
	def HintText(self) -> str: ...
	"""Hint text that appears when there is no text in the text box"""

	@property
	def HintTextDelegate(self) -> typing.Any: ...
	"""A bindable delegate to allow logic to drive the hint text of the widget"""

	@property
	def IsReadOnly(self) -> bool: ...
	"""Sets whether this text box can actually be modified interactively by the user"""

	@property
	def IsPassword(self) -> bool: ...
	"""Sets whether this text box is for storing a password"""

	@property
	def MinimumDesiredWidth(self) -> float: ...
	"""Minimum width that a text block should be"""

	@property
	def IsCaretMovedWhenGainFocus(self) -> bool: ...
	"""Workaround as we lose focus when the auto completion closes."""

	@property
	def SelectAllTextWhenFocused(self) -> bool: ...
	"""Whether to select all text when the user clicks to give focus on the widget"""

	@property
	def RevertTextOnEscape(self) -> bool: ...
	"""Whether to allow the user to back out of changes when they press the escape key"""

	@property
	def ClearKeyboardFocusOnCommit(self) -> bool: ...
	"""Whether to clear keyboard focus when pressing enter to commit changes"""

	@property
	def SelectAllTextOnCommit(self) -> bool: ...
	"""Whether to select all text when pressing enter to commit changes"""

	@property
	def AllowContextMenu(self) -> bool: ...
	"""Whether the context menu can be opened"""

	@property
	def KeyboardType(self) -> int: ...
	"""If we're on a platform that requires a virtual keyboard, what kind of keyboard should this widget use?"""

	@property
	def VirtualKeyboardOptions(self) -> typing.Any: ...
	"""Additional options to use for the virtual keyboard summoned by this widget"""

	@property
	def VirtualKeyboardTrigger(self) -> int: ...
	"""The type of event that will trigger the display of the virtual keyboard"""

	@property
	def VirtualKeyboardDismissAction(self) -> int: ...
	"""What action should be taken when the virtual keyboard is dismissed?"""

	@property
	def Justification(self) -> int: ...
	"""How the text should be aligned with the margin."""

	@property
	def ShapedTextOptions(self) -> ShapedTextOptions: ...
	"""Controls how the text within this widget should be shaped."""

	@property
	def OnTextChanged(self) -> typing.Any: ...
	"""Called whenever the text is changed programmatically or interactively by the user"""

	@property
	def OnTextCommitted(self) -> typing.Any: ...
	"""Called whenever the text is committed.  This happens when the user presses enter or the text box loses focus."""

	def SetJustification(self, InJustification: int): ...
	"""Set Justification"""

	def HasError(self) -> bool: ...
	"""Has Error"""

	def ClearError(self): ...
	"""Clear Error"""

	def SetIsPassword(self, bIsPassword: bool): ...
	"""Set Is Password"""

	def SetIsReadOnly(self, bReadOnly: bool): ...
	"""Set Is Read Only"""

	def SetError(self, InError: str): ...
	"""Set Error"""

	def SetHintText(self, InText: str): ...
	"""Set Hint Text"""

	def SetText(self, InText: str): ...
	"""Set Text"""

	def GetText(self) -> str: ...
	"""Get Text"""

	pass

class ExpandableArea(Widget):
	"""Expandable Area"""

	@property
	def Style(self) -> typing.Any: ...
	"""Style"""

	@property
	def BorderBrush(self) -> SlateBrush: ...
	"""Border Brush"""

	@property
	def BorderColor(self) -> SlateColor: ...
	"""Border Color"""

	@property
	def bIsExpanded(self) -> bool: ...
	"""Is Expanded"""

	@property
	def MaxHeight(self) -> float: ...
	"""The maximum height of the area"""

	@property
	def HeaderPadding(self) -> Margin: ...
	"""Header Padding"""

	@property
	def AreaPadding(self) -> Margin: ...
	"""Area Padding"""

	@property
	def OnExpansionChanged(self) -> typing.Any: ...
	"""A bindable delegate for the IsChecked."""

	def SetIsExpanded_Animated(self, IsExpanded: bool): ...
	"""Set Is Expanded Animated"""

	def SetIsExpanded(self, IsExpanded: bool): ...
	"""Set Is Expanded"""

	def GetIsExpanded(self) -> bool: ...
	"""Get Is Expanded"""

	pass

class GridPanel(PanelWidget):
	"""A table-like panel that retains the width of every column throughout the table.

* Many Children"""

	@property
	def ColumnFill(self) -> typing.List[float]: ...
	"""The column fill rules"""

	@property
	def RowFill(self) -> typing.List[float]: ...
	"""The row fill rules"""

	def SetRowFill(self, ColumnIndex: int, Coefficient: float): ...
	"""Set Row Fill"""

	def SetColumnFill(self, ColumnIndex: int, Coefficient: float): ...
	"""Set Column Fill"""

	def AddChildToGrid(self, Content: Widget, InRow: int = ..., InColumn: int = ...) -> GridSlot: ...
	"""Add Child to Grid"""

	pass

class GridSlot(PanelSlot):
	"""A slot for UGridPanel, these slots all share the same size as the largest slot
in the grid."""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the object horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the object vertically."""

	@property
	def Row(self) -> int: ...
	"""The row index of the cell this slot is in"""

	@property
	def RowSpan(self) -> int: ...
	"""Row Span"""

	@property
	def Column(self) -> int: ...
	"""The column index of the cell this slot is in"""

	@property
	def ColumnSpan(self) -> int: ...
	"""Column Span"""

	@property
	def Layer(self) -> int: ...
	"""Positive values offset this cell to be hit-tested and drawn on top of others. Default is 0; i.e. no offset."""

	@property
	def Nudge(self) -> Vector2D: ...
	"""Offset this slot's content by some amount; positive values offset to lower right"""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetNudge(self, InNudge: Vector2D): ...
	"""Sets the offset for this slot's content by some amount; positive values offset to lower right"""

	def SetLayer(self, InLayer: int): ...
	"""Sets positive values offset this cell to be hit-tested and drawn on top of others."""

	def SetColumnSpan(self, InColumnSpan: int): ...
	"""How many columns this slot spans over"""

	def SetColumn(self, InColumn: int): ...
	"""Sets the column index of the slot, this determines what cell the slot is in the panel"""

	def SetRowSpan(self, InRowSpan: int): ...
	"""How many rows this this slot spans over"""

	def SetRow(self, InRow: int): ...
	"""Sets the row index of the slot, this determines what cell the slot is in the panel"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class HorizontalBox(PanelWidget):
	"""Allows widgets to be laid out in a flow horizontally.

* Many Children
* Flow Horizontal"""

	def AddChildToHorizontalBox(self, Content: Widget) -> HorizontalBoxSlot: ...
	"""Add Child to Horizontal Box"""

	pass

class HorizontalBoxSlot(PanelSlot):
	"""Horizontal Box Slot"""

	@property
	def Padding(self) -> Margin: ...
	"""The amount of padding between the slots parent and the content."""

	@property
	def Size(self) -> SlateChildSize: ...
	"""How much space this slot should occupy in the direction of the panel."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""Horizontal Alignment"""

	@property
	def VerticalAlignment(self) -> int: ...
	"""Vertical Alignment"""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetSize(self, InSize: SlateChildSize): ...
	"""Set Size"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class Image(Widget):
	"""The image widget allows you to display a Slate Brush, or texture or material in the UI.

* No Children"""

	@property
	def Brush(self) -> SlateBrush: ...
	"""Image to draw"""

	@property
	def BrushDelegate(self) -> typing.Any: ...
	"""A bindable delegate for the Image."""

	@property
	def ColorAndOpacity(self) -> LinearColor: ...
	"""Color and opacity"""

	@property
	def ColorAndOpacityDelegate(self) -> typing.Any: ...
	"""A bindable delegate for the ColorAndOpacity."""

	@property
	def bFlipForRightToLeftFlowDirection(self) -> bool: ...
	"""Flips the image if the localization's flow direction is RightToLeft"""

	@property
	def OnMouseButtonDownEvent(self) -> typing.Any: ...
	"""On Mouse Button Down Event"""

	def GetDynamicMaterial(self) -> MaterialInstanceDynamic: ...
	"""Get Dynamic Material"""

	def SetBrushFromSoftMaterial(self, SoftMaterial): ...
	"""Set Brush from Soft Material"""

	def SetBrushFromSoftTexture(self, SoftTexture, bMatchSize: bool = ...): ...
	"""Sets the Brush to the specified Soft Texture.

  @param SoftTexture Soft Texture to use to set on Brush.
      @param bMatchSize If true, image will change its size to texture size. If false, texture will be stretched to image size."""

	def SetBrushFromMaterial(self, Material: MaterialInterface): ...
	"""Set Brush from Material"""

	def SetBrushFromTextureDynamic(self, Texture: Texture2DDynamic, bMatchSize: bool = ...): ...
	"""Sets the Brush to the specified Dynamic Texture.

  @param Texture Dynamic Texture to use to set on Brush.
      @param bMatchSize If true, image will change its size to texture size. If false, texture will be stretched to image size."""

	def SetBrushFromAtlasInterface(self, AtlasRegion, bMatchSize: bool = ...): ...
	"""Sets the Brush to the specified Atlas Region.

  @param AtlasRegion Region of the Atlas to use to set on Brush.
      @param bMatchSize If true, image will change its size to atlas region size. If false, atlas region will be stretched to image size."""

	def SetBrushFromTexture(self, Texture: Texture2D, bMatchSize: bool = ...): ...
	"""Sets the Brush to the specified Texture.

  @param Texture Texture to use to set on Brush.
      @param bMatchSize If true, image will change its size to texture size. If false, texture will be stretched to image size."""

	def SetBrushFromAsset(self, Asset: SlateBrushAsset): ...
	"""Set Brush from Asset"""

	def SetBrush(self, InBrush: SlateBrush): ...
	"""Set Brush"""

	def SetBrushResourceObject(self, ResourceObject: Object): ...
	"""Set Brush Resource Object"""

	def SetBrushTintColor(self, TintColor: SlateColor): ...
	"""Set Brush Tint Color"""

	def SetBrushSize(self, DesiredSize: Vector2D): ...
	"""Set Brush Size"""

	def SetOpacity(self, InOpacity: float): ...
	"""Set Opacity"""

	def SetColorAndOpacity(self, InColorAndOpacity: LinearColor): ...
	"""Set Color and Opacity"""

	pass

class InputKeySelector(Widget):
	"""A widget for selecting a single key or a single key with a modifier."""

	@property
	def WidgetStyle(self) -> ButtonStyle: ...
	"""The button style used at runtime"""

	@property
	def TextStyle(self) -> TextBlockStyle: ...
	"""The button style used at runtime"""

	@property
	def SelectedKey(self) -> InputChord: ...
	"""The currently selected key chord."""

	@property
	def Margin(self) -> Margin: ...
	"""The amount of blank space around the text used to display the currently selected key."""

	@property
	def KeySelectionText(self) -> str: ...
	"""Sets the text which is displayed while selecting keys."""

	@property
	def NoKeySpecifiedText(self) -> str: ...
	"""Sets the text to display when no key text is available or not selecting a key."""

	@property
	def bAllowModifierKeys(self) -> bool: ...
	"""input chord representing the selected key, if false modifier keys are ignored."""

	@property
	def bAllowGamepadKeys(self) -> bool: ...
	"""When true gamepad keys are allowed in the input chord representing the selected key, otherwise they are ignored."""

	@property
	def EscapeKeys(self) -> typing.List[Key]: ...
	"""When true gamepad keys are allowed in the input chord representing the selected key, otherwise they are ignored."""

	@property
	def OnKeySelected(self) -> typing.Any: ...
	"""Called whenever a new key is selected by the user."""

	@property
	def OnIsSelectingKeyChanged(self) -> typing.Any: ...
	"""Called whenever the key selection mode starts or stops."""

	def SetEscapeKeys(self, InKeys: typing.List[Key]): ...
	"""Sets escape keys."""

	def SetTextBlockVisibility(self, InVisibility: int): ...
	"""Sets the visibility of the text block."""

	def GetIsSelectingKey(self) -> bool: ...
	"""Returns true if the widget is currently selecting a key, otherwise returns false."""

	def SetAllowGamepadKeys(self, bInAllowGamepadKeys: bool): ...
	"""Sets whether or not gamepad keys are allowed in the selected key."""

	def SetAllowModifierKeys(self, bInAllowModifierKeys: bool): ...
	"""Sets whether or not modifier keys are allowed in the selected key."""

	def SetNoKeySpecifiedText(self, InNoKeySpecifiedText: str): ...
	"""Sets the text to display when no key text is available or not selecting a key."""

	def SetKeySelectionText(self, InKeySelectionText: str): ...
	"""Sets the text which is displayed while selecting keys."""

	def SetSelectedKey(self, InSelectedKey: InputChord): ...
	"""Sets the currently selected key."""

	pass

class InvalidationBox(ContentWidget):
	"""Invalidate
* Single Child
* Caching / Performance"""

	def SetCanCache(self, CanCache: bool): ...
	"""Set Can Cache"""

	def GetCanCache(self) -> bool: ...
	"""Get Can Cache"""

	def InvalidateCache(self): ...
	"""Invalidate Cache"""

	pass

class ListViewBase(Widget):
	"""Bare-bones base class to make creating custom UListView widgets easier.
Child classes should also inherit from ITypedUMGListView<T> to get a basic public ListView API for free.

Child classes will own the actual SListView<T> widgets, but this provides some boilerplate functionality for generating entries.
To generate a row for the child list, use GenerateTypedRow with the appropriate SObjectTableRow<T> type for your list

Additionally, the entry widget class can be filtered for a particular class and interface with the EntryClass and EntryInterface metadata arguments
This can be specified either on the class directly (see below) or on any BindWidget FProperty

Example:
class UMyUserWidget : public UUserWidget
{
            UPROPERTY(BindWidget, meta = (EntryClass = MyListEntryWidget))
            UListView* ListView_InventoryItems;"""

	def RequestRefresh(self): ...
	"""Sets the list to refresh on the next tick.

Note that refreshing, from a list perspective, is limited to accounting for discrepancies between items and entries.
In other words, it will only release entries that no longer have items and generate entries for new items (or newly visible items).

It does NOT account for changes within existing items - that is up to the item to announce and an entry to listen to as needed.
This can be onerous to set up for simple cases, so it's also reasonable (though not ideal) to call RegenerateAllEntries when changes within N list items need to be reflected."""

	def SetScrollbarVisibility(self, InVisibility: int): ...
	"""Set Scrollbar Visibility"""

	def SetWheelScrollMultiplier(self, NewWheelScrollMultiplier: float): ...
	"""Set Wheel Scroll Multiplier"""

	def SetScrollOffset(self, InScrollOffset: float): ...
	"""Set the scroll offset of this view (in items)"""

	def ScrollToBottom(self): ...
	"""Scroll the entire list down to the bottom-most item"""

	def ScrollToTop(self): ...
	"""Scroll the entire list up to the first item"""

	def RegenerateAllEntries(self): ...
	"""Full regeneration of all entries in the list. Note that the entry UWidget instances will not be destroyed, but they will be released and re-generated.
In other words, entry widgets will not receive Destruct/Construct events. They will receive OnEntryReleased and IUserObjectListEntry implementations will receive OnListItemObjectSet."""

	def GetDisplayedEntryWidgets(self) -> typing.List[UserWidget]: ...
	"""Gets all of the list entry widgets currently being displayed by the list"""

	pass

class ListView(ListViewBase):
	"""A virtualized list that allows up to thousands of items to be displayed.

An important distinction to keep in mind here is 'Item' vs. 'Entry'
The list itself is based on a list of n items, but only creates as many entry widgets as can fit on screen.
For example, a scrolling ListView of 200 items with 5 currently visible will only have created 5 entry widgets.

To make a widget usable as an entry in a ListView, it must inherit from the IUserObjectListEntry interface."""

	def NavigateToIndex(self, Index: int): ...
	"""Requests that the item at the given index navigated to, scrolling it into view if needed."""

	def SetSelectedIndex(self, Index: int): ...
	"""Sets the item at the given index as the sole selected item."""

	def ScrollIndexIntoView(self, Index: int): ...
	"""Requests that the item at the given index is scrolled into view"""

	def IsRefreshPending(self) -> bool: ...
	"""Returns true if a refresh is pending and the list will be rebuilt on the next tick"""

	def SetSelectionMode(self, SelectionMode: int): ...
	"""Sets the new selection mode, preserving the current selection where possible."""

	def ClearListItems(self): ...
	"""Removes all items from the list"""

	def GetIndexForItem(self, Item: Object) -> int: ...
	"""Returns the index that the specified item is at. Will return the first found, or -1 for not found"""

	def GetNumItems(self) -> int: ...
	"""Returns the total number of items"""

	def GetItemAt(self, Index: int) -> Object: ...
	"""Returns the item at the given index"""

	def RemoveItem(self, Item: Object): ...
	"""Removes an the item from the list"""

	def AddItem(self, Item: Object): ...
	"""Adds an the item to the list"""

	def GetListItems(self) -> typing.List[Object]: ...
	"""Gets the list of all items in the list.
Note that each of these items only has a corresponding entry widget when visible. Use GetDisplayedEntryWidgets to get the currently displayed widgets."""

	pass

class MenuAnchor(ContentWidget):
	"""The Menu Anchor allows you to specify an location that a popup menu should be anchored to,
and should be summoned from.
* Single Child
* Popup"""

	@property
	def MenuClass(self) -> UserWidget: ...
	"""The widget class to spawn when the menu is required.  Creates the widget freshly each time.
If you want to customize the creation of the popup, you should bind a function to OnGetMenuContentEvent
instead."""

	@property
	def OnGetMenuContentEvent(self) -> typing.Any: ...
	"""On Get Menu Content Event"""

	@property
	def OnGetUserMenuContentEvent(self) -> typing.Any: ...
	"""Called when the menu content is requested to allow a more customized handling over what to display"""

	@property
	def Placement(self) -> int: ...
	"""The placement location of the summoned widget."""

	@property
	def bFitInWindow(self) -> bool: ...
	"""Should the menu anchor attempt to fit the menu inside the window."""

	@property
	def ShouldDeferPaintingAfterWindowContent(self) -> bool: ...
	"""Should Defer Painting After Window Content"""

	@property
	def UseApplicationMenuStack(self) -> bool: ...
	"""Does this menu behave like a normal stacked menu? Set it to false to control the menu's lifetime yourself."""

	@property
	def OnMenuOpenChanged(self) -> typing.Any: ...
	"""Called when the opened state of the menu changes"""

	def HasOpenSubMenus(self) -> bool: ...
	"""Returns whether this menu has open submenus"""

	def GetMenuPosition(self) -> Vector2D: ...
	"""Returns the current menu position"""

	def ShouldOpenDueToClick(self) -> bool: ...
	"""Returns true if we should open the menu due to a click. Sometimes we should not, if
the same MouseDownEvent that just closed the menu is about to re-open it because it
happens to land on the button."""

	def IsOpen(self) -> bool: ...
	"""Returns true if the popup is open; false otherwise."""

	def Close(self): ...
	"""Closes the menu if it is currently open."""

	def Open(self, bFocusMenu: bool): ...
	"""Opens the menu if it is not already open"""

	def ToggleOpen(self, bFocusOnOpen: bool): ...
	"""Toggles the menus open state.

@param bFocusOnOpen  Should we focus the popup as soon as it opens?"""

	def FitInWindow(self, bFit: bool): ...
	"""Fit in Window"""

	def SetPlacement(self, InPlacement: int): ...
	"""TODO UMG Add Set MenuClass"""

	pass

class TextLayoutWidget(Widget):
	"""Base class for all widgets that use a text layout.
Contains the common options that should be exposed for the underlying Slate widget."""

	def SetJustification(self, InJustification: int): ...
	"""Set Justification"""

	pass

class MultiLineEditableText(TextLayoutWidget):
	"""Editable text box widget"""

	@property
	def Text(self) -> str: ...
	"""The text content for this editable text box widget"""

	@property
	def HintText(self) -> str: ...
	"""Hint text that appears when there is no text in the text box"""

	@property
	def HintTextDelegate(self) -> typing.Any: ...
	"""A bindable delegate to allow logic to drive the hint text of the widget"""

	@property
	def WidgetStyle(self) -> TextBlockStyle: ...
	"""The style"""

	@property
	def bIsReadOnly(self) -> bool: ...
	"""Sets whether this text block can be modified interactively by the user"""

	@property
	def SelectAllTextWhenFocused(self) -> bool: ...
	"""Whether to select all text when the user clicks to give focus on the widget"""

	@property
	def ClearTextSelectionOnFocusLoss(self) -> bool: ...
	"""Whether to clear text selection when focus is lost"""

	@property
	def RevertTextOnEscape(self) -> bool: ...
	"""Whether to allow the user to back out of changes when they press the escape key"""

	@property
	def ClearKeyboardFocusOnCommit(self) -> bool: ...
	"""Whether to clear keyboard focus when pressing enter to commit changes"""

	@property
	def AllowContextMenu(self) -> bool: ...
	"""Whether the context menu can be opened"""

	@property
	def VirtualKeyboardOptions(self) -> typing.Any: ...
	"""Additional options for the virtual keyboard"""

	@property
	def VirtualKeyboardDismissAction(self) -> int: ...
	"""What action should be taken when the virtual keyboard is dismissed?"""

	@property
	def OnTextChanged(self) -> typing.Any: ...
	"""Called whenever the text is changed programmatically or interactively by the user"""

	@property
	def OnTextCommitted(self) -> typing.Any: ...
	"""Called whenever the text is committed.  This happens when the user presses enter or the text box loses focus."""

	def SetWidgetStyle(self, InWidgetStyle: TextBlockStyle): ...
	"""Set Widget Style"""

	def SetIsReadOnly(self, bReadOnly: bool): ...
	"""Set Is Read Only"""

	def SetHintText(self, InHintText: str): ...
	"""Set Hint Text"""

	def GetHintText(self) -> str: ...
	"""Get Hint Text"""

	def SetText(self, InText: str): ...
	"""Set Text"""

	def GetText(self) -> str: ...
	"""Get Text"""

	pass

class MultiLineEditableTextBox(TextLayoutWidget):
	"""Allows a user to enter multiple lines of text"""

	@property
	def Text(self) -> str: ...
	"""The text content for this editable text box widget"""

	@property
	def HintText(self) -> str: ...
	"""Hint text that appears when there is no text in the text box"""

	@property
	def HintTextDelegate(self) -> typing.Any: ...
	"""A bindable delegate to allow logic to drive the hint text of the widget"""

	@property
	def WidgetStyle(self) -> EditableTextBoxStyle: ...
	"""The style"""

	@property
	def TextStyle(self) -> TextBlockStyle: ...
	"""The text style"""

	@property
	def bIsReadOnly(self) -> bool: ...
	"""Sets whether this text block can be modified interactively by the user"""

	@property
	def AllowContextMenu(self) -> bool: ...
	"""Whether the context menu can be opened"""

	@property
	def VirtualKeyboardOptions(self) -> typing.Any: ...
	"""Additional options to be used by the virtual keyboard summoned from this widget"""

	@property
	def VirtualKeyboardDismissAction(self) -> int: ...
	"""What action should be taken when the virtual keyboard is dismissed?"""

	@property
	def OnTextChanged(self) -> typing.Any: ...
	"""Called whenever the text is changed programmatically or interactively by the user"""

	@property
	def OnTextCommitted(self) -> typing.Any: ...
	"""Called whenever the text is committed.  This happens when the user presses enter or the text box loses focus."""

	def SetTextStyle(self, InTextStyle: TextBlockStyle): ...
	"""Set Text Style"""

	def SetIsReadOnly(self, bReadOnly: bool): ...
	"""Set Is Read Only"""

	def SetError(self, InError: str): ...
	"""Set Error"""

	def SetHintText(self, InHintText: str): ...
	"""Set Hint Text"""

	def GetHintText(self) -> str: ...
	"""Get Hint Text"""

	def SetText(self, InText: str): ...
	"""Set Text"""

	def GetText(self) -> str: ...
	"""Get Text"""

	pass

class NamedSlot(ContentWidget):
	"""Allows you to expose an external slot for your user widget.  When others reuse your user control,
they can put whatever they want in this named slot."""

	pass

class NativeWidgetHost(Widget):
	"""A NativeWidgetHost is a container widget that can contain one child slate widget.  This should
be used when all you need is to nest a native widget inside a UMG widget."""

	pass

class Overlay(PanelWidget):
	"""Allows widgets to be stacked on top of each other, uses simple flow layout for content on each layer."""

	def AddChildToOverlay(self, Content: Widget) -> OverlaySlot: ...
	"""Add Child to Overlay"""

	pass

class OverlaySlot(PanelSlot):
	"""Slot for the UOverlay panel.  Allows content to be hover above other content."""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the object horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the object vertically."""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class ProgressBar(Widget):
	"""The progress bar widget is a simple bar that fills up that can be restyled to fit any number of uses.

* No Children"""

	@property
	def WidgetStyle(self) -> ProgressBarStyle: ...
	"""The progress bar style"""

	@property
	def Percent(self) -> float: ...
	"""Used to determine the fill position of the progress bar ranging 0..1"""

	@property
	def BarFillType(self) -> int: ...
	"""Defines if this progress bar fills Left to right or right to left"""

	@property
	def bIsMarquee(self) -> bool: ...
	"""Is Marquee"""

	@property
	def BorderPadding(self) -> Vector2D: ...
	"""Border Padding"""

	@property
	def PercentDelegate(self) -> typing.Any: ...
	"""A bindable delegate to allow logic to drive the text of the widget"""

	@property
	def FillColorAndOpacity(self) -> LinearColor: ...
	"""Fill Color and Opacity"""

	@property
	def FillColorAndOpacityDelegate(self) -> typing.Any: ...
	"""Fill Color and Opacity Delegate"""

	def SetIsMarquee(self, InbIsMarquee: bool): ...
	"""Sets the progress bar to show as a marquee."""

	def SetFillColorAndOpacity(self, InColor: LinearColor): ...
	"""Sets the fill color of the progress bar."""

	def SetPercent(self, InPercent: float): ...
	"""Sets the current value of the ProgressBar."""

	pass

class RetainerBox(ContentWidget):
	"""The Retainer Box renders children widgets to a render target first before
later rendering that render target to the screen.  This allows both frequency
and phase to be controlled so that the UI can actually render less often than the
frequency of the main game render.  It also has the side benefit of allow materials
to be applied to the render target after drawing the widgets to apply a simple post process.

* Single Child
* Caching / Performance"""

	@property
	def RenderOnInvalidation(self) -> bool: ...
	"""Should this widget redraw the contents it has every time it receives an invalidation request
from it's children, similar to the invalidation panel."""

	@property
	def RenderOnPhase(self) -> bool: ...
	"""Should this widget redraw the contents it has every time the phase occurs."""

	@property
	def Phase(self) -> int: ...
	"""The Phase this widget will draw on.

If the Phase is 0, and the PhaseCount is 1, the widget will be drawn fresh every frame.
If the Phase were 0, and the PhaseCount were 2, this retainer would draw a fresh frame every
other frame.  So in a 60Hz game, the UI would render at 30Hz."""

	@property
	def PhaseCount(self) -> int: ...
	"""The PhaseCount controls how many phases are possible know what to modulus the current frame
count by to determine if this is the current frame to draw the widget on.

If the Phase is 0, and the PhaseCount is 1, the widget will be drawn fresh every frame.
If the Phase were 0, and the PhaseCount were 2, this retainer would draw a fresh frame every
other frame.  So in a 60Hz game, the UI would render at 30Hz."""

	def SetRetainRendering(self, bInRetainRendering: bool): ...
	"""Set the flag for if we retain the render or pass-through"""

	def SetTextureParameter(self, TextureParameter: str): ...
	"""Sets the name of the texture parameter to set the render target to on the material."""

	def SetEffectMaterial(self, EffectMaterial: MaterialInterface): ...
	"""Set a new effect material to the retainer widget."""

	def GetEffectMaterial(self) -> MaterialInstanceDynamic: ...
	"""Get the current dynamic effect material applied to the retainer box."""

	def RequestRender(self): ...
	"""Requests the retainer redrawn the contents it has."""

	def SetRenderingPhase(self, RenderPhase: int, TotalPhases: int): ...
	"""Requests the retainer redrawn the contents it has."""

	pass

class RichTextBlock(TextLayoutWidget):
	"""The rich text block

* Fancy Text
* No Children"""

	def GetDecoratorByClass(self, DecoratorClass: RichTextBlockDecorator) -> RichTextBlockDecorator: ...
	"""Get Decorator by Class"""

	def SetTextStyleSet(self, NewTextStyleSet: DataTable): ...
	"""Set Text Style Set"""

	def SetText(self, InText: str): ...
	"""Directly sets the widget text.
Warning: This will wipe any binding created for the Text property!
@param InText The text to assign to the widget"""

	def GetText(self) -> str: ...
	"""Returns widgets text."""

	def ClearAllDefaultStyleOverrides(self): ...
	"""Remove all overrides made to the default text style and return to the style specified in the style set data table"""

	def SetDefaultTextStyle(self, InDefaultTextStyle: TextBlockStyle): ...
	"""Wholesale override of the currently established default text style
@param InDefaultTextStyle The new text style to apply to all default (i.e. undecorated) text in the block"""

	def SetTextTransformPolicy(self, InTransformPolicy: int): ...
	"""Set the text transformation policy for this text block.
@param InTransformPolicy the new text transformation policy."""

	def SetAutoWrapText(self, InAutoTextWrap: bool): ...
	"""Set the auto wrap for this rich text block
@param InAutoTextWrap to turn wrap on or off"""

	def SetMinDesiredWidth(self, InMinDesiredWidth: float): ...
	"""Set the minimum desired width for this rich text block
@param InMinDesiredWidth new minimum desired width"""

	def SetDefaultStrikeBrush(self) -> SlateBrush: ...
	"""Dynamically set the default strike brush for this rich text block
@param InStrikeBrush The new brush to use to strike through text"""

	def SetDefaultFont(self, InFontInfo: SlateFontInfo): ...
	"""Dynamically set the default font info for this rich text block
@param InFontInfo The new font info"""

	def SetDefaultShadowOffset(self, InShadowOffset: Vector2D): ...
	"""Sets the offset that the default text drop shadow should be drawn at
@param InShadowOffset                The new offset"""

	def SetDefaultShadowColorAndOpacity(self, InShadowColorAndOpacity: LinearColor): ...
	"""Sets the color and opacity of the default text drop shadow
Note: if opacity is zero no shadow will be drawn
@param InShadowColorAndOpacity               The new drop shadow color and opacity"""

	def SetDefaultColorAndOpacity(self, InColorAndOpacity: SlateColor): ...
	"""Sets the color and opacity of the default text in this rich text block
@param InColorAndOpacity             The new text color and opacity"""

	pass

class RichTextBlockDecorator(Object):
	"""Rich Text Block Decorator"""

	pass

class RichTextBlockImageDecorator(RichTextBlockDecorator):
	"""Allows you to setup an image decorator that can be configured
to map certain keys to certain images.  We recommend you subclass this
as a blueprint to configure the instance.

Understands the format <img id='NameOfBrushInTable'></>"""

	pass

class SafeZone(ContentWidget):
	"""The Safe-Zone widget is an essential part of developing a game UI that can run on lots of different non-PC platforms.
While a modern flat panel computer monitor may not have over scan issues, this is a common occurrence for Consoles.
It's common for TVs to have extra pixels under the bezel, in addition to projectors and projection TVs having potentially
several vertical and horizontal columns of pixels hidden behind or against a black border of the projection screen.

Useful testing console commands to help, simulate the safe zone on PC,
  r.DebugSafeZone.TitleRatio 0.96
  r.DebugActionZone.ActionRatio 0.96

To enable a red band to visualize the safe zone, use this console command,
r.DebugSafeZone.Mode controls the debug visualization overlay (0..2, default 0).
  0: Do not display the safe zone overlay.
  1: Display the overlay for the title safe zone.
  2: Display the overlay for the action safe zone."""

	@property
	def PadLeft(self) -> bool: ...
	"""If this safe zone should pad for the left side of the screen's safe zone"""

	@property
	def PadRight(self) -> bool: ...
	"""If this safe zone should pad for the right side of the screen's safe zone"""

	@property
	def PadTop(self) -> bool: ...
	"""If this safe zone should pad for the top side of the screen's safe zone"""

	@property
	def PadBottom(self) -> bool: ...
	"""If this safe zone should pad for the bottom side of the screen's safe zone"""

	def SetSidesToPad(self, InPadLeft: bool, InPadRight: bool, InPadTop: bool, InPadBottom: bool): ...
	"""Set Sides to Pad"""

	pass

class SafeZoneSlot(PanelSlot):
	"""Safe Zone Slot"""

	@property
	def bIsTitleSafe(self) -> bool: ...
	"""Is Title Safe"""

	@property
	def SafeAreaScale(self) -> Margin: ...
	"""Safe Area Scale"""

	@property
	def HAlign(self) -> int: ...
	"""HAlign"""

	@property
	def VAlign(self) -> int: ...
	"""VAlign"""

	@property
	def Padding(self) -> Margin: ...
	"""Padding"""

	pass

class ScaleBox(ContentWidget):
	"""Allows you to place content with a desired size and have it scale to meet the constraints placed on this box's alloted area.  If
you needed to have a background image scale to fill an area but not become distorted with different aspect ratios, or if you need
to auto fit some text to an area, this is the control for you.

* Single Child
* Aspect Ratio"""

	@property
	def Stretch(self) -> int: ...
	"""The stretching rule to apply when content is stretched"""

	@property
	def StretchDirection(self) -> int: ...
	"""Controls in what direction content can be scaled"""

	@property
	def UserSpecifiedScale(self) -> float: ...
	"""Optional scale that can be specified by the User. Used only for UserSpecified stretching."""

	@property
	def IgnoreInheritedScale(self) -> bool: ...
	"""Optional bool to ignore the inherited scale. Applies inverse scaling to counteract parents before applying the local scale operation."""

	def SetIgnoreInheritedScale(self, bInIgnoreInheritedScale: bool): ...
	"""Set Ignore Inherited Scale"""

	def SetUserSpecifiedScale(self, InUserSpecifiedScale: float): ...
	"""Set User Specified Scale"""

	def SetStretchDirection(self, InStretchDirection: int): ...
	"""Set Stretch Direction"""

	def SetStretch(self, InStretch: int): ...
	"""Set Stretch"""

	pass

class ScaleBoxSlot(PanelSlot):
	"""The Slot for the UScaleBoxSlot, contains the widget displayed in a button's single slot"""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the object horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the object vertically."""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class ScrollBar(Widget):
	"""Scroll Bar"""

	@property
	def WidgetStyle(self) -> ScrollBarStyle: ...
	"""Style of the scrollbar"""

	@property
	def bAlwaysShowScrollbar(self) -> bool: ...
	"""Always Show Scrollbar"""

	@property
	def bAlwaysShowScrollbarTrack(self) -> bool: ...
	"""Always Show Scrollbar Track"""

	@property
	def Orientation(self) -> int: ...
	"""Orientation"""

	@property
	def Thickness(self) -> Vector2D: ...
	"""The thickness of the scrollbar thumb"""

	@property
	def Padding(self) -> Margin: ...
	"""The margin around the scrollbar"""

	def SetState(self, InOffsetFraction: float, InThumbSizeFraction: float): ...
	"""Set the offset and size of the track's thumb.
Note that the maximum offset is 1.0-ThumbSizeFraction.
If the user can view 1/3 of the items in a single page, the maximum offset will be ~0.667f

@param InOffsetFraction     Offset of the thumbnail from the top as a fraction of the total available scroll space.
@param InThumbSizeFraction  Size of thumbnail as a fraction of the total available scroll space."""

	pass

class ScrollBox(PanelWidget):
	"""An arbitrary scrollable collection of widgets.  Great for presenting 10-100 widgets in a list.  Doesn't support virtualization."""

	@property
	def WidgetStyle(self) -> ScrollBoxStyle: ...
	"""The style"""

	@property
	def WidgetBarStyle(self) -> ScrollBarStyle: ...
	"""The bar style"""

	@property
	def Orientation(self) -> int: ...
	"""The orientation of the scrolling and stacking in the box."""

	@property
	def ScrollBarVisibility(self) -> int: ...
	"""Visibility"""

	@property
	def ConsumeMouseWheel(self) -> int: ...
	"""When mouse wheel events should be consumed."""

	@property
	def ScrollbarThickness(self) -> Vector2D: ...
	"""The thickness of the scrollbar thumb"""

	@property
	def ScrollbarPadding(self) -> Margin: ...
	"""The margin around the scrollbar"""

	@property
	def AlwaysShowScrollbar(self) -> bool: ...
	"""Always Show Scrollbar"""

	@property
	def AlwaysShowScrollbarTrack(self) -> bool: ...
	"""Always Show Scrollbar Track"""

	@property
	def AllowOverscroll(self) -> bool: ...
	"""Disable to stop scrollbars from activating inertial overscrolling"""

	@property
	def bAnimateWheelScrolling(self) -> bool: ...
	"""True to lerp smoothly when wheel scrolling along the scroll box"""

	@property
	def NavigationDestination(self) -> int: ...
	"""Sets where to scroll a widget to when using explicit navigation or if ScrollWhenFocusChanges is enabled"""

	@property
	def NavigationScrollPadding(self) -> float: ...
	"""The amount of padding to ensure exists between the item being navigated to, at the edge of the
scrollbox.  Use this if you want to ensure there's a preview of the next item the user could scroll to."""

	@property
	def ScrollWhenFocusChanges(self) -> int: ...
	"""Scroll behavior when user focus is given to a child widget"""

	@property
	def bAllowRightClickDragScrolling(self) -> bool: ...
	"""Option to disable right-click-drag scrolling"""

	@property
	def WheelScrollMultiplier(self) -> float: ...
	"""The multiplier to apply when wheel scrolling"""

	@property
	def OnUserScrolled(self) -> typing.Any: ...
	"""Called when the scroll has changed"""

	def ScrollWidgetIntoView(self, WidgetToFind: Widget, AnimateScroll: bool = ..., ScrollDestination: int = ..., Padding: float = ...): ...
	"""Scrolls the ScrollBox to the widget during the next layout pass."""

	def ScrollToEnd(self): ...
	"""Scrolls the ScrollBox to the bottom instantly during the next layout pass."""

	def ScrollToStart(self): ...
	"""Scrolls the ScrollBox to the top instantly"""

	def GetViewOffsetFraction(self) -> float: ...
	"""Get View Offset Fraction"""

	def GetScrollOffsetOfEnd(self) -> float: ...
	"""Gets the scroll offset of the bottom of the ScrollBox in Slate Units."""

	def GetScrollOffset(self) -> float: ...
	"""Gets the scroll offset of the scrollbox in Slate Units."""

	def SetScrollOffset(self, NewScrollOffset: float): ...
	"""Updates the scroll offset of the scrollbox.
@param NewScrollOffset is in Slate Units."""

	def EndInertialScrolling(self): ...
	"""Instantly stops any inertial scrolling that is currently in progress"""

	def SetWheelScrollMultiplier(self, NewWheelScrollMultiplier: float): ...
	"""Set Wheel Scroll Multiplier"""

	def SetAnimateWheelScrolling(self, bShouldAnimateWheelScrolling: bool): ...
	"""Set Animate Wheel Scrolling"""

	def SetAllowOverscroll(self, NewAllowOverscroll: bool): ...
	"""Set Allow Overscroll"""

	def SetAlwaysShowScrollbar(self, NewAlwaysShowScrollbar: bool): ...
	"""Set Always Show Scrollbar"""

	def SetScrollbarPadding(self, NewScrollbarPadding: Margin): ...
	"""Set Scrollbar Padding"""

	def SetScrollbarThickness(self, NewScrollbarThickness: Vector2D): ...
	"""Set Scrollbar Thickness"""

	def SetScrollBarVisibility(self, NewScrollBarVisibility: int): ...
	"""Set Scroll Bar Visibility"""

	def SetOrientation(self, NewOrientation: int): ...
	"""Set Orientation"""

	def SetConsumeMouseWheel(self, NewConsumeMouseWheel: int): ...
	"""Set Consume Mouse Wheel"""

	pass

class ScrollBoxSlot(PanelSlot):
	"""The Slot for the UScrollBox, contains the widget that are scrollable"""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the object horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the object vertically."""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class SizeBox(ContentWidget):
	"""A widget that allows you to specify the size it reports to have and desire.  Not all widgets report a desired size
that you actually desire.  Wrapping them in a SizeBox lets you have the Size Box force them to be a particular size.

* Single Child
* Fixed Size"""

	@property
	def WidthOverride(self) -> float: ...
	"""When specified, ignore the content's desired size and report the WidthOverride as the Box's desired width."""

	@property
	def HeightOverride(self) -> float: ...
	"""When specified, ignore the content's desired size and report the HeightOverride as the Box's desired height."""

	@property
	def MinDesiredWidth(self) -> float: ...
	"""When specified, will report the MinDesiredWidth if larger than the content's desired width."""

	@property
	def MinDesiredHeight(self) -> float: ...
	"""When specified, will report the MinDesiredHeight if larger than the content's desired height."""

	@property
	def MaxDesiredWidth(self) -> float: ...
	"""When specified, will report the MaxDesiredWidth if smaller than the content's desired width."""

	@property
	def MaxDesiredHeight(self) -> float: ...
	"""When specified, will report the MaxDesiredHeight if smaller than the content's desired height."""

	@property
	def MinAspectRatio(self) -> float: ...
	"""Min Aspect Ratio"""

	@property
	def MaxAspectRatio(self) -> float: ...
	"""Max Aspect Ratio"""

	@property
	def bOverride_WidthOverride(self) -> bool: ...
	"""Override Width Override"""

	@property
	def bOverride_HeightOverride(self) -> bool: ...
	"""Override Height Override"""

	@property
	def bOverride_MinDesiredWidth(self) -> bool: ...
	"""Override Min Desired Width"""

	@property
	def bOverride_MinDesiredHeight(self) -> bool: ...
	"""Override Min Desired Height"""

	@property
	def bOverride_MaxDesiredWidth(self) -> bool: ...
	"""Override Max Desired Width"""

	@property
	def bOverride_MaxDesiredHeight(self) -> bool: ...
	"""Override Max Desired Height"""

	@property
	def bOverride_MinAspectRatio(self) -> bool: ...
	"""Override Min Aspect Ratio"""

	@property
	def bOverride_MaxAspectRatio(self) -> bool: ...
	"""Override Max Aspect Ratio"""

	def ClearMaxAspectRatio(self): ...
	"""Clear Max Aspect Ratio"""

	def ClearMinAspectRatio(self): ...
	"""Clear Min Aspect Ratio"""

	def SetMaxAspectRatio(self, InMaxAspectRatio: float): ...
	"""Set Max Aspect Ratio"""

	def SetMinAspectRatio(self, InMinAspectRatio: float): ...
	"""Set Min Aspect Ratio"""

	def ClearMaxDesiredHeight(self): ...
	"""Clear Max Desired Height"""

	def SetMaxDesiredHeight(self, InMaxDesiredHeight: float): ...
	"""When specified, will report the MaxDesiredHeight if smaller than the content's desired height."""

	def ClearMaxDesiredWidth(self): ...
	"""Clear Max Desired Width"""

	def SetMaxDesiredWidth(self, InMaxDesiredWidth: float): ...
	"""When specified, will report the MaxDesiredWidth if smaller than the content's desired width."""

	def ClearMinDesiredHeight(self): ...
	"""Clear Min Desired Height"""

	def SetMinDesiredHeight(self, InMinDesiredHeight: float): ...
	"""When specified, will report the MinDesiredHeight if larger than the content's desired height."""

	def ClearMinDesiredWidth(self): ...
	"""Clear Min Desired Width"""

	def SetMinDesiredWidth(self, InMinDesiredWidth: float): ...
	"""When specified, will report the MinDesiredWidth if larger than the content's desired width."""

	def ClearHeightOverride(self): ...
	"""Clear Height Override"""

	def SetHeightOverride(self, InHeightOverride: float): ...
	"""When specified, ignore the content's desired size and report the HeightOverride as the Box's desired height."""

	def ClearWidthOverride(self): ...
	"""Clear Width Override"""

	def SetWidthOverride(self, InWidthOverride: float): ...
	"""When specified, ignore the content's desired size and report the WidthOverride as the Box's desired width."""

	pass

class SizeBoxSlot(PanelSlot):
	"""The Slot for the USizeBoxSlot, contains the widget displayed in a button's single slot"""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the object horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the object vertically."""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class Slider(Widget):
	"""A simple widget that shows a sliding bar with a handle that allows you to control the value between 0..1.

* No Children"""

	@property
	def Value(self) -> float: ...
	"""The volume value to display."""

	@property
	def ValueDelegate(self) -> typing.Any: ...
	"""A bindable delegate to allow logic to drive the value of the widget"""

	@property
	def MinValue(self) -> float: ...
	"""The minimum value the slider can be set to."""

	@property
	def MaxValue(self) -> float: ...
	"""The maximum value the slider can be set to."""

	@property
	def WidgetStyle(self) -> SliderStyle: ...
	"""The progress bar style"""

	@property
	def Orientation(self) -> int: ...
	"""The slider's orientation."""

	@property
	def SliderBarColor(self) -> LinearColor: ...
	"""The color to draw the slider bar in."""

	@property
	def SliderHandleColor(self) -> LinearColor: ...
	"""The color to draw the slider handle in."""

	@property
	def IndentHandle(self) -> bool: ...
	"""Whether the slidable area should be indented to fit the handle."""

	@property
	def Locked(self) -> bool: ...
	"""Whether the handle is interactive or fixed."""

	@property
	def MouseUsesStep(self) -> bool: ...
	"""Sets new value if mouse position is greater/less than half the step size."""

	@property
	def RequiresControllerLock(self) -> bool: ...
	"""Sets whether we have to lock input to change the slider value."""

	@property
	def StepSize(self) -> float: ...
	"""The amount to adjust the value by, when using a controller or keyboard"""

	@property
	def IsFocusable(self) -> bool: ...
	"""Should the slider be focusable?"""

	@property
	def OnMouseCaptureBegin(self) -> typing.Any: ...
	"""Invoked when the mouse is pressed and a capture begins."""

	@property
	def OnMouseCaptureEnd(self) -> typing.Any: ...
	"""Invoked when the mouse is released and a capture ends."""

	@property
	def OnControllerCaptureBegin(self) -> typing.Any: ...
	"""Invoked when the controller capture begins."""

	@property
	def OnControllerCaptureEnd(self) -> typing.Any: ...
	"""Invoked when the controller capture ends."""

	@property
	def OnValueChanged(self) -> typing.Any: ...
	"""Called when the value is changed by slider or typing."""

	def SetSliderHandleColor(self, InValue: LinearColor): ...
	"""Sets the color of the handle bar"""

	def SetSliderBarColor(self, InValue: LinearColor): ...
	"""Sets the color of the slider bar"""

	def SetStepSize(self, InValue: float): ...
	"""Sets the amount to adjust the value by, when using a controller or keyboard"""

	def SetLocked(self, InValue: bool): ...
	"""Sets the handle to be interactive or fixed"""

	def SetIndentHandle(self, InValue: bool): ...
	"""Sets if the slidable area should be indented to fit the handle"""

	def SetMaxValue(self, InValue: float): ...
	"""Sets the maximum value of the slider."""

	def SetMinValue(self, InValue: float): ...
	"""Sets the minimum value of the slider."""

	def SetValue(self, InValue: float): ...
	"""Sets the current value of the slider."""

	def GetNormalizedValue(self) -> float: ...
	"""Get the current value scaled from 0 to 1"""

	def GetValue(self) -> float: ...
	"""Gets the current value of the slider."""

	pass

class Spacer(Widget):
	"""A spacer widget; it does not have a visual representation, and just provides padding between other widgets.

* No Children"""

	@property
	def Size(self) -> Vector2D: ...
	"""The size of the spacer"""

	def SetSize(self, InSize: Vector2D): ...
	"""Sets the size of the spacer"""

	pass

class SpinBox(Widget):
	"""A numerical entry box that allows for direct entry of the number or allows the user to click and slide the number."""

	@property
	def Value(self) -> float: ...
	"""Value stored in this spin box"""

	@property
	def ValueDelegate(self) -> typing.Any: ...
	"""A bindable delegate to allow logic to drive the value of the widget"""

	@property
	def WidgetStyle(self) -> SpinBoxStyle: ...
	"""The Style"""

	@property
	def MinFractionalDigits(self) -> int: ...
	"""The minimum required fractional digits - default 1"""

	@property
	def MaxFractionalDigits(self) -> int: ...
	"""The maximume required fractional digits - default 6"""

	@property
	def bAlwaysUsesDeltaSnap(self) -> bool: ...
	"""Whether this spin box should use the delta snapping logic for typed values - default false"""

	@property
	def Delta(self) -> float: ...
	"""The amount by which to change the spin box value as the slider moves."""

	@property
	def SliderExponent(self) -> float: ...
	"""The exponent by which to increase the delta as the mouse moves. 1 is constant (never increases the delta)."""

	@property
	def Font(self) -> SlateFontInfo: ...
	"""Font color and opacity (overrides style)"""

	@property
	def Justification(self) -> int: ...
	"""The justification the value text should appear as."""

	@property
	def MinDesiredWidth(self) -> float: ...
	"""The minimum width of the spin box"""

	@property
	def ClearKeyboardFocusOnCommit(self) -> bool: ...
	"""Whether to remove the keyboard focus from the spin box when the value is committed"""

	@property
	def SelectAllTextOnCommit(self) -> bool: ...
	"""Whether to select the text in the spin box when the value is committed"""

	@property
	def ForegroundColor(self) -> SlateColor: ...
	"""Foreground Color"""

	@property
	def OnValueChanged(self) -> typing.Any: ...
	"""Called when the value is changed interactively by the user"""

	@property
	def OnValueCommitted(self) -> typing.Any: ...
	"""Called when the value is committed. Occurs when the user presses Enter or the text box loses focus."""

	@property
	def OnBeginSliderMovement(self) -> typing.Any: ...
	"""Called right before the slider begins to move"""

	@property
	def OnEndSliderMovement(self) -> typing.Any: ...
	"""Called right after the slider handle is released by the user"""

	def SetForegroundColor(self, InForegroundColor: SlateColor): ...
	"""Set Foreground Color"""

	def ClearMaxSliderValue(self): ...
	"""Clear the maximum value that can be specified using the slider."""

	def SetMaxSliderValue(self, NewValue: float): ...
	"""Set the maximum value that can be specified using the slider."""

	def GetMaxSliderValue(self) -> float: ...
	"""Get the current maximum value that can be specified using the slider."""

	def ClearMinSliderValue(self): ...
	"""Clear the minimum value that can be specified using the slider."""

	def SetMinSliderValue(self, NewValue: float): ...
	"""Set the minimum value that can be specified using the slider."""

	def GetMinSliderValue(self) -> float: ...
	"""Get the current minimum value that can be specified using the slider."""

	def ClearMaxValue(self): ...
	"""Clear the maximum value that can be manually set in the spin box."""

	def SetMaxValue(self, NewValue: float): ...
	"""Set the maximum value that can be manually set in the spin box."""

	def GetMaxValue(self) -> float: ...
	"""Get the current maximum value that can be manually set in the spin box."""

	def ClearMinValue(self): ...
	"""Clear the minimum value that can be manually set in the spin box."""

	def SetMinValue(self, NewValue: float): ...
	"""Set the minimum value that can be manually set in the spin box."""

	def GetMinValue(self) -> float: ...
	"""Get the current minimum value that can be manually set in the spin box."""

	def SetDelta(self, NewValue: float): ...
	"""Set the delta for the spin box."""

	def GetDelta(self) -> float: ...
	"""Get the current delta for the spin box."""

	def SetAlwaysUsesDeltaSnap(self, bNewValue: bool): ...
	"""Set whether the spin box uses delta snap on type."""

	def GetAlwaysUsesDeltaSnap(self) -> bool: ...
	"""Get whether the spin box uses delta snap on type."""

	def SetMaxFractionalDigits(self, NewValue: int): ...
	"""Set the Max Fractional Digits for the spin box."""

	def GetMaxFractionalDigits(self) -> int: ...
	"""Get the current Max Fractional Digits for the spin box."""

	def SetMinFractionalDigits(self, NewValue: int): ...
	"""Set the Min Fractional Digits for the spin box."""

	def GetMinFractionalDigits(self) -> int: ...
	"""Get the current Min Fractional Digits for the spin box."""

	def SetValue(self, NewValue: float): ...
	"""Set the value of the spin box."""

	def GetValue(self) -> float: ...
	"""Get the current value of the spin box."""

	pass

class TextBlock(TextLayoutWidget):
	"""A simple static text widget.

* No Children
* Text"""

	@property
	def Text(self) -> str: ...
	"""The text to display"""

	@property
	def TextDelegate(self) -> typing.Any: ...
	"""A bindable delegate to allow logic to drive the text of the widget"""

	@property
	def ColorAndOpacity(self) -> SlateColor: ...
	"""The color of the text"""

	@property
	def ColorAndOpacityDelegate(self) -> typing.Any: ...
	"""A bindable delegate for the ColorAndOpacity."""

	@property
	def Font(self) -> SlateFontInfo: ...
	"""The font to render the text with"""

	@property
	def StrikeBrush(self) -> SlateBrush: ...
	"""The brush to strike through text with"""

	@property
	def ShadowOffset(self) -> Vector2D: ...
	"""The direction the shadow is cast"""

	@property
	def ShadowColorAndOpacity(self) -> LinearColor: ...
	"""The color of the shadow"""

	@property
	def ShadowColorAndOpacityDelegate(self) -> typing.Any: ...
	"""A bindable delegate for the ShadowColorAndOpacity."""

	@property
	def MinDesiredWidth(self) -> float: ...
	"""The minimum desired size for the text"""

	@property
	def bWrapWithInvalidationPanel(self) -> bool: ...
	"""If true, it will automatically wrap this text widget with an invalidation panel"""

	@property
	def TextTransformPolicy(self) -> int: ...
	"""The text transformation policy to apply to this text block"""

	def SetText(self, InText: str): ...
	"""Directly sets the widget text.
Warning: This will wipe any binding created for the Text property!
@param InText The text to assign to the widget"""

	def GetText(self) -> str: ...
	"""Gets the widget text
@return The widget text"""

	def GetDynamicOutlineMaterial(self) -> MaterialInstanceDynamic: ...
	"""Get Dynamic Outline Material"""

	def GetDynamicFontMaterial(self) -> MaterialInstanceDynamic: ...
	"""Get Dynamic Font Material"""

	def SetTextTransformPolicy(self, InTransformPolicy: int): ...
	"""Set the text transformation policy for this text block.

@param InTransformPolicy the new text transformation policy."""

	def SetAutoWrapText(self, InAutoTextWrap: bool): ...
	"""Set the auto wrap for this text block.

@param InAutoTextWrap to turn wrap on or off."""

	def SetMinDesiredWidth(self, InMinDesiredWidth: float): ...
	"""Set the minimum desired width for this text block

@param InMinDesiredWidth new minimum desired width"""

	def SetStrikeBrush(self, InStrikeBrush: SlateBrush): ...
	"""Dynamically set the strike brush for this text block

@param InStrikeBrush The new brush to use to strike through text"""

	def SetFont(self, InFontInfo: SlateFontInfo): ...
	"""Dynamically set the font info for this text block

@param InFontInfo The new font info"""

	def SetShadowOffset(self, InShadowOffset: Vector2D): ...
	"""Sets the offset that the text drop shadow should be drawn at

@param InShadowOffset                The new offset"""

	def SetShadowColorAndOpacity(self, InShadowColorAndOpacity: LinearColor): ...
	"""Sets the color and opacity of the text drop shadow
Note: if opacity is zero no shadow will be drawn

@param InShadowColorAndOpacity               The new drop shadow color and opacity"""

	def SetOpacity(self, InOpacity: float): ...
	"""Sets the opacity of the text in this text block

@param InOpacity              The new text opacity"""

	def SetColorAndOpacity(self, InColorAndOpacity: SlateColor): ...
	"""Sets the color and opacity of the text in this text block

@param InColorAndOpacity             The new text color and opacity"""

	pass

class Throbber(Widget):
	"""A Throbber widget that shows several zooming circles in a row."""

	@property
	def NumberOfPieces(self) -> int: ...
	"""How many pieces there are"""

	@property
	def bAnimateHorizontally(self) -> bool: ...
	"""Should the pieces animate horizontally?"""

	@property
	def bAnimateVertically(self) -> bool: ...
	"""Should the pieces animate vertically?"""

	@property
	def bAnimateOpacity(self) -> bool: ...
	"""Should the pieces animate their opacity?"""

	@property
	def Image(self) -> SlateBrush: ...
	"""Image"""

	def SetAnimateOpacity(self, bInAnimateOpacity: bool): ...
	"""Sets whether the pieces animate their opacity."""

	def SetAnimateVertically(self, bInAnimateVertically: bool): ...
	"""Sets whether the pieces animate vertically."""

	def SetAnimateHorizontally(self, bInAnimateHorizontally: bool): ...
	"""Sets whether the pieces animate horizontally."""

	def SetNumberOfPieces(self, InNumberOfPieces: int): ...
	"""Sets how many pieces there are"""

	pass

class TileView(ListView):
	"""A ListView that presents the contents as a set of tiles all uniformly sized.

To make a widget usable as an entry in a TileView, it must inherit from the IUserObjectListEntry interface."""

	def GetEntryWidth(self) -> float: ...
	"""Gets the width of tile entries"""

	def GetEntryHeight(self) -> float: ...
	"""Gets the height of tile entries"""

	def SetEntryWidth(self, NewWidth: float): ...
	"""Sets the width of every tile entry"""

	def SetEntryHeight(self, NewHeight: float): ...
	"""Sets the height of every tile entry"""

	pass

class TreeView(ListView):
	"""Similar to ListView, but can display a hierarchical tree of elements.
The base items source for the tree identifies the root items, each of which can have n associated child items.
There is no hard limit to the nesting - child items can have children and so on

To make a widget usable as an entry in a TreeView, it must inherit from the IUserObjectListEntry interface."""

	def CollapseAll(self): ...
	"""Collapses all currently expanded items"""

	def ExpandAll(self): ...
	"""Expands all items with children"""

	def SetItemExpansion(self, Item: Object, bExpandItem: bool): ...
	"""Attempts to expand/collapse the given item (only relevant if the item has children)"""

	pass

class UniformGridPanel(PanelWidget):
	"""A panel that evenly divides up available space between all of its children."""

	@property
	def SlotPadding(self) -> Margin: ...
	"""Padding given to each slot"""

	@property
	def MinDesiredSlotWidth(self) -> float: ...
	"""The minimum desired width of the slots"""

	@property
	def MinDesiredSlotHeight(self) -> float: ...
	"""The minimum desired height of the slots"""

	def AddChildToUniformGrid(self, Content: Widget, InRow: int = ..., InColumn: int = ...) -> UniformGridSlot: ...
	"""Add Child to Uniform Grid"""

	def SetMinDesiredSlotHeight(self, InMinDesiredSlotHeight: float): ...
	"""Set Min Desired Slot Height"""

	def SetMinDesiredSlotWidth(self, InMinDesiredSlotWidth: float): ...
	"""Set Min Desired Slot Width"""

	def SetSlotPadding(self, InSlotPadding: Margin): ...
	"""Set Slot Padding"""

	pass

class UniformGridSlot(PanelSlot):
	"""A slot for UUniformGridPanel, these slots all share the same size as the largest slot
in the grid."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the object horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the object vertically."""

	@property
	def Row(self) -> int: ...
	"""The row index of the cell this slot is in"""

	@property
	def Column(self) -> int: ...
	"""The column index of the cell this slot is in"""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetColumn(self, InColumn: int): ...
	"""Sets the column index of the slot, this determines what cell the slot is in the panel"""

	def SetRow(self, InRow: int): ...
	"""Sets the row index of the slot, this determines what cell the slot is in the panel"""

	pass

class VerticalBox(PanelWidget):
	"""A vertical box widget is a layout panel allowing child widgets to be automatically laid out
vertically.

* Many Children
* Flows Vertical"""

	def AddChildToVerticalBox(self, Content: Widget) -> VerticalBoxSlot: ...
	"""Add Child to Vertical Box"""

	pass

class VerticalBoxSlot(PanelSlot):
	"""The Slot for the UVerticalBox, contains the widget that is flowed vertically"""

	@property
	def Size(self) -> SlateChildSize: ...
	"""How much space this slot should occupy in the direction of the panel."""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the object horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the object vertically."""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetSize(self, InSize: SlateChildSize): ...
	"""Set Size"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class Viewport(ContentWidget):
	"""Viewport"""

	@property
	def BackgroundColor(self) -> LinearColor: ...
	"""Background Color"""

	def Spawn(self, ActorClass: Actor) -> Actor: ...
	"""Spawn"""

	def SetViewRotation(self, Rotation: Rotator): ...
	"""Set View Rotation"""

	def GetViewRotation(self) -> Rotator: ...
	"""Get View Rotation"""

	def SetViewLocation(self, Location: Vector): ...
	"""Set View Location"""

	def GetViewLocation(self) -> Vector: ...
	"""Get View Location"""

	def GetViewportWorld(self) -> World: ...
	"""Get Viewport World"""

	pass

class WidgetComponent(MeshComponent):
	"""The widget component provides a surface in the 3D environment on which to render widgets normally rendered to the screen.
Widgets are first rendered to a render target, then that render target is displayed in the world.

Material Properties set by this component on whatever material overrides the default.
SlateUI [Texture]
BackColor [Vector]
TintColorAndOpacity [Vector]
OpacityFromTexture [Scalar]"""

	def IsWidgetVisible(self) -> bool: ...
	"""Returns true if the the Slate window is visible and that the widget is also visible, false otherwise."""

	def SetTickMode(self, InTickMode: int): ...
	"""Sets the Tick mode of the Widget Component."""

	def SetWindowVisibility(self, InVisibility: int): ...
	"""Sets the visibility of the virtual window created to host the widget focusable."""

	def GetWindowVisiblility(self) -> int: ...
	"""Gets the visibility of the virtual window created to host the widget focusable."""

	def SetWindowFocusable(self, bInWindowFocusable: bool): ...
	"""@see bWindowFocusable"""

	def GetWindowFocusable(self) -> bool: ...
	"""@see bWindowFocusable"""

	def SetCylinderArcAngle(self, InCylinderArcAngle: float): ...
	"""Defines the curvature of the widget component when using EWidgetGeometryMode::Cylinder; ignored otherwise."""

	def GetCylinderArcAngle(self) -> float: ...
	"""Defines the curvature of the widget component when using EWidgetGeometryMode::Cylinder; ignored otherwise."""

	def SetGeometryMode(self, InGeometryMode: int): ...
	"""Set Geometry Mode"""

	def GetGeometryMode(self) -> int: ...
	"""@see EWidgetGeometryMode, @see GetCylinderArcAngle()"""

	def SetWidgetSpace(self, NewSpace: int): ...
	"""Set Widget Space"""

	def GetWidgetSpace(self) -> int: ...
	"""Get Widget Space"""

	def SetRedrawTime(self, InRedrawTime: float): ...
	"""Set Redraw Time"""

	def GetRedrawTime(self) -> float: ...
	"""Get Redraw Time"""

	def SetDrawAtDesiredSize(self, bInDrawAtDesiredSize: bool): ...
	"""Set Draw at Desired Size"""

	def GetDrawAtDesiredSize(self) -> bool: ...
	"""Get Draw at Desired Size"""

	def SetPivot(self, InPivot: Vector2D): ...
	"""Set Pivot"""

	def GetPivot(self) -> Vector2D: ...
	"""Returns the pivot point where the UI is rendered about the origin."""

	def SetTintColorAndOpacity(self, NewTintColorAndOpacity: LinearColor): ...
	"""Sets the tint color and opacity scale for this widget"""

	def SetBackgroundColor(self, NewBackgroundColor: LinearColor): ...
	"""Sets the background color and opacityscale for this widget"""

	def SetTickWhenOffscreen(self, bWantTickWhenOffscreen: bool): ...
	"""Sets whether the widget ticks when offscreen or not"""

	def GetTickWhenOffscreen(self) -> bool: ...
	"""Gets whether the widget ticks when offscreen or not"""

	def SetTwoSided(self, bWantTwoSided: bool): ...
	"""Sets whether the widget is two-sided or not"""

	def GetTwoSided(self) -> bool: ...
	"""Gets whether the widget is two-sided or not"""

	def RequestRedraw(self): ...
	"""Requests that the widget be redrawn."""

	def SetDrawSize(self, Size: Vector2D): ...
	"""Sets the draw size of the quad in the world"""

	def GetCurrentDrawSize(self) -> Vector2D: ...
	"""Returns the 'actual' draw size of the quad in the world"""

	def GetDrawSize(self) -> Vector2D: ...
	"""Returns the 'specified' draw size of the quad in the world"""

	def GetOwnerPlayer(self) -> typing.Any: ...
	"""Gets the local player that owns this widget component."""

	def SetManuallyRedraw(self, bUseManualRedraw: bool): ...
	"""@see bManuallyRedraw"""

	def GetManuallyRedraw(self) -> bool: ...
	"""@see bManuallyRedraw"""

	def SetOwnerPlayer(self, LocalPlayer): ...
	"""Sets the local player that owns this widget component.  Setting the owning player controls
which player's viewport the widget appears on in a split screen scenario.  Additionally it
forwards the owning player to the actual UserWidget that is spawned."""

	def SetWidget(self, Widget: UserWidget): ...
	"""Sets the widget to use directly. This function will keep track of the widget till the next time it's called
    with either a newer widget or a nullptr"""

	def GetWidget(self) -> UserWidget: ...
	"""Sets the widget to use directly. This function will keep track of the widget till the next time it's called
    with either a newer widget or a nullptr"""

	def GetMaterialInstance(self) -> MaterialInstanceDynamic: ...
	"""Returns the dynamic material instance used to render the user widget"""

	def GetRenderTarget(self) -> TextureRenderTarget2D: ...
	"""Returns the render target to which the user widget is rendered"""

	def GetUserWidgetObject(self) -> UserWidget: ...
	"""Returns the user widget object displayed by this component"""

	pass

class WidgetInteractionComponent(SceneComponent):
	"""This is a component to allow interaction with the Widget Component.  This class allows you to
simulate a sort of laser pointer device, when it hovers over widgets it will send the basic signals
to show as if the mouse were moving on top of it.  You'll then tell the component to simulate key presses,
like Left Mouse, down and up, to simulate a mouse click."""

	@property
	def OnHoveredWidgetChanged(self) -> typing.Any: ...
	"""Called when the hovered Widget Component changes.  The interaction component functions at the Slate
level - so it's unable to report anything about what UWidget is under the hit result."""

	@property
	def VirtualUserIndex(self) -> int: ...
	"""Represents the Virtual User Index.  Each virtual user should be represented by a different
index number, this will maintain separate capture and focus states for them.  Each
controller or finger-tip should get a unique PointerIndex."""

	@property
	def PointerIndex(self) -> int: ...
	"""Each user virtual controller or virtual finger tips being simulated should use a different pointer index."""

	@property
	def TraceChannel(self) -> int: ...
	"""The trace channel to use when tracing for widget components in the world."""

	@property
	def InteractionDistance(self) -> float: ...
	"""The distance in game units the component should be able to interact with a widget component."""

	@property
	def InteractionSource(self) -> int: ...
	"""Should we project from the world location of the component?  If you set this to false, you'll
need to call SetCustomHitResult(), and provide the result of a custom hit test form whatever
location you wish."""

	@property
	def bEnableHitTesting(self) -> bool: ...
	"""Should the interaction component perform hit testing (Automatic or Custom) and attempt to
simulate hover - if you were going to emulate a keyboard you would want to turn this option off
if the virtual keyboard was separate from the virtual pointer device and used a second interaction
component."""

	@property
	def bShowDebug(self) -> bool: ...
	"""Shows some debugging lines and a hit sphere to help you debug interactions."""

	@property
	def DebugSphereLineThickness(self) -> float: ...
	"""Determines the line thickness of the debug sphere."""

	@property
	def DebugLineThickness(self) -> float: ...
	"""Determines the thickness of the debug lines."""

	@property
	def DebugColor(self) -> LinearColor: ...
	"""Determines the color of the debug lines."""

	def SetFocus(self, FocusWidget: Widget): ...
	"""Set the focus target of the virtual user managed by this component"""

	def SetCustomHitResult(self, HitResult: HitResult): ...
	"""Set custom hit result.  This is only taken into account if InteractionSource is set to EWidgetInteractionSource::Custom."""

	def Get2DHitLocation(self) -> Vector2D: ...
	"""Gets the last hit location on the widget in 2D, local pixel units of the render target."""

	def GetLastHitResult(self) -> HitResult: ...
	"""Gets the last hit result generated by the component.  Returns the custom hit result if that was set."""

	def IsOverHitTestVisibleWidget(self) -> bool: ...
	"""Returns true if a widget under the hit result is has a visibility that makes it hit test
visible.  e.g. Slate widgets that return true for GetVisibility().IsHitTestVisible()."""

	def IsOverFocusableWidget(self) -> bool: ...
	"""Returns true if a widget under the hit result is focusable.  e.g. Slate widgets that
return true for SupportsKeyboardFocus()."""

	def IsOverInteractableWidget(self) -> bool: ...
	"""Returns true if a widget under the hit result is interactive.  e.g. Slate widgets
that return true for IsInteractable()."""

	def GetHoveredWidgetComponent(self) -> WidgetComponent: ...
	"""Get the currently hovered widget component."""

	def ScrollWheel(self, ScrollDelta: float): ...
	"""Sends a scroll wheel event to the widget under the last hit result."""

	def SendKeyChar(self, Characters: str, bRepeat: bool = ...) -> bool: ...
	"""Transmits a list of characters to a widget by simulating a OnKeyChar event for each key listed in
the string."""

	def PressAndReleaseKey(self, Key: Key) -> bool: ...
	"""Does both the press and release of a simulated keyboard key."""

	def ReleaseKey(self, Key: Key) -> bool: ...
	"""Releases a key as if it had been released by the keyboard."""

	def PressKey(self, Key: Key, bRepeat: bool = ...) -> bool: ...
	"""Press a key as if it had come from the keyboard.  Avoid using this for 'a-z|A-Z', things like
the Editable Textbox in Slate expect OnKeyChar to be called to signal a specific character being
send to the widget.  So for those cases you should use SendKeyChar."""

	def ReleasePointerKey(self, Key: Key): ...
	"""Releases a key as if the mouse/pointer were the source of it.  Normally you would just use
Left/Right mouse button for the Key.  However - advanced uses could also be imagined where you
send other keys to signal widgets to take special actions if they're under the cursor."""

	def PressPointerKey(self, Key: Key): ...
	"""Presses a key as if the mouse/pointer were the source of it.  Normally you would just use
Left/Right mouse button for the Key.  However - advanced uses could also be imagined where you
send other keys to signal widgets to take special actions if they're under the cursor."""

	pass

class WidgetSwitcher(PanelWidget):
	"""A widget switcher is like a tab control, but without tabs. At most one widget is visible at time."""

	@property
	def ActiveWidgetIndex(self) -> int: ...
	"""The slot index to display"""

	def GetActiveWidget(self) -> Widget: ...
	"""Get the reference of the currently active widget"""

	def GetWidgetAtIndex(self, Index: int) -> Widget: ...
	"""Get a widget at the provided index"""

	def SetActiveWidget(self, Widget: Widget): ...
	"""Activates the widget and makes it the active index."""

	def SetActiveWidgetIndex(self, Index: int): ...
	"""Activates the widget at the specified index."""

	def GetActiveWidgetIndex(self) -> int: ...
	"""Gets the slot index of the currently active widget"""

	def GetNumWidgets(self) -> int: ...
	"""Gets the number of widgets that this switcher manages."""

	pass

class WidgetSwitcherSlot(PanelSlot):
	"""The Slot for the UWidgetSwitcher, contains the widget that is flowed vertically"""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the object horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the object vertically."""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class WindowTitleBarArea(ContentWidget):
	"""A panel for defining a region of the UI that should allow users to drag the window on desktop platforms."""

	@property
	def bWindowButtonsEnabled(self) -> bool: ...
	"""Should the title bar area diaplay window minimize/maximize/close buttons."""

	@property
	def bDoubleClickTogglesFullscreen(self) -> bool: ...
	"""Should double clicking the title bar area toggle fullscreen instead of maximizing the window."""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class WindowTitleBarAreaSlot(PanelSlot):
	"""The Slot for the UWindowTitleBarArea"""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class WrapBox(PanelWidget):
	"""Arranges widgets left-to-right or top-to-bottom dependently of the orientation.  When the widgets exceed the wrapSize it will place widgets on the next line.

* Many Children
* Flows
* Wraps"""

	@property
	def InnerSlotPadding(self) -> Vector2D: ...
	"""The inner slot padding goes between slots sharing borders"""

	@property
	def WrapSize(self) -> float: ...
	"""When this size is exceeded, elements will start appearing on the next line."""

	@property
	def bExplicitWrapSize(self) -> bool: ...
	"""Use explicit wrap size whenever possible. It greatly simplifies layout calculations and reduces likelihood of 'wiggling UI'"""

	@property
	def Orientation(self) -> int: ...
	"""Determines if the Wrap Box should arranges the widgets left-to-right or top-to-bottom"""

	def AddChildToWrapBox(self, Content: Widget) -> WrapBoxSlot: ...
	"""Add Child to Wrap Box"""

	def SetInnerSlotPadding(self, InPadding: Vector2D): ...
	"""Sets the inner slot padding goes between slots sharing borders"""

	pass

class WrapBoxSlot(PanelSlot):
	"""The Slot for the UWrapBox, contains the widget that is flowed vertically"""

	@property
	def Padding(self) -> Margin: ...
	"""The padding area between the slot and the content it contains."""

	@property
	def bFillEmptySpace(self) -> bool: ...
	"""Should this slot fill the remaining space on the line?"""

	@property
	def FillSpanWhenLessThan(self) -> float: ...
	"""If the total available space in the wrap panel drops below this threshold, this slot will attempt to fill an entire line.
NOTE: A value of 0, denotes no filling will occur."""

	@property
	def HorizontalAlignment(self) -> int: ...
	"""The alignment of the object horizontally."""

	@property
	def VerticalAlignment(self) -> int: ...
	"""The alignment of the object vertically."""

	def SetVerticalAlignment(self, InVerticalAlignment: int): ...
	"""Set Vertical Alignment"""

	def SetHorizontalAlignment(self, InHorizontalAlignment: int): ...
	"""Set Horizontal Alignment"""

	def SetFillSpanWhenLessThan(self, InFillSpanWhenLessThan: float): ...
	"""Set Fill Span when Less Than"""

	def SetFillEmptySpace(self, InbFillEmptySpace: bool): ...
	"""Set Fill Empty Space"""

	def SetPadding(self, InPadding: Margin): ...
	"""Set Padding"""

	pass

class ESlateVisibility(Enum):
	"""Is an entity visible?"""

	# Visible and hit-testable (can interact with cursor). Default value.
	Visible = 0
	# Not visible and takes up no space in the layout (obviously not hit-testable).
	Collapsed = 1
	# Not visible but occupies layout space (obviously not hit-testable).
	Hidden = 2
	# Visible but not hit-testable (cannot interact with cursor) and children in the hierarchy (if any) are also not hit-testable.
	HitTestInvisible = 3
	# Visible but not hit-testable (cannot interact with cursor) and doesn't affect hit-testing on children (if any).
	SelfHitTestInvisible = 4

class ESlateAccessibleBehavior(Enum):
	"""Whether a widget should be included in accessibility, and if so, how its text should be retrieved."""

	# Not accessible.
	NotAccessible = 0
	# Accessible, first checking to see if there's any custom default text assigned for widgets of this type.
	# If not, then it will attempt to use the alternate behavior (ie AccessibleSummaryBehavior instead of AccessibleBehavior)
	# and return that value instead. This acts as a reference so that you only need to set one value for both of them
	# to return the same thing.
	Auto = 1
	# Accessible, and traverse all child widgets and concat their AccessibleSummaryText together.
	Summary = 2
	# Accessible, and retrieve manually-assigned text from a TAttribute.
	Custom = 3
	# Accessible, and use the tooltip's accessible text.
	ToolTip = 4

class ESlateSizeRule(Enum):
	"""The sizing options of UWidgets"""

	# Only requests as much room as it needs based on the widgets desired size.
	Automatic = 0
	# Greedily attempts to fill all available room based on the percentage value 0..1
	Fill = 1

class EVirtualKeyboardType(Enum):
	"""EVirtual Keyboard Type"""

	# 
	Default = 0
	# 
	Number = 1
	# 
	Web = 2
	# 
	Email = 3
	# 
	Password = 4
	# 
	AlphaNumeric = 5

class EWidgetDesignFlags(Enum):
	"""Flags used by the widget designer."""

	# 
	None = 0
	# 
	Designing = -1
	# 
	ShowOutline = -1
	# 
	ExecutePreConstruct = -1

class EBindingKind(Enum):
	"""EBinding Kind"""

	# 
	Function = 0
	# 
	Property = 1

class EWidgetTickFrequency(Enum):
	"""Determines what strategy we use to determine when and if the widget ticks."""

	# This widget never ticks
	Never = 0
	# This widget will tick if a blueprint tick function is implemented, any latent actions are found or animations need to play
	# If the widget inherits from something other than UserWidget it will also tick so that native C++ or inherited ticks function
	# To disable native ticking use add the class metadata flag 'DisableNativeTick'.  I.E: meta=(DisableNativeTick)
	Auto = 1

class EWidgetAnimationEvent(Enum):
	"""Different animation events."""

	# 
	Started = 0
	# 
	Finished = 1

class EUMGSequencePlayMode(Enum):
	"""Describes playback modes for UMG sequences."""

	# Animation plays and loops from the beginning to the end.
	Forward = 0
	# Animation plays and loops from the end to the beginning.
	Reverse = 1
	# Animation plays from the beginning to the end and then from the end to the beginning.
	PingPong = 2

class EDesignPreviewSizeMode(Enum):
	"""EDesign Preview Size Mode"""

	# 
	FillScreen = 0
	# 
	Custom = 1
	# 
	CustomOnScreen = 2
	# 
	Desired = 3
	# 
	DesiredOnScreen = 4

class EDragPivot(Enum):
	"""Controls where the drag widget visual will appear when dragged relative to the pointer performing
the drag operation."""

	# 
	MouseDown = 0
	# 
	TopLeft = 1
	# 
	TopCenter = 2
	# 
	TopRight = 3
	# 
	CenterLeft = 4
	# 
	CenterCenter = 5
	# 
	CenterRight = 6
	# 
	BottomLeft = 7
	# 
	BottomCenter = 8
	# 
	BottomRight = 9

class EDynamicBoxType(Enum):
	"""EDynamic Box Type"""

	# 
	Horizontal = 0
	# 
	Vertical = 1
	# 
	Wrap = 2
	# 
	VerticalWrap = 3
	# 
	Radial = 4
	# 
	Overlay = 5

class EWidgetSpace(Enum):
	"""EWidget Space"""

	# The widget is rendered in the world as mesh, it can be occluded like any other mesh in the world.
	World = 0
	# The widget is rendered in the screen, completely outside of the world, never occluded.
	Screen = 1

class EWidgetTimingPolicy(Enum):
	"""EWidget Timing Policy"""

	# The widget will tick using real time. When not ticking, real time will accumulate and be simulated on the next tick.
	RealTime = 0
	# The widget will tick using game time, respecting pausing and time dilation.
	GameTime = 1

class EWidgetBlendMode(Enum):
	"""EWidget Blend Mode"""

	# 
	Opaque = 0
	# 
	Masked = 1
	# 
	Transparent = 2

class EWidgetGeometryMode(Enum):
	"""EWidget Geometry Mode"""

	# The widget is mapped onto a plane
	Plane = 0
	# The widget is mapped onto a cylinder
	Cylinder = 1

class EWindowVisibility(Enum):
	"""EWindow Visibility"""

	# The window visibility is Visible
	Visible = 0
	# The window visibility is SelfHitTestInvisible
	SelfHitTestInvisible = 1

class ETickMode(Enum):
	"""ETick Mode"""

	# The component tick is disabled until re-enabled.
	Disabled = 0
	# The component is always ticked
	Enabled = 1
	# The component is ticked only when needed. i.e. when visible.
	Automatic = 2

class EWidgetInteractionSource(Enum):
	"""The interaction source for the widget interaction component, e.g. where do we try and
trace from to try to find a widget under a virtual pointer device."""

	# Sends traces from the world location and orientation of the interaction component.
	World = 0
	# Sends traces from the mouse location of the first local player controller.
	Mouse = 1
	# Sends trace from the center of the first local player's screen.
	CenterScreen = 2
	# Sends traces from a custom location determined by the user.  Will use whatever
	# FHitResult is set by the call to SetCustomHitResult.
	Custom = 3

class LevelSequenceSnapshotSettings(object):
	"""Level Sequence Snapshot Settings"""

	@property
	def ZeroPadAmount(self) -> int: ...
	"""Zero pad frames"""

	@property
	def FrameRate(self) -> FrameRate: ...
	"""Playback framerate"""

	pass

class LevelSequencePlayerSnapshot(object):
	"""Frame snapshot information for a level sequence"""

	@property
	def MasterName(self) -> str: ...
	"""Master Name"""

	@property
	def MasterTime(self) -> QualifiedFrameTime: ...
	"""Master Time"""

	@property
	def SourceTime(self) -> QualifiedFrameTime: ...
	"""Source Time"""

	@property
	def CurrentShotName(self) -> str: ...
	"""Current Shot Name"""

	@property
	def CurrentShotLocalTime(self) -> QualifiedFrameTime: ...
	"""Current Shot Local Time"""

	@property
	def CurrentShotSourceTime(self) -> QualifiedFrameTime: ...
	"""Current Shot Source Time"""

	@property
	def SourceTimecode(self) -> str: ...
	"""Source Timecode"""

	@property
	def CameraComponent(self) -> typing.Any: ...
	"""Camera Component"""

	@property
	def Settings(self) -> LevelSequenceSnapshotSettings: ...
	"""Settings"""

	@property
	def ActiveShot(self) -> LevelSequence: ...
	"""Active Shot"""

	@property
	def ShotID(self) -> typing.Any: ...
	"""Shot ID"""

	pass

class LevelSequenceCameraSettings(object):
	"""Level Sequence Camera Settings"""

	@property
	def bOverrideAspectRatioAxisConstraint(self) -> bool: ...
	"""Override Aspect Ratio Axis Constraint"""

	@property
	def AspectRatioAxisConstraint(self) -> int: ...
	"""Aspect Ratio Axis Constraint"""

	pass

class DefaultLevelSequenceInstanceData(Object):
	"""Default instance data class that level sequences understand. Implements IMovieSceneTransformOrigin."""

	@property
	def TransformOriginActor(self) -> Actor: ...
	"""When set, this actor's world position will be used as the transform origin for all absolute transform sections"""

	@property
	def TransformOrigin(self) -> Transform: ...
	"""Specifies a transform that offsets all absolute transform sections in this sequence. Will compound with attach tracks. Scale is ignored. Not applied to Relative or Additive sections."""

	pass

class LevelSequence(MovieSceneSequence):
	"""Movie scene animation for Actors."""

	@property
	def MovieScene(self) -> typing.Any: ...
	"""Pointer to the movie scene that controls this animation."""

	def RemoveMetaDataByClass(self, InClass: Object): ...
	"""Remove meta-data of a particular type for this level sequence instance, if it exists
@param InClass - The class type that you wish to remove the metadata for"""

	def CopyMetaData(self, InMetaData: Object) -> Object: ...
	"""Copy the specified meta data into this level sequence, overwriting any existing meta-data of the same type
Meta-data may implement the ILevelSequenceMetaData interface in order to hook into default ULevelSequence functionality.
@param InMetaData - Existing Metadata Object that you wish to copy into this Level Sequence.
@return The newly copied instance of the Metadata that now exists on this sequence."""

	def FindOrAddMetaDataByClass(self, InClass: Object) -> Object: ...
	"""Find meta-data of a particular type for this level sequence instance, adding it if it doesn't already exist.
@param InClass - Class that you wish to find or create the metadata object for.
@return An instance of this class as metadata on this Level Sequence."""

	def FindMetaDataByClass(self, InClass: Object) -> Object: ...
	"""Find meta-data of a particular type for this level sequence instance.
@param InClass - Class that you wish to find the metadata object for.
@return An instance of this class if it already exists as metadata on this Level Sequence, otherwise null."""

	pass

class LevelSequenceBurnInInitSettings(Object):
	"""Level Sequence Burn in Init Settings"""

	pass

class LevelSequenceBurnInOptions(Object):
	"""Level Sequence Burn in Options"""

	@property
	def bUseBurnIn(self) -> bool: ...
	"""Use Burn In"""

	@property
	def BurnInClass(self) -> SoftClassPath: ...
	"""Burn in Class"""

	@property
	def Settings(self) -> LevelSequenceBurnInInitSettings: ...
	"""Settings"""

	def SetBurnIn(self, InBurnInClass: SoftClassPath): ...
	"""Loads the specified class path and initializes an instance, then stores it in Settings."""

	pass

class LevelSequenceActor(Actor):
	"""Actor responsible for controlling a specific level sequence in the world."""

	@property
	def PlaybackSettings(self) -> MovieSceneSequencePlaybackSettings: ...
	"""Playback Settings"""

	@property
	def SequencePlayer(self) -> LevelSequencePlayer: ...
	"""Sequence Player"""

	@property
	def LevelSequence(self) -> SoftObjectPath: ...
	"""Level Sequence"""

	@property
	def CameraSettings(self) -> LevelSequenceCameraSettings: ...
	"""Camera Settings"""

	@property
	def BurnInOptions(self) -> LevelSequenceBurnInOptions: ...
	"""Burn in Options"""

	@property
	def BindingOverrides(self) -> typing.Any: ...
	"""Mapping of actors to override the sequence bindings with"""

	@property
	def bOverrideInstanceData(self) -> bool: ...
	"""Enable specification of dynamic instance data to be supplied to the sequence during playback"""

	@property
	def bReplicatePlayback(self) -> bool: ...
	"""If true, playback of this level sequence on the server will be synchronized across other clients"""

	@property
	def DefaultInstanceData(self) -> Object: ...
	"""Instance data that can be used to dynamically control sequence evaluation at runtime"""

	def FindNamedBindings(self, Tag: str) -> typing.List[MovieSceneObjectBindingID]: ...
	"""Retrieve all the bindings that have been tagged with the specified name

@param Tag  The unique tag name to lookup bindings with. Object Bindings can be tagged within the sequence UI by RMB -> Tags... on the object binding in the tree.
@return An array containing all the bindings that are tagged with this name, potentially empty."""

	def FindNamedBinding(self, Tag: str) -> MovieSceneObjectBindingID: ...
	"""Retrieve the first object binding that has been tagged with the specified name"""

	def ResetBindings(self): ...
	"""Resets all overridden bindings back to the defaults defined by the Level Sequence asset"""

	def ResetBinding(self, Binding: MovieSceneObjectBindingID): ...
	"""Resets the specified binding back to the defaults defined by the Level Sequence asset"""

	def RemoveBindingByTag(self, Tag: str, Actor: Actor): ...
	"""Removes the specified actor from the specified binding's actor array"""

	def RemoveBinding(self, Binding: MovieSceneObjectBindingID, Actor: Actor): ...
	"""Removes the specified actor from the specified binding's actor array"""

	def AddBindingByTag(self, BindingTag: str, Actor: Actor, bAllowBindingsFromAsset: bool = ...): ...
	"""Binds an actor to all the bindings tagged with the specified name in this sequence. Does not remove any exising bindings that have been set up through this API. Object Bindings can be tagged within the sequence UI by RMB -> Tags... on the object binding in the tree.

@param BindingTag   The unique tag name to lookup bindings with
@param Actor        The actor to assign to all the tagged bindings
@param bAllowBindingsFromAsset Whether to continue to allow bindings from the level sequence asset (true) or not (false)"""

	def AddBinding(self, Binding: MovieSceneObjectBindingID, Actor: Actor, bAllowBindingsFromAsset: bool = ...): ...
	"""Adds the specified actor to the overridden bindings for the specified binding ID, optionally still allowing the bindings defined in the Level Sequence asset

@param Binding Binding to modify
@param Actor Actor to bind
@param bAllowBindingsFromAsset Allow bindings from the level sequence asset"""

	def SetBindingByTag(self, BindingTag: str, Actors: typing.List[Actor], bAllowBindingsFromAsset: bool = ...): ...
	"""Assigns an set of actors to all the bindings tagged with the specified name in this sequence. Object Bindings can be tagged within the sequence UI by RMB -> Tags... on the object binding in the tree.

@param BindingTag   The unique tag name to lookup bindings with
@param Actors       The actors to assign to all the tagged bindings
@param bAllowBindingsFromAsset Whether to continue to allow bindings from the level sequence asset (true) or not (false)"""

	def SetBinding(self, Binding: MovieSceneObjectBindingID, Actors: typing.List[Actor], bAllowBindingsFromAsset: bool = ...): ...
	"""Overrides the specified binding with the specified actors, optionally still allowing the bindings defined in the Level Sequence asset

@param Binding Binding to modify
@param Actors Actors to bind
@param bAllowBindingsFromAsset Allow bindings from the level sequence asset"""

	def ShowBurnin(self): ...
	"""Show burnin"""

	def HideBurnin(self): ...
	"""Hide burnin"""

	def GetSequencePlayer(self) -> LevelSequencePlayer: ...
	"""Access this actor's sequence player, or None if it is not yet initialized"""

	def SetReplicatePlayback(self, ReplicatePlayback: bool): ...
	"""Set whether or not to replicate playback for this actor"""

	def SetSequence(self, InSequence: LevelSequence): ...
	"""Set the level sequence being played by this actor.

@param InSequence The sequence object to set.
@see GetSequence"""

	def LoadSequence(self) -> LevelSequence: ...
	"""Get the level sequence being played by this actor.

@return Level sequence, or nullptr if not assigned or if it cannot be loaded.
@see SetSequence"""

	def GetSequence(self) -> LevelSequence: ...
	"""Get the level sequence being played by this actor.

@return Level sequence, or nullptr if not assigned or if it cannot be loaded.
@see SetSequence"""

	pass

class LevelSequenceBurnIn(UserWidget):
	"""Base class for level sequence burn ins"""

	def GetSettingsClass(self) -> LevelSequenceBurnInInitSettings: ...
	"""Get the settings class to use for this burn in"""

	pass

class LevelSequenceDirector(Object):
	"""Level Sequence Director"""

	@property
	def Player(self) -> LevelSequencePlayer: ...
	"""Pointer to the player that's playing back this director's sequence"""

	pass

class LevelSequencePlayer(MovieSceneSequencePlayer):
	"""ULevelSequencePlayer is used to actually 'play' an level sequence asset at runtime.

This class keeps track of playback state and provides functions for manipulating
an level sequence while its playing."""

	@property
	def OnCameraCut(self) -> typing.Any: ...
	"""Event triggered when there is a camera cut"""

	def GetActiveCameraComponent(self) -> CameraComponent: ...
	"""Get the active camera cut camera"""

	@staticmethod
	def CreateLevelSequencePlayer(WorldContextObject: Object, LevelSequence: LevelSequence, Settings: MovieSceneSequencePlaybackSettings) -> typing.Tuple[LevelSequencePlayer, LevelSequenceActor]: ...
	"""Create a new level sequence player.

@param WorldContextObject Context object from which to retrieve a UWorld.
@param LevelSequence The level sequence to play.
@param Settings The desired playback settings
@param OutActor The level sequence actor created to play this sequence."""

	pass

class LevelSequenceMediaController(Actor):
	"""Replicated actor class that is responsible for instigating various cinematic assets (Media, Audio, Level Sequences) in a synchronized fasion"""

	def SynchronizeToServer(self, DesyncThresholdSeconds: float = ...): ...
	"""Forcibly synchronize the sequence to the server's position if it has diverged by more than the specified threshold"""

	def GetSequence(self) -> LevelSequenceActor: ...
	"""Access this actor's Level Sequence Actor"""

	def GetMediaComponent(self) -> typing.Any: ...
	"""Access this actor's media component"""

	def Play(self): ...
	"""Play"""

	pass

class CameraLookatTrackingSettings(object):
	"""Settings to control the camera's lookat feature"""

	@property
	def bEnableLookAtTracking(self) -> bool: ...
	"""True to enable lookat tracking, false otherwise."""

	@property
	def bDrawDebugLookAtTrackingPosition(self) -> bool: ...
	"""True to draw a debug representation of the lookat location"""

	@property
	def LookAtTrackingInterpSpeed(self) -> float: ...
	"""Controls degree of smoothing. 0.f for no smoothing, higher numbers for faster/tighter tracking."""

	@property
	def ActorToTrack(self) -> typing.Any: ...
	"""If set, camera will track this actor's location"""

	@property
	def RelativeOffset(self) -> Vector: ...
	"""Offset from actor position to look at. Relative to actor if tracking an actor, relative to world otherwise."""

	@property
	def bAllowRoll(self) -> bool: ...
	"""True to allow user-defined roll, false otherwise."""

	pass

class CameraFilmbackSettings(object):
	"""#note, this struct has a details customization in CameraFilmbackSettingsCustomization.cpp/h"""

	@property
	def SensorWidth(self) -> float: ...
	"""Horizontal size of filmback or digital sensor, in mm."""

	@property
	def SensorHeight(self) -> float: ...
	"""Vertical size of filmback or digital sensor, in mm."""

	@property
	def SensorAspectRatio(self) -> float: ...
	"""Read-only. Computed from Sensor dimensions."""

	pass

class NamedFilmbackPreset(object):
	"""A named bundle of filmback settings used to implement filmback presets"""

	@property
	def Name(self) -> str: ...
	"""Name for the preset."""

	@property
	def FilmbackSettings(self) -> CameraFilmbackSettings: ...
	"""Filmback Settings"""

	pass

class CameraLensSettings(object):
	"""#note, this struct has a details customization in CameraLensSettingsCustomization.cpp/h"""

	@property
	def MinFocalLength(self) -> float: ...
	"""Minimum focal length for this lens"""

	@property
	def MaxFocalLength(self) -> float: ...
	"""Maximum focal length for this lens"""

	@property
	def MinFStop(self) -> float: ...
	"""Minimum aperture for this lens (e.g. 2.8 for an f/2.8 lens)"""

	@property
	def MaxFStop(self) -> float: ...
	"""Maximum aperture for this lens (e.g. 2.8 for an f/2.8 lens)"""

	@property
	def MinimumFocusDistance(self) -> float: ...
	"""Shortest distance this lens can focus on."""

	@property
	def DiaphragmBladeCount(self) -> int: ...
	"""Number of blades of diaphragm."""

	pass

class NamedLensPreset(object):
	"""A named bundle of lens settings used to implement lens presets."""

	@property
	def Name(self) -> str: ...
	"""Name for the preset."""

	@property
	def LensSettings(self) -> CameraLensSettings: ...
	"""Lens Settings"""

	pass

class CameraTrackingFocusSettings(object):
	"""Settings to control tracking-focus mode."""

	@property
	def ActorToTrack(self) -> typing.Any: ...
	"""Focus distance will be tied to this actor's location."""

	@property
	def RelativeOffset(self) -> Vector: ...
	"""Offset from actor position to track. Relative to actor if tracking an actor, relative to world otherwise."""

	@property
	def bDrawDebugTrackingFocusPoint(self) -> bool: ...
	"""True to draw a debug representation of the tracked position."""

	pass

class CameraFocusSettings(object):
	"""Settings to control camera focus"""

	@property
	def FocusMethod(self) -> int: ...
	"""Which method to use to handle camera focus"""

	@property
	def ManualFocusDistance(self) -> float: ...
	"""Manually-controlled focus distance (manual focus mode only)"""

	@property
	def TrackingFocusSettings(self) -> CameraTrackingFocusSettings: ...
	"""Settings to control tracking focus (tracking focus mode only)"""

	@property
	def bDrawDebugFocusPlane(self) -> bool: ...
	"""True to draw a translucent plane at the current focus depth, for easy tweaking."""

	@property
	def DebugFocusPlaneColor(self) -> Color: ...
	"""For customizing the focus plane color, in case the default doesn't show up well in your scene."""

	@property
	def bSmoothFocusChanges(self) -> bool: ...
	"""True to use interpolation to smooth out changes in focus distance, false for focus distance changes to be instantaneous."""

	@property
	def FocusSmoothingInterpSpeed(self) -> float: ...
	"""Controls interpolation speed when smoothing focus distance changes. Ignored if bSmoothFocusChanges is false."""

	@property
	def FocusOffset(self) -> float: ...
	"""Additional focus depth offset, used for manually tweaking if your chosen focus method needs adjustment"""

	pass

class CameraRig_Crane(Actor):
	"""A simple rig for simulating crane-like camera movements."""

	@property
	def CranePitch(self) -> float: ...
	"""Controls the pitch of the crane arm."""

	@property
	def CraneYaw(self) -> float: ...
	"""Controls the yaw of the crane arm."""

	@property
	def CraneArmLength(self) -> float: ...
	"""Controls the length of the crane arm."""

	@property
	def bLockMountPitch(self) -> bool: ...
	"""Lock the mount pitch so that an attached camera is locked and pitched in the direction of the crane arm"""

	@property
	def bLockMountYaw(self) -> bool: ...
	"""Lock the mount yaw so that an attached camera is locked and oriented in the direction of the crane arm"""

	pass

class CameraRig_Rail(Actor):
	"""Camera Rig Rail"""

	@property
	def CurrentPositionOnRail(self) -> float: ...
	"""Defines current position of the mount point along the rail, in terms of normalized distance from the beginning of the rail."""

	@property
	def bLockOrientationToRail(self) -> bool: ...
	"""Determines whether the orientation of the mount should be in the direction of the rail."""

	def GetRailSplineComponent(self) -> SplineComponent: ...
	"""Returns the spline component that defines the rail path"""

	pass

class CineCameraActor(CameraActor):
	"""A CineCameraActor is a CameraActor specialized to work like a cinematic camera."""

	@property
	def LookatTrackingSettings(self) -> CameraLookatTrackingSettings: ...
	"""Lookat Tracking Settings"""

	def GetCineCameraComponent(self) -> CineCameraComponent: ...
	"""Returns the CineCameraComponent of this CineCamera"""

	pass

class CineCameraComponent(CameraComponent):
	"""A specialized version of a camera component, geared toward cinematic usage."""

	@property
	def Filmback(self) -> CameraFilmbackSettings: ...
	"""Controls the filmback of the camera."""

	@property
	def LensSettings(self) -> CameraLensSettings: ...
	"""Controls the camera's lens."""

	@property
	def FocusSettings(self) -> CameraFocusSettings: ...
	"""Controls the camera's focus."""

	@property
	def CurrentFocalLength(self) -> float: ...
	"""Current focal length of the camera (i.e. controls FoV, zoom)"""

	@property
	def CurrentAperture(self) -> float: ...
	"""Current aperture, in terms of f-stop (e.g. 2.8 for f/2.8)"""

	@property
	def CurrentFocusDistance(self) -> float: ...
	"""Read-only. Control this value via FocusSettings."""

	@staticmethod
	def GetLensPresetsCopy() -> typing.List[NamedLensPreset]: ...
	"""Returns a copy of the list of available lens presets."""

	@staticmethod
	def GetFilmbackPresetsCopy() -> typing.List[NamedFilmbackPreset]: ...
	"""Returns a copy of the list of available filmback presets."""

	def SetLensPresetByName(self, InPresetName: str): ...
	"""Set the current lens settings by preset name."""

	def GetLensPresetName(self) -> str: ...
	"""Returns the lens name of the camera with the current settings."""

	def SetFilmbackPresetByName(self, InPresetName: str): ...
	"""Set the current preset settings by preset name."""

	def GetDefaultFilmbackPresetName(self) -> str: ...
	"""Returns the name of the default filmback preset."""

	def GetFilmbackPresetName(self) -> str: ...
	"""Returns the filmback name of the camera with the current settings."""

	def GetVerticalFieldOfView(self) -> float: ...
	"""Returns the vertical FOV of the camera with current settings."""

	def GetHorizontalFieldOfView(self) -> float: ...
	"""Returns the horizonal FOV of the camera with current settings."""

	def SetCurrentFocalLength(self, InFocalLength: float): ...
	"""Set Current Focal Length"""

	pass

class ECameraFocusMethod(Enum):
	"""Supported methods for focusing the camera."""

	# Don't override, ie. allow post process volume settings to persist.
	DoNotOverride = 0
	# Allows for specifying or animating exact focus distances.
	Manual = 1
	# Locks focus to specific object.
	Tracking = 2
	# Disable depth of field entirely.
	Disable = 3
	# 
	MAX = 4

def Log(Message: str) -> None: ...

def LogWarning(Message: str) -> None: ...

def LogError(Message: str) -> None: ...

def AddOnScreenDebugMessage(Key: int, TimeToDisplay: float, Message: str) -> None: ...

def PrintString(Message: str, TimeToDisplay: float = ..., Color: Color = ...) -> None: ...

def GetContentDir() -> str: ...

def GetDocumentDir() -> str: ...

def GetLogDir() -> str: ...

def GetLogFilename() -> str: ...

def GetGameSavedDir() -> str: ...

def GetGameUserDeveloperDir() -> str: ...

def ConvertRelativePathToFull(Path: str) -> str: ...

def ConvertAbsolutePathApp(Path: str) -> str: ...

def ObjectPathToPackageName(Path: str) -> str: ...

def GetPath(Path: str) -> str: ...

def GetBaseFilename(Path: str) -> str: ...

def FindFile(FullName: str, Path: str) -> bool: ...

def GetFile(FullName: str, Path: str) -> bool: ...

def RenderImgs(...) -> typing.Any: ...

def EncryptBuffer(...) -> typing.Any: ...

def NewModule(...) -> typing.Any: ...

def MountPak(...) -> typing.Any: ...

def SetLowPak(...) -> typing.Any: ...

def CreateWorld(WorldType: EWorldType = ...) -> World: ...

def ParsePropertyFlags(Flags: int) -> typing.List[str]: ...

def GetTransientPackage() -> Package: ...

def GetIniFilenameFromObjectsReference(ObjectsReferenceString: str) -> str: ...

def ResolveIniObjectsReference(ObjectReference: str, IniFilename: str = ..., bThrow: bool = ...) -> str: ...

def LoadPackage(Name: str) -> Package: ...

def LoadPackageAsync(Name: str, Callback: typing.Callable[[str, Package, EAsyncLoadingResult], typing.Any], Priority: int = ..., PackageFlags: EPackageFlags = ...) -> None: ...

def UnloadPackage(PackageToUnload: Package) -> None: ...

def GetPackageFileName(Name: str) -> str: ...

def FindClass(Name: str) -> Class: ...

def LoadClass(Name: str) -> Class: ...

def AsyncLoadClass(Name: str, Callback: typing.Callable[[str, Class], typing.Any], Priority: int = ...) -> None: ...

def FindObject(Name: str) -> Object: ...

def LoadObject(Class: Class, Name: str) -> Object: ...

def AsyncLoadObject(Name: str, Callback: typing.Callable[[str, Object], typing.Any], Priority: int = ...) -> None: ...

def CancelAsyncLoading() -> None: ...

def GetAsyncLoadPercentage(PackageName: str) -> float: ...

def FlushAsyncLoading(PackageID: int = ...) -> None: ...

def GetNumAsyncPackages() -> int: ...

def IsLoading() -> bool: ...

def FindPackage(PackageName: str) -> Package: ...

def CreatePackage(PackageName: str) -> Package: ...

def NewObject(Class: Class, Outer: Object = ..., Name: str = ..., Flags: int = ...) -> Object: ...

def StringToGuid(Str: str) -> Guid: ...

def GuidToString(Guid: Guid) -> str: ...

def TickSlate() -> None: ...

def TickEngine(DeltaSeconds: float, bIdle: bool) -> None: ...

def TickRenderingTickables() -> None: ...

def GetDeltaTime() -> float: ...

def GetAllWorlds() -> typing.List[World]: ...

def GetGameViewportSize() -> typing.Tuple[float, float]: ...

def GetResolution() -> typing.Tuple[float, float]: ...

def GetViewportScreenshot(bAsIntList: bool) -> typing.List[Color] | typing.List[typing.Tuple[float, float, float, float]]: ...

def GetStatUnit() -> typing.Dict: ...

def GetStatFps()-> typing.float: ...

def GetStatRhi() -> typing.Dict: ...

def CopyPropertiesForUnrelatedObjects(...) -> typing.Any: ...

def SetRandomSeed(Seed: int) -> None: ...

def ClipboardCopy(Text: str) -> None: ...

def ClipboardPaste() -> str: ...

def GetEditorWorld() -> World: ...

def GetSelectedActors(...) -> typing.Any: ...

def SelectNone(...) -> typing.Any: ...

def IsRunningCommandlet() -> bool: ...

def ReloadShaderByteCode() -> None: ...
